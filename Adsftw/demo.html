<!doctype html>
<html>
	<head>
		
		<script src="script/textsearch.js"></script>
		
		<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.0.2/jquery.min.js"></script>
	</head>
	<body>

		<div id="result"></div>

		<div id="fbsd-hb">
FreeBSD Handbook

The FreeBSD Documentation Project

Revision: 41824

Copyright Â© 1995-2013 The FreeBSD Documentation Project

Copyright

Redistribution and use in source (XML DocBook) and 'compiled' forms (XML, HTML,
PDF, PostScript, RTF and so forth) with or without modification, are permitted
provided that the following conditions are met:

 1. Redistributions of source code (XML DocBook) must retain the above
    copyright notice, this list of conditions and the following disclaimer as
    the first lines of this file unmodified.

 2. Redistributions in compiled form (transformed to other DTDs, converted to
    PDF, PostScript, RTF and other formats) must reproduce the above copyright
    notice, this list of conditions and the following disclaimer in the
    documentation and/or other materials provided with the distribution.

Important:

THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION PROJECT "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE FREEBSD DOCUMENTATION PROJECT BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
DOCUMENTATION, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

FreeBSD is a registered trademark of the FreeBSD Foundation.

3Com and HomeConnect are registered trademarks of 3Com Corporation.

3ware and Escalade are registered trademarks of 3ware Inc.

ARM is a registered trademark of ARM Limited.

Adaptec is a registered trademark of Adaptec, Inc.

Adobe, Acrobat, Acrobat Reader, and PostScript are either registered trademarks
or trademarks of Adobe Systems Incorporated in the United States and/or other
countries.

Apple, AirPort, FireWire, Mac, Macintosh, Mac OS, Quicktime, and TrueType are
trademarks of Apple Computer, Inc., registered in the United States and other
countries.

Sound Blaster is a trademark of Creative Technology Ltd. in the United States
and/or other countries.

CVSup is a registered trademark of John D. Polstra.

Heidelberg, Helvetica, Palatino, and Times Roman are either registered
trademarks or trademarks of Heidelberger Druckmaschinen AG in the U.S. and
other countries.

IBM, AIX, EtherJet, Netfinity, OS/2, PowerPC, PS/2, S/390, and ThinkPad are
trademarks of International Business Machines Corporation in the United States,
other countries, or both.

IEEE, POSIX, and 802 are registered trademarks of Institute of Electrical and
Electronics Engineers, Inc. in the United States.

Intel, Celeron, EtherExpress, i386, i486, Itanium, Pentium, and Xeon are
trademarks or registered trademarks of Intel Corporation or its subsidiaries in
the United States and other countries.

Intuit and Quicken are registered trademarks and/or registered service marks of
Intuit Inc., or one of its subsidiaries, in the United States and other
countries.

Linux is a registered trademark of Linus Torvalds.

LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID and Mylex are trademarks or
registered trademarks of LSI Logic Corp.

M-Systems and DiskOnChip are trademarks or registered trademarks of M-Systems
Flash Disk Pioneers, Ltd.

Macromedia, Flash, and Shockwave are trademarks or registered trademarks of
Macromedia, Inc. in the United States and/or other countries.

Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows NT
are either registered trademarks or trademarks of Microsoft Corporation in the
United States and/or other countries.

GateD and NextHop are registered and unregistered trademarks of NextHop in the
U.S. and other countries.

Motif, OSF/1, and UNIX are registered trademarks and IT DialTone and The Open
Group are trademarks of The Open Group in the United States and other
countries.

Oracle is a registered trademark of Oracle Corporation.

RealNetworks, RealPlayer, and RealAudio are the registered trademarks of
RealNetworks, Inc.

Red Hat, RPM, are trademarks or registered trademarks of Red Hat, Inc. in the
United States and other countries.

SAP, R/3, and mySAP are trademarks or registered trademarks of SAP AG in
Germany and in several other countries all over the world.

Sun, Sun Microsystems, Java, Java Virtual Machine, JavaServer Pages, JDK, JRE,
JSP, JVM, Netra, OpenJDK, Solaris, StarOffice, Sun Blade, Sun Enterprise, Sun
Fire, SunOS, Ultra and VirtualBox are trademarks or registered trademarks of
Sun Microsystems, Inc. in the United States and other countries.

MATLAB is a registered trademark of The MathWorks, Inc.

SpeedTouch is a trademark of Thomson.

U.S. Robotics and Sportster are registered trademarks of U.S. Robotics
Corporation.

VMware is a trademark of VMware, Inc.

Waterloo Maple and Maple are trademarks or registered trademarks of Waterloo
Maple Inc.

Mathematica is a registered trademark of Wolfram Research, Inc.

XFree86 is a trademark of The XFree86 Project, Inc.

Ogg Vorbis and Xiph.Org are trademarks of Xiph.Org.

Many of the designations used by manufacturers and sellers to distinguish their
products are claimed as trademarks. Where those designations appear in this
document, and the FreeBSD Project was aware of the trademark claim, the
designations have been followed by the â  â ¢â   or the â  Â®â   symbol.

Last modified on 2013-06-01 by eadler.
Abstract

Welcome to FreeBSD! This handbook covers the installation and day to day use of
FreeBSD 8.4-RELEASE and FreeBSD 9.1-RELEASE. This manual is a work in progress
and is the work of many individuals. As such, some sections may become dated
and require updating. If you are interested in helping out with this project,
send email to the FreeBSD documentation project mailing list. The latest
version of this document is always available from the FreeBSD web site
(previous versions of this handbook can be obtained from http://
docs.FreeBSD.org/doc/). It may also be downloaded in a variety of formats and
compression options from the FreeBSD FTP server or one of the numerous mirror
sites. If you would prefer to have a hard copy of the handbook, you can
purchase one at the FreeBSD Mall. You may also want to search the handbook.

[ Split HTML / Single HTML ]
-------------------------------------------------------------------------------
Table of Contents

Preface
I. Getting Started

    1. Introduction

        1.1. Synopsis
        1.2. Welcome to FreeBSD!
        1.3. About the FreeBSDÂ Project

    2. Installing FreeBSDÂ 9.X and Later

        2.1. Synopsis
        2.2. Hardware Requirements
        2.3. Pre-Installation Tasks
        2.4. Starting the Installation
        2.5. Introducing bsdinstall
        2.6. Installing from the Network
        2.7. Allocating Disk Space
        2.8. Committing to the Installation
        2.9. Post-Installation
        2.10. Troubleshooting
        2.11. Using the Live CD

    3. Installing FreeBSDÂ 8.X and Earlier

        3.1. Synopsis
        3.2. Hardware Requirements
        3.3. Pre-installation Tasks
        3.4. Starting the Installation
        3.5. Introducing Sysinstall
        3.6. Allocating Disk Space
        3.7. Choosing What to Install
        3.8. Choosing Your Installation Media
        3.9. Committing to the Installation
        3.10. Post-installation
        3.11. Troubleshooting
        3.12. Advanced Installation Guide
        3.13. Preparing Your Own Installation Media

    4. UNIX Basics

        4.1. Synopsis
        4.2. Virtual Consoles and Terminals
        4.3. Permissions
        4.4. Directory Structure
        4.5. Disk Organization
        4.6. Mounting and Unmounting File Systems
        4.7. Processes
        4.8. Daemons, Signals, and Killing Processes
        4.9. Shells
        4.10. Text Editors
        4.11. Devices and Device Nodes
        4.12. Binary Formats
        4.13. For More Information

    5. Installing Applications: Packages and Ports

        5.1. Synopsis
        5.2. Overview of Software Installation
        5.3. Finding Software
        5.4. Using Binary Packages
        5.5. Using pkgng for Binary Package Management
        5.6. Using the Ports Collection
        5.7. Post-installation Activities
        5.8. Dealing with Broken Ports

    6. The X Window System

        6.1. Synopsis
        6.2. Understanding X
        6.3. Installing X11
        6.4. X11 Configuration
        6.5. Using Fonts in X11
        6.6. The X Display Manager
        6.7. Desktop Environments

II. Common Tasks

    7. Desktop Applications

        7.1. Synopsis
        7.2. Browsers
        7.3. Productivity
        7.4. Document Viewers
        7.5. Finance

    8. Multimedia

        8.1. Synopsis
        8.2. Setting Up the Sound Card
        8.3. MP3 Audio
        8.4. Video Playback
        8.5. Setting Up TV Cards
        8.6. MythTV
        8.7. Image Scanners

    9. Configuring the FreeBSD Kernel

        9.1. Synopsis
        9.2. Why Build a Custom Kernel?
        9.3. Finding the System Hardware
        9.4. Kernel Drivers, Subsystems, and Modules
        9.5. Building and Installing a Custom Kernel
        9.6. The Configuration File
        9.7. If Something Goes Wrong

    10. Printing

        10.1. Synopsis
        10.2. Introduction
        10.3. Basic Setup
        10.4. Advanced Printer Setup
        10.5. Using Printers
        10.6. Alternatives to the Standard Spooler
        10.7. Troubleshooting

    11. LinuxÂ® Binary Compatibility

        11.1. Synopsis
        11.2. Installation
        11.3. Installing MathematicaÂ®
        11.4. Installing Mapleâ ¢
        11.5. Installing MATLABÂ®
        11.6. Installing OracleÂ®
        11.7. Advanced Topics

III. System Administration

    12. Configuration and Tuning

        12.1. Synopsis
        12.2. Initial Configuration
        12.3. Core Configuration
        12.4. Application Configuration
        12.5. Starting Services
        12.6. Configuring the cron Utility
        12.7. Using rc(8) Under FreeBSD
        12.8. Setting Up Network Interface Cards
        12.9. Virtual Hosts
        12.10. Configuring the System Logger, syslogd
        12.11. Configuration Files
        12.12. Tuning with sysctl(8)
        12.13. Tuning Disks
        12.14. Tuning Kernel Limits
        12.15. Adding Swap Space
        12.16. Power and Resource Management
        12.17. Using and Debugging FreeBSD ACPI

    13. The FreeBSD Booting Process

        13.1. Synopsis
        13.2. The Booting Problem
        13.3. The Boot Manager and Boot Stages
        13.4. Kernel Interaction During Boot
        13.5. Device Hints
        13.6. Init: Process Control Initialization
        13.7. Shutdown Sequence

    14. Users and Basic Account Management

        14.1. Synopsis
        14.2. Introduction
        14.3. Modifying Accounts
        14.4. Limiting Users
        14.5. Groups

    15. Security

        15.1. Synopsis
        15.2. Introduction
        15.3. Securing FreeBSD
        15.4. DES, Blowfish, MD5, SHA256, SHA512, and Crypt
        15.5. One-time Passwords
        15.6. TCP Wrappers
        15.7. Kerberos5
        15.8. OpenSSL
        15.9. VPN over IPsec
        15.10. OpenSSH
        15.11. File System Access Control Lists (ACLs)
        15.12. Monitoring Third Party Security Issues
        15.13. FreeBSD Security Advisories
        15.14. Process Accounting

    16. Jails

        16.1. Synopsis
        16.2. Terms Related to Jails
        16.3. Introduction
        16.4. Creating and Controlling Jails
        16.5. Fine Tuning and Administration
        16.6. Application of Jails

    17. Mandatory Access Control

        17.1. Synopsis
        17.2. Key Terms in This Chapter
        17.3. Explanation of MAC
        17.4. Understanding MAC Labels
        17.5. Planning the Security Configuration
        17.6. Module Configuration
        17.7. The mac_seeotheruids(4) Module
        17.8. The mac_bsdextended(4) Module
        17.9. The mac_ifoff(4) Module
        17.10. The mac_portacl(4) Module
        17.11. The mac_partition(4) Module
        17.12. The MAC Multi-Level Security Module
        17.13. The MAC Biba Module
        17.14. The MAC LOMAC Module
        17.15. Nagios in a MAC Jail
        17.16. User Lock Down
        17.17. Troubleshooting the MAC Framework

    18. Security Event Auditing

        18.1. Synopsis
        18.2. Key Terms in This Chapter
        18.3. Installing Audit Support
        18.4. Audit Configuration
        18.5. Administering the Audit Subsystem

    19. Storage

        19.1. Synopsis
        19.2. Device Names
        19.3. Adding Disks
        19.4. RAID
        19.5. USB Storage Devices
        19.6. Creating and Using CD Media
        19.7. Creating and Using DVD Media
        19.8. Creating and Using Floppy Disks
        19.9. Creating and Using Data Tapes
        19.10. Backups to Floppies
        19.11. Backup Strategies
        19.12. Backup Basics
        19.13. Network, Memory, and File-Backed File Systems
        19.14. File System Snapshots
        19.15. File System Quotas
        19.16. Encrypting Disk Partitions
        19.17. Encrypting Swap Space
        19.18. Highly Available Storage (HAST)

    20. GEOM: Modular Disk Transformation Framework

        20.1. Synopsis
        20.2. GEOM Introduction
        20.3. RAID0 - Striping
        20.4. RAID1 - Mirroring
        20.5. RAID3 - Byte-level Striping with Dedicated Parity
        20.6. GEOM Gate Network Devices
        20.7. Labeling Disk Devices
        20.8. UFS Journaling Through GEOM

    21. File Systems Support

        21.1. Synopsis
        21.2. The Z File System (ZFS)
        21.3. LinuxÂ® Filesystems

    22. The vinum Volume Manager

        22.1. Synopsis
        22.2. Access Bottlenecks
        22.3. Data Integrity
        22.4. vinum Objects
        22.5. Some Examples
        22.6. Object Naming
        22.7. Configuring vinum
        22.8. Using vinum for the Root File System

    23. Virtualization

        23.1. Synopsis
        23.2. FreeBSD as a Guest OS
        23.3. FreeBSD as a Host

    24. Localization - i18n/L10n Usage and Setup

        24.1. Synopsis
        24.2. The Basics
        24.3. Using Localization
        24.4. Compiling i18n Programs
        24.5. Localizing FreeBSD to Specific Languages

    25. Updating and Upgrading FreeBSD

        25.1. Synopsis
        25.2. FreeBSD Update
        25.3. Portsnap: a Ports Collection Update Tool
        25.4. Updating the Documentation Set
        25.5. Tracking a Development Branch
        25.6. Synchronizing Source
        25.7. Rebuilding â  worldâ  
        25.8. Tracking for Multiple Machines

    26. DTrace

        26.1. Synopsis
        26.2. Implementation Differences
        26.3. Enabling DTrace Support
        26.4. Using DTrace
        26.5. The D Language

IV. Network Communication

    27. Serial Communications

        27.1. Synopsis
        27.2. Introduction
        27.3. Terminals
        27.4. Dial-in Service
        27.5. Dial-out Service
        27.6. Setting Up the Serial Console

    28. PPP and SLIP

        28.1. Synopsis
        28.2. Using User PPP
        28.3. Using Kernel PPP
        28.4. Troubleshooting PPP Connections
        28.5. Using PPP over Ethernet (PPPoE)
        28.6. Using PPP over ATM (PPPoA)
        28.7. Using SLIP

    29. Electronic Mail

        29.1. Synopsis
        29.2. Using Electronic Mail
        29.3. sendmail Configuration
        29.4. Changing Your Mail Transfer Agent
        29.5. Troubleshooting
        29.6. Advanced Topics
        29.7. Setting Up to Send Only
        29.8. Using Mail with a Dialup Connection
        29.9. SMTP Authentication
        29.10. Mail User Agents
        29.11. Using fetchmail
        29.12. Using procmail

    30. Network Servers

        30.1. Synopsis
        30.2. The inetd â  Super-Serverâ  
        30.3. Network File System (NFS)
        30.4. Network Information System (NIS/YP)
        30.5. Automatic Network Configuration (DHCP)
        30.6. Domain Name System (DNS)
        30.7. Apache HTTP Server
        30.8. File Transfer Protocol (FTP)
        30.9. File and Print Services for MicrosoftÂ®Â WindowsÂ® Clients
            (Samba)
        30.10. Clock Synchronization with NTP
        30.11. Remote Host Logging with syslogd

    31. Firewalls

        31.1. Introduction
        31.2. Firewall Concepts
        31.3. Firewall Packages
        31.4. PF and ALTQ
        31.5. The IPFILTER (IPF) Firewall
        31.6. IPFW

    32. Advanced Networking

        32.1. Synopsis
        32.2. Gateways and Routes
        32.3. Wireless Networking
        32.4. Bluetooth
        32.5. Bridging
        32.6. Link Aggregation and Failover
        32.7. Diskless Operation
        32.8. PXE Booting with an NFS Root File System
        32.9. ISDN
        32.10. Network Address Translation
        32.11. IPv6
        32.12. Asynchronous Transfer Mode (ATM)
        32.13. Common Address Redundancy Protocol (CARP)

V. Appendices

    A. Obtaining FreeBSD

        A.1. CDROM and DVD Publishers
        A.2. FTP Sites
        A.3. Anonymous CVS (Deprecated)
        A.4. Using CTM
        A.5. Using Subversion
        A.6. Subversion Mirror Sites
        A.7. Using CVSup (Deprecated)
        A.8. CVS Tags
        A.9. rsync Sites

    B. Bibliography

        B.1. Books & Magazines Specific to FreeBSD
        B.2. Users' Guides
        B.3. Administrators' Guides
        B.4. Programmers' Guides
        B.5. Operating System Internals
        B.6. Security Reference
        B.7. Hardware Reference
        B.8. UNIXÂ® History
        B.9. Magazines and Journals

    C. Resources on the Internet

        C.1. Mailing Lists
        C.2. Usenet Newsgroups
        C.3. World Wide Web Servers
        C.4. Email Addresses

    D. PGP Keys

        D.1. Officers
        D.2. Core Team Members
        D.3. Developers
        D.4. Other Cluster Account Holders

FreeBSD Glossary
Index

List of Figures

2.1. FreeBSD Boot Loader Menu
2.2. Typical Device Probe Results
2.3. Selecting Installation Media Mode
2.4. Keymap Selection
2.5. Selecting Keyboard Menu
2.6. Setting the Hostname
2.7. Selecting Components to Install
2.8. Installing from the Network
2.9. Choosing a Mirror
2.10. Selecting Guided or Manual Partitioning
2.11. Selecting from Multiple Disks
2.12. Selecting Entire Disk or Partition
2.13. Review Created Partitions
2.14. Manually Create Partitions
2.15. Manually Create Partitions
2.16. Manually Create Partitions
2.17. Final Confirmation
2.18. Fetching Distribution Files
2.19. Verifying Distribution Files
2.20. Extracting Distribution Files
2.21. Setting the root Password
2.22. Choose a Network Interface
2.23. Scanning for Wireless Access Points
2.24. Choosing a Wireless Network
2.25. WPA2 Setup
2.26. Choose IPv4 Networking
2.27. Choose IPv4 DHCP Configuration
2.28. IPv4 Static Configuration
2.29. Choose IPv6 Networking
2.30. Choose IPv6 SLAAC Configuration
2.31. IPv6 Static Configuration
2.32. DNS Configuration
2.33. Select Local or UTC Clock
2.34. Select a Region
2.35. Select a Country
2.36. Select a Time Zone
2.37. Confirm Time Zone
2.38. Selecting Additional Services to Enable
2.39. Enabling Crash Dumps
2.40. Add User Accounts
2.41. Enter User Information
2.42. Exit User and Group Management
2.43. Final Configuration
2.44. Manual Configuration
2.45. Complete the Installation
3.1. FreeBSD Boot Loader Menu
3.2. Typical Device Probe Results
3.3. Selecting Country Menu
3.4. Selecting Keyboard Menu
3.5. Selecting Usage from Sysinstall Main Menu
3.6. Selecting Documentation Menu
3.7. Sysinstall Documentation Menu
3.8. Sysinstall Main Menu
3.9. Sysinstall Keymap Menu
3.10. Sysinstall Main Menu
3.11. Sysinstall Options
3.12. Begin Standard Installation
3.13. Select Drive for FDisk
3.14. Typical fdisk Partitions Before Editing
3.15. Fdisk Partition Using Entire Disk
3.16. Sysinstall Boot Manager Menu
3.17. Exit Select Drive
3.18. Sysinstall Disklabel Editor
3.19. Sysinstall Disklabel Editor with Auto Defaults
3.20. Free Space for Root Partition
3.21. Edit Root Partition Size
3.22. Choose the Root Partition Type
3.23. Choose the Root Mount Point
3.24. Sysinstall Disklabel Editor
3.25. Choose Distributions
3.26. Confirm Distributions
3.27. Choose Installation Media
3.28. Selecting an Ethernet Device
3.29. Set Network Configuration for ed0
3.30. Editing inetd.conf
3.31. Default Anonymous FTP Configuration
3.32. Edit the FTP Welcome Message
3.33. Editing exports
3.34. System Console Configuration Options
3.35. Screen Saver Options
3.36. Screen Saver Timeout
3.37. System Console Configuration Exit
3.38. Select Your Region
3.39. Select Your Country
3.40. Select Your Time Zone
3.41. Select Mouse Protocol Type
3.42. Set Mouse Protocol
3.43. Configure Mouse Port
3.44. Setting the Mouse Port
3.45. Enable the Mouse Daemon
3.46. Test the Mouse Daemon
3.47. Select Package Category
3.48. Select Packages
3.49. Install Packages
3.50. Confirm Package Installation
3.51. Select User
3.52. Add User Information
3.53. Exit User and Group Management
3.54. Exit Install
3.55. Network Configuration Upper-level
3.56. Select a Default MTA
3.57. Ntpdate Configuration
3.58. Network Configuration Lower-level
22.1. Concatenated Organization
22.2. Striped Organization
22.3. RAID-5 Organization
22.4. A Simple vinum Volume
22.5. A Mirrored vinum Volume
22.6. A Striped vinum Volume
22.7. A Mirrored, Striped vinum Volume
32.1. PXE Booting Process with NFS Root Mount

List of Tables

2.1. Partitioning Schemes
3.1. Sample Device Inventory
3.2. Partition Layout for First Disk
3.3. Partition Layout for Subsequent Disks
3.4. FreeBSD ISO Image Names and Meanings
4.1. Disk Device Codes
19.1. Physical Disk Naming Conventions
22.1. vinum Plex Organizations
27.1. DB-25 to DB-25 Null-Modem Cable
27.2. DB-9 to DB-9 Null-Modem Cable
27.3. DB-9 to DB-25 Null-Modem Cable
27.4. Signal Names
32.1. Station Capability Codes
32.2. Reserved IPv6 Addresses

List of Examples

2.1. Using an Existing Partition
2.2. Shrinking an Existing Partition
2.3. Creating Traditional Split Filesystem Partitions
3.1. Using an Existing Partition Unchanged
3.2. Shrinking an Existing Partition
4.1. Sample Disk, Slice, and Partition Names
4.2. Conceptual Model of a Disk
5.1. Downloading a Package Manually and Installing It Locally
12.1. Creating a Swapfile on FreeBSD
13.1. boot0 Screenshot
13.2. boot2 Screenshot
13.3. An Insecure Console in /etc/ttys
14.1. Adding a User on FreeBSD
14.2. rmuser Interactive Account Removal
14.3. Interactive chpass by Superuser
14.4. Interactive chpass by Normal User
14.5. Changing Your Password
14.6. Changing Another User's Password as the Superuser
14.7. Adding a Group Using pw(8)
14.8. Adding User Accounts to a New Group Using pw(8)
14.9. Adding a New Member to a Group Using pw(8)
14.10. Using id(1) to Determine Group Membership
15.1. Using SSH to Create a Secure Tunnel for SMTP
19.1. Using dump over ssh
19.2. Using dump over ssh with RSH Set
19.3. Using mdconfig to Mount an Existing File System Image
19.4. Creating a New File-Backed Disk with mdconfig
19.5. Configure and Mount a File-Backed Disk with mdmfs
19.6. Creating a New Memory-Based Disk with mdconfig
19.7. Creating a New Memory-Based Disk with mdmfs
20.1. Labeling Partitions on the Boot Disk
27.1. Adding Terminal Entries to /etc/ttys
29.1. Configuring the sendmail Access Database
29.2. Mail Aliases
29.3. Example Virtual Domain Mail Map
30.1. Reloading the inetd Configuration File
30.2. Mounting an Export with amd
30.3. Installing Django with Apache2, mod_python3, and PostgreSQL
30.4. Apache Configuration for Django/mod_python
32.1. LACP Aggregation with a CiscoÂ® Switch
32.2. Failover Mode
32.3. Failover Mode Between Wired and Wireless Interfaces
32.4. Branch Office or Home Network
32.5. Head Office or Other LAN

Preface

Intended Audience

The FreeBSD newcomer will find that the first section of this book guides the
user through the FreeBSD installation process and gently introduces the
concepts and conventions that underpin UNIXÂ®. Working through this section
requires little more than the desire to explore, and the ability to take on
board new concepts as they are introduced.

Once you have traveled this far, the second, far larger, section of the
Handbook is a comprehensive reference to all manner of topics of interest to
FreeBSD system administrators. Some of these chapters may recommend that you do
some prior reading, and this is noted in the synopsis at the beginning of each
chapter.

For a list of additional sources of information, please see AppendixÂ B, 
Bibliography.

Changes from the Third Edition

The current online version of the Handbook represents the cumulative effort of
many hundreds of contributors over the past 10 years. The following are some of
the significant changes since the two volume third edition was published in
2004:

  * ChapterÂ 26, DTrace, DTrace, has been added with information about the
    powerful DTrace performance analysis tool.

  * ChapterÂ 21, File Systems Support, File Systems Support, has been added
    with information about non-native file systems in FreeBSD, such as ZFS from
    Sunâ ¢.

  * ChapterÂ 18, Security Event Auditing, Security Event Auditing, has been
    added to cover the new auditing capabilities in FreeBSD and explain its
    use.

  * ChapterÂ 23, Virtualization, Virtualization, has been added with
    information about installing FreeBSD on virtualization software.

  * ChapterÂ 2, Installing FreeBSDÂ 9.X and Later, Installing FreeBSDÂ 9.x and
    Later, has been added to cover installation of FreeBSD using the new
    installation utility, bsdinstall.

Changes from the Second Edition (2004)

The third edition was the culmination of over two years of work by the
dedicated members of the FreeBSD Documentation Project. The printed edition
grew to such a size that it was necessary to publish as two separate volumes.
The following are the major changes in this new edition:

  * ChapterÂ 12, Configuration and Tuning, Configuration and Tuning, has been
    expanded with new information about the ACPI power and resource management,
    the cron system utility, and more kernel tuning options.

  * ChapterÂ 15, Security, Security, has been expanded with new information
    about virtual private networks (VPNs), file system access control lists
    (ACLs), and security advisories.

  * ChapterÂ 17, Mandatory Access Control, Mandatory Access Control (MAC), is a
    new chapter with this edition. It explains what MAC is and how this
    mechanism can be used to secure a FreeBSD system.

  * ChapterÂ 19, Storage, Storage, has been expanded with new information about
    USB storage devices, file system snapshots, file system quotas, file and
    network backed filesystems, and encrypted disk partitions.

  * ChapterÂ 22, The vinum Volume Manager, Vinum, is a new chapter with this
    edition. It describes how to use Vinum, a logical volume manager which
    provides device-independent logical disks, and software RAID-0, RAID-1 and
    RAID-5.

  * A troubleshooting section has been added to ChapterÂ 28, PPP and SLIP, PPP
    and SLIP.

  * ChapterÂ 29, Electronic Mail, Electronic Mail, has been expanded with new
    information about using alternative transport agents, SMTP authentication,
    UUCP, fetchmail, procmail, and other advanced topics.

  * ChapterÂ 30, Network Servers, Network Servers, is all new with this
    edition. This chapter includes information about setting up the Apache HTTP
    Server, ftpd, and setting up a server for MicrosoftÂ® WindowsÂ® clients
    with Samba. Some sections from ChapterÂ 32, Advanced Networking, Advanced
    Networking, were moved here to improve the presentation.

  * ChapterÂ 32, Advanced Networking, Advanced Networking, has been expanded
    with new information about using BluetoothÂ® devices with FreeBSD, setting
    up wireless networks, and Asynchronous Transfer Mode (ATM) networking.

  * A glossary has been added to provide a central location for the definitions
    of technical terms used throughout the book.

  * A number of aesthetic improvements have been made to the tables and figures
    throughout the book.

Changes from the First Edition (2001)

The second edition was the culmination of over two years of work by the
dedicated members of the FreeBSD Documentation Project. The following were the
major changes in this edition:

  * A complete Index has been added.

  * All ASCII figures have been replaced by graphical diagrams.

  * A standard synopsis has been added to each chapter to give a quick summary
    of what information the chapter contains, and what the reader is expected
    to know.

  * The content has been logically reorganized into three parts: â  Getting
    Startedâ  , â  System Administrationâ  , and â  Appendicesâ  .

  * ChapterÂ 3, Installing FreeBSDÂ 8.X and Earlier (â  Installing FreeBSDâ  )
    was completely rewritten with many screenshots to make it much easier for
    new users to grasp the text.

  * ChapterÂ 4, UNIX Basics (â  UNIXÂ® Basicsâ  ) has been expanded to contain
    additional information about processes, daemons, and signals.

  * ChapterÂ 5, Installing Applications: Packages and Ports (â  Installing
    Applicationsâ  ) has been expanded to contain additional information about
    binary package management.

  * ChapterÂ 6, The X Window System (â  The X Window Systemâ  ) has been
    completely rewritten with an emphasis on using modern desktop technologies
    such as KDE and GNOME on XFree86â ¢ 4.X.

  * ChapterÂ 13, The FreeBSD Booting Process (â  The FreeBSD Booting Processâ  
    ) has been expanded.

  * ChapterÂ 19, Storage (â  Storageâ  ) has been written from what used to be
    two separate chapters on â  Disksâ   and â  Backupsâ  . We feel that the
    topics are easier to comprehend when presented as a single chapter. A
    section on RAID (both hardware and software) has also been added.

  * ChapterÂ 27, Serial Communications (â  Serial Communicationsâ  ) has been
    completely reorganized and updated for FreeBSD 4.X/5.X.

  * ChapterÂ 28, PPP and SLIP (â  PPP and SLIPâ  ) has been substantially
    updated.

  * Many new sections have been added to ChapterÂ 32, Advanced Networking (â  
    Advanced Networkingâ  ).

  * ChapterÂ 29, Electronic Mail (â  Electronic Mailâ  ) has been expanded to
    include more information about configuring sendmail.

  * ChapterÂ 11, LinuxÂ® Binary Compatibility (â  LinuxÂ® Compatibilityâ  ) has
    been expanded to include information about installing OracleÂ® and SAPÂ®Â R
    /3Â®.

  * The following new topics are covered in this second edition:

      o Configuration and Tuning (ChapterÂ 12, Configuration and Tuning).

      o Multimedia (ChapterÂ 8, Multimedia)

Organization of This Book

This book is split into five logically distinct sections. The first section, 
Getting Started, covers the installation and basic usage of FreeBSD. It is
expected that the reader will follow these chapters in sequence, possibly
skipping chapters covering familiar topics. The second section, Common Tasks,
covers some frequently used features of FreeBSD. This section, and all
subsequent sections, can be read out of order. Each chapter begins with a
succinct synopsis that describes what the chapter covers and what the reader is
expected to already know. This is meant to allow the casual reader to skip
around to find chapters of interest. The third section, System Administration,
covers administration topics. The fourth section, Network Communication, covers
networking and server topics. The fifth section contains appendices of
reference information.

ChapterÂ 1, Introduction, Introduction

    Introduces FreeBSD to a new user. It describes the history of the FreeBSD
    Project, its goals and development model.

ChapterÂ 3, Installing FreeBSDÂ 8.X and Earlier, Installation of FreeBSDÂ 8.x
    and Earlier

    Walks a user through the entire installation process of FreeBSDÂ 8.x and
    earlier using sysinstall. Some advanced installation topics, such as
    installing through a serial console, are also covered.

ChapterÂ 2, Installing FreeBSDÂ 9.X and Later, Installation of FreeBSDÂ 9.x and
    Later

    Walks a user through the entire installation process of FreeBSDÂ 9.x and
    later using bsdinstall.

ChapterÂ 4, UNIX Basics, UNIXÂ® Basics

    Covers the basic commands and functionality of the FreeBSD operating
    system. If you are familiar with LinuxÂ® or another flavor of UNIXÂ® then
    you can probably skip this chapter.

ChapterÂ 5, Installing Applications: Packages and Ports, Installing
    Applications

    Covers the installation of third-party software with both FreeBSD's
    innovative â  Ports Collectionâ   and standard binary packages.

ChapterÂ 6, The X Window System, The X Window System

    Describes the X Window System in general and using X11 on FreeBSD in
    particular. Also describes common desktop environments such as KDE and 
    GNOME.

ChapterÂ 7, Desktop Applications, Desktop Applications

    Lists some common desktop applications, such as web browsers and
    productivity suites, and describes how to install them on FreeBSD.

ChapterÂ 8, Multimedia, Multimedia

    Shows how to set up sound and video playback support for your system. Also
    describes some sample audio and video applications.

ChapterÂ 9, Configuring the FreeBSD Kernel, Configuring the FreeBSD Kernel

    Explains why you might need to configure a new kernel and provides detailed
    instructions for configuring, building, and installing a custom kernel.

ChapterÂ 10, Printing, Printing

    Describes managing printers on FreeBSD, including information about banner
    pages, printer accounting, and initial setup.

ChapterÂ 11, LinuxÂ® Binary Compatibility, LinuxÂ® Binary Compatibility

    Describes the LinuxÂ® compatibility features of FreeBSD. Also provides
    detailed installation instructions for many popular LinuxÂ® applications
    such as OracleÂ® and MathematicaÂ®.

ChapterÂ 12, Configuration and Tuning, Configuration and Tuning

    Describes the parameters available for system administrators to tune a
    FreeBSD system for optimum performance. Also describes the various
    configuration files used in FreeBSD and where to find them.

ChapterÂ 13, The FreeBSD Booting Process, Booting Process

    Describes the FreeBSD boot process and explains how to control this process
    with configuration options.

ChapterÂ 14, Users and Basic Account Management, Users and Basic Account
    Management

    Describes the creation and manipulation of user accounts. Also discusses
    resource limitations that can be set on users and other account management
    tasks.

ChapterÂ 15, Security, Security

    Describes many different tools available to help keep your FreeBSD system
    secure, including Kerberos, IPsec and OpenSSH.

ChapterÂ 16, Jails, Jails

    Describes the jails framework, and the improvements of jails over the
    traditional chroot support of FreeBSD.

ChapterÂ 17, Mandatory Access Control, Mandatory Access Control

    Explains what Mandatory Access Control (MAC) is and how this mechanism can
    be used to secure a FreeBSD system.

ChapterÂ 18, Security Event Auditing, Security Event Auditing

    Describes what FreeBSD Event Auditing is, how it can be installed,
    configured, and how audit trails can be inspected or monitored.

ChapterÂ 19, Storage, Storage

    Describes how to manage storage media and filesystems with FreeBSD. This
    includes physical disks, RAID arrays, optical and tape media, memory-backed
    disks, and network filesystems.

SectionÂ 20.1, â  Synopsisâ  , GEOM

    Describes what the GEOM framework in FreeBSD is and how to configure
    various supported RAID levels.

ChapterÂ 21, File Systems Support, File Systems Support

    Examines support of non-native file systems in FreeBSD, like the Z File
    System from Sunâ ¢.

ChapterÂ 22, The vinum Volume Manager, Vinum

    Describes how to use Vinum, a logical volume manager which provides
    device-independent logical disks, and software RAID-0, RAID-1 and RAID-5.

ChapterÂ 23, Virtualization, Virtualization

    Describes what virtualization systems offer, and how they can be used with
    FreeBSD.

ChapterÂ 24, Localization - i18n/L10n Usage and Setup, Localization

    Describes how to use FreeBSD in languages other than English. Covers both
    system and application level localization.

ChapterÂ 25, Updating and Upgrading FreeBSD, Updating and Upgrading FreeBSD

    Explains the differences between FreeBSD-STABLE, FreeBSD-CURRENT, and
    FreeBSD releases. Describes which users would benefit from tracking a
    development system and outlines that process. Covers the methods users may
    take to update their system to the latest security release.

ChapterÂ 26, DTrace, DTrace

    Describes how to configure and use the DTrace tool from Sunâ ¢ in FreeBSD.
    Dynamic tracing can help locate performance issues, by performing real time
    system analysis.

ChapterÂ 27, Serial Communications, Serial Communications

    Explains how to connect terminals and modems to your FreeBSD system for
    both dial in and dial out connections.

ChapterÂ 28, PPP and SLIP, PPP and SLIP

    Describes how to use PPP, SLIP, or PPP over Ethernet to connect to remote
    systems with FreeBSD.

ChapterÂ 29, Electronic Mail, Electronic Mail

    Explains the different components of an email server and dives into simple
    configuration topics for the most popular mail server software: sendmail.

ChapterÂ 30, Network Servers, Network Servers

    Provides detailed instructions and example configuration files to set up
    your FreeBSD machine as a network filesystem server, domain name server,
    network information system server, or time synchronization server.

ChapterÂ 31, Firewalls, Firewalls

    Explains the philosophy behind software-based firewalls and provides
    detailed information about the configuration of the different firewalls
    available for FreeBSD.

ChapterÂ 32, Advanced Networking, Advanced Networking

    Describes many networking topics, including sharing an Internet connection
    with other computers on your LAN, advanced routing topics, wireless
    networking, BluetoothÂ®, ATM, IPv6, and much more.

AppendixÂ A, Obtaining FreeBSD, Obtaining FreeBSD

    Lists different sources for obtaining FreeBSD media on CDROM or DVD as well
    as different sites on the Internet that allow you to download and install
    FreeBSD.

AppendixÂ B, Bibliography, Bibliography

    This book touches on many different subjects that may leave you hungry for
    a more detailed explanation. The bibliography lists many excellent books
    that are referenced in the text.

AppendixÂ C, Resources on the Internet, Resources on the Internet

    Describes the many forums available for FreeBSD users to post questions and
    engage in technical conversations about FreeBSD.

AppendixÂ D, PGP Keys, PGP Keys

    Lists the PGP fingerprints of several FreeBSD Developers.

Conventions used in this book

To provide a consistent and easy to read text, several conventions are followed
throughout the book.

Typographic Conventions

Italic

    An italic font is used for filenames, URLs, emphasized text, and the first
    usage of technical terms.

Monospace

    A monospaced font is used for error messages, commands, environment
    variables, names of ports, hostnames, user names, group names, device
    names, variables, and code fragments.

Bold

    A bold font is used for applications, commands, and keys.

User Input

Keys are shown in bold to stand out from other text. Key combinations that are
meant to be typed simultaneously are shown with `+' between the keys, such as:

Ctrl+Alt+Del

Meaning the user should type the Ctrl, Alt, and Del keys at the same time.

Keys that are meant to be typed in sequence will be separated with commas, for
example:

Ctrl+X, Ctrl+S

Would mean that the user is expected to type the Ctrl and X keys simultaneously
and then to type the Ctrl and S keys simultaneously.

Examples

Examples starting with E:\&gt; indicate a MS-DOSÂ® command. Unless otherwise
noted, these commands may be executed from a â  Command Promptâ   window in a
modern MicrosoftÂ®Â WindowsÂ® environment.

E:\&gt; tools\fdimage floppies\kern.flp A:

Examples starting with # indicate a command that must be invoked as the
superuser in FreeBSD. You can login as root to type the command, or login as
your normal account and use su(1) to gain superuser privileges.

# dd if=kern.flp of=/dev/fd0

Examples starting with % indicate a command that should be invoked from a
normal user account. Unless otherwise noted, C-shell syntax is used for setting
environment variables and other shell commands.

% top

Acknowledgments

The book you are holding represents the efforts of many hundreds of people
around the world. Whether they sent in fixes for typos, or submitted complete
chapters, all the contributions have been useful.

Several companies have supported the development of this document by paying
authors to work on it full-time, paying for publication, etc. In particular,
BSDi (subsequently acquired by Wind River Systems) paid members of the FreeBSD
Documentation Project to work on improving this book full time leading up to
the publication of the first printed edition in March 2000 (ISBN
1-57176-241-8). Wind River Systems then paid several additional authors to make
a number of improvements to the print-output infrastructure and to add
additional chapters to the text. This work culminated in the publication of the
second printed edition in November 2001 (ISBN 1-57176-303-1). In 2003-2004,
FreeBSD Mall, Inc, paid several contributors to improve the Handbook in
preparation for the third printed edition.

PartÂ I.Â Getting Started

This part of the FreeBSD Handbook is for users and administrators who are new
to FreeBSD. These chapters:

  * Introduce you to FreeBSD.

  * Guide you through the installation process.

  * Teach you UNIXÂ® basics and fundamentals.

  * Show you how to install the wealth of third party applications available
    for FreeBSD.

  * Introduce you to X, the UNIXÂ® windowing system, and detail how to
    configure a desktop environment that makes you more productive.

We have tried to keep the number of forward references in the text to a minimum
so that you can read this section of the Handbook from front to back with the
minimum page flipping required.

Table of Contents

1. Introduction

    1.1. Synopsis
    1.2. Welcome to FreeBSD!
    1.3. About the FreeBSDÂ Project

2. Installing FreeBSDÂ 9.X and Later

    2.1. Synopsis
    2.2. Hardware Requirements
    2.3. Pre-Installation Tasks
    2.4. Starting the Installation
    2.5. Introducing bsdinstall
    2.6. Installing from the Network
    2.7. Allocating Disk Space
    2.8. Committing to the Installation
    2.9. Post-Installation
    2.10. Troubleshooting
    2.11. Using the Live CD

3. Installing FreeBSDÂ 8.X and Earlier

    3.1. Synopsis
    3.2. Hardware Requirements
    3.3. Pre-installation Tasks
    3.4. Starting the Installation
    3.5. Introducing Sysinstall
    3.6. Allocating Disk Space
    3.7. Choosing What to Install
    3.8. Choosing Your Installation Media
    3.9. Committing to the Installation
    3.10. Post-installation
    3.11. Troubleshooting
    3.12. Advanced Installation Guide
    3.13. Preparing Your Own Installation Media

4. UNIX Basics

    4.1. Synopsis
    4.2. Virtual Consoles and Terminals
    4.3. Permissions
    4.4. Directory Structure
    4.5. Disk Organization
    4.6. Mounting and Unmounting File Systems
    4.7. Processes
    4.8. Daemons, Signals, and Killing Processes
    4.9. Shells
    4.10. Text Editors
    4.11. Devices and Device Nodes
    4.12. Binary Formats
    4.13. For More Information

5. Installing Applications: Packages and Ports

    5.1. Synopsis
    5.2. Overview of Software Installation
    5.3. Finding Software
    5.4. Using Binary Packages
    5.5. Using pkgng for Binary Package Management
    5.6. Using the Ports Collection
    5.7. Post-installation Activities
    5.8. Dealing with Broken Ports

6. The X Window System

    6.1. Synopsis
    6.2. Understanding X
    6.3. Installing X11
    6.4. X11 Configuration
    6.5. Using Fonts in X11
    6.6. The X Display Manager
    6.7. Desktop Environments

ChapterÂ 1.Â Introduction

Restructured, reorganized, and parts rewritten by Jim Mock.
Table of Contents

1.1. Synopsis
1.2. Welcome to FreeBSD!
1.3. About the FreeBSDÂ Project

1.1.Â Synopsis

Thank you for your interest in FreeBSD! The following chapter covers various
aspects of the FreeBSDÂ Project, such as its history, goals, development model,
and so on.

After reading this chapter, you will know:

  * How FreeBSD relates to other computer operating systems.

  * The history of the FreeBSDÂ Project.

  * The goals of the FreeBSDÂ Project.

  * The basics of the FreeBSD open-source development model.

  * And of course: where the name â  FreeBSDâ   comes from.

1.2.Â Welcome to FreeBSD!

FreeBSD is a 4.4BSD-Lite based operating system for Intel (x86 and ItaniumÂ®),
AMD64, Sun UltraSPARCÂ® computers. Ports to other architectures are also
underway. You can also read about the history of FreeBSD, or the current
release. If you are interested in contributing something to the Project (code,
hardware, funding), see the Contributing to FreeBSD article.

1.2.1.Â What Can FreeBSD Do?

FreeBSD has many noteworthy features. Some of these are:

  * Preemptive multitasking with dynamic priority adjustment to ensure smooth
    and fair sharing of the computer between applications and users, even under
    the heaviest of loads.

  * Multi-user facilities which allow many people to use a FreeBSD system
    simultaneously for a variety of things. This means, for example, that
    system peripherals such as printers and tape drives are properly shared
    between all users on the system or the network and that individual resource
    limits can be placed on users or groups of users, protecting critical
    system resources from over-use.

  * Strong TCP/IP networking with support for industry standards such as SCTP,
    DHCP, NFS, NIS, PPP, SLIP, IPsec, and IPv6. This means that your FreeBSD
    machine can interoperate easily with other systems as well as act as an
    enterprise server, providing vital functions such as NFS (remote file
    access) and email services or putting your organization on the Internet
    with WWW, FTP, routing and firewall (security) services.

  * Memory protection ensures that applications (or users) cannot interfere
    with each other. One application crashing will not affect others in any
    way.

  * FreeBSD is a 32-bit operating system (64-bit on the ItaniumÂ®, AMD64, and 
    UltraSPARCÂ®) and was designed as such from the ground up.

  * The industry standard X Window System (X11R7) provides a graphical user
    interface (GUI) for the cost of a common VGA card and monitor and comes
    with full sources.

  * Binary compatibility with many programs built for Linux, SCO, SVR4, BSDI
    and NetBSD.

  * Thousands of ready-to-run applications are available from the FreeBSD ports
    and packages collection. Why search the net when you can find it all right
    here?

  * Thousands of additional and easy-to-port applications are available on the
    Internet. FreeBSD is source code compatible with most popular commercial 
    UNIXÂ® systems and thus most applications require few, if any, changes to
    compile.

  * Demand paged virtual memory and â  merged VM/buffer cacheâ   design
    efficiently satisfies applications with large appetites for memory while
    still maintaining interactive response to other users.

  * SMP support for machines with multiple CPUs.

  * A full complement of C and C++ development tools. Many additional languages
    for advanced research and development are also available in the ports and
    packages collection.

  * Source code for the entire system means you have the greatest degree of
    control over your environment. Why be locked into a proprietary solution at
    the mercy of your vendor when you can have a truly open system?

  * Extensive online documentation.

  * And many more!

FreeBSD is based on the 4.4BSD-Lite release from Computer Systems Research
Group (CSRG) at the University of California at Berkeley, and carries on the
distinguished tradition of BSD systems development. In addition to the fine
work provided by CSRG, the FreeBSDÂ Project has put in many thousands of hours
in fine tuning the system for maximum performance and reliability in real-life
load situations. As many of the commercial giants struggle to field PC
operating systems with such features, performance and reliability, FreeBSD can
offer them now!

The applications to which FreeBSD can be put are truly limited only by your own
imagination. From software development to factory automation, inventory control
to azimuth correction of remote satellite antennae; if it can be done with a
commercial UNIXÂ® product then it is more than likely that you can do it with
FreeBSD too! FreeBSD also benefits significantly from literally thousands of
high quality applications developed by research centers and universities around
the world, often available at little to no cost. Commercial applications are
also available and appearing in greater numbers every day.

Because the source code for FreeBSD itself is generally available, the system
can also be customized to an almost unheard of degree for special applications
or projects, and in ways not generally possible with operating systems from
most major commercial vendors. Here is just a sampling of some of the
applications in which people are currently using FreeBSD:

  * Internet Services: The robust TCP/IP networking built into FreeBSD makes it
    an ideal platform for a variety of Internet services such as:

      o FTP servers

      o World Wide Web servers (standard or secure [SSL])

      o IPv4 and IPv6 routing

      o Firewalls and NAT (â  IP masqueradingâ  ) gateways

      o Electronic Mail servers

      o USENET News or Bulletin Board Systems

      o And more...

    With FreeBSD, you can easily start out small with an inexpensive 386 class
    PC and upgrade all the way up to a quad-processor Xeon with RAID storage as
    your enterprise grows.

  * Education: Are you a student of computer science or a related engineering
    field? There is no better way of learning about operating systems, computer
    architecture and networking than the hands on, under the hood experience
    that FreeBSD can provide. A number of freely available CAD, mathematical
    and graphic design packages also make it highly useful to those whose
    primary interest in a computer is to get other work done!

  * Research: With source code for the entire system available, FreeBSD is an
    excellent platform for research in operating systems as well as other
    branches of computer science. FreeBSD's freely available nature also makes
    it possible for remote groups to collaborate on ideas or shared development
    without having to worry about special licensing agreements or limitations
    on what may be discussed in open forums.

  * Networking: Need a new router? A name server (DNS)? A firewall to keep
    people out of your internal network? FreeBSD can easily turn that unused
    386 or 486 PC sitting in the corner into an advanced router with
    sophisticated packet-filtering capabilities.

  * X Window workstation: FreeBSD is a fine choice for an inexpensive X
    terminal solution, using the freely available X11 server. Unlike an X
    terminal, FreeBSD allows many applications to be run locally if desired,
    thus relieving the burden on a central server. FreeBSD can even boot â  
    disklessâ  , making individual workstations even cheaper and easier to
    administer.

  * Software Development: The basic FreeBSD system comes with a full complement
    of development tools including the renowned GNU C/C++ compiler and
    debugger.

FreeBSD is available in both source and binary form on CD-ROM, DVD, and via
anonymous FTP. Please see AppendixÂ A, Obtaining FreeBSD for more information
about obtaining FreeBSD.

1.2.2.Â Who Uses FreeBSD?

FreeBSD is used as a platform for devices and products from many of the world's
largest IT companies, including:

  * Apple

  * Cisco

  * Juniper

  * NetApp

FreeBSD is also used to power some of the biggest sites on the Internet,
including:

  * Yahoo!

  * Yandex

  * Apache

  * Rambler

  * Sina

  * Pair Networks

  * Sony Japan

  * Netcraft

  * NetEase

  * Weathernews

  * TELEHOUSE America

  * Experts Exchange

and many more.

1.3.Â About the FreeBSDÂ Project

The following section provides some background information on the project,
including a brief history, project goals, and the development model of the
project.

1.3.1.Â A Brief History of FreeBSD

The FreeBSDÂ Project had its genesis in the early part of 1993, partially as an
outgrowth of the Unofficial 386BSDPatchkit by the patchkit's last 3
coordinators: Nate Williams, Rod Grimes and Jordan Hubbard.

The original goal was to produce an intermediate snapshot of 386BSD in order to
fix a number of problems with it that the patchkit mechanism just was not
capable of solving. The early working title for the project was 386BSD 0.5 or
386BSD Interim in reference of that fact.

386BSD was Bill Jolitz's operating system, which had been up to that point
suffering rather severely from almost a year's worth of neglect. As the
patchkit swelled ever more uncomfortably with each passing day, they decided to
assist Bill by providing this interim â  cleanupâ   snapshot. Those plans came
to a rude halt when Bill Jolitz suddenly decided to withdraw his sanction from
the project without any clear indication of what would be done instead.

The trio thought that the goal remained worthwhile, even without Bill's
support, and so they adopted the name "FreeBSD" coined by David Greenman. The
initial objectives were set after consulting with the system's current users
and, once it became clear that the project was on the road to perhaps even
becoming a reality, Jordan contacted Walnut Creek CDROM with an eye toward
improving FreeBSD's distribution channels for those many unfortunates without
easy access to the Internet. Walnut Creek CDROM not only supported the idea of
distributing FreeBSD on CD but also went so far as to provide the project with
a machine to work on and a fast Internet connection. Without Walnut Creek
CDROM's almost unprecedented degree of faith in what was, at the time, a
completely unknown project, it is quite unlikely that FreeBSD would have gotten
as far, as fast, as it has today.

The first CD-ROM (and general net-wide) distribution was FreeBSDÂ 1.0, released
in December of 1993. This was based on the 4.3BSD-Lite (â  Net/2â  ) tape from
U.C. Berkeley, with many components also provided by 386BSD and the Free
Software Foundation. It was a fairly reasonable success for a first offering,
and they followed it with the highly successful FreeBSD 1.1 release in May of
1994.

Around this time, some rather unexpected storm clouds formed on the horizon as
Novell and U.C. Berkeley settled their long-running lawsuit over the legal
status of the Berkeley Net/2 tape. A condition of that settlement was U.C.
Berkeley's concession that large parts of Net/2 were â  encumberedâ   code and
the property of Novell, who had in turn acquired it from AT&T some time
previously. What Berkeley got in return was Novell's â  blessingâ   that the
4.4BSD-Lite release, when it was finally released, would be declared
unencumbered and all existing Net/2 users would be strongly encouraged to
switch. This included FreeBSD, and the project was given until the end of July
1994 to stop shipping its own Net/2 based product. Under the terms of that
agreement, the project was allowed one last release before the deadline, that
release being FreeBSDÂ 1.1.5.1.

FreeBSD then set about the arduous task of literally re-inventing itself from a
completely new and rather incomplete set of 4.4BSD-Lite bits. The â  Liteâ  
releases were light in part because Berkeley's CSRG had removed large chunks of
code required for actually constructing a bootable running system (due to
various legal requirements) and the fact that the Intel port of 4.4 was highly
incomplete. It took the project until November of 1994 to make this transition,
at which point it released FreeBSDÂ 2.0 to the net and on CD-ROM (in late
December). Despite being still more than a little rough around the edges, the
release was a significant success and was followed by the more robust and
easier to install FreeBSDÂ 2.0.5 release in June of 1995.

Since that time, FreeBSD has made a series of releases each time improving the
stability, speed, and feature set of the previous version.

For now, long-term development projects continue to take place in the
10.X-CURRENT (trunk) branch, and snapshot releases of 10.X are continually made
available from the snapshot server as work progresses.

1.3.2.Â FreeBSDÂ Project Goals

Contributed by Jordan Hubbard.

The goals of the FreeBSDÂ Project are to provide software that may be used for
any purpose and without strings attached. Many of us have a significant
investment in the code (and project) and would certainly not mind a little
financial compensation now and then, but we are definitely not prepared to
insist on it. We believe that our first and foremost â  missionâ   is to
provide code to any and all comers, and for whatever purpose, so that the code
gets the widest possible use and provides the widest possible benefit. This is,
I believe, one of the most fundamental goals of Free Software and one that we
enthusiastically support.

That code in our source tree which falls under the GNU General Public License
(GPL) or Library General Public License (LGPL) comes with slightly more strings
attached, though at least on the side of enforced access rather than the usual
opposite. Due to the additional complexities that can evolve in the commercial
use of GPL software we do, however, prefer software submitted under the more
relaxed BSD copyright when it is a reasonable option to do so.

1.3.3.Â The FreeBSD Development Model

Contributed by Satoshi Asami.

The development of FreeBSD is a very open and flexible process, being literally
built from the contributions of hundreds of people around the world, as can be
seen from our list of contributors. FreeBSD's development infrastructure allow
these hundreds of developers to collaborate over the Internet. We are
constantly on the lookout for new developers and ideas, and those interested in
becoming more closely involved with the project need simply contact us at the
FreeBSD technical discussions mailing list. The FreeBSD announcements mailing
list is also available to those wishing to make other FreeBSD users aware of
major areas of work.

Useful things to know about the FreeBSDÂ Project and its development process,
whether working independently or in close cooperation:

The SVN repositories
   
    For several years, the central source tree for FreeBSD was maintained by
    CVS (Concurrent Versions System), a freely available source code control
    tool that comes bundled with FreeBSD. In June 2008, the Project switched to
    using SVN (Subversion). The switch was deemed necessary, as the technical
    limitations imposed by CVS were becoming obvious due to the rapid expansion
    of the source tree and the amount of history already stored. The
    Documentation Project and Ports Collection repositories also moved from CVS
    to SVN in May 2012 and July 2012, respectively. Please refer to the
    Synchronizing your source tree section for more information on obtaining
    the FreeBSD src/ repository and Using the Ports Collection for details on
    obtaining the FreeBSD Ports Collection.

The committers list
   
    The committers are the people who have write access to the Subversion tree,
    and are authorized to make modifications to the FreeBSD source (the term â 
     committerâ   comes from the source control commit command, which is used
    to bring new changes into the repository). The best way of making
    submissions for review by the committers list is to use the send-pr(1)
    command. If something appears to be jammed in the system, then you may also
    reach them by sending mail to the FreeBSD committer's mailing list.

The FreeBSD core team
   
    The FreeBSD core team would be equivalent to the board of directors if the
    FreeBSDÂ Project were a company. The primary task of the core team is to
    make sure the project, as a whole, is in good shape and is heading in the
    right directions. Inviting dedicated and responsible developers to join our
    group of committers is one of the functions of the core team, as is the
    recruitment of new core team members as others move on. The current core
    team was elected from a pool of committer candidates in July 2012.
    Elections are held every 2 years.

    Some core team members also have specific areas of responsibility, meaning
    that they are committed to ensuring that some large portion of the system
    works as advertised. For a complete list of FreeBSD developers and their
    areas of responsibility, please see the Contributors List

    Note:

    Most members of the core team are volunteers when it comes to FreeBSD
    development and do not benefit from the project financially, so â  
    commitmentâ   should also not be misconstrued as meaning â  guaranteed
    support.â   The â  board of directorsâ   analogy above is not very
    accurate, and it may be more suitable to say that these are the people who
    gave up their lives in favor of FreeBSD against their better judgement!

Outside contributors
   
    Last, but definitely not least, the largest group of developers are the
    users themselves who provide feedback and bug fixes to us on an almost
    constant basis. The primary way of keeping in touch with FreeBSD's more
    non-centralized development is to subscribe to the FreeBSD technical
    discussions mailing list where such things are discussed. See AppendixÂ C, 
    Resources on the Internet for more information about the various FreeBSD
    mailing lists.

    The FreeBSD Contributors List is a long and growing one, so why not join it
    by contributing something back to FreeBSD today?

    Providing code is not the only way of contributing to the project; for a
    more complete list of things that need doing, please refer to the
    FreeBSDÂ Project web site.

In summary, our development model is organized as a loose set of concentric
circles. The centralized model is designed for the convenience of the users of
FreeBSD, who are provided with an easy way of tracking one central code base,
not to keep potential contributors out! Our desire is to present a stable
operating system with a large set of coherent application programs that the
users can easily install and use â   this model works very well in
accomplishing that.

All we ask of those who would join us as FreeBSD developers is some of the same
dedication its current people have to its continued success!

1.3.4.Â Third Party Programs

In addition to the base distributions, FreeBSD offers a ported software
collection with thousands of commonly sought-after programs. At the time of
this writing, there were over 24,000 ports! The list of ports ranges from http
servers, to games, languages, editors, and almost everything in between. The
entire Ports Collection requires approximately 500Â MB. To compile a port, you
simply change to the directory of the program you wish to install, type make
install, and let the system do the rest. The full original distribution for
each port you build is retrieved dynamically so you need only enough disk space
to build the ports you want. Almost every port is also provided as a
pre-compiled â  packageâ  , which can be installed with a simple command
(pkg_add) by those who do not wish to compile their own ports from source. More
information on packages and ports can be found in ChapterÂ 5, Installing
Applications: Packages and Ports.

1.3.5.Â Additional Documentation

All recent FreeBSD versions provide an option in the installer (either
sysinstall(8) or bsdinstall(8)) to install additional documentation under /usr/
local/share/doc/freebsd during the initial system setup. Documentation may also
be installed at any later time using packages as described in
SectionÂ 25.4.6.2, â  Using Documentation Packagesâ  . You may view the locally
installed manuals with any HTML capable browser using the following URLs:

The FreeBSD Handbook

    /usr/local/share/doc/freebsd/handbook/index.html

The FreeBSD FAQ

    /usr/local/share/doc/freebsd/faq/index.html

You can also view the master (and most frequently updated) copies at http://
www.FreeBSD.org/.

ChapterÂ 2.Â Installing FreeBSDÂ 9.X and Later

Restructured, reorganized, and parts rewritten by Jim Mock.
The sysinstall walkthrough, screenshots, and general copy by Randy Pratt.
Updated for bsdinstall by Gavin Atkinson and Warren Block.
Table of Contents

2.1. Synopsis
2.2. Hardware Requirements
2.3. Pre-Installation Tasks
2.4. Starting the Installation
2.5. Introducing bsdinstall
2.6. Installing from the Network
2.7. Allocating Disk Space
2.8. Committing to the Installation
2.9. Post-Installation
2.10. Troubleshooting
2.11. Using the Live CD

2.1.Â Synopsis

FreeBSD comes with a text-based, easy to use installation program.
FreeBSDÂ 9.0-RELEASE and later use an installation program called bsdinstall,
while releases prior to FreeBSDÂ 9.0-RELEASE using sysinstall for installation.
This chapter describes the use of bsdinstall. The use of sysinstall is covered
in ChapterÂ 3, Installing FreeBSDÂ 8.X and Earlier.

After reading this chapter, you will know:

  * How to create the FreeBSD installation media.

  * How FreeBSD subdivides and refers to hard disks.

  * How to start bsdinstall.

  * The questions bsdinstall will ask you, what they mean, and how to answer
    them.

Before reading this chapter, you should:

  * Read the supported hardware list that shipped with the version of FreeBSD
    you are installing, and verify that your hardware is supported.

Note:

In general, these installation instructions are written for i386â ¢ (â  PC
compatibleâ  ) architecture computers. Where applicable, instructions specific
to other platforms will be listed. There may be minor differences between the
installer and what is shown here, so use this chapter as a general guide rather
than as exact literal instructions.

2.2.Â Hardware Requirements

2.2.1.Â Minimal Configuration

The minimal configuration to install FreeBSD varies with the FreeBSD version
and the hardware architecture.

A summary of this information is given in the following sections. Depending on
the method you choose to install FreeBSD, you may also need a supported CDROM
drive, and in some cases a network adapter. This will be covered by
SectionÂ 2.3.5, â  Prepare the Installation Mediaâ  .

2.2.1.1.Â FreeBSD/i386

FreeBSD/i386 requires a 486 or better processor and at least 64Â MB of RAM. At
least 1.1Â GB of free hard drive space is needed for the most minimal
installation.

Note:

On old computers, increasing RAM and hard drive space is usually more effective
at improving performance than installing a faster processor.

2.2.1.2.Â FreeBSD/amd64

There are two classes of processors capable of running FreeBSD/amd64. The first
are AMD64 processors, including the AMDÂ Athlonâ ¢64, AMDÂ Athlonâ ¢64-FX, 
AMDÂ Opteronâ ¢ or better processors.

The second class of processors that can use FreeBSD/amd64 includes those using
the IntelÂ®Â EM64T architecture. Examples of these processors include the Intel
Â®Â Coreâ ¢Â 2 Duo, Quad, Extreme processor families, the IntelÂ®Â Xeonâ ¢
3000, 5000, and 7000 sequences of processors, and the IntelÂ®Â Coreâ ¢ i3, i5
and i7 processors.

If you have a machine based on an nVidia nForce3 Pro-150, you must use the BIOS
setup to disable the IO APIC. If you do not have an option to do this, you will
likely have to disable ACPI instead. There are bugs in the Pro-150 chipset for
which we have not yet found a workaround.

2.2.1.3.Â FreeBSD/powerpc AppleÂ® MacintoshÂ®

All New World AppleÂ® MacintoshÂ® systems with built-in USB are supported. SMP
is supported on machines with multiple CPUs.

A 32-bit kernel can only use the first 2Â GB of RAM. FireWireÂ® is not
supported on the Blue & White PowerMac G3.

2.2.1.4.Â FreeBSD/sparc64

Systems supported by FreeBSD/sparc64 are listed at the FreeBSD/sparc64 Project.

A dedicated disk is required for FreeBSD/sparc64. It is not possible to share a
disk with another operating system at this time.

2.2.2.Â Supported Hardware

Hardware architectures and devices supported by a FreeBSD release are listed in
the Hardware Notes file. Usually named HARDWARE.TXT, the file is located in the
root directory of the release media. Copies of the supported hardware list are
also available on the Release Information page of the FreeBSD web site.

2.3.Â Pre-Installation Tasks

2.3.1.Â Back Up Your Data

Back up all important data on the target computer where FreeBSD will be
installed. Test the backups before continuing. The FreeBSD installer will ask
before making changes to the disk, but once the process has started it cannot
be undone.

2.3.2.Â Decide Where to Install FreeBSD

If FreeBSD will be the only operating system installed, and will be allowed to
use the entire hard disk, the rest of this section can be skipped. But if
FreeBSD will share the disk with other operating systems, an understanding of
disk layout is useful during the installation.

2.3.2.1.Â Disk Layouts for FreeBSD/i386 and FreeBSD/amd64

Hard disks can be divided into multiple sections. These sections are called
partitions.

There are two ways of dividing a disk into partitions. A traditional Master
Boot Record (MBR) holds a partition table defining up to four primary
partitions. (For historical reasons, FreeBSD calls primary partitions slices.)
A limit of only four partitions is restrictive for large disks, so one of these
primary partitions can be made into an extended partition. Multiple logical
partitions may then be created inside the extended partition. This may sound a
little unwieldy, and it is.

The GUID Partition Table (GPT) is a newer and simpler method of partitioning a
disk. GPT is far more versatile than the traditional MBR partition table.
Common GPT implementations allow up to 128 partitions per disk, eliminating the
need for inconvenient workarounds like logical partitions.

Warning:

Some older operating systems like WindowsÂ®Â XP are not compatible with the GPT
partition scheme. If FreeBSD will be sharing a disk with such an operating
system, MBR partitioning is required.

FreeBSD's standard boot loader requires either a primary or GPT partition. (See
ChapterÂ 13, The FreeBSD Booting Process for more information about the FreeBSD
booting process.) If all of the primary or GPT partitions are already in use,
one must be freed for FreeBSD.

A minimal installation of FreeBSD takes as little as 1Â GB of disk space.
However, that is a very minimal install, leaving almost no free space. A more
realistic minimum is 3Â GB without a graphical environment, and 5Â GB or more
if a graphical user interface will be used. Third-party application software
requires more space.

A variety of free and commercial partition resizing tools are available.
GParted Live is a free Live CD which includes the GParted partition editor. 
GParted is also included with many other Linux Live CD distributions.

Warning:

Disk partition applications can destroy data. Make a full backup and verify its
integrity before modifying disk partitions.

Resizing MicrosoftÂ®Â Vista partitions can be difficult. A Vista installation
CDROM can be useful when attempting such an operation.

ExampleÂ 2.1.Â Using an Existing Partition

A WindowsÂ® computer has a single 40Â GB disk that has been split into two
20Â GB partitions. WindowsÂ® calls them C: and D:. The C: partition contains
10Â GB of data, and the D: partition contains 5Â GB of data.

Moving the data from D: to C: frees up the second partition to be used for
FreeBSD.


ExampleÂ 2.2.Â Shrinking an Existing Partition

A WindowsÂ® computer has a single 40Â GB disk and one large partition using the
whole disk. WindowsÂ® shows this 40Â GB partition as a single C:. 15Â GB of
space is being used. The goal is to end up with WindowsÂ® in a 20Â GB
partition, and have another 20Â GB partition for FreeBSD.

There are two ways to do this:

 1. Back up your WindowsÂ® data. Then reinstall WindowsÂ®, creating a 20Â GB
    partition during the install.

 2. Use a partition resizing tool like GParted to shrink the WindowsÂ®
    partition and create a new partition in the freed space for FreeBSD.


Disk partitions containing different operating systems make it possible to run
any one of those operating systems at a time. An alternative method that allows
running multiple operating systems at the same time is covered in ChapterÂ 23, 
Virtualization.

2.3.3.Â Collect Network Information

Some FreeBSD installation methods need a network connection to download files.
To connect to an Ethernet network (or cable or DSL modem with an Ethernet
interface), the installer will request some information about the network.

DHCP is commonly used to provide automatic network configuration. If DHCP is
not available, this network information must be obtained from the local network
administrator or service provider:

Network Information

 1. IP address

 2. Subnet mask

 3. Default router IP address

 4. Domain name of the local network

 5. DNS server IP address(es)

2.3.4.Â Check for FreeBSD Errata

Although the FreeBSDÂ Project strives to ensure that each release of FreeBSD is
as stable as possible, bugs occasionally creep into the process. On very rare
occasions those bugs affect the installation process. As these problems are
discovered and fixed, they are noted in the FreeBSD Errata on the FreeBSD web
site. Check the errata before installing to make sure that there are no
problems that might affect the installation.

Information and errata for all the releases can be found on the release
information section of the FreeBSD web site.

2.3.5.Â Prepare the Installation Media

A FreeBSD installation is started by booting the computer with a FreeBSD
installation CD, DVD, or USB memory stick. The installer is not a program that
can be run from within another operating system.

In addition to the standard installation media which contains copies of all the
FreeBSD installation files, there is a bootonly variant. Bootonly install media
does not have copies of the installation files, but downloads them from the
network during an install. The bootonly install CD is consequently much
smaller, and reduces bandwidth usage during the install by only downloading
required files.

Copies of FreeBSD installation media are available at the FreeBSD web site.

Tip:

If you already have a copy of FreeBSD on CDROM, DVD, or USB memory stick, this
section can be skipped.

FreeBSD CD and DVD images are bootable ISO files. Only one CD or DVD is needed
for an install. Burn the ISO image to a bootable CD or DVD using the CD
recording applications available with your current operating system.

To create a bootable memory stick, follow these steps:

 1. Acquire the Memory Stick Image

    Memory stick images for FreeBSDÂ 9.0-RELEASE and later can be downloaded
    from the ISO-IMAGES/ directory at ftp://ftp.FreeBSD.org/pub/FreeBSD/
    releases/arch/arch/ISO-IMAGES/version/FreeBSD-version-RELEASE-arch
    -memstick.img. Replace arch and version with the architecture and the
    version number which you want to install, respectively. For example, the
    memory stick images for FreeBSD/i386Â 9.0-RELEASE are available from ftp://
    ftp.FreeBSD.org/pub/FreeBSD/releases/i386/i386/ISO-IMAGES/9.0/
    FreeBSD-9.0-RELEASE-i386-memstick.img.

    Tip:

    A different directory path is used for FreeBSDÂ 8.X and earlier versions.
    Details of download and installation of FreeBSDÂ 8.X and earlier is covered
    in ChapterÂ 3, Installing FreeBSDÂ 8.X and Earlier.

    The memory stick image has a .img extension. The ISO-IMAGES/ directory
    contains a number of different images, and the one needed depends on the
    version of FreeBSD being installed, and in some cases, the target hardware.

    Important:

    Before proceeding, back up the data on the USB stick, as this procedure
    will erase it.

 2. Write the Image File to the Memory Stick

    ProcedureÂ 2.1.Â Using FreeBSD to Write the Image

    Warning:

    The example below shows /dev/da0 as the target device where the image will
    be written. Be very careful that the correct device is used as the output
    target, or you may destroy existing data.

      + Writing the Image with dd(1)

        The .img file is not a regular file. It is an image of the complete
        contents of the memory stick. It cannot simply be copied like a regular
        file, but must be written directly to the target device with dd(1):

        # dd if=FreeBSD-9.0-RELEASE-i386-memstick.img of=/dev/da0 bs=64k
    ProcedureÂ 2.2.Â Using WindowsÂ® to Write the Image

    Warning:

    Be sure to give the correct drive letter as the output target, or you may
    overwrite and destroy existing data.

     1. Obtaining Image Writer for WindowsÂ®

        Image Writer for WindowsÂ® is a free application that can correctly
        write an image file to a memory stick. Download it from https://
        launchpad.net/win32-image-writer/ and extract it into a folder.

     2. Writing the Image with Image Writer

        Double-click the Win32DiskImager icon to start the program. Verify that
        the drive letter shown under Device is the drive with the memory stick.
        Click the folder icon and select the image to be written to the memory
        stick. Click [Â SaveÂ ] to accept the image file name. Verify that
        everything is correct, and that no folders on the memory stick are open
        in other windows. When everything is ready, click [Â WriteÂ ] to write
        the image file to the memory stick.

Note:

Installation from floppy disks is no longer supported.

You are now ready to start installing FreeBSD.

2.4.Â Starting the Installation

Important:

By default, the installation will not make any changes to your disk(s) until
you see the following message:

Your changes will now be written to disk.  If you
have chosen to overwrite existing data, it will
be PERMANENTLY ERASED. Are you sure you want to
commit your changes?

The install can be exited at any time prior to this warning without changing
the contents of the hard drive. If you are concerned that you have configured
something incorrectly you can just turn the computer off before this point, and
no damage will be done.

2.4.1.Â Booting

2.4.1.1.Â Booting on i386â ¢ and amd64

 1. If you prepared a â  bootableâ   USB stick, as described in SectionÂ 2.3.5,
    â  Prepare the Installation Mediaâ  , then plug in your USB stick before
    turning on the computer.

    If you are booting from CDROM, then you will need to turn on the computer,
    and insert the CDROM at the first opportunity.

 2. Configure your machine to boot from either the CDROM or from USB, depending
    on the media being used for the installation. BIOS configurations allow the
    selection of a specific boot device. Most systems also provide for
    selecting a boot device during startup, typically by pressing F10, F11, F12
    , or Escape.

 3. If your computer starts up as normal and loads your existing operating
    system, then either:

     1. The disks were not inserted early enough in the boot process. Leave
        them in, and try restarting your computer.

     2. The BIOS changes earlier did not work correctly. You should redo that
        step until you get the right option.

     3. Your particular BIOS does not support booting from the desired media.
        The Plop Boot Manager can be used to boot older computers from CD or
        USB media.

 4. FreeBSD will start to boot. If you are booting from CDROM you will see a
    display similar to this (version information omitted):

    Booting from CD-ROM... 645MB medium detected CD Loader 1.2 Building the
    boot loader arguments Looking up /BOOT/LOADER... Found Relocating the
    loader and the BTX Starting the BTX loader BTX loader 1.00 BTX version is
    1.02 Consoles: internal video/keyboard BIOS CD is cd0 BIOS drive C: is
    disk0 BIOS drive D: is disk1 BIOS 636kB/261056kB available memory FreeBSD/
    i386 bootstrap loader, Revision 1.1 Loading /boot/defaults/loader.conf /
    boot/kernel/kernel text=0x64daa0 data=0xa4e80+0xa9e40 syms=
    [0x4+0x6cac0+0x4+0x88e9d] \
 5. The FreeBSD boot loader is displayed:

    FigureÂ 2.1.Â FreeBSD Boot Loader Menu
    FreeBSD Boot Loader Menu


    Either wait ten seconds, or press Enter.

2.4.1.2.Â Booting for MacintoshÂ® PowerPCÂ®

On most machines, holding C on the keyboard during boot will boot from the CD.
Otherwise, hold Command+Option+O+F, or Windows+Alt+O+F on non-AppleÂ®
keyboards. At the 0 &gt; prompt, enter

boot cd:,\ppc\loader cd:0

For Xserves without keyboards, see AppleÂ®'s support web site about booting
into Open Firmware.

2.4.1.3.Â Booting for SPARC64Â®

Most SPARC64Â® systems are set up to boot automatically from disk. To install
FreeBSD, you need to boot over the network or from a CDROM, which requires you
to break into the PROM (OpenFirmware).

To do this, reboot the system, and wait until the boot message appears. It
depends on the model, but should look about like:

Sun Blade 100 (UltraSPARC-IIe), Keyboard Present Copyright 1998-2001 Sun
Microsystems, Inc. All rights reserved. OpenBoot 4.2, 128 MB memory installed,
Serial #51090132. Ethernet address 0:3:ba:b:92:d4, Host ID: 830b92d4.

If your system proceeds to boot from disk at this point, you need to press L1+A
or Stop+A on the keyboard, or send a BREAK over the serial console (using for
example ~# in tip(1) or cu(1)) to get to the PROM prompt. It looks like this:

ok 1 ok {0} 2

1    This is the prompt used on systems with just one CPU.

2    This is the prompt used on SMP systems, the digit indicates the number of
     the active CPU.

At this point, place the CDROM into your drive, and from the PROM prompt, type
boot cdrom.

2.4.2.Â Reviewing the Device Probe Results

The last few hundred lines that have been displayed on screen are stored and
can be reviewed.

To review the buffer, press Scroll Lock. This turns on scrolling in the
display. You can then use the arrow keys, or PageUp and PageDown to view the
results. Press Scroll Lock again to stop scrolling.

Do this now, to review the text that scrolled off the screen when the kernel
was carrying out the device probes. You will see text similar to FigureÂ 2.2, â
  Typical Device Probe Resultsâ  , although the precise text will differ
depending on the devices that you have in your computer.

FigureÂ 2.2.Â Typical Device Probe Results
Copyright (c) 1992-2011 The FreeBSD Project. Copyright (c) 1979, 1980, 1983,
1986, 1988, 1989, 1991, 1992, 1993, 1994 The Regents of the University of
California. All rights reserved. FreeBSD is a registered trademark of The
FreeBSD Foundation. FreeBSD 9.0-RELEASE #0 r225473M: Sun Sep 11 16:07:30 BST
2011 root@psi:/usr/obj/usr/src/sys/GENERIC amd64 CPU: Intel(R) Core(TM)2 Duo
CPU T9400 @ 2.53GHz (2527.05-MHz K8-class CPU) Origin = "GenuineIntel" Id =
0x10676 Family = 6 Model = 17 Stepping = 6 Features=0xbfebfbff
&lt;FPU,VME,DE,PSE,TSC,MSR,PAE,MCE,CX8,APIC,SEP,MTRR,PGE,MCA,CMOV,PAT,PSE36,CLFLUSH,DTS,ACPI,MMX,FXSR,SSE,SSE2,SS,HTT,TM,PBE&gt;
Features2=0x8e3fd
&lt;SSE3,DTES64,MON,DS_CPL,VMX,SMX,EST,TM2,SSSE3,CX16,xTPR,PDCM,SSE4.1&gt; AMD
Features=0x20100800&lt;SYSCALL,NX,LM&gt; AMD Features2=0x1&lt;LAHF&gt; TSC: P-state
invariant, performance statistics real memory = 3221225472 (3072 MB) avail
memory = 2926649344 (2791 MB) Event timer "LAPIC" quality 400 ACPI APIC Table:
&lt;TOSHIB A0064 &gt; FreeBSD/SMP: Multiprocessor System Detected: 2 CPUs FreeBSD/
SMP: 1 package(s) x 2 core(s) cpu0 (BSP): APIC ID: 0 cpu1 (AP): APIC ID: 1
ioapic0: Changing APIC ID to 1 ioapic0 &lt;Version 2.0&gt; irqs 0-23 on motherboard
kbd1 at kbdmux0 acpi0: &lt;TOSHIB A0064&gt; on motherboard acpi0: Power Button
(fixed) acpi0: reservation of 0, a0000 (3) failed acpi0: reservation of 100000,
b6690000 (3) failed Timecounter "ACPI-safe" frequency 3579545 Hz quality 850
acpi_timer0: &lt;24-bit timer at 3.579545MHz&gt; port 0xd808-0xd80b on acpi0 cpu0:
&lt;ACPI CPU&gt; on acpi0 ACPI Warning: Incorrect checksum in table [ASF!] - 0xFE,
should be 0x9A (20110527/tbutils-282) cpu1: &lt;ACPI CPU&gt; on acpi0 pcib0: &lt;ACPI
Host-PCI bridge&gt; port 0xcf8-0xcff on acpi0 pci0: &lt;ACPI PCI bus&gt; on pcib0
vgapci0: &lt;VGA-compatible display&gt; port 0xcff8-0xcfff mem
0xff400000-0xff7fffff,0xe0000000-0xefffffff irq 16 at device 2.0 on pci0 agp0:
&lt;Intel GM45 SVGA controller&gt; on vgapci0 agp0: aperture size is 256M, detected
131068k stolen memory vgapci1: &lt;VGA-compatible display&gt; mem
0xffc00000-0xffcfffff at device 2.1 on pci0 pci0: &lt;simple comms&gt; at device 3.0
(no driver attached) em0: &lt;Intel(R) PRO/1000 Network Connection 7.2.3&gt; port
0xcf80-0xcf9f mem 0xff9c0000-0xff9dffff,0xff9fe000-0xff9fefff irq 20 at device
25.0 on pci0 em0: Using an MSI interrupt em0: Ethernet address:
00:1c:7e:6a:ca:b0 uhci0: &lt;Intel 82801I (ICH9) USB controller&gt; port
0xcf60-0xcf7f irq 16 at device 26.0 on pci0 usbus0: &lt;Intel 82801I (ICH9) USB
controller&gt; on uhci0 uhci1: &lt;Intel 82801I (ICH9) USB controller&gt; port
0xcf40-0xcf5f irq 21 at device 26.1 on pci0 usbus1: &lt;Intel 82801I (ICH9) USB
controller&gt; on uhci1 uhci2: &lt;Intel 82801I (ICH9) USB controller&gt; port
0xcf20-0xcf3f irq 19 at device 26.2 on pci0 usbus2: &lt;Intel 82801I (ICH9) USB
controller&gt; on uhci2 ehci0: &lt;Intel 82801I (ICH9) USB 2.0 controller&gt; mem
0xff9ff800-0xff9ffbff irq 19 at device 26.7 on pci0 usbus3: EHCI version 1.0
usbus3: &lt;Intel 82801I (ICH9) USB 2.0 controller&gt; on ehci0 hdac0: &lt;Intel 82801I
High Definition Audio Controller&gt; mem 0xff9f8000-0xff9fbfff irq 22 at device
27.0 on pci0 pcib1: &lt;ACPI PCI-PCI bridge&gt; irq 17 at device 28.0 on pci0 pci1:
&lt;ACPI PCI bus&gt; on pcib1 iwn0: &lt;Intel(R) WiFi Link 5100&gt; mem
0xff8fe000-0xff8fffff irq 16 at device 0.0 on pci1 pcib2: &lt;ACPI PCI-PCI bridge&gt;
irq 16 at device 28.1 on pci0 pci2: &lt;ACPI PCI bus&gt; on pcib2 pcib3: &lt;ACPI
PCI-PCI bridge&gt; irq 18 at device 28.2 on pci0 pci4: &lt;ACPI PCI bus&gt; on pcib3
pcib4: &lt;ACPI PCI-PCI bridge&gt; at device 30.0 on pci0 pci5: &lt;ACPI PCI bus&gt; on
pcib4 cbb0: &lt;RF5C476 PCI-CardBus Bridge&gt; at device 11.0 on pci5 cardbus0:
&lt;CardBus bus&gt; on cbb0 pccard0: &lt;16-bit PCCard bus&gt; on cbb0 isab0: &lt;PCI-ISA
bridge&gt; at device 31.0 on pci0 isa0: &lt;ISA bus&gt; on isab0 ahci0: &lt;Intel ICH9M
AHCI SATA controller&gt; port
0x8f58-0x8f5f,0x8f54-0x8f57,0x8f48-0x8f4f,0x8f44-0x8f47,0x8f20-0x8f3f mem
0xff9fd800-0xff9fdfff irq 19 at device 31.2 on pci0 ahci0: AHCI v1.20 with 4
3Gbps ports, Port Multiplier not supported ahcich0: &lt;AHCI channel&gt; at channel 0
on ahci0 ahcich1: &lt;AHCI channel&gt; at channel 1 on ahci0 ahcich2: &lt;AHCI channel&gt;
at channel 4 on ahci0 acpi_lid0: &lt;Control Method Lid Switch&gt; on acpi0 battery0:
&lt;ACPI Control Method Battery&gt; on acpi0 acpi_button0: &lt;Power Button&gt; on acpi0
acpi_acad0: &lt;AC Adapter&gt; on acpi0 acpi_toshiba0: &lt;Toshiba HCI Extras&gt; on acpi0
acpi_tz0: &lt;Thermal Zone&gt; on acpi0 attimer0: &lt;AT timer&gt; port 0x40-0x43 irq 0 on
acpi0 Timecounter "i8254" frequency 1193182 Hz quality 0 Event timer "i8254"
frequency 1193182 Hz quality 100 atkbdc0: &lt;Keyboard controller (i8042)&gt; port
0x60,0x64 irq 1 on acpi0 atkbd0: &lt;AT Keyboard&gt; irq 1 on atkbdc0 kbd0 at atkbd0
atkbd0: [GIANT-LOCKED] psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0 psm0:
[GIANT-LOCKED] psm0: model GlidePoint, device ID 0 atrtc0: &lt;AT realtime clock&gt;
port 0x70-0x71 irq 8 on acpi0 Event timer "RTC" frequency 32768 Hz quality 0
hpet0: &lt;High Precision Event Timer&gt; iomem 0xfed00000-0xfed003ff on acpi0
Timecounter "HPET" frequency 14318180 Hz quality 950 Event timer "HPET"
frequency 14318180 Hz quality 450 Event timer "HPET1" frequency 14318180 Hz
quality 440 Event timer "HPET2" frequency 14318180 Hz quality 440 Event timer
"HPET3" frequency 14318180 Hz quality 440 uart0: &lt;16550 or compatible&gt; port
0x3f8-0x3ff irq 4 flags 0x10 on acpi0 sc0: &lt;System console&gt; at flags 0x100 on
isa0 sc0: VGA &lt;16 virtual consoles, flags=0x300&gt; vga0: &lt;Generic ISA VGA&gt; at
port 0x3c0-0x3df iomem 0xa0000-0xbffff on isa0 ppc0: cannot reserve I/O port
range est0: &lt;Enhanced SpeedStep Frequency Control&gt; on cpu0 p4tcc0: &lt;CPU
Frequency Thermal Control&gt; on cpu0 est1: &lt;Enhanced SpeedStep Frequency Control&gt;
on cpu1 p4tcc1: &lt;CPU Frequency Thermal Control&gt; on cpu1 Timecounters tick every
1.000 msec hdac0: HDA Codec #0: Realtek ALC268 hdac0: HDA Codec #1: Lucent/
Agere Systems (Unknown) pcm0: &lt;HDA Realtek ALC268 PCM #0 Analog&gt; at cad 0 nid 1
on hdac0 pcm1: &lt;HDA Realtek ALC268 PCM #1 Analog&gt; at cad 0 nid 1 on hdac0
usbus0: 12Mbps Full Speed USB v1.0 usbus1: 12Mbps Full Speed USB v1.0 usbus2:
12Mbps Full Speed USB v1.0 usbus3: 480Mbps High Speed USB v2.0 ugen0.1: &lt;Intel&gt;
at usbus0 uhub0: &lt;Intel UHCI root HUB, class 9/0, rev 1.00/1.00, addr 1&gt; on
usbus0 ugen1.1: &lt;Intel&gt; at usbus1 uhub1: &lt;Intel UHCI root HUB, class 9/0, rev
1.00/1.00, addr 1&gt; on usbus1 ugen2.1: &lt;Intel&gt; at usbus2 uhub2: &lt;Intel UHCI root
HUB, class 9/0, rev 1.00/1.00, addr 1&gt; on usbus2 ugen3.1: &lt;Intel&gt; at usbus3
uhub3: &lt;Intel EHCI root HUB, class 9/0, rev 2.00/1.00, addr 1&gt; on usbus3 uhub0:
2 ports with 2 removable, self powered uhub1: 2 ports with 2 removable, self
powered uhub2: 2 ports with 2 removable, self powered uhub3: 6 ports with 6
removable, self powered ugen2.2: &lt;vendor 0x0b97&gt; at usbus2 uhub8: &lt;vendor
0x0b97 product 0x7761, class 9/0, rev 1.10/1.10, addr 2&gt; on usbus2 ugen1.2:
&lt;Microsoft&gt; at usbus1 ada0 at ahcich0 bus 0 scbus1 target 0 lun 0 ada0:
&lt;Hitachi HTS543225L9SA00 FBEOC43C&gt; ATA-8 SATA 1.x device ada0: 150.000MB/s
transfers (SATA 1.x, UDMA6, PIO 8192bytes) ada0: Command Queueing enabled ada0:
238475MB (488397168 512 byte sectors: 16H 63S/T 16383C) ada0: Previously was
known as ad4 ums0: &lt;Microsoft Microsoft 3-Button Mouse with IntelliEyeTM, class
0/0, rev 1.10/3.00, addr 2&gt; on usbus1 SMP: AP CPU #1 Launched! cd0 at ahcich1
bus 0 scbus2 target 0 lun 0 cd0: &lt;TEAC DV-W28S-RT 7.0C&gt; Removable CD-ROM SCSI-0
device cd0: 150.000MB/s transfers (SATA 1.x, ums0: 3 buttons and [XYZ]
coordinates ID=0 UDMA2, ATAPI 12bytes, PIO 8192bytes) cd0: cd present [1 x 2048
byte records] ugen0.2: &lt;Microsoft&gt; at usbus0 ukbd0: &lt;Microsoft Natural
Ergonomic Keyboard 4000, class 0/0, rev 2.00/1.73, addr 2&gt; on usbus0 kbd2 at
ukbd0 uhid0: &lt;Microsoft Natural Ergonomic Keyboard 4000, class 0/0, rev 2.00/
1.73, addr 2&gt; on usbus0 Trying to mount root from cd9660:/dev/iso9660/
FREEBSD_INSTALL [ro]...


Check the probe results carefully to make sure that FreeBSD found all the
devices you expected. If a device was not found, then it will not be listed.
Kernel modules allows you to add in support for devices which are not in the
GENERIC kernel.

After the procedure of device probing, you will see FigureÂ 2.3, â  Selecting
Installation Media Modeâ  . The install media can be used in three ways: to
install FreeBSD, as a live CD, or to simply access a FreeBSD shell. Use the
arrow keys to choose an option, and Enter to select.

FigureÂ 2.3.Â Selecting Installation Media Mode
Selecting Installation Media Mode


Selecting [Â InstallÂ ] here will enter the installer.

2.5.Â Introducing bsdinstall

bsdinstall is a text-based FreeBSD installer program written by Nathan
Whitehorn &lt;nwhitehorn@FreeBSD.org&gt; and introduced in 2011 for FreeBSDÂ 9.0.

Note:

Kris Moore &lt;kmoore@FreeBSD.org&gt;'s pc-sysinstall is included with PC-BSD, and
can also be used to install FreeBSD. Although sometimes confused with 
bsdinstall, the two are not related.

The bsdinstall menu system is controlled by the arrow keys, Enter, Tab, Space,
and other keys.

2.5.1.Â Selecting the Keymap Menu

Depending on the system console being used, bsdinstall may initially prompt to
select a non-default keyboard layout.

FigureÂ 2.4.Â Keymap Selection
Keymap Selection


If [Â YESÂ ] is selected, the following keyboard selection screen will be
displayed. Otherwise, this selection menu will not be displayed, and a default
keyboard mapping will be used.

FigureÂ 2.5.Â Selecting Keyboard Menu
Selecting Keyboard Menu


Select the keymap that most closely represents the mapping of the keyboard
attached to the system, using the up/down arrow keys and pressing Enter.

Note:

Pressing Esc will use the default keymap. United States of America ISO-8859-1
is also a safe option if the choice of keymap is not clear.

2.5.2.Â Setting the Hostname

Next, bsdinstall will prompt for the hostname to be given to the newly
installed system.

FigureÂ 2.6.Â Setting the Hostname
Setting the Hostname


The entered hostname should be a fully-qualified hostname, such as
machine3.example.com

2.5.3.Â Selecting Components to Install

Next, bsdinstall will prompt to select optional components to install.

FigureÂ 2.7.Â Selecting Components to Install
Selecting Components to Install


Deciding which components to install will depend largely on the intended use of
the system and the amount of disk space available. The FreeBSD Kernel and
userland (collectively the â  base systemâ  ) are always installed.

Depending on the type of installation, some of these components may not appear.

Optional Components

  * doc - Additional documentation, mostly of historical interest.
    Documentation provided by the FreeBSD Documentation Project may be
    installed later.

  * games - Several traditional BSD games, including fortune, rot13, and
    others.

  * lib32 - Compatibility libraries for running 32-bit applications on a 64-bit
    version of FreeBSD.

  * ports - The FreeBSD Ports Collection.

    The ports collection is an easy and convenient way to install software. The
    Ports Collection does not contain the source code necessary to compile the
    software. Instead, it is a collection of files which automates the
    downloading, compiling and installation of third-party software packages.
    ChapterÂ 5, Installing Applications: Packages and Ports discusses how to
    use the ports collection.

    Warning:

    The installation program does not check to see if you have adequate space.
    Select this option only if you have adequate hard disk space. As of
    FreeBSDÂ 9.0, the FreeBSD Ports Collection takes up about 500Â MB of disk
    space. You can safely assume a larger value for more recent versions of
    FreeBSD.

  * src - System source code.

    FreeBSD comes with full source code for both the kernel and the userland.
    Although not required for the majority of applications, it may be required
    to build certain software supplied as source (for example, device drivers
    or kernel modules), or for developing FreeBSD itself.

    The full source tree requires 1Â GB of disk space, and recompiling the
    entire FreeBSD system requires an additional 5Â GB of space.

2.6.Â Installing from the Network

The bootonly installation media does not hold copies of the installation files.
When a bootonly installation method is used, the files must be retrieved over a
network connection as they are needed.

FigureÂ 2.8.Â Installing from the Network
Installing from the Network


After the network connection has been configured as shown in SectionÂ 2.9.2, â 
 Configuring Network Interfacesâ  , a mirror site is selected. Mirror sites
cache copies of the FreeBSD files. Choose a mirror site located in the same
region of the world as the computer on which FreeBSD is being installed. Files
can be retrieved more quickly when the mirror is close to the target computer,
and installation time will be reduced.

FigureÂ 2.9.Â Choosing a Mirror
Choosing a Mirror


Installation will continue as if the installation files were located on local
media.

2.7.Â Allocating Disk Space

There are three ways to allocate disk space for FreeBSD. Guided partitioning
automatically sets up disk partitions, while Manual partitioning allows
advanced users to create customized partitions. Finally, there's the option of
starting a shell where command-line programs like gpart(8), fdisk(8), and
bsdlabel(8) can be used directly.

FigureÂ 2.10.Â Selecting Guided or Manual Partitioning
Selecting Guided or Manual Partitioning


2.7.1.Â Guided Partitioning

If multiple disks are connected, choose the one where FreeBSD is to be
installed.

FigureÂ 2.11.Â Selecting from Multiple Disks
Selecting from Multiple Disks


The entire disk can be allocated to FreeBSD, or just a portion of it. If 
[Â EntireÂ DiskÂ ] is chosen, a general partition layout filling the whole disk
is created. Selecting [Â PartitionÂ ] creates a partition layout in unused
space on the disk.

FigureÂ 2.12.Â Selecting Entire Disk or Partition
Selecting Entire Disk or Partition


After the partition layout has been created, review it carefully for accuracy.
If a mistake has been made, selecting [Â RevertÂ ] will reset the partitions as
they were previously, or [Â AutoÂ ] will recreate the automatic FreeBSD
partitions. Partitions can be manually created, modified, or deleted. When the
partitioning is correct, select [Â FinishÂ ] to continue with the installation.

FigureÂ 2.13.Â Review Created Partitions
Review Created Partitions


2.7.2.Â Manual Partitioning

Manual partitioning goes straight to the partition editor.

FigureÂ 2.14.Â Manually Create Partitions
Manually Create Partitions


Highlighting a drive (ada0 in this example) and selecting [Â CreateÂ ] displays
a menu for choosing the type of partitioning scheme.

FigureÂ 2.15.Â Manually Create Partitions
Manually Create Partitions


GPT partitioning is usually the most appropriate choice for PC-compatible
computers. Older PC operating systems that are not compatible with GPT may
require MBR partitioning instead. The other partitioning schemes are generally
used for uncommon or older computer systems.

TableÂ 2.1.Â Partitioning Schemes

Abbreviation Description
APM          Apple Partition Map, used by PowerPCÂ® MacintoshÂ®.
BSD          BSD Labels without an MBR, sometimes called "dangerously dedicated
             mode". See bsdlabel(8).
GPT          GUID Partition Table.
MBR          Master Boot Record.
PC98         MBR variant, used by NEC PC-98 computers.
VTOC8        Volume Table Of Contents, used by Sun SPARC64 and UltraSPARC
             computers.


After the partitioning scheme has been selected and created, selecting 
[Â CreateÂ ] again will create new partitions.

FigureÂ 2.16.Â Manually Create Partitions
Manually Create Partitions


A standard FreeBSD GPT installation uses at least three partitions:

Standard FreeBSD GPT Partitions

  * freebsd-boot - FreeBSD boot code.

  * freebsd-ufs - A FreeBSD UFS filesystem.

  * freebsd-swap - FreeBSD swap space.

Another partition type worth noting is freebsd-zfs, used for partitions that
will contain a FreeBSD ZFS filesystem. See SectionÂ 21.2, â  The Z File System
(ZFS)â  . gpart(8) shows more of the available GPT partition types.

Multiple filesystem partitions can be used, and some people may prefer a
traditional layout with separate partitions for the /, /var, /tmp, and /usr
filesystems. See ExampleÂ 2.3, â  Creating Traditional Split Filesystem
Partitionsâ   for an example.

Size may be entered with common abbreviations: K for kilobytes, M for
megabytes, or G for gigabytes.

Tip:

Proper sector alignment provides the best performance, and making partition
sizes even multiples of 4K bytes helps to ensure alignment on drives with
either 512-byte or 4K-byte sectors. Generally, using partition sizes that are
even multiples of 1M or 1G is the easiest way to make sure every partition
starts at an even multiple of 4K. One exception: at present, the freebsd-boot
partition should be no larger than 512K due to boot code limitations.

A mountpoint is needed if this partition will contain a filesystem. If only a
single UFS partition will be created, the mountpoint should be /.

A label is also requested. A label is a name by which this partition will be
known. Drive names or numbers can change if the drive is connected to a
different controller or port, but the partition label does not change.
Referring to labels instead of drive names and partition numbers in files like
/etc/fstab makes the system more tolerant of changing hardware. GPT labels
appear in /dev/gpt/ when a disk is attached. Other partitioning schemes have
different label capabilities, and their labels appear in different directories
in /dev/.

Tip:

Use a unique label on every filesystem to avoid conflicts from identical
labels. A few letters from the computer's name, use, or location can be added
to the label. "labroot" or "rootfs-lab" for the UFS root partition on the lab's
computer, for example.

ExampleÂ 2.3.Â Creating Traditional Split Filesystem Partitions

For a traditional partition layout where the /, /var, /tmp, and /usr
directories are separate filesystems on their own partitions, create a GPT
partitioning scheme, then create the partitions as shown. Partition sizes shown
are typical for a 20G target disk. If more space is available on the target
disk, larger swap or /var partitions may be useful. Labels shown here are
prefixed with ex for "example", but readers should use other unique label
values as described above.

By default, FreeBSD's gptboot expects the first UFS partition found to be the /
partition.

Partition Type                    Size                    Mountpoint  Label
freebsd-boot   512K                                       Â          Â 
freebsd-ufs    2G                                         /          exrootfs
freebsd-swap   4G                                         Â          exswap
freebsd-ufs    2G                                         /var       exvarfs
freebsd-ufs    1G                                         /tmp       extmpfs
freebsd-ufs    accept the default (remainder of the disk) /usr       exusrfs


After the custom partitions have been created, select [Â FinishÂ ] to continue
with the installation.

2.8.Â Committing to the Installation

This is the last chance for aborting the installation to prevent changes to the
hard drive.

FigureÂ 2.17.Â Final Confirmation
Final Confirmation


Select [Â CommitÂ ] and press Enter to proceed. If changes need to be made,
select [Â BackÂ ] to return to the partition editor. [Â RevertÂ &Â ExitÂ ] will
exit the installer without making any changes to the hard drive.

Installation time will vary depending on the distributions chosen, installation
media, and speed of the computer. There will be a series of messages displayed
indicating progress.

Firstly, the installer will write the partitions to the disk, and perform a
newfs to initialise the partitions.

If doing a network install, bsdinstall will then proceed to download the
required distribution files.

FigureÂ 2.18.Â Fetching Distribution Files
Fetching Distribution Files


Next, the integrity of the distribution files is verified, to ensure they have
not been corrupted during download or misread from the installation media.

FigureÂ 2.19.Â Verifying Distribution Files
Verifying Distribution Files


Finally, the verified distribution files are extracted to the disk.

FigureÂ 2.20.Â Extracting Distribution Files
Extracting Distribution Files


Once all requested distribution files have been extracted, bsdinstall will then
drop straight into the post-installation configuration tasks (see SectionÂ 2.9,
â  Post-Installationâ  ).

2.9.Â Post-Installation

Configuration of various options follows a successful installation of FreeBSD.
An option can be configured by re-entering the configuration options from the
final menu before booting into the newly installed FreeBSD system.

2.9.1.Â Setting the root Password

The root password must be set. Note that while entering the password, the
characters being typed are not displayed on the screen. After the password has
been entered, it must be entered again. This helps prevent typing errors.

FigureÂ 2.21.Â Setting the root Password
Setting the root Password


After the password has been successfully entered, the installation will
continue.

2.9.2.Â Configuring Network Interfaces

Note:

Network configuration will be skipped if it has already been done as part of a 
bootonly installation.

A list of all the network interfaces found on the computer is shown next.
Select one to be configured.

FigureÂ 2.22.Â Choose a Network Interface
Choose a Network Interface


2.9.2.1.Â Configuring a Wireless Network Interface

If a wireless network interface is chosen, wireless identification and security
parameters must be entered to allow it to connect to the network.

Wireless networks are identified by a Service Set Identifier, or SSID. The SSID
is a short, unique name given to each network.

Most wireless networks encrypt transmitted data to protect information from
unauthorized viewing. WPA2 encryption is strongly recommended. Older encryption
types, like WEP, offer very little security.

The first step in connecting to a wireless network is to scan for wireless
access points.

FigureÂ 2.23.Â Scanning for Wireless Access Points
Scanning for Wireless Access Points


SSIDs found during the scan are listed, followed by a description of the
encryption types available for that network. If the desired SSID does not
appear in the list, select [Â RescanÂ ] to scan again. If the desired network
still does not appear, check for problems with antenna connections or try
moving the computer closer to the access point. Rescan after each change is
made.

FigureÂ 2.24.Â Choosing a Wireless Network
Choosing a Wireless Network


The encryption information for connecting to the selected wireless network is
entered after selecting the network. With WPA2, only a password (also known as
the Pre-Shared Key, or PSK) is needed. Characters typed into the input box are
shown as asterisks for security.

FigureÂ 2.25.Â WPA2 Setup
WPA2 Setup


Network configuration continues after selection of the wireless network and
entry of the connection information.

2.9.2.2.Â Configuring IPv4 Networking

Choose whether IPv4 networking is to be used. This is the most common type of
network connection.

FigureÂ 2.26.Â Choose IPv4 Networking
Choose IPv4 Networking


There are two methods of IPv4 configuration. DHCP will automatically configure
the network interface correctly, and is the preferred method. Static
configuration requires manual entry of network information.

Note:

Do not enter random network information, as it will not work. Obtain the
information shown in SectionÂ 2.3.3, â  Collect Network Informationâ   from the
network administrator or service provider.

2.9.2.2.1.Â IPv4 DHCP Network Configuration

If a DHCP server is available, select [Â YesÂ ] to automatically configure the
network interface.

FigureÂ 2.27.Â Choose IPv4 DHCP Configuration
Choose IPv4 DHCP Configuration


2.9.2.2.2.Â IPv4 Static Network Configuration

Static configuration of the network interface requires entry of some IPv4
information.

FigureÂ 2.28.Â IPv4 Static Configuration
IPv4 Static Configuration


  * IP Address - The manually-assigned IPv4 address to be assigned to this
    computer. This address must be unique and not already in use by another
    piece of equipment on the local network.

  * Subnet Mask - The subnet mask used for the local network. Typically, this
    is 255.255.255.0.

  * Default Router - The IP address of the default router on this network.
    Usually this is the address of the router or other network equipment that
    connects the local network to the Internet. Also known as the default
    gateway.

2.9.2.3.Â Configuring IPv6 Networking

IPv6 is a newer method of network configuration. If IPv6 is available and
desired, choose [Â YesÂ ] to select it.

FigureÂ 2.29.Â Choose IPv6 Networking
Choose IPv6 Networking


IPv6 also has two methods of configuration. SLAAC , or StateLess Address
AutoConfiguration, will automatically configure the network interface
correctly. Static configuration requires manual entry of network information.

2.9.2.3.1.Â IPv6 Stateless Address Autoconfiguration

SLAAC allows an IPv6 network component to request autoconfiguration information
from a local router. See RFC4862 for more information.

FigureÂ 2.30.Â Choose IPv6 SLAAC Configuration
Choose IPv6 SLAAC Configuration


2.9.2.3.2.Â IPv6 Static Network Configuration

Static configuration of the network interface requires entry of the IPv6
configuration information.

FigureÂ 2.31.Â IPv6 Static Configuration
IPv6 Static Configuration


  * IPv6 Address - The manually-assigned IP address to be assigned to this
    computer. This address must be unique and not already in use by another
    piece of equipment on the local network.

  * Default Router - The IPv6 address of the default router on this network.
    Usually this is the address of the router or other network equipment that
    connects the local network to the Internet. Also known as the default
    gateway.

2.9.2.4.Â Configuring DNS

The Domain Name System (or DNS) Resolver converts hostnames to and from network
addresses. If DHCP or SLAAC was used to autoconfigure the network interface,
the Resolver Configuration values may already be present. Otherwise, enter the
local network's domain name in the Search field. DNS #1 and DNS #2 are the IP
addresses for the local DNS servers. At least one DNS server is required.

FigureÂ 2.32.Â DNS Configuration
DNS Configuration


2.9.3.Â Setting the Time Zone

Setting the time zone for your machine will allow it to automatically correct
for any regional time changes and perform other time zone related functions
properly.

The example shown is for a machine located in the Eastern time zone of the
United States. Your selections will vary according to your geographical
location.

FigureÂ 2.33.Â Select Local or UTC Clock
Select Local or UTC Clock


Select [Â YesÂ ] or [Â NoÂ ] according to how the machine's clock is configured
and press Enter. If you do not know whether the system uses UTC or local time,
select [Â NoÂ ] to choose the more commonly-used local time.

FigureÂ 2.34.Â Select a Region
Select a Region


The appropriate region is selected using the arrow keys and then pressing Enter
.

FigureÂ 2.35.Â Select a Country
Select a Country


Select the appropriate country using the arrow keys and press Enter.

FigureÂ 2.36.Â Select a Time Zone
Select a Time Zone


The appropriate time zone is selected using the arrow keys and pressing Enter.

FigureÂ 2.37.Â Confirm Time Zone
Confirm Time Zone


Confirm the abbreviation for the time zone is correct. If it looks okay, press 
Enter to continue with the post-installation configuration.

2.9.4.Â Selecting Services to Enable

Additional system services which will be started at boot can be enabled. All of
these services are optional.

FigureÂ 2.38.Â Selecting Additional Services to Enable
Selecting Additional Services to Enable

Additional Services

  * sshd - Secure Shell (SSH) daemon for secure remote access.

  * moused - Provides mouse usage within the system console.

  * ntpd - Network Time Protocol (NTP) daemon for automatic clock
    synchronization.

  * powerd - System power control utility for power control and energy saving.

2.9.5.Â Enabling Crash Dumps

bsdinstall will prompt if crash dumps should be enabled on the target system.
Enabling crash dumps can be very useful in debugging issues with the system, so
users are encouraged to enable crash dumps whenever possible. Select [Â YesÂ ]
to enable crash dumps, or [Â NoÂ ] to proceed without crash dumps enabled.

FigureÂ 2.39.Â Enabling Crash Dumps
Enabling Crash Dumps


2.9.6.Â Add Users

Adding at least one user during the installation allows the system to be used
without being logged in as root. When logged in as root, there are essentially
no limits or protection on what can be done. Logging in as a normal user is
safer and more secure.

Select [Â YesÂ ] to add new users.

FigureÂ 2.40.Â Add User Accounts
Add User Accounts


Enter the information for the user to be added.

FigureÂ 2.41.Â Enter User Information
Enter User Information

User Information

  * Username - The name the user will enter to log in. Typically the first
    letter of their first name combined with their last name.

  * Full name - The user's full name.

  * Uid - User ID. Typically, this is left blank so the system will assign a
    value.

  * Login group - The user's group. Typically left blank to accept the default.

  * Invite user into other groups? - Additional groups to which the user will
    be added as a member.

  * Login class - Typically left blank for the default.

  * Shell - The interactive shell for this user. In the example, csh(1) has
    been chosen.

  * Home directory - The user's home directory. The default is usually correct.

  * Home directory permissions - Permissions on the user's home directory. The
    default is usually correct.

  * Use password-based authentication? - Typically "yes".

  * Use an empty password? - Typically "no".

  * Use a random password? - Typically "no".

  * Enter password - The actual password for this user. Characters typed will
    not show on the screen.

  * Enter password again - The password must be typed again for verification.

  * Lock out the account after creation? - Typically "no".

After entering everything, a summary is shown, and the system asks if it is
correct. If a mistake was made during entry, enter no and try again. If
everything is correct, enter yes to create the new user.

FigureÂ 2.42.Â Exit User and Group Management
Exit User and Group Management


If there are more users to add, answer the "Add another user?" question with
yes. Enter no to finish adding users and continue the installation.

For more information on adding users and user management, see ChapterÂ 14, 
Users and Basic Account Management.

2.9.7.Â Final Configuration

After everything has been installed and configured, a final chance is provided
to modify settings.

FigureÂ 2.43.Â Final Configuration
Final Configuration


Use this menu to make any changes or do any additional configuration before
completing the installation.

Final Configuration Options

  * Add User - Described in SectionÂ 2.9.6, â  Add Usersâ  .

  * Root Password - Described in SectionÂ 2.9.1, â  Setting the root Passwordâ 
     .

  * Hostname - Described in SectionÂ 2.5.2, â  Setting the Hostnameâ  .

  * Network - Described in SectionÂ 2.9.2, â  Configuring Network Interfacesâ  
    .

  * Services - Described in SectionÂ 2.9.4, â  Selecting Services to Enableâ  .

  * Time Zone - Described in SectionÂ 2.9.3, â  Setting the Time Zoneâ  .

  * Handbook - Download and install the FreeBSD Handbook (which is what you are
    reading now).

After any final configuration is complete, select Exit to leave the
installation.

FigureÂ 2.44.Â Manual Configuration
Manual Configuration


bsdinstall will prompt if there are any additional configuration that needs to
be done before rebooting into the new system. Select [Â YesÂ ] to exit to a
shell within the new system, or [Â NoÂ ] to proceed to the last step of the
installation.

FigureÂ 2.45.Â Complete the Installation
Complete the Installation


If further configuration or special setup is needed, selecting [Â LiveÂ CDÂ ]
will boot the install media into Live CD mode.

When the installation is complete, select [Â RebootÂ ] to reboot the computer
and start the new FreeBSD system. Do not forget to remove the FreeBSD install
CD, DVD, or USB memory stick, or the computer may boot from it again.

2.9.8.Â FreeBSD Booting and Shutdown

2.9.8.1.Â FreeBSD/i386 Booting

As FreeBSD boots, many informational messages are displayed. Most will scroll
off the screen; this is normal. After the system finishes booting, a login
prompt is displayed. Messages that scrolled off the screen can be reviewed by
pressing Scroll-Lock to turn on the scroll-back buffer. The PgUp, PgDn, and
arrow keys can be used to scroll back through the messages. Pressing 
Scroll-Lock again unlocks the display and returns to the normal screen.

At the login: prompt, enter the username added during the installation, asample
in the example. Avoid logging in as root except when necessary.

The scroll-back buffer examined above is limited in size, so not all of the
messages may have been visible. After logging in, most of them can be seen from
the command line by typing dmesg | less at the prompt. Press q to return to the
command line after viewing.

Typical boot messages (version information omitted):

Copyright (c) 1992-2011 The FreeBSD Project. Copyright (c) 1979, 1980, 1983,
1986, 1988, 1989, 1991, 1992, 1993, 1994 The Regents of the University of
California. All rights reserved. FreeBSD is a registered trademark of The
FreeBSD Foundation. root@farrell.cse.buffalo.edu:/usr/obj/usr/src/sys/GENERIC
amd64 CPU: Intel(R) Core(TM)2 Duo CPU E8400 @ 3.00GHz (3007.77-MHz K8-class
CPU) Origin = "GenuineIntel" Id = 0x10676 Family = 6 Model = 17 Stepping = 6
Features=0x783fbff
&lt;FPU,VME,DE,PSE,TSC,MSR,PAE,MCE,CX8,APIC,SEP,MTRR,PGE,MCA,CMOV,PAT,PSE36,MMX,FXSR,SSE,SSE2&gt;
Features2=0x209&lt;SSE3,MON,SSSE3&gt; AMD Features=0x20100800&lt;SYSCALL,NX,LM&gt; AMD
Features2=0x1&lt;LAHF&gt; real memory = 536805376 (511 MB) avail memory = 491819008
(469 MB) Event timer "LAPIC" quality 400 ACPI APIC Table: &lt;VBOX VBOXAPIC&gt;
ioapic0: Changing APIC ID to 1 ioapic0 &lt;Version 1.1&gt; irqs 0-23 on motherboard
kbd1 at kbdmux0 acpi0: &lt;VBOX VBOXXSDT&gt; on motherboard acpi0: Power Button
(fixed) acpi0: Sleep Button (fixed) Timecounter "ACPI-fast" frequency 3579545
Hz quality 900 acpi_timer0: &lt;32-bit timer at 3.579545MHz&gt; port 0x4008-0x400b on
acpi0 cpu0: &lt;ACPI CPU&gt; on acpi0 pcib0: &lt;ACPI Host-PCI bridge&gt; port 0xcf8-0xcff
on acpi0 pci0: &lt;ACPI PCI bus&gt; on pcib0 isab0: &lt;PCI-ISA bridge&gt; at device 1.0 on
pci0 isa0: &lt;ISA bus&gt; on isab0 atapci0: &lt;Intel PIIX4 UDMA33 controller&gt; port
0x1f0-0x1f7,0x3f6,0x170-0x177,0x376,0xd000-0xd00f at device 1.1 on pci0 ata0:
&lt;ATA channel 0&gt; on atapci0 ata1: &lt;ATA channel 1&gt; on atapci0 vgapci0:
&lt;VGA-compatible display&gt; mem 0xe0000000-0xe0ffffff irq 18 at device 2.0 on pci0
em0: &lt;Intel(R) PRO/1000 Legacy Network Connection 1.0.3&gt; port 0xd010-0xd017 mem
0xf0000000-0xf001ffff irq 19 at device 3.0 on pci0 em0: Ethernet address:
08:00:27:9f:e0:92 pci0: &lt;base peripheral&gt; at device 4.0 (no driver attached)
pcm0: &lt;Intel ICH (82801AA)&gt; port 0xd100-0xd1ff,0xd200-0xd23f irq 21 at device
5.0 on pci0 pcm0: &lt;SigmaTel STAC9700/83/84 AC97 Codec&gt; ohci0: &lt;OHCI (generic)
USB controller&gt; mem 0xf0804000-0xf0804fff irq 22 at device 6.0 on pci0 usbus0:
&lt;OHCI (generic) USB controller&gt; on ohci0 pci0: &lt;bridge&gt; at device 7.0 (no
driver attached) acpi_acad0: &lt;AC Adapter&gt; on acpi0 atkbdc0: &lt;Keyboard
controller (i8042)&gt; port 0x60,0x64 irq 1 on acpi0 atkbd0: &lt;AT Keyboard&gt; irq 1
on atkbdc0 kbd0 at atkbd0 atkbd0: [GIANT-LOCKED] psm0: &lt;PS/2 Mouse&gt; irq 12 on
atkbdc0 psm0: [GIANT-LOCKED] psm0: model IntelliMouse Explorer, device ID 4
attimer0: &lt;AT timer&gt; port 0x40-0x43,0x50-0x53 on acpi0 Timecounter "i8254"
frequency 1193182 Hz quality 0 Event timer "i8254" frequency 1193182 Hz quality
100 sc0: &lt;System console&gt; at flags 0x100 on isa0 sc0: VGA &lt;16 virtual consoles,
flags=0x300&gt; vga0: &lt;Generic ISA VGA&gt; at port 0x3c0-0x3df iomem 0xa0000-0xbffff
on isa0 atrtc0: &lt;AT realtime clock&gt; at port 0x70 irq 8 on isa0 Event timer
"RTC" frequency 32768 Hz quality 0 ppc0: cannot reserve I/O port range
Timecounters tick every 10.000 msec pcm0: measured ac97 link rate at 485193 Hz
em0: link state changed to UP usbus0: 12Mbps Full Speed USB v1.0 ugen0.1:
&lt;Apple&gt; at usbus0 uhub0: &lt;Apple OHCI root HUB, class 9/0, rev 1.00/1.00, addr
1&gt; on usbus0 cd0 at ata1 bus 0 scbus1 target 0 lun 0 cd0: &lt;VBOX CD-ROM 1.0&gt;
Removable CD-ROM SCSI-0 device cd0: 33.300MB/s transfers (UDMA2, ATAPI 12bytes,
PIO 65534bytes) cd0: Attempt to query device size failed: NOT READY, Medium not
present ada0 at ata0 bus 0 scbus0 target 0 lun 0 ada0: &lt;VBOX HARDDISK 1.0&gt;
ATA-6 device ada0: 33.300MB/s transfers (UDMA2, PIO 65536bytes) ada0: 12546MB
(25694208 512 byte sectors: 16H 63S/T 16383C) ada0: Previously was known as ad0
Timecounter "TSC" frequency 3007772192 Hz quality 800 Root mount waiting for:
usbus0 uhub0: 8 ports with 8 removable, self powered Trying to mount root from
ufs:/dev/ada0p2 [rw]... Setting hostuuid: 1848d7bf-e6a4-4ed4-b782-bd3f1685d551.
Setting hostid: 0xa03479b2. Entropy harvesting: interrupts ethernet
point_to_point kickstart. Starting file system checks: /dev/ada0p2: FILE SYSTEM
CLEAN; SKIPPING CHECKS /dev/ada0p2: clean, 2620402 free (714 frags, 327461
blocks, 0.0% fragmentation) Mounting local file systems:. vboxguest0 port
0xd020-0xd03f mem 0xf0400000-0xf07fffff,0xf0800000-0xf0803fff irq 20 at device
4.0 on pci0 vboxguest: loaded successfully Setting hostname:
machine3.example.com. Starting Network: lo0 em0. lo0: flags=8049
&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384 options=3&lt;RXCSUM,TXCSUM&gt;
inet6 ::1 prefixlen 128 inet6 fe80::1%lo0 prefixlen 64 scopeid 0x3 inet
127.0.0.1 netmask 0xff000000 nd6 options=21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt; em0:
flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500 options=9b
&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM&gt; ether 08:00:27:9f:e0:92 nd6
options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt; media: Ethernet autoselect
(1000baseT &lt;full-duplex&gt;) status: active Starting devd. Starting Network:
usbus0. DHCPREQUEST on em0 to 255.255.255.255 port 67 DHCPACK from 10.0.2.2
bound to 192.168.1.142 -- renewal in 43200 seconds. add net ::ffff:0.0.0.0:
gateway ::1 add net ::0.0.0.0: gateway ::1 add net fe80::: gateway ::1 add net
ff02::: gateway ::1 ELF ldconfig path: /lib /usr/lib /usr/lib/compat /usr/local
/lib 32-bit compatibility ldconfig path: /usr/lib32 Creating and/or trimming
log files. Starting syslogd. No core dumps found. Clearing /tmp (X related).
Updating motd:. Configuring syscons: blanktime. Generating public/private rsa1
key pair. Your identification has been saved in /etc/ssh/ssh_host_key. Your
public key has been saved in /etc/ssh/ssh_host_key.pub. The key fingerprint is:
10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com The
key's randomart image is: +--[RSA1 1024]----+ | o.. | | o . . | | . o | | o | |
o S | | + + o | |o . + * | |o+ ..+ . | |==o..o+E | +-----------------+
Generating public/private dsa key pair. Your identification has been saved in /
etc/ssh/ssh_host_dsa_key. Your public key has been saved in /etc/ssh/
ssh_host_dsa_key.pub. The key fingerprint is:
7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com The
key's randomart image is: +--[ DSA 1024]----+ | .. . .| | o . . + | | . .. . E
.| | . . o o . . | | + S = . | | + . = o | | + . * . | | . . o . | | .o. . |
+-----------------+ Starting sshd. Starting cron. Starting background file
system checks in 60 seconds. Thu Oct 6 19:15:31 MDT 2011 FreeBSD/amd64
(machine3.example.com) (ttyv0) login:

Generating the RSA and DSA keys may take some time on slower machines. This
happens only on the initial boot-up of a new installation, and only if sshd is
set to start automatically. Subsequent boots will be faster.

FreeBSD does not install graphical environments by default, but many are
available. See ChapterÂ 6, The X Window System for more information.

2.9.9.Â FreeBSD Shutdown

Proper shutdown of a FreeBSD computer helps protect data and even hardware from
damage. Do not just turn off the power. If the user is a member of the wheel
group, become the superuser by typing su at the command line and entering the
root password. Otherwise, log in as root and use shutdown -p now. The system
will close down cleanly and turn itself off.

The Ctrl+Alt+Del key combination can be used to reboot the system, but is not
recommended during normal operation.

2.10.Â Troubleshooting

The following section covers basic installation troubleshooting, such as common
problems people have reported.

2.10.1.Â What to Do If Something Goes Wrong

Due to various limitations of the PC architecture, it is impossible for probing
to be 100% reliable, however, there are a few things you can do if it fails.

Check the Hardware Notes document for your version of FreeBSD to make sure your
hardware is supported.

If your hardware is supported and you still experience lock-ups or other
problems, you will need to build a custom kernel. This will allow you to add in
support for devices which are not present in the GENERIC kernel. The kernel on
the boot disks is configured assuming that most hardware devices are in their
factory default configuration in terms of IRQs, IO addresses, and DMA channels.
If your hardware has been reconfigured, you will most likely need to edit the
kernel configuration and recompile to tell FreeBSD where to find things.

It is also possible that a probe for a device not present will cause a later
probe for another device that is present to fail. In that case, the probes for
the conflicting driver(s) should be disabled.

Note:

Some installation problems can be avoided or alleviated by updating the
firmware on various hardware components, most notably the motherboard.
Motherboard firmware is usually referred to as the BIOS. Most motherboard and
computer manufacturers have a website for upgrades and upgrade information.

Manufacturers generally advise against upgrading the motherboard BIOS unless
there is a good reason for doing so, like a critical update. The upgrade
process can go wrong, leaving the BIOS incomplete and the computer inoperative.

2.10.2.Â Troubleshooting Questions and Answers

2.10.2.1. My system hangs while probing hardware during boot, or it behaves
    strangely during install.

2.10.2.1. My system hangs while probing hardware during boot, or it behaves
          strangely during install.

          FreeBSD makes extensive use of the system ACPI service on the i386,
          amd64, and ia64 platforms to aid in system configuration if it is
          detected during boot. Unfortunately, some bugs still exist in both
          the ACPI driver and within system motherboards and BIOS firmware.
          ACPI can be disabled by setting the hint.acpi.0.disabled hint in the
          third stage boot loader:

          set hint.acpi.0.disabled="1"

          This is reset each time the system is booted, so it is necessary to
          add hint.acpi.0.disabled="1" to the file /boot/loader.conf. More
          information about the boot loader can be found in SectionÂ 13.1, â  
          Synopsisâ  .

2.11.Â Using the Live CD

A live CD of FreeBSD is available on the same CD as the main installation
program. This is useful for those who are still wondering whether FreeBSD is
the right operating system for them and want to test some of the features
before installing.

Note:

The following points should be noted while using the live CD:

  * To gain access to the system, authentication is required. The username is
    root, and the password is blank.

  * As the system runs directly from the CD, performance will be significantly
    slower than that of a system installed on a hard disk.

  * The live CD provides a command prompt and not a graphical interface.

ChapterÂ 3.Â Installing FreeBSDÂ 8.X and Earlier

Restructured, reorganized, and parts rewritten by Jim Mock.
The sysinstall walkthrough, screenshots, and general copy by Randy Pratt.
Table of Contents

3.1. Synopsis
3.2. Hardware Requirements
3.3. Pre-installation Tasks
3.4. Starting the Installation
3.5. Introducing Sysinstall
3.6. Allocating Disk Space
3.7. Choosing What to Install
3.8. Choosing Your Installation Media
3.9. Committing to the Installation
3.10. Post-installation
3.11. Troubleshooting
3.12. Advanced Installation Guide
3.13. Preparing Your Own Installation Media

3.1.Â Synopsis

FreeBSD is provided with a text-based, easy to use installation program.
FreeBSD 9.0-RELEASE and later use the installation program known as bsdinstall,
with releases prior to 9.0-RELEASE using sysinstall for installation. This
chapter describes the use of sysinstall to install FreeBSD. The use of 
bsdinstall is covered in ChapterÂ 2, Installing FreeBSDÂ 9.X and Later.

After reading this chapter, you will know:

  * How to create the FreeBSD installation disks.

  * How FreeBSD refers to, and subdivides, your hard disks.

  * How to start sysinstall.

  * The questions sysinstall will ask you, what they mean, and how to answer
    them.

Before reading this chapter, you should:

  * Read the supported hardware list that shipped with the version of FreeBSD
    you are installing, and verify that your hardware is supported.

Note:

In general, these installation instructions are written for i386â ¢ (â  PC
compatibleâ  ) architecture computers. Where applicable, instructions specific
to other platforms will be listed. Although this guide is kept as up to date as
possible, you may find minor differences between the installer and what is
shown here. It is suggested that you use this chapter as a general guide rather
than a literal installation manual.

3.2.Â Hardware Requirements

3.2.1.Â Minimal Configuration

The minimal configuration to install FreeBSD varies with the FreeBSD version
and the hardware architecture.

A summary of this information is given in the following sections. Depending on
the method you choose to install FreeBSD, you may also need a floppy drive, a
supported CDROM drive, and in some case a network adapter. This will be covered
by the SectionÂ 3.3.7, â  Prepare the Boot Mediaâ  .

3.2.1.1.Â FreeBSD/i386 and FreeBSD/pc98

Both FreeBSD/i386 and FreeBSD/pc98 require a 486 or better processor and at
least 24Â MB of RAM. You will need at least 150Â MB of free hard drive space
for the most minimal installation.

Note:

In case of old configurations, most of time, getting more RAM and more hard
drive space is more important than getting a faster processor.

3.2.1.2.Â FreeBSD/amd64

There are two classes of processors capable of running FreeBSD/amd64. The first
are AMD64 processors, including the AMDÂ Athlonâ ¢64, AMDÂ Athlonâ ¢64-FX, 
AMDÂ Opteronâ ¢ or better processors.

The second class of processors that can use FreeBSD/amd64 includes those using
the IntelÂ® EM64T architecture. Examples of these processors include the IntelÂ
®Â Coreâ ¢Â 2 Duo, Quad, Extreme processor families, and the IntelÂ®Â Xeonâ ¢
3000, 5000, and 7000 sequences of processors.

If you have a machine based on an nVidia nForce3 Pro-150, you must use the BIOS
setup to disable the IO APIC. If you do not have an option to do this, you will
likely have to disable ACPI instead. There are bugs in the Pro-150 chipset that
we have not found a workaround for yet.

3.2.1.3.Â FreeBSD/sparc64

To install FreeBSD/sparc64, you will need a supported platform (see
SectionÂ 3.2.2, â  Supported Hardwareâ  ).

You will need a dedicated disk for FreeBSD/sparc64. It is not possible to share
a disk with another operating system at this time.

3.2.2.Â Supported Hardware

A list of supported hardware is provided with each FreeBSD release in the
FreeBSD Hardware Notes. This document can usually be found in a file named
HARDWARE.TXT, in the top-level directory of a CDROM or FTP distribution or in 
sysinstall's documentation menu. It lists, for a given architecture, what
hardware devices are known to be supported by each release of FreeBSD. Copies
of the supported hardware list for various releases and architectures can also
be found on the Release Information page of the FreeBSD Web site.

3.3.Â Pre-installation Tasks

3.3.1.Â Inventory Your Computer

Before installing FreeBSD you should attempt to inventory the components in
your computer. The FreeBSD installation routines will show you the components
(hard disks, network cards, CDROM drives, and so forth) with their model number
and manufacturer. FreeBSD will also attempt to determine the correct
configuration for these devices, which includes information about IRQ and IO
port usage. Due to the vagaries of PC hardware this process is not always
completely successful, and you may need to correct FreeBSD's determination of
your configuration.

If you already have another operating system installed, such as WindowsÂ® or
Linux, it is a good idea to use the facilities provided by those operating
systems to see how your hardware is already configured. If you are not sure
what settings an expansion card is using, you may find it printed on the card
itself. Popular IRQ numbers are 3, 5, and 7, and IO port addresses are normally
written as hexadecimal numbers, such as 0x330.

We recommend you print or write down this information before installing
FreeBSD. It may help to use a table, like this:

TableÂ 3.1.Â Sample Device Inventory

     Device Name      IRQ IO port(s)                   Notes
First hard disk       N/A N/A        40Â GB, made by Seagate, first IDE master
CDROM                 N/A N/A        First IDE slave
Second hard disk      N/A N/A        20Â GB, made by IBM, second IDE master
First IDE controller  14  0x1f0      Â 
Network card          N/A N/A        IntelÂ® 10/100
Modem                 N/A N/A        3ComÂ® 56K faxmodem, on COM1
â Š                   Â   Â          Â 


Once the inventory of the components in your computer is done, you have to
check if they match the hardware requirements of the FreeBSD release you want
to install.

3.3.2.Â Backup Your Data

If the computer you will be installing FreeBSD on contains valuable data, then
ensure you have it backed up, and that you have tested the backups before
installing FreeBSD. The FreeBSD installation routine will prompt you before
writing any data to your disk, but once that process has started it cannot be
undone.

3.3.3.Â Decide Where to Install FreeBSD

If you want FreeBSD to use your entire hard disk, then there is nothing more to
concern yourself with at this point â   you can skip this section.

However, if you need FreeBSD to co-exist with other operating systems then you
need to have a rough understanding of how data is laid out on the disk, and how
this affects you.

3.3.3.1.Â Disk Layouts for FreeBSD/i386

A PC disk can be divided into discrete chunks. These chunks are called
partitions. Since FreeBSD internally also has partitions, the naming can become
confusing very quickly, therefore these disk chunks are referred to as disk
slices or simply slices in FreeBSD itself. For example, the FreeBSD utility
fdisk which operates on the PC disk partitions, refers to slices instead of
partitions. By design, the PC only supports four partitions per disk. These
partitions are called primary partitions. To work around this limitation and
allow more than four partitions, a new partition type was created, the extended
partition. A disk may contain only one extended partition. Special partitions,
called logical partitions, can be created inside this extended partition.

Each partition has a partition ID, which is a number used to identify the type
of data on the partition. FreeBSD partitions have the partition ID of 165.

In general, each operating system that you use will identify partitions in a
particular way. For example, MS-DOSÂ®, and its descendants, like WindowsÂ®,
assign each primary and logical partition a drive letter, starting with C:.

FreeBSD must be installed into a primary partition. FreeBSD can keep all its
data, including any files that you create, on this one partition. However, if
you have multiple disks, then you can create a FreeBSD partition on all, or
some, of them. When you install FreeBSD, you must have one partition available.
This might be a blank partition that you have prepared, or it might be an
existing partition that contains data that you no longer care about.

If you are already using all the partitions on all your disks, then you will
have to free one of them for FreeBSD using the tools provided by the other
operating systems you use (e.g., fdisk on MS-DOSÂ® or WindowsÂ®).

If you have a spare partition then you can use that. However, you may need to
shrink one or more of your existing partitions first.

A minimal installation of FreeBSD takes as little as 100Â MB of disk space.
However, that is a very minimal install, leaving almost no space for your own
files. A more realistic minimum is 250Â MB without a graphical environment, and
350Â MB or more if you want a graphical user interface. If you intend to
install a lot of third-party software as well, then you will need more space.

You can use a tool such as GParted to resize your partitions and make space for
FreeBSD. GParted is known to work on NTFS and is available on a number of Live
CD Linux distributions, such as SystemRescueCD.

Problems have been reported resizing MicrosoftÂ® Vista partitions. Having a
Vista installation CDROM handy when attempting such an operation is
recommended. As with all such disk maintenance tasks, a current set of backups
is also strongly advised.

Warning:

Incorrect use of these tools can delete the data on your disk. Be sure that you
have recent, working backups before using them.

ExampleÂ 3.1.Â Using an Existing Partition Unchanged

Suppose that you have a computer with a single 4Â GB disk that already has a
version of WindowsÂ® installed, and you have split the disk into two drive
letters, C: and D:, each of which is 2Â GB in size. You have 1Â GB of data on
C:, and 0.5Â GB of data on D:.

This means that your disk has two partitions on it, one per drive letter. You
can copy all your existing data from D: to C:, which will free up the second
partition, ready for FreeBSD.


ExampleÂ 3.2.Â Shrinking an Existing Partition

Suppose that you have a computer with a single 4Â GB disk that already has a
version of WindowsÂ® installed. When you installed WindowsÂ® you created one
large partition, giving you a C: drive that is 4Â GB in size. You are currently
using 1.5Â GB of space, and want FreeBSD to have 2Â GB of space.

In order to install FreeBSD you will need to either:

 1. Backup your WindowsÂ® data, and then reinstall WindowsÂ®, asking for a
    2Â GB partition at install time.

 2. Use one of the tools described above to shrink your WindowsÂ® partition.


3.3.4.Â Collect Your Network Configuration Details

If you intend to connect to a network as part of your FreeBSD installation (for
example, if you will be installing from an FTP site or an NFS server), then you
need to know your network configuration. You will be prompted for this
information during the installation so that FreeBSD can connect to the network
to complete the install.

3.3.4.1.Â Connecting to an Ethernet Network or Cable/DSL Modem

If you connect to an Ethernet network, or you have an Internet connection using
an Ethernet adapter via cable or DSL, then you will need the following
information:

 1. IP address

 2. IP address of the default gateway

 3. Hostname

 4. DNS server IP addresses

 5. Subnet Mask

If you do not know this information, then ask your system administrator or
service provider. They may say that this information is assigned automatically,
using DHCP. If so, make a note of this.

3.3.4.2.Â Connecting Using a Modem

If you dial up to an ISP using a regular modem then you can still install
FreeBSD over the Internet, it will just take a very long time.

You will need to know:

 1. The phone number to dial for your ISP

 2. The COM: port your modem is connected to

 3. The username and password for your ISP account

3.3.5.Â Check for FreeBSD Errata

Although the FreeBSD project strives to ensure that each release of FreeBSD is
as stable as possible, bugs do occasionally creep into the process. On very
rare occasions those bugs affect the installation process. As these problems
are discovered and fixed, they are noted in the FreeBSD Errata, which is found
on the FreeBSD web site. You should check the errata before installing to make
sure that there are no late-breaking problems which you should be aware of.

Information about all the releases, including the errata for each release, can
be found on the release information section of the FreeBSD web site.

3.3.6.Â Obtain the FreeBSD Installation Files

The FreeBSD installation process can install FreeBSD from files located in any
of the following places:

Local Media

  * A CDROM or DVD

  * A USB Memory Stick

  * A MS-DOSÂ® partition on the same computer

  * A SCSI or QIC tape

  * Floppy disks

Network

  * An FTP site, going through a firewall, or using an HTTP proxy, as necessary

  * An NFS server

  * A dedicated parallel or serial connection

If you have purchased FreeBSD on CD or DVD then you already have everything you
need, and should proceed to the next section (SectionÂ 3.3.7, â  Prepare the
Boot Mediaâ  ).

If you have not obtained the FreeBSD installation files you should skip ahead
to SectionÂ 3.13, â  Preparing Your Own Installation Mediaâ   which explains
how to prepare to install FreeBSD from any of the above. After reading that
section, you should come back here, and read on to SectionÂ 3.3.7, â  Prepare
the Boot Mediaâ  .

3.3.7.Â Prepare the Boot Media

The FreeBSD installation process is started by booting the computer into the
FreeBSD installerâ  it is not a program you run within another operating
system. The computer normally boots using the operating system installed on the
hard disk, but it can also be configured to boot from a CDROM or from a USB
disk.

Tip:

If you have FreeBSD on CDROM or DVD (either one you purchased or you prepared
yourself), and your computer allows you to boot from the CDROM or DVD
(typically a BIOS option called â  Boot Orderâ   or similar), then you can skip
this section. The FreeBSD CDROM and DVD images are bootable and can be used to
install FreeBSD without any other special preparation.

To create a bootable memory stick, follow these steps:

 1. Acquire the Memory Stick Image

    Memory stick images for FreeBSDÂ 8.X and earlier can be downloaded from the
    ISO-IMAGES/ directory at ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/arch/
    ISO-IMAGES/version/FreeBSD-version-RELEASE-arch-memstick.img. Replace arch
    and version with the architecture and the version number which you want to
    install, respectively. For example, the memory stick images for FreeBSD/
    i386Â 8.4-RELEASE are available from ftp://ftp.FreeBSD.org/pub/FreeBSD/
    releases/i386/ISO-IMAGES/8.4/FreeBSD-8.4-RELEASE-i386-memstick.img.

    Tip:

    A different directory path is used for FreeBSDÂ 9.0-RELEASE and later
    versions. Details of download and installation of FreeBSDÂ 9.0-RELEASE and
    later is covered in ChapterÂ 2, Installing FreeBSDÂ 9.X and Later.

    The memory stick image has a .img extension. The ISO-IMAGES/ directory
    contains a number of different images, and the one you will need to use
    will depend on the version of FreeBSD you are installing, and in some
    cases, the hardware you are installing to.

    Important:

    Before proceeding, back up the data you currently have on your USB stick,
    as this procedure will erase it.

 2. Write the Image File to the Memory Stick

    ProcedureÂ 3.1.Â Using FreeBSD to Write the Image

    Warning:

    The example below lists /dev/da0 as the target device where the image will
    be written. Be very careful that you have the correct device as the output
    target, or you may destroy your existing data.

      + Writing the Image with dd(1)

        The .img file is not a regular file you copy to the memory stick. It is
        an image of the complete contents of the disk. This means that you 
        cannot simply copy files from one disk to another. Instead, you must
        use dd(1) to write the image directly to the disk:

        # dd if=FreeBSD-8.4-RELEASE-i386-memstick.img of=/dev/da0 bs=64k

        If an Operation not permitted error is displayed, make certain that the
        target device is not in use, mounted, or being automounted by some
        well-intentioned utility program. Then try again.

    ProcedureÂ 3.2.Â Using WindowsÂ® to Write the Image

    Warning:

    Make sure you use the correct drive letter as the output target, or you may
    overwrite and destroy existing data.

     1. Obtaining Image Writer for Windows

        Image Writer for Windows is a free application that can correctly write
        an image file to a memory stick. Download it from https://launchpad.net
        /win32-image-writer/ and extract it into a folder.

     2. Writing the Image with Image Writer

        Double-click the Win32DiskImager icon to start the program. Verify that
        the drive letter shown under Device is the drive with the memory stick.
        Click the folder icon and select the image to be written to the memory
        stick. Click Save to accept the image file name. Verify that everything
        is correct, and that no folders on the memory stick are open in other
        windows. Finally, click Write to write the image file to the drive.

To create the boot floppy images for a FreeBSD/pc98 installation, follow these
steps:

 1. Acquire the Boot Floppy Images

    The FreeBSD/pc98 boot disks can be downloaded from the floppies directory,
    ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/pc98/version-RELEASE/floppies/.
    Replace version with the version number to install.

    The floppy images have a .flp extension. floppies/ contains a number of
    different images. Download boot.flp as well as the number of files
    associated with the type of installation, such as kern.small* or kern*.

    Important:

    Your FTP program must use binary mode to download these disk images. Some
    web browsers have been known to use text (or ASCII) mode, which will be
    apparent if you cannot boot from the disks.

 2. Prepare the Floppy Disks

    Prepare one floppy disk per image file you had to download. It is
    imperative that these disks are free from defects. The easiest way to test
    this is to format the disks for yourself. Do not trust pre-formatted
    floppies. The format utility in WindowsÂ® will not tell about the presence
    of bad blocks, it simply marks them as â  badâ   and ignores them. It is
    advised that you use brand new floppies if choosing this installation
    route.

    Important:

    If you try to install FreeBSD and the installation program crashes,
    freezes, or otherwise misbehaves, one of the first things to suspect is the
    floppies. Write the floppy image files to new disks and try again.

 3. Write the Image Files to the Floppy Disks

    The .flp files are not regular files you copy to the disk. They are images
    of the complete contents of the disk. This means that you cannot simply
    copy files from one disk to another. Instead, you must use specific tools
    to write the images directly to the disk.

    If you are creating the floppies on a computer running MS-DOSÂ® / WindowsÂ
    ®, then we provide a tool to do this called fdimage.

    If you are using the floppies from the CDROM, and your CDROM is the E:
    drive, then you would run this:

    E:\&gt; tools\fdimage floppies\boot.flp A:

    Repeat this command for each .flp file, replacing the floppy disk each
    time, being sure to label the disks with the name of the file that you
    copied to them. Adjust the command line as necessary, depending on where
    you have placed the .flp files. If you do not have the CDROM, then fdimage
    can be downloaded from the tools directory on the FreeBSD FTP site.

    If you are writing the floppies on a UNIXÂ® system (such as another FreeBSD
    system) you can use the dd(1) command to write the image files directly to
    disk. On FreeBSD, you would run:

    # dd if=boot.flp of=/dev/fd0

    On FreeBSD, /dev/fd0 refers to the first floppy disk (the A: drive). /dev/
    fd1 would be the B: drive, and so on. Other UNIXÂ® variants might have
    different names for the floppy disk devices, and you will need to check the
    documentation for the system as necessary.

You are now ready to start installing FreeBSD.

3.4.Â Starting the Installation

Important:

By default, the installation will not make any changes to your disk(s) until
you see the following message:

Last Chance: Are you SURE you want continue the installation?

If you're running this on a disk with data you wish to save then WE
STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before proceeding!

We can take no responsibility for lost disk contents!

The install can be exited at any time prior to the final warning without
changing the contents of the hard drive. If you are concerned that you have
configured something incorrectly you can just turn the computer off before this
point, and no damage will be done.

3.4.1.Â Booting

3.4.1.1.Â Booting for the i386â ¢

 1. Start with your computer turned off.

 2. Turn on the computer. As it starts it should display an option to enter the
    system set up menu, or BIOS, commonly reached by keys like F2, F10, Del, or
    Alt+S. Use whichever keystroke is indicated on screen. In some cases your
    computer may display a graphic while it starts. Typically, pressing Esc
    will dismiss the graphic and allow you to see the necessary messages.

 3. Find the setting that controls which devices the system boots from. This is
    usually labeled as the â  Boot Orderâ   and commonly shown as a list of
    devices, such as Floppy, CDROM, First Hard Disk, and so on.

    If you are booting from the CDROM then make sure that the CDROM is
    selected. If you are booting from a USB disk or a floppy disk then make
    sure that is selected instead. In case of doubt, you should consult the
    manual that came with your computer, and/or its motherboard.

    Make the change, then save and exit. The computer should now restart.

 4. If you prepared a â  bootableâ   USB stick, as described in SectionÂ 3.3.7,
    â  Prepare the Boot Mediaâ  , then plug in your USB stick before turning on
    the computer.

    If you are booting from CDROM, then you will need to turn on the computer,
    and insert the CDROM at the first opportunity.

    Note:

    For FreeBSD/pc98, installation boot floppies are available and can be
    prepared as described in SectionÂ 3.3.7, â  Prepare the Boot Mediaâ  . The
    first floppy disc will contain boot.flp. Put this floppy in the floppy
    drive to boot into the installer.

    If your computer starts up as normal and loads your existing operating
    system, then either:

     1. The disks were not inserted early enough in the boot process. Leave
        them in, and try restarting your computer.

     2. The BIOS changes earlier did not work correctly. You should redo that
        step until you get the right option.

     3. Your particular BIOS does not support booting from the desired media.

 5. FreeBSD will start to boot. If you are booting from CDROM you will see a
    display similar to this (version information omitted):

    Booting from CD-Rom... 645MB medium detected CD Loader 1.2 Building the
    boot loader arguments Looking up /BOOT/LOADER... Found Relocating the
    loader and the BTX Starting the BTX loader BTX loader 1.00 BTX version is
    1.02 Consoles: internal video/keyboard BIOS CD is cd0 BIOS drive C: is
    disk0 BIOS drive D: is disk1 BIOS 636kB/261056kB available memory FreeBSD/
    i386 bootstrap loader, Revision 1.1 Loading /boot/defaults/loader.conf /
    boot/kernel/kernel text=0x64daa0 data=0xa4e80+0xa9e40 syms=
    [0x4+0x6cac0+0x4+0x88e9d] \

    If you are booting from floppy disc, you will see a display similar to this
    (version information omitted):

    Booting from Floppy... Uncompressing ... done BTX loader 1.00 BTX version
    is 1.01 Console: internal video/keyboard BIOS drive A: is disk0 BIOS drive
    C: is disk1 BIOS 639kB/261120kB available memory FreeBSD/i386 bootstrap
    loader, Revision 1.1 Loading /boot/defaults/loader.conf /kernel text=
    0x277391 data=0x3268c+0x332a8 | Insert disk labelled "Kernel floppy 1" and
    press any key...

    Follow these instructions by removing the boot.flp disc, insert the
    kern1.flp disc, and press Enter. Boot from first floppy; when prompted,
    insert the other disks as required.

 6. Whether you booted from CDROM, USB stick or floppy, the boot process will
    then get to the FreeBSD boot loader menu:

    FigureÂ 3.1.Â FreeBSD Boot Loader Menu
    FreeBSD Boot Loader Menu


    Either wait ten seconds, or press Enter.

3.4.1.2.Â Booting for SPARC64Â®

Most SPARC64Â® systems are set up to boot automatically from disk. To install
FreeBSD, you need to boot over the network or from a CDROM, which requires you
to break into the PROM (OpenFirmware).

To do this, reboot the system, and wait until the boot message appears. It
depends on the model, but should look about like:

Sun Blade 100 (UltraSPARC-IIe), Keyboard Present Copyright 1998-2001 Sun
Microsystems, Inc. All rights reserved. OpenBoot 4.2, 128 MB memory installed,
Serial #51090132. Ethernet address 0:3:ba:b:92:d4, Host ID: 830b92d4.

If your system proceeds to boot from disk at this point, you need to press L1+A
or Stop+A on the keyboard, or send a BREAK over the serial console (using for
example ~# in tip(1) or cu(1)) to get to the PROM prompt. It looks like this:

ok 1 ok {0} 2

1    This is the prompt used on systems with just one CPU.

2    This is the prompt used on SMP systems, the digit indicates the number of
     the active CPU.

At this point, place the CDROM into your drive, and from the PROM prompt, type
boot cdrom.

3.4.2.Â Reviewing the Device Probe Results

The last few hundred lines that have been displayed on screen are stored and
can be reviewed.

To review the buffer, press Scroll Lock. This turns on scrolling in the
display. You can then use the arrow keys, or PageUp and PageDown to view the
results. Press Scroll Lock again to stop scrolling.

Do this now, to review the text that scrolled off the screen when the kernel
was carrying out the device probes. You will see text similar to FigureÂ 3.2, â
  Typical Device Probe Resultsâ  , although the precise text will differ
depending on the devices that you have in your computer.

FigureÂ 3.2.Â Typical Device Probe Results
avail memory = 253050880 (247120K bytes) Preloaded elf kernel "kernel" at
0xc0817000. Preloaded mfs_root "/mfsroot" at 0xc0817084. md0: Preloaded image
&lt;/mfsroot&gt; 4423680 bytes at 0xc03ddcd4 md1: Malloc disk Using $PIR table, 4
entries at 0xc00fde60 npx0: &lt;math processor&gt; on motherboard npx0: INT 16
interface pcib0: &lt;Host to PCI bridge&gt; on motherboard pci0: &lt;PCI bus&gt; on pcib0
pcib1:&lt;VIA 82C598MVP (Apollo MVP3) PCI-PCI (AGP) bridge&gt; at device 1.0 on pci0
pci1: &lt;PCI bus&gt; on pcib1 pci1: &lt;Matrox MGA G200 AGP graphics accelerator&gt; at
0.0 irq 11 isab0: &lt;VIA 82C586 PCI-ISA bridge&gt; at device 7.0 on pci0 isa0: &lt;iSA
bus&gt; on isab0 atapci0: &lt;VIA 82C586 ATA33 controller&gt; port 0xe000-0xe00f at
device 7.1 on pci0 ata0: at 0x1f0 irq 14 on atapci0 ata1: at 0x170 irq 15 on
atapci0 uhci0 &lt;VIA 83C572 USB controller&gt; port 0xe400-0xe41f irq 10 at device
7.2 on pci 0 usb0: &lt;VIA 83572 USB controller&gt; on uhci0 usb0: USB revision 1.0
uhub0: VIA UHCI root hub, class 9/0, rev 1.00/1.00, addr1 uhub0: 2 ports with 2
removable, self powered pci0: &lt;unknown card&gt; (vendor=0x1106, dev=0x3040) at 7.3
dc0: &lt;ADMtek AN985 10/100BaseTX&gt; port 0xe800-0xe8ff mem 0xdb000000-0xeb0003ff
ir q 11 at device 8.0 on pci0 dc0: Ethernet address: 00:04:5a:74:6b:b5 miibus0:
&lt;MII bus&gt; on dc0 ukphy0: &lt;Generic IEEE 802.3u media interface&gt; on miibus0
ukphy0: 10baseT, 10baseT-FDX, 100baseTX, 100baseTX-FDX, auto ed0: &lt;NE2000 PCI
Ethernet (RealTek 8029)&gt; port 0xec00-0xec1f irq 9 at device 10. 0 on pci0 ed0
address 52:54:05:de:73:1b, type NE2000 (16 bit) isa0: too many dependant
configs (8) isa0: unexpected small tag 14 orm0: &lt;Option ROM&gt; at iomem
0xc0000-0xc7fff on isa0 fdc0: &lt;NEC 72065B or clone&gt; at port 0x3f0-0x3f5,0x3f7
irq 6 drq2 on isa0 fdc0: FIFO enabled, 8 bytes threshold fd0: &lt;1440-KB 3.5â  
drive&gt; on fdc0 drive 0 atkbdc0: &lt;Keyboard controller (i8042)&gt; at port 0x60,0x64
on isa0 atkbd0: &lt;AT Keyboard&gt; flags 0x1 irq1 on atkbdc0 kbd0 at atkbd0 psm0:
&lt;PS/2 Mouse&gt; irq 12 on atkbdc0 psm0: model Generic PS/@ mouse, device ID 0
vga0: &lt;Generic ISA VGA&gt; at port 0x3c0-0x3df iomem 0xa0000-0xbffff on isa0 sc0:
&lt;System console&gt; at flags 0x100 on isa0 sc0: VGA &lt;16 virtual consoles, flags=
0x300&gt; sio0 at port 0x3f8-0x3ff irq 4 flags 0x10 on isa0 sio0: type 16550A sio1
at port 0x2f8-0x2ff irq 3 on isa0 sio1: type 16550A ppc0: &lt;Parallel port&gt; at
port 0x378-0x37f irq 7 on isa0 pppc0: SMC-like chipset (ECP/EPP/PS2/NIBBLE) in
COMPATIBLE mode ppc0: FIFO with 16/16/15 bytes threshold plip0: &lt;PLIP network
interface&gt; on ppbus0 ad0: 8063MB &lt;IBM-DHEA-38451&gt; [16383/16/63] at ata0-master
UDMA33 acd0: CD-RW &lt;LITE-ON LTR-1210B&gt; at ata1-slave PIO4 Mounting root from
ufs:/dev/md0c /stand/sysinstall running as init on vty0


Check the probe results carefully to make sure that FreeBSD found all the
devices you expected. If a device was not found, then it will not be listed. A
custom kernel allows you to add in support for devices which are not in the
GENERIC kernel, such as sound cards.

After the procedure of device probing, you will see FigureÂ 3.3, â  Selecting
Country Menuâ  . Use the arrow key to choose a country, region, or group. Then
press Enter, it will set your country easily.

FigureÂ 3.3.Â Selecting Country Menu
Selecting Country Menu


If you selected United States as country, the standard American keyboard map
will be used, if a different country is chosen the following menu will be
displayed. Use the arrow keys to choose the correct keyboard map and press 
Enter.

FigureÂ 3.4.Â Selecting Keyboard Menu
Selecting Keyboard Menu


After the country selecting, the sysinstall main menu will display.

3.5.Â Introducing Sysinstall

The sysinstall utility is the installation application provided by the FreeBSD
Project. It is console based and is divided into a number of menus and screens
that you can use to configure and control the installation process.

The sysinstall menu system is controlled by the arrow keys, Enter, Tab, Space,
and other keys. A detailed description of these keys and what they do is
contained in sysinstall's usage information.

To review this information, ensure that the Usage entry is highlighted and that
the [Select] button is selected, as shown in FigureÂ 3.5, â  Selecting Usage
from Sysinstall Main Menuâ  , then press Enter.

The instructions for using the menu system will be displayed. After reviewing
them, press Enter to return to the Main Menu.

FigureÂ 3.5.Â Selecting Usage from Sysinstall Main Menu
Selecting Usage from Sysinstall Main Menu


3.5.1.Â Selecting the Documentation Menu

From the Main Menu, select Doc with the arrow keys and press Enter.

FigureÂ 3.6.Â Selecting Documentation Menu
Selecting Documentation Menu


This will display the Documentation Menu.

FigureÂ 3.7.Â Sysinstall Documentation Menu
Sysinstall Documentation Menu


It is important to read the documents provided.

To view a document, select it with the arrow keys and press Enter. When
finished reading a document, pressing Enter will return to the Documentation
Menu.

To return to the Main Installation Menu, select Exit with the arrow keys and
press Enter.

3.5.2.Â Selecting the Keymap Menu

To change the keyboard mapping, use the arrow keys to select Keymap from the
menu and press Enter. This is only required if you are using a non-standard or
non-US keyboard.

FigureÂ 3.8.Â Sysinstall Main Menu
Sysinstall Main Menu


A different keyboard mapping may be chosen by selecting the menu item using up/
down arrow keys and pressing Space. Pressing Space again will unselect the
item. When finished, choose the [Â OKÂ ] using the arrow keys and press Enter.

Only a partial list is shown in this screen representation. Selecting 
[Â CancelÂ ] by pressing Tab will use the default keymap and return to the Main
Install Menu.

FigureÂ 3.9.Â Sysinstall Keymap Menu
Sysinstall Keymap Menu


3.5.3.Â Installation Options Screen

Select Options and press Enter.

FigureÂ 3.10.Â Sysinstall Main Menu
Sysinstall Main Menu

FigureÂ 3.11.Â Sysinstall Options
Sysinstall Options


The default values are usually fine for most users and do not need to be
changed. The release name will vary according to the version being installed.

The description of the selected item will appear at the bottom of the screen
highlighted in blue. Notice that one of the options is Use Defaults to reset
all values to startup defaults.

Press F1 to read the help screen about the various options.

Pressing Q will return to the Main Install menu.

3.5.4.Â Begin a Standard Installation

The Standard installation is the option recommended for those new to UNIXÂ® or
FreeBSD. Use the arrow keys to select Standard and then press Enter to start
the installation.

FigureÂ 3.12.Â Begin Standard Installation
Begin Standard Installation


3.6.Â Allocating Disk Space

Your first task is to allocate disk space for FreeBSD, and label that space so
that sysinstall can prepare it. In order to do this you need to know how
FreeBSD expects to find information on the disk.

3.6.1.Â BIOS Drive Numbering

Before installing and configuring FreeBSD it is important to be aware how
FreeBSD deals with BIOS drive mappings.

In a PC running a BIOS-dependent operating system such as MS-DOSÂ® or Microsoft
Â®Â WindowsÂ®, the BIOS is able to abstract the normal disk drive order, and
the operating system goes along with the change. This allows the user to boot
from a disk drive other than the "primary master". This is especially
convenient for users buy an identical second hard drive, and perform routine
copies of the first drive to the second drive. If the first drive fails, is
attacked by a virus, or is scribbled upon by an operating system defect, they
can easily recover by instructing the BIOS to logically swap the drives. It is
like switching the cables on the drives, but without having to open the case.

More expensive systems with SCSI controllers often include BIOS extensions
which allow the SCSI drives to be re-ordered in a similar fashion for up to
seven drives.

A user who is accustomed to taking advantage of these features may become
surprised when the results with FreeBSD are not as expected. FreeBSD does not
use the BIOS, and does not know the â  logical BIOS drive mappingâ  . This can
lead to very perplexing situations, especially when drives are physically
identical in geometry, and have also been made as data clones of one another.

When using FreeBSD, always restore the BIOS to natural drive numbering before
installing FreeBSD, and then leave it that way. If you need to switch drives
around, then do so, but do it the hard way, and open the case and move the
jumpers and cables.

An Illustration from the Files of Bill and Fred's Exceptional Adventures:

Bill breaks-down an older Wintel box to make another FreeBSD box for Fred. Bill
installs a single SCSI drive as SCSI unit zero and installs FreeBSD on it.

Fred begins using the system, but after several days notices that the older
SCSI drive is reporting numerous soft errors and reports this fact to Bill.

After several more days, Bill decides it is time to address the situation, so
he grabs an identical SCSI drive from the disk drive â  archiveâ   in the back
room. An initial surface scan indicates that this drive is functioning well, so
Bill installs this drive as SCSI unit four and makes an image copy from drive
zero to drive four. Now that the new drive is installed and functioning nicely,
Bill decides that it is a good idea to start using it, so he uses features in
the SCSI BIOS to re-order the disk drives so that the system boots from SCSI
unit four. FreeBSD boots and runs just fine.

Fred continues his work for several days, and soon Bill and Fred decide that it
is time for a new adventure â   time to upgrade to a newer version of FreeBSD.
Bill removes SCSI unit zero because it was a bit flaky and replaces it with
another identical disk drive from the â  archiveâ  . Bill then installs the new
version of FreeBSD onto the new SCSI unit zero using Fred's magic Internet FTP
floppies. The installation goes well.

Fred uses the new version of FreeBSD for a few days, and certifies that it is
good enough for use in the engineering department. It is time to copy all of
his work from the old version. So Fred mounts SCSI unit four (the latest copy
of the older FreeBSD version). Fred is dismayed to find that none of his
precious work is present on SCSI unit four.

Where did the data go?

When Bill made an image copy of the original SCSI unit zero onto SCSI unit
four, unit four became the â  new cloneâ  . When Bill re-ordered the SCSI BIOS
so that he could boot from SCSI unit four, he was only fooling himself. FreeBSD
was still running on SCSI unit zero. Making this kind of BIOS change will cause
some or all of the Boot and Loader code to be fetched from the selected BIOS
drive, but when the FreeBSD kernel drivers take-over, the BIOS drive numbering
will be ignored, and FreeBSD will transition back to normal drive numbering. In
the illustration at hand, the system continued to operate on the original SCSI
unit zero, and all of Fred's data was there, not on SCSI unit four. The fact
that the system appeared to be running on SCSI unit four was simply an artifact
of human expectations.

We are delighted to mention that no data bytes were killed or harmed in any way
by our discovery of this phenomenon. The older SCSI unit zero was retrieved
from the bone pile, and all of Fred's work was returned to him, (and now Bill
knows that he can count as high as zero).

Although SCSI drives were used in this illustration, the concepts apply equally
to IDE drives.

3.6.2.Â Creating Slices Using FDisk

Note:

No changes you make at this point will be written to the disk. If you think you
have made a mistake and want to start again you can use the menus to exit 
sysinstall and try again or press U to use the Undo option. If you get confused
and can not see how to exit you can always turn your computer off.

After choosing to begin a standard installation in sysinstall you will be shown
this message:

Message In the next menu, you will need to set up a DOS-style ("fdisk")
partitioning scheme for your hard disk. If you simply wish to devote all disk
space to FreeBSD (overwriting anything else that might be on the disk(s)
selected) then use the (A)ll command to select the default partitioning scheme
followed by a (Q)uit. If you wish to allocate only free space to FreeBSD, move
to a partition marked "unused" and use the (C)reate command. [ OK ] [ Press
enter or space ]

Press Enter as instructed. You will then be shown a list of all the hard drives
that the kernel found when it carried out the device probes. FigureÂ 3.13, â  
Select Drive for FDiskâ   shows an example from a system with two IDE disks.
They have been called ad0 and ad2.

FigureÂ 3.13.Â Select Drive for FDisk
Select Drive for FDisk


You might be wondering why ad1 is not listed here. Why has it been missed?

Consider what would happen if you had two IDE hard disks, one as the master on
the first IDE controller, and one as the master on the second IDE controller.
If FreeBSD numbered these as it found them, as ad0 and ad1 then everything
would work.

But if you then added a third disk, as the slave device on the first IDE
controller, it would now be ad1, and the previous ad1 would become ad2. Because
device names (such as ad1s1a) are used to find filesystems, you may suddenly
discover that some of your filesystems no longer appear correctly, and you
would need to change your FreeBSD configuration.

To work around this, the kernel can be configured to name IDE disks based on
where they are, and not the order in which they were found. With this scheme
the master disk on the second IDE controller will always be ad2, even if there
are no ad0 or ad1 devices.

This configuration is the default for the FreeBSD kernel, which is why this
display shows ad0 and ad2. The machine on which this screenshot was taken had
IDE disks on both master channels of the IDE controllers, and no disks on the
slave channels.

You should select the disk on which you want to install FreeBSD, and then press
[Â OKÂ ]. FDisk will start, with a display similar to that shown in
FigureÂ 3.14, â  Typical fdisk Partitions Before Editingâ  .

The FDisk display is broken into three sections.

The first section, covering the first two lines of the display, shows details
about the currently selected disk, including its FreeBSD name, the disk
geometry, and the total size of the disk.

The second section shows the slices that are currently on the disk, where they
start and end, how large they are, the name FreeBSD gives them, and their
description and sub-type. This example shows two small unused slices, which are
artifacts of disk layout schemes on the PC. It also shows one large FAT slice,
which almost certainly appears as C: in MS-DOSÂ® / WindowsÂ®, and an extended
slice, which may contain other drive letters for MS-DOSÂ® / WindowsÂ®.

The third section shows the commands that are available in FDisk.

FigureÂ 3.14.Â Typical fdisk Partitions Before Editing
Typical fdisk Partitions Before Editing


What you do now will depend on how you want to slice up your disk.

If you want to use FreeBSD for the entire disk (which will delete all the other
data on this disk when you confirm that you want sysinstall to continue later
in the installation process) then you can press A, which corresponds to the Use
Entire Disk option. The existing slices will be removed, and replaced with a
small area flagged as unused (again, an artifact of PC disk layout), and then
one large slice for FreeBSD. If you do this, then you should select the newly
created FreeBSD slice using the arrow keys, and press S to mark the slice as
being bootable. The screen will then look very similar to FigureÂ 3.15, â  
Fdisk Partition Using Entire Diskâ  . Note the A in the Flags column, which
indicates that this slice is active, and will be booted from.

If you will be deleting an existing slice to make space for FreeBSD then you
should select the slice using the arrow keys, and then press D. You can then
press C, and be prompted for size of slice you want to create. Enter the
appropriate figure and press Enter. The default value in this box represents
the largest possible slice you can make, which could be the largest contiguous
block of unallocated space or the size of the entire hard disk.

If you have already made space for FreeBSD then you can press C to create a new
slice. Again, you will be prompted for the size of slice you would like to
create.

FigureÂ 3.15.Â Fdisk Partition Using Entire Disk
Fdisk Partition Using Entire Disk


When finished, press Q. Your changes will be saved in sysinstall, but will not
yet be written to disk.

3.6.3.Â Install a Boot Manager

You now have the option to install a boot manager. In general, you should
choose to install the FreeBSD boot manager if:

  * You have more than one drive, and have installed FreeBSD onto a drive other
    than the first one.

  * You have installed FreeBSD alongside another operating system on the same
    disk, and you want to choose whether to start FreeBSD or the other
    operating system when you start the computer.

If FreeBSD is going to be the only operating system on this machine, installed
on the first hard disk, then the Standard boot manager will suffice. Choose 
None if you are using a third-party boot manager capable of booting FreeBSD.

Make your choice and press Enter.

FigureÂ 3.16.Â Sysinstall Boot Manager Menu
Sysinstall Boot Manager Menu


The help screen, reached by pressing F1, discusses the problems that can be
encountered when trying to share the hard disk between operating systems.

3.6.4.Â Creating Slices on Another Drive

If there is more than one drive, it will return to the Select Drives screen
after the boot manager selection. If you wish to install FreeBSD on to more
than one disk, then you can select another disk here and repeat the slice
process using FDisk.

Important:

If you are installing FreeBSD on a drive other than your first, then the
FreeBSD boot manager needs to be installed on both drives.

FigureÂ 3.17.Â Exit Select Drive
Exit Select Drive


The Tab key toggles between the last drive selected, [Â OKÂ ], and [Â CancelÂ ]
.

Press the Tab once to toggle to the [Â OKÂ ], then press Enter to continue with
the installation.

3.6.5.Â Creating Partitions Using Disklabel

You must now create some partitions inside each slice that you have just
created. Remember that each partition is lettered, from a through to h, and
that partitions b, c, and d have conventional meanings that you should adhere
to.

Certain applications can benefit from particular partition schemes, especially
if you are laying out partitions across more than one disk. However, for this,
your first FreeBSD installation, you do not need to give too much thought to
how you partition the disk. It is more important that you install FreeBSD and
start learning how to use it. You can always re-install FreeBSD to change your
partition scheme when you are more familiar with the operating system.

This scheme features four partitionsâ  one for swap space, and three for
filesystems.

TableÂ 3.2.Â Partition Layout for First Disk

Partition Filesystem   Size                      Description
                              This is the root filesystem. Every other
                              filesystem will be mounted somewhere under this
                              one. 1Â GB is a reasonable size for this
                              filesystem. You will not be storing too much data
a         /          1Â GB    on it, as a regular FreeBSD install will put
                              about 128Â MB of data here. The remaining space
                              is for temporary data, and also leaves expansion
                              space if future versions of FreeBSD need more
                              space in /.
                              The system's swap space is kept on the b
                              partition. Choosing the right amount of swap
                              space can be a bit of an art. A good rule of
                              thumb is that your swap space should be two or
                              three times as much as the available physical
                              memory (RAM). You should also have at least
                              64Â MB of swap, so if you have less than 32Â MB
                              of RAM in your computer then set the swap amount
                              to 64Â MB.
b         N/A        2-3 x
                     RAM      If you have more than one disk then you can put
                              swap space on each disk. FreeBSD will then use
                              each disk for swap, which effectively speeds up
                              the act of swapping. In this case, calculate the
                              total amount of swap you need (e.g., 128Â MB),
                              and then divide this by the number of disks you
                              have (e.g., two disks) to give the amount of swap
                              you should put on each disk, in this example,
                              64Â MB of swap per disk.

                              The /var directory contains files that are
                              constantly varying; log files, and other
                              administrative files. Many of these files are
                     512Â MB  read-from or written-to extensively during
e         /var       to       FreeBSD's day-to-day running. Putting these files
                     4096Â MB on another filesystem allows FreeBSD to optimize
                              the access of these files without affecting other
                              files in other directories that do not have the
                              same access pattern.
                     Rest of
f         /usr       disk (at All your other files will typically be stored in
                     least    /usr and its subdirectories.
                     8Â GB)


Warning:

The values above are given as example and should be used by experienced users
only. Users are encouraged to use the automatic partition layout called Auto
Defaults by the FreeBSD partition editor.

If you will be installing FreeBSD on to more than one disk then you must also
create partitions in the other slices that you configured. The easiest way to
do this is to create two partitions on each disk, one for the swap space, and
one for a filesystem.

TableÂ 3.3.Â Partition Layout for Subsequent Disks

Partition Filesystem    Size                      Description
                                 As already discussed, you can split swap space
b         N/A        See         across each disk. Even though the a partition
                     description is free, convention dictates that swap space
                                 stays on the b partition.
                                 The rest of the disk is taken up with one big
                                 partition. This could easily be put on the a
                                 partition, instead of the e partition.
                                 However, convention says that the a partition
                                 on a slice is reserved for the filesystem that
                                 will be the root (/) filesystem. You do not
e         /diskn     Rest of     have to follow this convention, but sysinstall
                     disk        does, so following it yourself makes the
                                 installation slightly cleaner. You can choose
                                 to mount this filesystem anywhere; this
                                 example suggests that you mount them as
                                 directories /diskn, where n is a number that
                                 changes for each disk. But you can use another
                                 scheme if you prefer.


Having chosen your partition layout you can now create it using sysinstall. You
will see this message:

Message Now, you need to create BSD partitions inside of the fdisk partition(s)
just created. If you have a reasonable amount of disk space (1GB or more) and
don't have any special requirements, simply use the (A)uto command to allocate
space automatically. If you have more specific needs or just don't care for the
layout chosen by (A)uto, press F1 for more information on manual layout. [ OK ]
[ Press enter or space ]

Press Enter to start the FreeBSD partition editor, called Disklabel.

FigureÂ 3.18, â  Sysinstall Disklabel Editorâ   shows the display when you
first start Disklabel. The display is divided in to three sections.

The first few lines show the name of the disk you are currently working on, and
the slice that contains the partitions you are creating (at this point 
Disklabel calls this the Partition name rather than slice name). This display
also shows the amount of free space within the slice; that is, space that was
set aside in the slice, but that has not yet been assigned to a partition.

The middle of the display shows the partitions that have been created, the name
of the filesystem that each partition contains, their size, and some options
pertaining to the creation of the filesystem.

The bottom third of the screen shows the keystrokes that are valid in Disklabel
.

FigureÂ 3.18.Â Sysinstall Disklabel Editor
Sysinstall Disklabel Editor


Disklabel can automatically create partitions for you and assign them default
sizes. The default sizes are calculated with the help of an internal partition
sizing algorithm based on the disk size. Try this now, by Pressing A. You will
see a display similar to that shown in FigureÂ 3.19, â  Sysinstall Disklabel
Editor with Auto Defaultsâ  . Depending on the size of the disk you are using,
the defaults may or may not be appropriate. This does not matter, as you do not
have to accept the defaults.

Note:

The default partitioning assigns the /tmp directory its own partition instead
of being part of the / partition. This helps avoid filling the / partition with
temporary files.

FigureÂ 3.19.Â Sysinstall Disklabel Editor with Auto Defaults
Sysinstall Disklabel Editor with Auto Defaults


If you choose to not use the default partitions and wish to replace them with
your own, use the arrow keys to select the first partition, and press D to
delete it. Repeat this to delete all the suggested partitions.

To create the first partition (a, mounted as / â   root), make sure the proper
disk slice at the top of the screen is selected and press C. A dialog box will
appear prompting you for the size of the new partition (as shown in
FigureÂ 3.20, â  Free Space for Root Partitionâ  ). You can enter the size as
the number of disk blocks you want to use, or as a number followed by either M
for megabytes, G for gigabytes, or C for cylinders.

FigureÂ 3.20.Â Free Space for Root Partition
Free Space for Root Partition


The default size shown will create a partition that takes up the rest of the
slice. If you are using the partition sizes described in the earlier example,
then delete the existing figure using Backspace, and then type in 512M, as
shown in FigureÂ 3.21, â  Edit Root Partition Sizeâ  . Then press [Â OKÂ ].

FigureÂ 3.21.Â Edit Root Partition Size
Edit Root Partition Size


Having chosen the partition's size you will then be asked whether this
partition will contain a filesystem or swap space. The dialog box is shown in
FigureÂ 3.22, â  Choose the Root Partition Typeâ  . This first partition will
contain a filesystem, so check that FS is selected and press Enter.

FigureÂ 3.22.Â Choose the Root Partition Type
Choose the Root Partition Type


Finally, because you are creating a filesystem, you must tell Disklabel where
the filesystem is to be mounted. The dialog box is shown in FigureÂ 3.23, â  
Choose the Root Mount Pointâ  . The root filesystem's mount point is /, so type
/, and then press Enter.

FigureÂ 3.23.Â Choose the Root Mount Point
Choose the Root Mount Point


The display will then update to show you the newly created partition. You
should repeat this procedure for the other partitions. When you create the swap
partition, you will not be prompted for the filesystem mount point, as swap
partitions are never mounted. When you create the final partition, /usr, you
can leave the suggested size as is, to use the rest of the slice.

Your final FreeBSD DiskLabel Editor screen will appear similar to FigureÂ 3.24,
â  Sysinstall Disklabel Editorâ  , although your values chosen may be
different. Press Q to finish.

FigureÂ 3.24.Â Sysinstall Disklabel Editor
Sysinstall Disklabel Editor


3.7.Â Choosing What to Install

3.7.1.Â Select the Distribution Set

Deciding which distribution set to install will depend largely on the intended
use of the system and the amount of disk space available. The predefined
options range from installing the smallest possible configuration to
everything. Those who are new to UNIXÂ® and/or FreeBSD should almost certainly
select one of these canned options. Customizing a distribution set is typically
for the more experienced user.

Press F1 for more information on the distribution set options and what they
contain. When finished reviewing the help, pressing Enter will return to the
Select Distributions Menu.

If a graphical user interface is desired then the configuration of the X server
and selection of a default desktop must be done after the installation of
FreeBSD. More information regarding the installation and configuration of a X
server can be found in ChapterÂ 6, The X Window System.

If compiling a custom kernel is anticipated, select an option which includes
the source code. For more information on why a custom kernel should be built or
how to build a custom kernel, see ChapterÂ 9, Configuring the FreeBSD Kernel.

Obviously, the most versatile system is one that includes everything. If there
is adequate disk space, select All as shown in FigureÂ 3.25, â  Choose
Distributionsâ   by using the arrow keys and press Enter. If there is a concern
about disk space consider using an option that is more suitable for the
situation. Do not fret over the perfect choice, as other distributions can be
added after installation.

FigureÂ 3.25.Â Choose Distributions
Choose Distributions


3.7.2.Â Installing the Ports Collection

After selecting the desired distribution, an opportunity to install the FreeBSD
Ports Collection is presented. The ports collection is an easy and convenient
way to install software. The Ports Collection does not contain the source code
necessary to compile the software. Instead, it is a collection of files which
automates the downloading, compiling and installation of third-party software
packages. ChapterÂ 5, Installing Applications: Packages and Ports discusses how
to use the ports collection.

The installation program does not check to see if you have adequate space.
Select this option only if you have adequate hard disk space. As of FreeBSD
9.1, the FreeBSD Ports Collection takes up about 500Â MB of disk space. You can
safely assume a larger value for more recent versions of FreeBSD.

User Confirmation Requested Would you like to install the FreeBSD ports
collection? This will give you ready access to over 24,000 ported software
packages, at a cost of around 500Â MB of disk space when "clean" and possibly
much more than that if a lot of the distribution tarballs are loaded (unless
you have the extra CDs from a FreeBSD CD/DVD distribution available and can
mount it on /cdrom, in which case this is far less of a problem). The Ports
Collection is a very valuable resource and well worth having on your /usr
partition, so it is advisable to say Yes to this option. For more information
on the Ports Collection & the latest ports, visit: http://www.FreeBSD.org/ports
[ Yes ] No

Select [Â YesÂ ] with the arrow keys to install the Ports Collection or 
[Â NoÂ ] to skip this option. Press Enter to continue. The Choose Distributions
menu will redisplay.

FigureÂ 3.26.Â Confirm Distributions
Confirm Distributions


If satisfied with the options, select Exit with the arrow keys, ensure that 
[Â OKÂ ] is highlighted, and pressing Enter to continue.

3.8.Â Choosing Your Installation Media

If Installing from a CDROM or DVD, use the arrow keys to highlight Install from
a FreeBSD CD/DVD. Ensure that [Â OKÂ ] is highlighted, then press Enter to
proceed with the installation.

For other methods of installation, select the appropriate option and follow the
instructions.

Press F1 to display the Online Help for installation media. Press Enter to
return to the media selection menu.

FigureÂ 3.27.Â Choose Installation Media
Choose Installation Media


FTP Installation Modes:

There are three FTP installation modes you can choose from: active FTP, passive
FTP, or via a HTTP proxy.

FTP Active: Install from an FTP server

    This option will make all FTP transfers use â  Activeâ   mode. This will
    not work through firewalls, but will often work with older FTP servers that
    do not support passive mode. If your connection hangs with passive mode
    (the default), try active!

FTP Passive: Install from an FTP server through a firewall
   
    This option instructs sysinstall to â  Passiveâ   mode for all FTP
    operations. This allows the user to pass through firewalls that do not
    allow incoming connections on random TCP ports.

FTP via a HTTP proxy: Install from an FTP server through a http proxy
   
    This option instructs sysinstall to use the HTTP protocol (like a web
    browser) to connect to a proxy for all FTP operations. The proxy will
    translate the requests and send them to the FTP server. This allows the
    user to pass through firewalls that do not allow FTP at all, but offer a
    HTTP proxy. In this case, you have to specify the proxy in addition to the
    FTP server.

For a proxy FTP server, you should usually give the name of the server you
really want as a part of the username, after an â  @â   sign. The proxy server
then â  fakesâ   the real server. For example, assuming you want to install
from ftp.FreeBSD.org, using the proxy FTP server foo.example.com, listening on
port 1234.

In this case, you go to the options menu, set the FTP username to
ftp@ftp.FreeBSD.org, and the password to your email address. As your
installation media, you specify FTP (or passive FTP, if the proxy supports it),
and the URL ftp://foo.example.com:1234/pub/FreeBSD.

Since /pub/FreeBSD from ftp.FreeBSD.org is proxied under foo.example.com, you
are able to install from that machine (which will fetch the files from
ftp.FreeBSD.org as your installation requests them).

3.9.Â Committing to the Installation

The installation can now proceed if desired. This is also the last chance for
aborting the installation to prevent changes to the hard drive.

User Confirmation Requested Last Chance! Are you SURE you want to continue the
installation? If you're running this on a disk with data you wish to save then
WE STRONGLY ENCOURAGE YOU TO MAKE PROPER BACKUPS before proceeding! We can take
no responsibility for lost disk contents! [ Yes ] No

Select [Â YesÂ ] and press Enter to proceed.

The installation time will vary according to the distribution chosen,
installation media, and the speed of the computer. There will be a series of
messages displayed indicating the status.

The installation is complete when the following message is displayed:

Message Congratulations! You now have FreeBSD installed on your system. We will
now move on to the final configuration questions. For any option you do not
wish to configure, simply select No. If you wish to re-enter this utility after
the system is up, you may do so by typing: /usr/sbin/sysinstall. [ OK ] [ Press
enter or space ]

Press Enter to proceed with post-installation configurations.

Selecting [Â NoÂ ] and pressing Enter will abort the installation so no changes
will be made to your system. The following message will appear:

Message Installation complete with some errors. You may wish to scroll through
the debugging messages on VTY1 with the scroll-lock feature. You can also
choose "No" at the next prompt and go back into the installation menus to retry
whichever operations have failed. [ OK ]

This message is generated because nothing was installed. Pressing Enter will
return to the Main Installation Menu to exit the installation.

3.10.Â Post-installation

Configuration of various options follows the successful installation. An option
can be configured by re-entering the configuration options before booting the
new FreeBSD system or after installation using sysinstall and selecting 
Configure.

3.10.1.Â Network Device Configuration

If you previously configured PPP for an FTP install, this screen will not
display and can be configured later as described above.

For detailed information on Local Area Networks and configuring FreeBSD as a
gateway/router refer to the Advanced Networking chapter.

User Confirmation Requested Would you like to configure any Ethernet or PPP
network devices? [ Yes ] No

To configure a network device, select [Â YesÂ ] and press Enter. Otherwise,
select [Â NoÂ ] to continue.

FigureÂ 3.28.Â Selecting an Ethernet Device
Selecting an Ethernet Device


Select the interface to be configured with the arrow keys and press Enter.

User Confirmation Requested Do you want to try IPv6 configuration of the
interface? Yes [ No ]

In this private local area network, the current Internet type protocol (IPv4)
was sufficient and [Â NoÂ ] was selected with the arrow keys and Enter pressed.

If you are connected to an existing IPv6 network with an RA server, then choose
[Â YesÂ ] and press Enter. It will take several seconds to scan for RA servers.

User Confirmation Requested Do you want to try DHCP configuration of the
interface? Yes [ No ]

If DHCP (Dynamic Host Configuration Protocol) is not required select [Â NoÂ ]
with the arrow keys and press Enter.

Selecting [Â YesÂ ] will execute dhclient, and if successful, will fill in the
network configuration information automatically. Refer to SectionÂ 30.5, â  
Automatic Network Configuration (DHCP)â   for more information.

The following Network Configuration screen shows the configuration of the
Ethernet device for a system that will act as the gateway for a Local Area
Network.

FigureÂ 3.29.Â Set Network Configuration for ed0
Set Network Configuration for ed0


Use Tab to select the information fields and fill in appropriate information:

Host

    The fully-qualified hostname, such as k6-2.example.com in this case.

Domain

    The name of the domain that your machine is in, such as example.com for
    this case.

IPv4 Gateway

    IP address of host forwarding packets to non-local destinations. You must
    fill this in if the machine is a node on the network. Leave this field
    blank if the machine is the gateway to the Internet for the network. The
    IPv4 Gateway is also known as the default gateway or default route.

Name server

    IP address of your local DNS server. There is no local DNS server on this
    private local area network so the IP address of the provider's DNS server
    (208.163.10.2) was used.

IPv4 address

    The IP address to be used for this interface was 192.168.0.1

Netmask

    The address block being used for this local area network is 192.168.0.0 -
    192.168.0.255 with a netmask of 255.255.255.0.

Extra options to ifconfig

    Any interface-specific options to ifconfig you would like to add. There
    were none in this case.

Use Tab to select [Â OKÂ ] when finished and press Enter.

User Confirmation Requested Would you like to bring the ed0 interface up right
now? [ Yes ] No

Choosing [Â YesÂ ] and pressing Enter will bring the machine up on the network
and be ready for use. However, this does not accomplish much during
installation, since the machine still needs to be rebooted.

3.10.2.Â Configure Gateway

User Confirmation Requested Do you want this machine to function as a network
gateway? [ Yes ] No

If the machine will be acting as the gateway for a local area network and
forwarding packets between other machines then select [Â YesÂ ] and press Enter
. If the machine is a node on a network then select [Â NoÂ ] and press Enter to
continue.

3.10.3.Â Configure Internet Services

User Confirmation Requested Do you want to configure inetd and the network
services that it provides? Yes [ No ]

If [Â NoÂ ] is selected, various services such telnetd will not be enabled.
This means that remote users will not be able to telnet into this machine.
Local users will still be able to access remote machines with telnet.

These services can be enabled after installation by editing /etc/inetd.conf
with your favorite text editor. See SectionÂ 30.2.1, â  Overviewâ   for more
information.

Select [Â YesÂ ] if you wish to configure these services during install. An
additional confirmation will display:

User Confirmation Requested The Internet Super Server (inetd) allows a number
of simple Internet services to be enabled, including finger, ftp and telnetd.
Enabling these services may increase risk of security problems by increasing
the exposure of your system. With this in mind, do you wish to enable inetd? [
Yes ] No

Select [Â YesÂ ] to continue.

User Confirmation Requested inetd(8) relies on its configuration file, /etc/
inetd.conf, to determine which of its Internet services will be available. The
default FreeBSD inetd.conf(5) leaves all services disabled by default, so they
must be specifically enabled in the configuration file before they will
function, even once inetd(8) is enabled. Note that services for IPv6 must be
separately enabled from IPv4 services. Select [Yes] now to invoke an editor on
/etc/inetd.conf, or [No] to use the current settings. [ Yes ] No

Selecting [Â YesÂ ] will allow adding services by deleting the # at the
beginning of a line.

FigureÂ 3.30.Â Editing inetd.conf
Editing inetd.conf


After adding the desired services, pressing Esc will display a menu which will
allow exiting and saving the changes.

3.10.4.Â Enabling SSH Login

User Confirmation Requested Would you like to enable SSH login? Yes [ No ]

Selecting [Â YesÂ ] will enable sshd(8), the daemon program for OpenSSH. This
will allow secure remote access to your machine. For more information about 
OpenSSH see SectionÂ 15.10, â  OpenSSHâ  .

3.10.5.Â Anonymous FTP

User Confirmation Requested Do you want to have anonymous FTP access to this
machine? Yes [ No ]

3.10.5.1.Â Deny Anonymous FTP

Selecting the default [Â NoÂ ] and pressing Enter will still allow users who
have accounts with passwords to use FTP to access the machine.

3.10.5.2.Â Allow Anonymous FTP

Anyone can access your machine if you elect to allow anonymous FTP connections.
The security implications should be considered before enabling this option. For
more information about security see ChapterÂ 15, Security.

To allow anonymous FTP, use the arrow keys to select [Â YesÂ ] and press Enter.
An additional confirmation will display:

User Confirmation Requested Anonymous FTP permits un-authenticated users to
connect to the system FTP server, if FTP service is enabled. Anonymous users
are restricted to a specific subset of the file system, and the default
configuration provides a drop-box incoming directory to which uploads are
permitted. You must separately enable both inetd(8), and enable ftpd(8) in
inetd.conf(5) for FTP services to be available. If you did not do so earlier,
you will have the opportunity to enable inetd(8) again later. If you want the
server to be read-only you should leave the upload directory option empty and
add the -r command-line option to ftpd(8) in inetd.conf(5) Do you wish to
continue configuring anonymous FTP? [ Yes ] No

This message informs you that the FTP service will also have to be enabled in /
etc/inetd.conf if you want to allow anonymous FTP connections, see
SectionÂ 3.10.3, â  Configure Internet Servicesâ  . Select [Â YesÂ ] and press 
Enter to continue; the following screen will display:

FigureÂ 3.31.Â Default Anonymous FTP Configuration
Default Anonymous FTP Configuration


Use Tab to select the information fields and fill in appropriate information:

UID

    The user ID you wish to assign to the anonymous FTP user. All files
    uploaded will be owned by this ID.

Group

    Which group you wish the anonymous FTP user to be in.

Comment

    String describing this user in /etc/passwd.

FTP Root Directory

    Where files available for anonymous FTP will be kept.

Upload Subdirectory

    Where files uploaded by anonymous FTP users will go.

The FTP root directory will be put in /var by default. If you do not have
enough room there for the anticipated FTP needs, the /usr directory could be
used by setting the FTP root directory to /usr/ftp.

When you are satisfied with the values, press Enter to continue.

User Confirmation Requested Create a welcome message file for anonymous FTP
users? [ Yes ] No

If you select [Â YesÂ ] and press Enter, an editor will automatically start
allowing you to edit the message.

FigureÂ 3.32.Â Edit the FTP Welcome Message
Edit the FTP Welcome Message


This is a text editor called ee. Use the instructions to change the message or
change the message later using a text editor of your choice. Note the file name
/location at the bottom of the editor screen.

Press Esc and a pop-up menu will default to a) leave editor. Press Enter to
exit and continue. Press Enter again to save changes if you made any.

3.10.6.Â Configure Network File System

Network File System (NFS) allows sharing of files across a network. A machine
can be configured as a server, a client, or both. Refer to SectionÂ 30.3, â  
Network File System (NFS)â   for a more information.

3.10.6.1.Â NFS Server

User Confirmation Requested Do you want to configure this machine as an NFS
server? Yes [ No ]

If there is no need for a Network File System server, select [Â NoÂ ] and press
Enter.

If [Â YesÂ ] is chosen, a message will pop-up indicating that the exports file
must be created.

Message Operating as an NFS server means that you must first configure an /etc/
exports file to indicate which hosts are allowed certain kinds of access to
your local filesystems. Press [Enter] now to invoke an editor on /etc/exports [
OK ]

Press Enter to continue. A text editor will start allowing the exports file to
be created and edited.

FigureÂ 3.33.Â Editing exports
Editing exports


Use the instructions to add the actual exported filesystems now or later using
a text editor of your choice. Note the file name/location at the bottom of the
editor screen.

Press Esc and a pop-up menu will default to a) leave editor. Press Enter to
exit and continue.

3.10.6.2.Â NFS Client

The NFS client allows your machine to access NFS servers.

User Confirmation Requested Do you want to configure this machine as an NFS
client? Yes [ No ]

With the arrow keys, select [Â YesÂ ] or [Â NoÂ ] as appropriate and press 
Enter.

3.10.7.Â System Console Settings

There are several options available to customize the system console.

User Confirmation Requested Would you like to customize your system console
settings? [ Yes ] No

To view and configure the options, select [Â YesÂ ] and press Enter.

FigureÂ 3.34.Â System Console Configuration Options
System Console Configuration Options


A commonly used option is the screen saver. Use the arrow keys to select Saver
and then press Enter.

FigureÂ 3.35.Â Screen Saver Options
Screen Saver Options


Select the desired screen saver using the arrow keys and then press Enter. The
System Console Configuration menu will redisplay.

The default time interval is 300 seconds. To change the time interval, select 
Saver again. At the Screen Saver Options menu, select Timeout using the arrow
keys and press Enter. A pop-up menu will appear:

FigureÂ 3.36.Â Screen Saver Timeout
Screen Saver Timeout


The value can be changed, then select [Â OKÂ ] and press Enter to return to the
System Console Configuration menu.

FigureÂ 3.37.Â System Console Configuration Exit
System Console Configuration Exit


Selecting Exit and pressing Enter will continue with the post-installation
configurations.

3.10.8.Â Setting the Time Zone

Setting the time zone for your machine will allow it to automatically correct
for any regional time changes and perform other time zone related functions
properly.

The example shown is for a machine located in the Eastern time zone of the
United States. Your selections will vary according to your geographical
location.

User Confirmation Requested Would you like to set this machine's time zone now?
[ Yes ] No

Select [Â YesÂ ] and press Enter to set the time zone.

User Confirmation Requested Is this machine's CMOS clock set to UTC? If it is
set to local time or you don't know, please choose NO here! Yes [ No ]

Select [Â YesÂ ] or [Â NoÂ ] according to how the machine's clock is configured
and press Enter.

FigureÂ 3.38.Â Select Your Region
Select Your Region


The appropriate region is selected using the arrow keys and then pressing Enter
.

FigureÂ 3.39.Â Select Your Country
Select Your Country


Select the appropriate country using the arrow keys and press Enter.

FigureÂ 3.40.Â Select Your Time Zone
Select Your Time Zone


The appropriate time zone is selected using the arrow keys and pressing Enter.

Confirmation Does the abbreviation 'EDT' look reasonable? [ Yes ] No

Confirm the abbreviation for the time zone is correct. If it looks okay, press 
Enter to continue with the post-installation configuration.

3.10.9.Â Mouse Settings

This option will allow you to cut and paste text in the console and user
programs with a 3-button mouse. If using a 2-button mouse, refer to manual
page, moused(8), after installation for details on emulating the 3-button
style. This example depicts a non-USB mouse configuration (such as a PS/2 or
COM port mouse):

User Confirmation Requested Does this system have a PS/2, serial, or bus mouse?
[ Yes ] No

Select [Â YesÂ ] for a PS/2, serial or bus mouse, or [Â NoÂ ] for a USB mouse
and press Enter.

FigureÂ 3.41.Â Select Mouse Protocol Type
Select Mouse Protocol Type


Use the arrow keys to select Type and press Enter.

FigureÂ 3.42.Â Set Mouse Protocol
Set Mouse Protocol


The mouse used in this example is a PS/2 type, so the default Auto was
appropriate. To change protocol, use the arrow keys to select another option.
Ensure that [Â OKÂ ] is highlighted and press Enter to exit this menu.

FigureÂ 3.43.Â Configure Mouse Port
Configure Mouse Port


Use the arrow keys to select Port and press Enter.

FigureÂ 3.44.Â Setting the Mouse Port
Setting the Mouse Port


This system had a PS/2 mouse, so the default PS/2 was appropriate. To change
the port, use the arrow keys and then press Enter.

FigureÂ 3.45.Â Enable the Mouse Daemon
Enable the Mouse Daemon


Last, use the arrow keys to select Enable, and press Enter to enable and test
the mouse daemon.

FigureÂ 3.46.Â Test the Mouse Daemon
Test the Mouse Daemon


Move the mouse around the screen and verify the cursor shown responds properly.
If it does, select [Â YesÂ ] and press Enter. If not, the mouse has not been
configured correctly â   select [Â NoÂ ] and try using different configuration
options.

Select Exit with the arrow keys and press Enter to return to continue with the
post-installation configuration.

3.10.10.Â Install Packages

Packages are pre-compiled binaries and are a convenient way to install
software.

Installation of one package is shown for purposes of illustration. Additional
packages can also be added at this time if desired. After installation
sysinstall can be used to add additional packages.

User Confirmation Requested The FreeBSD package collection is a collection of
hundreds of ready-to-run applications, from text editors to games to WEB
servers and more. Would you like to browse the collection now? [ Yes ] No

Selecting [Â YesÂ ] and pressing Enter will be followed by the Package
Selection screens:

FigureÂ 3.47.Â Select Package Category
Select Package Category


Only packages on the current installation media are available for installation
at any given time.

All packages available will be displayed if All is selected or you can select a
particular category. Highlight your selection with the arrow keys and press 
Enter.

A menu will display showing all the packages available for the selection made:

FigureÂ 3.48.Â Select Packages
Select Packages


The bash shell is shown selected. Select as many as desired by highlighting the
package and pressing the Space key. A short description of each package will
appear in the lower left corner of the screen.

Pressing the Tab key will toggle between the last selected package, [Â OKÂ ],
and [Â CancelÂ ].

When you have finished marking the packages for installation, press Tab once to
toggle to the [Â OKÂ ] and press Enter to return to the Package Selection menu.

The left and right arrow keys will also toggle between [Â OKÂ ] and 
[Â CancelÂ ]. This method can also be used to select [Â OKÂ ] and press Enter
to return to the Package Selection menu.

FigureÂ 3.49.Â Install Packages
Install Packages


Use the Tab and arrow keys to select [Â InstallÂ ] and press Enter. You will
then need to confirm that you want to install the packages:

FigureÂ 3.50.Â Confirm Package Installation
Confirm Package Installation


Selecting [Â OKÂ ] and pressing Enter will start the package installation.
Installing messages will appear until completed. Make note if there are any
error messages.

The final configuration continues after packages are installed. If you end up
not selecting any packages, and wish to return to the final configuration,
select Install anyways.

3.10.11.Â Add Users/Groups

You should add at least one user during the installation so that you can use
the system without being logged in as root. The root partition is generally
small and running applications as root can quickly fill it. A bigger danger is
noted below:

User Confirmation Requested Would you like to add any initial user accounts to
the system? Adding at least one account for yourself at this stage is suggested
since working as the "root" user is dangerous (it is easy to do things which
adversely affect the entire system). [ Yes ] No

Select [Â YesÂ ] and press Enter to continue with adding a user.

FigureÂ 3.51.Â Select User
Select User


Select User with the arrow keys and press Enter.

FigureÂ 3.52.Â Add User Information
Add User Information


The following descriptions will appear in the lower part of the screen as the
items are selected with Tab to assist with entering the required information:

Login ID

    The login name of the new user (mandatory).

UID

    The numerical ID for this user (leave blank for automatic choice).

Group

    The login group name for this user (leave blank for automatic choice).

Password

    The password for this user (enter this field with care!).

Full name

    The user's full name (comment).

Member groups

    The groups this user belongs to (i.e., gets access rights for).

Home directory

    The user's home directory (leave blank for default).

Login shell

    The user's login shell (leave blank for default, e.g., /bin/sh).

The login shell was changed from /bin/sh to /usr/local/bin/bash to use the bash
shell that was previously installed as a package. Do not try to use a shell
that does not exist or you will not be able to login. The most common shell
used in the BSD-world is the C shell, which can be indicated as /bin/tcsh.

The user was also added to the wheel group to be able to become a superuser
with root privileges.

When you are satisfied, press [Â OKÂ ] and the User and Group Management menu
will redisplay:

FigureÂ 3.53.Â Exit User and Group Management
Exit User and Group Management


Groups can also be added at this time if specific needs are known. Otherwise,
this may be accessed through using sysinstall after installation is completed.

When you are finished adding users, select Exit with the arrow keys and press 
Enter to continue the installation.

3.10.12.Â Set the root Password

Message Now you must set the system manager's password. This is the password
you'll use to log in as "root". [ OK ] [ Press enter or space ]

Press Enter to set the root password.

The password will need to be typed in twice correctly. Needless to say, make
sure you have a way of finding the password if you forget. Notice that the
password you type in is not echoed, nor are asterisks displayed.

New password: Retype new password :

The installation will continue after the password is successfully entered.

3.10.13.Â Exiting Install

If you need to configure additional network services or any other
configuration, you can do it at this point or after installation with
sysinstall.

User Confirmation Requested Visit the general configuration menu for a chance
to set any last options? Yes [ No ]

Select [Â NoÂ ] with the arrow keys and press Enter to return to the Main
Installation Menu.

FigureÂ 3.54.Â Exit Install
Exit Install


Select [X Exit Install] with the arrow keys and press Enter. You will be asked
to confirm exiting the installation:

User Confirmation Requested Are you sure you wish to exit? The system will
reboot. [ Yes ] No

Select [Â YesÂ ]. If you are booting from the CDROM drive the following message
will remind you to remove the disk:

Message Be sure to remove the media from the drive. [ OK ] [ Press enter or
space ]

The CDROM drive is locked until the machine starts to reboot then the disk can
be removed from drive (quickly). Press [Â OKÂ ] to reboot.

The system will reboot so watch for any error messages that may appear, see
SectionÂ 3.10.15, â  FreeBSD Bootupâ   for more details.

3.10.14.Â Configure Additional Network Services

Contributed by Tom Rhodes.

Configuring network services can be a daunting task for new users if they lack
previous knowledge in this area. Networking, including the Internet, is
critical to all modern operating systems including FreeBSD; as a result, it is
very useful to have some understanding FreeBSD's extensive networking
capabilities. Doing this during the installation will ensure users have some
understanding of the various services available to them.

Network services are programs that accept input from anywhere on the network.
Every effort is made to make sure these programs will not do anything â  
harmfulâ  . Unfortunately, programmers are not perfect and through time there
have been cases where bugs in network services have been exploited by attackers
to do bad things. It is important that you only enable the network services you
know that you need. If in doubt it is best if you do not enable a network
service until you find out that you do need it. You can always enable it later
by re-running sysinstall or by using the features provided by the /etc/rc.conf
file.

Selecting the Networking option will display a menu similar to the one below:

FigureÂ 3.55.Â Network Configuration Upper-level
Network Configuration Upper-level


The first option, Interfaces, was previously covered during the
SectionÂ 3.10.1, â  Network Device Configurationâ  , thus this option can
safely be ignored.

Selecting the AMD option adds support for the BSD automatic mount utility. This
is usually used in conjunction with the NFS protocol (see below) for
automatically mounting remote file systems. No special configuration is
required here.

Next in line is the AMD Flags option. When selected, a menu will pop up for you
to enter specific AMD flags. The menu already contains a set of default
options:

-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map

The -a option sets the default mount location which is specified here as
/.amd_mnt. The -l option specifies the default log file; however, when syslogd
is used all log activity will be sent to the system log daemon. The /host
directory is used to mount an exported file system from a remote host, while /
net directory is used to mount an exported file system from an IP address. The
/etc/amd.map file defines the default options for AMD exports.

The Anon FTP option permits anonymous FTP connections. Select this option to
make this machine an anonymous FTP server. Be aware of the security risks
involved with this option. Another menu will be displayed to explain the
security risks and configuration in depth.

The Gateway configuration menu will set the machine up to be a gateway as
explained previously. This can be used to unset the Gateway option if you
accidentally selected it during the installation process.

The Inetd option can be used to configure or completely disable the inetd(8)
daemon as discussed above.

The Mail option is used to configure the system's default MTA or Mail Transfer
Agent. Selecting this option will bring up the following menu:

FigureÂ 3.56.Â Select a Default MTA
Select a Default MTA


Here you are offered a choice as to which MTA to install and set as the
default. An MTA is nothing more than a mail server which delivers email to
users on the system or the Internet.

Selecting Sendmail will install the popular sendmail server which is the
FreeBSD default. The Sendmail local option will set sendmail to be the default 
MTA, but disable its ability to receive incoming email from the Internet. The
other options here, Postfix and Exim act similar to Sendmail. They both deliver
email; however, some users prefer these alternatives to the sendmail MTA.

After selecting an MTA, or choosing not to select an MTA, the network
configuration menu will appear with the next option being NFS client.

The NFS client option will configure the system to communicate with a server
via NFS. An NFS server makes file systems available to other machines on the
network via the NFS protocol. If this is a stand-alone machine, this option can
remain unselected. The system may require more configuration later; see
SectionÂ 30.3, â  Network File System (NFS)â   for more information about
client and server configuration.

Below that option is the NFS server option, permitting you to set the system up
as an NFS server. This adds the required information to start up the RPC remote
procedure call services. RPC is used to coordinate connections between hosts
and programs.

Next in line is the Ntpdate option, which deals with time synchronization. When
selected, a menu like the one below shows up:

FigureÂ 3.57.Â Ntpdate Configuration
Ntpdate Configuration


From this menu, select the server which is the closest to your location.
Selecting a close one will make the time synchronization more accurate as a
server further from your location may have more connection latency.

The next option is the PCNFSD selection. This option will install the net/
pcnfsd package from the Ports Collection. This is a useful utility which
provides NFS authentication services for systems which are unable to provide
their own, such as Microsoft's MS-DOSÂ® operating system.

Now you must scroll down a bit to see the other options:

FigureÂ 3.58.Â Network Configuration Lower-level
Network Configuration Lower-level


The rpcbind(8), rpc.statd(8), and rpc.lockd(8) utilities are all used for
Remote Procedure Calls (RPC). The rpcbind utility manages communication between
NFS servers and clients, and is required for NFS servers to operate correctly.
The rpc.statd daemon interacts with the rpc.statd daemon on other hosts to
provide status monitoring. The reported status is usually held in the /var/db/
statd.status file. The next option listed here is the rpc.lockd option, which,
when selected, will provide file locking services. This is usually used with 
rpc.statd to monitor what hosts are requesting locks and how frequently they
request them. While these last two options are marvelous for debugging, they
are not required for NFS servers and clients to operate correctly.

As you progress down the list the next item here is Routed, which is the
routing daemon. The routed(8) utility manages network routing tables, discovers
multicast routers, and supplies a copy of the routing tables to any physically
connected host on the network upon request. This is mainly used for machines
which act as a gateway for the local network. When selected, a menu will be
presented requesting the default location of the utility. The default location
is already defined for you and can be selected with the Enter key. You will
then be presented with yet another menu, this time asking for the flags you
wish to pass on to routed. The default is -q and it should already appear on
the screen.

Next in line is the Rwhod option which, when selected, will start the rwhod(8)
daemon during system initialization. The rwhod utility broadcasts system
messages across the network periodically, or collects them when in â  consumerâ
   mode. More information can be found in the ruptime(1) and rwho(1) manual
pages.

The next to the last option in the list is for the sshd(8) daemon. This is the
secure shell server for OpenSSH and it is highly recommended over the standard 
telnet and FTP servers. The sshd server is used to create a secure connection
from one host to another by using encrypted connections.

Finally there is the TCP Extensions option. This enables the TCP Extensions
defined in RFCÂ 1323 and RFCÂ 1644. While on many hosts this can speed up
connections, it can also cause some connections to be dropped. It is not
recommended for servers, but may be beneficial for stand alone machines.

Now that you have configured the network services, you can scroll up to the
very top item which is X Exit and continue on to the next configuration item or
simply exit sysinstall in selecting X Exit twice then [X Exit Install].

3.10.15.Â FreeBSD Bootup

3.10.15.1.Â FreeBSD/i386 Bootup

If everything went well, you will see messages scroll off the screen and you
will arrive at a login prompt. You can view the content of the messages by
pressing Scroll-Lock and using PgUp and PgDn. Pressing Scroll-Lock again will
return to the prompt.

The entire message may not display (buffer limitation) but it can be viewed
from the command line after logging in by typing dmesg at the prompt.

Login using the username/password you set during installation (rpratt, in this
example). Avoid logging in as root except when necessary.

Typical boot messages (version information omitted):

Copyright (c) 1992-2002 The FreeBSD Project. Copyright (c) 1979, 1980, 1983,
1986, 1988, 1989, 1991, 1992, 1993, 1994 The Regents of the University of
California. All rights reserved. Timecounter "i8254" frequency 1193182 Hz CPU:
AMD-K6(tm) 3D processor (300.68-MHz 586-class CPU) Origin = "AuthenticAMD" Id =
0x580 Stepping = 0 Features=0x8001bf&lt;FPU,VME,DE,PSE,TSC,MSR,MCE,CX8,MMX&gt; AMD
Features=0x80000800&lt;SYSCALL,3DNow!&gt; real memory = 268435456 (262144K bytes)
config&gt; di sn0 config&gt; di lnc0 config&gt; di le0 config&gt; di ie0 config&gt; di fe0
config&gt; di cs0 config&gt; di bt0 config&gt; di aic0 config&gt; di aha0 config&gt; di adv0
config&gt; q avail memory = 256311296 (250304K bytes) Preloaded elf kernel
"kernel" at 0xc0491000. Preloaded userconfig_script "/boot/kernel.conf" at
0xc049109c. md0: Malloc disk Using $PIR table, 4 entries at 0xc00fde60 npx0:
&lt;math processor&gt; on motherboard npx0: INT 16 interface pcib0: &lt;Host to PCI
bridge&gt; on motherboard pci0: &lt;PCI bus&gt; on pcib0 pcib1: &lt;VIA 82C598MVP (Apollo
MVP3) PCI-PCI (AGP) bridge&gt; at device 1.0 on pci0 pci1: &lt;PCI bus&gt; on pcib1
pci1: &lt;Matrox MGA G200 AGP graphics accelerator&gt; at 0.0 irq 11 isab0: &lt;VIA
82C586 PCI-ISA bridge&gt; at device 7.0 on pci0 isa0: &lt;ISA bus&gt; on isab0 atapci0:
&lt;VIA 82C586 ATA33 controller&gt; port 0xe000-0xe00f at device 7.1 on pci0 ata0: at
0x1f0 irq 14 on atapci0 ata1: at 0x170 irq 15 on atapci0 uhci0: &lt;VIA 83C572 USB
controller&gt; port 0xe400-0xe41f irq 10 at device 7.2 on pci0 usb0: &lt;VIA 83C572
USB controller&gt; on uhci0 usb0: USB revision 1.0 uhub0: VIA UHCI root hub, class
9/0, rev 1.00/1.00, addr 1 uhub0: 2 ports with 2 removable, self powered chip1:
&lt;VIA 82C586B ACPI interface&gt; at device 7.3 on pci0 ed0: &lt;NE2000 PCI Ethernet
(RealTek 8029)&gt; port 0xe800-0xe81f irq 9 at device 10.0 on pci0 ed0: address
52:54:05:de:73:1b, type NE2000 (16 bit) isa0: too many dependant configs (8)
isa0: unexpected small tag 14 fdc0: &lt;NEC 72065B or clone&gt; at port
0x3f0-0x3f5,0x3f7 irq 6 drq 2 on isa0 fdc0: FIFO enabled, 8 bytes threshold
fd0: &lt;1440-KB 3.5" drive&gt; on fdc0 drive 0 atkbdc0: &lt;keyboard controller
(i8042)&gt; at port 0x60-0x64 on isa0 atkbd0: &lt;AT Keyboard&gt; flags 0x1 irq 1 on
atkbdc0 kbd0 at atkbd0 psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0 psm0: model Generic
PS/2 mouse, device ID 0 vga0: &lt;Generic ISA VGA&gt; at port 0x3c0-0x3df iomem
0xa0000-0xbffff on isa0 sc0: &lt;System console&gt; at flags 0x1 on isa0 sc0: VGA &lt;16
virtual consoles, flags=0x300&gt; sio0 at port 0x3f8-0x3ff irq 4 flags 0x10 on
isa0 sio0: type 16550A sio1 at port 0x2f8-0x2ff irq 3 on isa0 sio1: type 16550A
ppc0: &lt;Parallel port&gt; at port 0x378-0x37f irq 7 on isa0 ppc0: SMC-like chipset
(ECP/EPP/PS2/NIBBLE) in COMPATIBLE mode ppc0: FIFO with 16/16/15 bytes
threshold ppbus0: IEEE1284 device found /NIBBLE Probing for PnP devices on
ppbus0: plip0: &lt;PLIP network interface&gt; on ppbus0 lpt0: &lt;Printer&gt; on ppbus0
lpt0: Interrupt-driven port ppi0: &lt;Parallel I/O&gt; on ppbus0 ad0: 8063MB
&lt;IBM-DHEA-38451&gt; [16383/16/63] at ata0-master using UDMA33 ad2: 8063MB
&lt;IBM-DHEA-38451&gt; [16383/16/63] at ata1-master using UDMA33 acd0: CDROM &lt;DELTA
OTC-H101/ST3 F/W by OIPD&gt; at ata0-slave using PIO4 Mounting root from ufs:/dev/
ad0s1a swapon: adding /dev/ad0s1b as swap device Automatic boot in progress...
/dev/ad0s1a: FILESYSTEM CLEAN; SKIPPING CHECKS /dev/ad0s1a: clean, 48752 free
(552 frags, 6025 blocks, 0.9% fragmentation) /dev/ad0s1f: FILESYSTEM CLEAN;
SKIPPING CHECKS /dev/ad0s1f: clean, 128997 free (21 frags, 16122 blocks, 0.0%
fragmentation) /dev/ad0s1g: FILESYSTEM CLEAN; SKIPPING CHECKS /dev/ad0s1g:
clean, 3036299 free (43175 frags, 374073 blocks, 1.3% fragmentation) /dev/
ad0s1e: filesystem CLEAN; SKIPPING CHECKS /dev/ad0s1e: clean, 128193 free (17
frags, 16022 blocks, 0.0% fragmentation) Doing initial network setup: hostname.
ed0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 inet
192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255 inet6
fe80::5054::5ff::fede:731b%ed0 prefixlen 64 tentative scopeid 0x1 ether
52:54:05:de:73:1b lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; mtu 16384
inet6 fe80::1%lo0 prefixlen 64 scopeid 0x8 inet6 ::1 prefixlen 128 inet
127.0.0.1 netmask 0xff000000 Additional routing options: IP gateway=YES TCP
keepalive=YES routing daemons:. additional daemons: syslogd. Doing additional
network setup:. Starting final network daemons: creating ssh RSA host key
Generating public/private rsa1 key pair. Your identification has been saved in
/etc/ssh/ssh_host_key. Your public key has been saved in /etc/ssh/
ssh_host_key.pub. The key fingerprint is:
cd:76:89:16:69:0e:d0:6e:f8:66:d0:07:26:3c:7e:2d root@k6-2.example.com creating
ssh DSA host key Generating public/private dsa key pair. Your identification
has been saved in /etc/ssh/ssh_host_dsa_key. Your public key has been saved in
/etc/ssh/ssh_host_dsa_key.pub. The key fingerprint is:
f9:a1:a9:47:c4:ad:f9:8d:52:b8:b8:ff:8c:ad:2d:e6 root@k6-2.example.com. setting
ELF ldconfig path: /usr/lib /usr/lib/compat /usr/X11R6/lib /usr/local/lib a.out
ldconfig path: /usr/lib/aout /usr/lib/compat/aout /usr/X11R6/lib/aout starting
standard daemons: inetd cron sshd usbd sendmail. Initial rc.i386
initialization:. rc.i386 configuring syscons: blank_time screensaver moused.
Additional ABI support: linux. Local package initialization:. Additional TCP
options:. FreeBSD/i386 (k6-2.example.com) (ttyv0) login: rpratt Password:

Generating the RSA and DSA keys may take some time on slower machines. This
happens only on the initial boot-up of a new installation. Subsequent boots
will be faster.

If the X server has been configured and a Default Desktop chosen, it can be
started by typing startx at the command line.

3.10.16.Â FreeBSD Shutdown

It is important to properly shutdown the operating system. Do not just turn off
power. First, become a superuser by typing su at the command line and entering
the root password. This will work only if the user is a member of the wheel
group. Otherwise, login as root and use shutdown -h now.

The operating system has halted. Please press any key to reboot.

It is safe to turn off the power after the shutdown command has been issued and
the message â  Please press any key to rebootâ   appears. If any key is pressed
instead of turning off the power switch, the system will reboot.

You could also use the Ctrl+Alt+Del key combination to reboot the system,
however this is not recommended during normal operation.

3.11.Â Troubleshooting

The following section covers basic installation troubleshooting, such as common
problems people have reported. There are also a few questions and answers for
people wishing to dual-boot FreeBSD with MS-DOSÂ® or WindowsÂ®.

3.11.1.Â What to Do If Something Goes Wrong

Due to various limitations of the PC architecture, it is impossible for probing
to be 100% reliable, however, there are a few things you can do if it fails.

Check the Hardware Notes document for your version of FreeBSD to make sure your
hardware is supported.

If your hardware is supported and you still experience lock-ups or other
problems, you will need to build a custom kernel. This will allow you to add in
support for devices which are not present in the GENERIC kernel. The kernel on
the boot disks is configured assuming that most hardware devices are in their
factory default configuration in terms of IRQs, IO addresses, and DMA channels.
If your hardware has been reconfigured, you will most likely need to edit the
kernel configuration and recompile to tell FreeBSD where to find things.

It is also possible that a probe for a device not present will cause a later
probe for another device that is present to fail. In that case, the probes for
the conflicting driver(s) should be disabled.

Note:

Some installation problems can be avoided or alleviated by updating the
firmware on various hardware components, most notably the motherboard. The
motherboard firmware may also be referred to as BIOS and most of the
motherboard or computer manufactures have a website where the upgrades and
upgrade information may be located.

Most manufacturers strongly advise against upgrading the motherboard BIOS
unless there is a good reason for doing so, which could possibly be a critical
update of sorts. The upgrade process can go wrong, causing permanent damage to
the BIOS chip.

3.11.2.Â Using MS-DOSÂ® and WindowsÂ® File Systems

At this time, FreeBSD does not support file systems compressed with the Double
Spaceâ ¢ application. Therefore the file system will need to be uncompressed
before FreeBSD can access the data. This can be done by running the Compression
Agent located in the Start&gt; Programs &gt; System Tools menu.

FreeBSD can support MS-DOSÂ® file systems (sometimes called FAT file systems).
The mount_msdosfs(8) command grafts such file systems onto the existing
directory hierarchy, allowing the file system's contents to be accessed. The
mount_msdosfs(8) program is not usually invoked directly; instead, it is called
by the system through a line in /etc/fstab or by a call to the mount(8) utility
with the appropriate parameters.

A typical line in /etc/fstab is:

/dev/ad0sN /dos msdosfs rw 0 0

Note:

The /dos directory must already exist for this to work. For details about the
format of /etc/fstab, see fstab(5).

A typical call to mount(8) for a MS-DOSÂ® file system looks like:

# mount -t msdosfs /dev/ad0s1 /mnt

In this example, the MS-DOSÂ® file system is located on the first partition of
the primary hard disk. Your situation may be different, check the output from
the dmesg, and mount commands. They should produce enough information to give
an idea of the partition layout.

Note:

FreeBSD may number disk slices (that is, MS-DOSÂ® partitions) differently than
other operating systems. In particular, extended MS-DOSÂ® partitions are
usually given higher slice numbers than primary MS-DOSÂ® partitions. The fdisk
(8) utility can help determine which slices belong to FreeBSD and which belong
to other operating systems.

NTFS partitions can also be mounted in a similar manner using the mount_ntfs(8)
command.

3.11.3.Â Troubleshooting Questions and Answers

3.11.3.1. My system hangs while probing hardware during boot, or it behaves
    strangely during install, or the floppy drive is not probed.
3.11.3.2. I go to boot from the hard disk for the first time after installing
    FreeBSD, the kernel loads and probes my hardware, but stops with messages
    like:
3.11.3.3. I go to boot from the hard disk for the first time after installing
    FreeBSD, but the Boot Manager prompt just prints F? at the boot menu each
    time but the boot will not go any further.
3.11.3.4. The system finds my ed(4) network card, but I keep getting device
    timeout errors.
3.11.3.5.  

3.11.3.1. My system hangs while probing hardware during boot, or it behaves
          strangely during install, or the floppy drive is not probed.

          FreeBSD makes extensive use of the system ACPI service on the i386,
          amd64 and ia64 platforms to aid in system configuration if it is
          detected during boot. Unfortunately, some bugs still exist in both
          the ACPI driver and within system motherboards and BIOS. The use of
          ACPI can be disabled by setting the hint.acpi.0.disabled hint in the
          third stage boot loader:

          set hint.acpi.0.disabled="1"

          This is reset each time the system is booted, so it is necessary to
          add hint.acpi.0.disabled="1" to the file /boot/loader.conf. More
          information about the boot loader can be found in SectionÂ 13.1, â  
          Synopsisâ  .

3.11.3.2. I go to boot from the hard disk for the first time after installing
          FreeBSD, the kernel loads and probes my hardware, but stops with
          messages like:

          changing root device to ad1s1a panic: cannot mount root

          What is wrong? What can I do?

          What is this bios_drive:interface(unit,partition)kernel_name thing
          that is displayed with the boot help?

          There is a longstanding problem in the case where the boot disk is
          not the first disk in the system. The BIOS uses a different numbering
          scheme to FreeBSD, and working out which numbers correspond to which
          is difficult to get right.

          In the case where the boot disk is not the first disk in the system,
          FreeBSD can need some help finding it. There are two common
          situations here, and in both of these cases, you need to tell FreeBSD
          where the root filesystem is. You do this by specifying the BIOS disk
          number, the disk type and the FreeBSD disk number for that type.

          The first situation is where you have two IDE disks, each configured
          as the master on their respective IDE busses, and wish to boot
          FreeBSD from the second disk. The BIOS sees these as disk 0 and disk
          1, while FreeBSD sees them as ad0 and ad2.

          FreeBSD is on BIOS disk 1, of type ad and the FreeBSD disk number is
          2, so you would say:

          1:ad(2,a)kernel

          Note that if you have a slave on the primary bus, the above is not
          necessary (and is effectively wrong).

          The second situation involves booting from a SCSI disk when you have
          one or more IDE disks in the system. In this case, the FreeBSD disk
          number is lower than the BIOS disk number. If you have two IDE disks
          as well as the SCSI disk, the SCSI disk is BIOS disk 2, type da and
          FreeBSD disk number 0, so you would say:

          2:da(0,a)kernel

          To tell FreeBSD that you want to boot from BIOS disk 2, which is the
          first SCSI disk in the system. If you only had one IDE disk, you
          would use 1: instead.

          Once you have determined the correct values to use, you can put the
          command exactly as you would have typed it in the /boot.config file
          using a standard text editor. Unless instructed otherwise, FreeBSD
          will use the contents of this file as the default response to the
          boot: prompt.

3.11.3.3. I go to boot from the hard disk for the first time after installing
          FreeBSD, but the Boot Manager prompt just prints F? at the boot menu
          each time but the boot will not go any further.

          The hard disk geometry was set incorrectly in the partition editor
          when you installed FreeBSD. Go back into the partition editor and
          specify the actual geometry of your hard disk. You must reinstall
          FreeBSD again from the beginning with the correct geometry.

          If you are failing entirely in figuring out the correct geometry for
          your machine, here is a tip: Install a small MS-DOSÂ® partition at
          the beginning of the disk and install FreeBSD after that. The install
          program will see the MS-DOSÂ® partition and try to infer the correct
          geometry from it, which usually works.

          The following tip is no longer recommended, but is left here for
          reference:

              If you are setting up a truly dedicated FreeBSD server or
              workstation where you do not care for (future) compatibility with
              MS-DOSÂ®, Linux or another operating system, you also have got
              the option to use the entire disk (A in the partition editor),
              selecting the non-standard option where FreeBSD occupies the
              entire disk from the very first to the very last sector. This
              will leave all geometry considerations aside, but is somewhat
              limiting unless you're never going to run anything other than
              FreeBSD on a disk.

3.11.3.4. The system finds my ed(4) network card, but I keep getting device
          timeout errors.

          Your card is probably on a different IRQ from what is specified in
          the /boot/device.hints file. The ed(4) driver does not use the â  
          softâ   configuration by default (values entered using EZSETUP in 
          MS-DOSÂ®), but it will use the software configuration if you specify
          -1 in the hints for the interface.

          Either move the jumper on the card to a hard configuration setting
          (altering the kernel settings if necessary), or specify the IRQ as -1
          by setting the hint hint.ed.0.irq="-1". This will tell the kernel to
          use the soft configuration.

          Another possibility is that your card is at IRQ 9, which is shared by
          IRQ 2 and frequently a cause of problems (especially when you have a
          VGA card using IRQ 2!). You should not use IRQ 2 or 9 if at all
          possible.

3.11.3.5. When sysinstall is used in an X11 terminal, the yellow font is
          difficult to read against the light gray background. Is there a way
          to provide higher contrast for this application?

          If you already have X11 installed and the default colors chosen by 
          sysinstall make text illegible while using xterm(1) or rxvt(1), add
          the following to your ~/.Xdefaults to get a darker background gray:
          XTerm*color7: #c0c0c0

3.12.Â Advanced Installation Guide

Contributed by Valentino Vaschetto.
Updated by Marc Fonvieille.

This section describes how to install FreeBSD in exceptional cases.

3.12.1.Â Installing FreeBSD on a System Without a Monitor or Keyboard

This type of installation is called a â  headless installâ  , because the
machine that you are trying to install FreeBSD on either does not have a
monitor attached to it, or does not even have a VGA output. How is this
possible you ask? Using a serial console. A serial console is basically using
another machine to act as the main display and keyboard for a system. To do
this, just follow the steps to create an installation USB memstick, explained
in SectionÂ 3.3.7, â  Prepare the Boot Mediaâ   or download the correct
installation ISO image, see SectionÂ 3.13.1, â  Creating an Installation CDROMâ
  .

To modify these media to boot into a serial console, follow these steps (If you
want to use a CDROM you can skip the first step):

 1. Enabling the Installation USB Stick to Boot into a Serial Console

    If you were to boot into the USB stick that you just made, FreeBSD would
    boot into its normal install mode. We want FreeBSD to boot into a serial
    console for our install. To do this, you have to mount the USB disk onto
    your FreeBSD system using the mount(8) command.

    # mount /dev/da0a /mnt

    Note:

    Adapt the device node and the mount point to your situation.

    Now that you have the stick mounted, you must set the USB stick to boot
    into a serial console. You have to add to the loader.conf file of the USB
    stick file system a line setting the serial console as the system console:

    # echo 'console="comconsole"' &gt;&gt; /mnt/boot/loader.conf

    Now that you have your USB stick configured correctly, you must unmount the
    disk using the umount(8) command:

    # umount /mnt

    Now you can unplug the USB stick and jump directly to the third step of
    this procedure.

 2. Enabling the Installation CD to Boot into a Serial Console

    If you were to boot into the CD that you just made from the installation
    ISO image (see SectionÂ 3.13.1, â  Creating an Installation CDROMâ  ),
    FreeBSD would boot into its normal install mode. We want FreeBSD to boot
    into a serial console for our install. To do this, you have to extract,
    modify and regenerate the ISO image before burning it on a CD-R media.

    From the FreeBSD system where is saved the installation ISO image, for
    example FreeBSD-9.1-RELEASE-i386-disc1.iso, use the tar(1) utility to
    extract all the files:

    # mkdir /path/to/headless-iso # tar -C /path/to/headless-iso -pxvf FreeBSD-
    9.1-RELEASE-i386-disc1.iso

    Now you must set the installation media to boot into a serial console. You
    have to add to the loader.conf file from the extracted ISO image a line
    setting the serial console as the system console:

    # echo 'console="comconsole"' &gt;&gt; /path/to/headless-iso/boot/loader.conf

    Then we can create a new ISO image from the modified tree. The mkisofs(8)
    tool from the sysutils/cdrtools port is used:

    # mkisofs -v -b boot/cdboot -no-emul-boot -r -J -V "Headless_install" \ -o
    Headless-FreeBSD-9.1-RELEASE-i386-disc1.iso /path/to/headless-iso

    Now that you have your ISO image configured correctly, you can burn it on a
    CD-R with your favorite burning application.

 3. Connecting Your Null-modem Cable

    You now need to connect a null-modem cable between the two machines. Just
    connect the cable to the serial ports of the 2 machines. A normal serial
    cable will not work here, you need a null-modem cable because it has some
    of the wires inside crossed over.

 4. Booting Up for the Install

    It is now time to go ahead and start the install. Plug in the USB memstick
    on the machine you are doing the headless install on, and power on the
    machine. If you are using a prepared CDROM, power on the machine and insert
    the disk to boot on.

 5. Connecting to Your Headless Machine

    Now you have to connect to that machine with cu(1):

    # cu -l /dev/cuau0

That's it! You should now be able to control the headless machine through your
cu session. It will load the kernel and then it will come up with a selection
of what kind of terminal to use. Select the FreeBSD color console and proceed
with your install!

3.13.Â Preparing Your Own Installation Media

Note:

To prevent repetition, â  FreeBSD discâ   in this context means a FreeBSD CDROM
or DVD that you have purchased or produced yourself.

There may be some situations in which you need to create your own FreeBSD
installation media and/or source. This might be physical media, such as a tape,
or a source that sysinstall can use to retrieve the files, such as a local FTP
site, or an MS-DOSÂ® partition.

For example:

  * You have many machines connected to your local network, and one FreeBSD
    disc. You want to create a local FTP site using the contents of the FreeBSD
    disc, and then have your machines use this local FTP site instead of
    needing to connect to the Internet.

  * You have a FreeBSD disc, and FreeBSD does not recognize your CD/DVD drive,
    but MS-DOSÂ® / WindowsÂ® does. You want to copy the FreeBSD installation
    files to a MS-DOSÂ® partition on the same computer, and then install
    FreeBSD using those files.

  * The computer you want to install on does not have a CD/DVD drive or a
    network card, but you can connect a â  Laplink-styleâ   serial or parallel
    cable to a computer that does.

  * You want to create a tape that can be used to install FreeBSD.

3.13.1.Â Creating an Installation CDROM

As part of each release, the FreeBSD project makes available at least two CDROM
images (â  ISO imagesâ  ) per supported architecture. These images can be
written (â  burnedâ  ) to CDs if you have a CD writer, and then used to install
FreeBSD. If you have a CD writer, and bandwidth is cheap, then this is the
easiest way to install FreeBSD.

 1. Download the Correct ISO Images

    The ISO images for each release can be downloaded from ftp://
    ftp.FreeBSD.org/pub/FreeBSD/ISO-IMAGES-arch/version or the closest mirror.
    Substitute arch and version as appropriate.

    That directory will normally contain the following images:

    TableÂ 3.4.Â FreeBSD ISO Image Names and Meanings

                    Filename                              Contents
                                              This CD image allows you to start
                                              the installation process by
                                              booting from a CD-ROM drive but
                                              it does not contain the support
    FreeBSD-version-RELEASE-arch-bootonly.iso for installing FreeBSD from the
                                              CD itself. You would need to
                                              perform a network based install
                                              (e.g. from an FTP server) after
                                              booting from this CD.
                                              This DVD image contains
                                              everything necessary to install
                                              the base FreeBSD operating
    FreeBSD-version-RELEASE-arch-dvd1.iso.gz  system, a collection of pre-built
                                              packages, and the documentation.
                                              It also supports booting into a â
                                                livefsâ   based rescue mode.
                                              This image can be written to an
                                              USB memory stick and used to do
                                              an install on machines capable of
    FreeBSD-version-RELEASE-arch-memstick.img booting off USB drives. It also
                                              supports booting into a â  livefs
                                              â   based rescue mode. The
                                              documentation packages are
                                              provided but no other packages.
                                              This CD image contains the base
    FreeBSD-version-RELEASE-arch-disc1.iso    FreeBSD operating system and the
                                              documentation packages but no
                                              other packages.
                                              A CD image with as many
    FreeBSD-version-RELEASE-arch-disc2.iso    third-party packages as would fit
                                              on the disc. This image is not
                                              available for FreeBSDÂ 9.X.
                                              Another CD image with as many
    FreeBSD-version-RELEASE-arch-disc3.iso    third-party packages as would fit
                                              on the disc. This image is not
                                              available for FreeBSDÂ 9.X.
                                              This CD image contains support
                                              for booting into a â  livefsâ  
    FreeBSD-version-RELEASE-arch-livefs.iso   based rescue mode but does not
                                              support doing an install from the
                                              CD itself.


    You must download one of either the bootonly ISO image, or the image of
    disc1. Do not download both of them, since the disc1 image contains
    everything that the bootonly ISO image contains.

    Use the bootonly ISO if Internet access is cheap for you. It will let you
    install FreeBSD, and you can then install third-party packages by
    downloading them using the ports/packages system (see ChapterÂ 5, 
    Installing Applications: Packages and Ports) as necessary.

    Use the image of dvd1 if you want to install a FreeBSD release and want a
    reasonable selection of third-party packages on the disc as well.

    The additional disc images are useful, but not essential, especially if you
    have high-speed access to the Internet.

 2. Write the CDs

    You must then write the CD images to disc. If you will be doing this on
    another FreeBSD system then see SectionÂ 19.6, â  Creating and Using CD
    Mediaâ   for more information (in particular, SectionÂ 19.6.3, â  burncdâ  
    and SectionÂ 19.6.4, â  cdrecordâ  ).

    If you will be doing this on another platform then you will need to use
    whatever utilities exist to control your CD writer on that platform. The
    images provided are in the standard ISO format, which many CD writing
    applications support.

Note:

If you are interested in building a customized release of FreeBSD, please see
the Release Engineering Article.

3.13.2.Â Creating a Local FTP Site with a FreeBSD Disc

FreeBSD discs are laid out in the same way as the FTP site. This makes it very
easy for you to create a local FTP site that can be used by other machines on
your network when installing FreeBSD.

 1. On the FreeBSD computer that will host the FTP site, ensure that the CDROM
    is in the drive, and mounted on /cdrom.

    # mount /cdrom
 2. Create an account for anonymous FTP in /etc/passwd. Do this by editing /etc
    /passwd using vipw(8) and adding this line:

    ftp:*:99:99::0:0:FTP:/cdrom:/nonexistent
 3. Ensure that the FTP service is enabled in /etc/inetd.conf.

Anyone with network connectivity to your machine can now chose a media type of
FTP and type in ftp://your machine after picking â  Otherâ   in the FTP sites
menu during the install.

Note:

If the boot media (floppy disks, usually) for your FTP clients is not precisely
the same version as that provided by the local FTP site, then sysinstall will
not let you complete the installation. If the versions are not similar and you
want to override this, you must go into the Options menu and change
distribution name to any.

Warning:

This approach is OK for a machine that is on your local network, and that is
protected by your firewall. Offering up FTP services to other machines over the
Internet (and not your local network) exposes your computer to the attention of
crackers and other undesirables. We strongly recommend that you follow good
security practices if you do this.

3.13.3.Â Creating Installation Floppies

If you must install from floppy disk (which we suggest you do not do), either
due to unsupported hardware or simply because you insist on doing things the
hard way, you must first prepare some floppies for the installation.

At a minimum, you will need as many 1.44Â MB floppies as it takes to hold all
the files in the base (base distribution) directory. If you are preparing the
floppies from MS-DOSÂ®, then they must be formatted using the MS-DOSÂ® FORMAT
command. If you are using WindowsÂ®, use Explorer to format the disks
(right-click on the A: drive, and select â  Formatâ  ).

Do not trust factory pre-formatted floppies. Format them again yourself, just
to be sure. Many problems reported by our users in the past have resulted from
the use of improperly formatted media, which is why we are making a point of it
now.

If you are creating the floppies on another FreeBSD machine, a format is still
not a bad idea, though you do not need to put a MS-DOSÂ® filesystem on each
floppy. You can use the bsdlabel and newfs commands to put a UFS filesystem on
them instead, as the following sequence of commands (for a 3.5" 1.44Â MB
floppy) illustrates:

# fdformat -f 1440 fd0.1440 # bsdlabel -w fd0.1440 floppy3 # newfs -t 2 -u 18
-l 1 -i 65536 /dev/fd0

Then you can mount and write to them like any other filesystem.

After you have formatted the floppies, you will need to copy the files to them.
The distribution files are split into chunks conveniently sized so that five of
them will fit on a conventional 1.44Â MB floppy. Go through all your floppies,
packing as many files as will fit on each one, until you have all of the
distributions you want packed up in this fashion. Each distribution should go
into a subdirectory on the floppy, e.g.: a:\base\base.aa, a:\base\base.ab, and
so on.

Important:

The base.inf file also needs to go on the first floppy of the base set since it
is read by the installation program in order to figure out how many additional
pieces to look for when fetching and concatenating the distribution.

Once you come to the Media screen during the install process, select Floppy and
you will be prompted for the rest.

3.13.4.Â Installing from an MS-DOSÂ® Partition

To prepare for an installation from an MS-DOSÂ® partition, copy the files from
the distribution into a directory called freebsd in the root directory of the
partition. For example, c:\freebsd. The directory structure of the CDROM or FTP
site must be partially reproduced within this directory, so we suggest using
the MS-DOSÂ® xcopy command if you are copying it from a CD. For example, to
prepare for a minimal installation of FreeBSD:

C:\&gt; md c:\freebsd C:\&gt; xcopy e:\bin c:\freebsd\bin\ /s C:\&gt; xcopy e:\manpages
c:\freebsd\manpages\ /s

Assuming that C: is where you have free space and E: is where your CDROM is
mounted.

If you do not have a CDROM drive, you can download the distribution from
ftp.FreeBSD.org. Each distribution is in its own directory; for example, the 
base distribution can be found in the 9.1/base/ directory.

For as many distributions you wish to install from an MS-DOSÂ® partition (and
you have the free space for), install each one under c:\freebsd â   the BIN
distribution is the only one required for a minimum installation.

3.13.5.Â Creating an Installation Tape

Installing from tape is probably the easiest method, short of an online FTP
install or CDROM install. The installation program expects the files to be
simply tarred onto the tape. After getting all of the distribution files you
are interested in, simply tar them onto the tape:

# cd /freebsd/distdir # tar cvf /dev/rwt0 dist1 ... dist2

When you perform the installation, you should make sure that you leave enough
room in some temporary directory (which you will be allowed to choose) to
accommodate the full contents of the tape you have created. Due to the
non-random access nature of tapes, this method of installation requires quite a
bit of temporary storage.

Note:

When starting the installation, the tape must be in the drive before booting
from the boot floppy. The installation probe may otherwise fail to find it.

3.13.6.Â Before Installing over a Network

There are three types of network installations available. Ethernet (a standard
Ethernet controller), Serial port (PPP), or Parallel port (PLIP (laplink
cable)).

For the fastest possible network installation, an Ethernet adapter is always a
good choice! FreeBSD supports most common PC Ethernet cards; a table of
supported cards (and their required settings) is provided in the Hardware Notes
for each release of FreeBSD. If you are using one of the supported PCMCIA
Ethernet cards, also be sure that it is plugged in before the laptop is powered
on! FreeBSD does not, unfortunately, currently support hot insertion of PCMCIA
cards during installation.

You will also need to know your IP address on the network, the netmask value
for your address class, and the name of your machine. If you are installing
over a PPP connection and do not have a static IP, fear not, the IP address can
be dynamically assigned by your ISP. Your system administrator can tell you
which values to use for your particular network setup. If you will be referring
to other hosts by name rather than IP address, you will also need a name server
and possibly the address of a gateway (if you are using PPP, it is your
provider's IP address) to use in talking to it. If you want to install by FTP
via a HTTP proxy, you will also need the proxy's address. If you do not know
the answers to all or most of these questions, then you should really probably
talk to your system administrator or ISP before trying this type of
installation.

If you are using a modem, then PPP is almost certainly your only choice. Make
sure that you have your service provider's information handy as you will need
to know it fairly early in the installation process.

If you use PAP or CHAP to connect your ISP (in other words, if you can connect
to the ISP in WindowsÂ® without using a script), then all you will need to do
is type in dial at the ppp prompt. Otherwise, you will need to know how to dial
your ISP using the â  AT commandsâ   specific to your modem, as the PPP dialer
provides only a very simple terminal emulator. Please refer to the user-ppp
handbook and FAQ entries for further information. If you have problems, logging
can be directed to the screen using the command set log local ....

If a hard-wired connection to another FreeBSD machine is available, you might
also consider installing over a â  laplinkâ   parallel port cable. The data
rate over the parallel port is much higher than what is typically possible over
a serial line (up to 50Â kbytes/sec), thus resulting in a quicker installation.

3.13.6.1.Â Before Installing via NFS

The NFS installation is fairly straight-forward. Simply copy the FreeBSD
distribution files you want onto an NFS server and then point the NFS media
selection at it.

If this server supports only â  privileged portâ   (as is generally the default
for Sun workstations), you will need to set the option NFS Secure in the 
Options menu before installation can proceed.

If you have a poor quality Ethernet card which suffers from very slow transfer
rates, you may also wish to toggle the NFS Slow flag.

In order for NFS installation to work, the server must support subdir mounts,
for example, if your FreeBSDÂ 9.1 distribution directory lives on: ziggy:/usr/
archive/stuff/FreeBSD, then ziggy will have to allow the direct mounting of /
usr/archive/stuff/FreeBSD, not just /usr or /usr/archive/stuff.

In FreeBSD's /etc/exports file, this is controlled by the -alldirs options.
Other NFS servers may have different conventions. If you are getting permission
denied messages from the server, then it is likely that you do not have this
enabled properly.

ChapterÂ 4.Â UNIX Basics

Rewritten by Chris Shumway.
Table of Contents

4.1. Synopsis
4.2. Virtual Consoles and Terminals
4.3. Permissions
4.4. Directory Structure
4.5. Disk Organization
4.6. Mounting and Unmounting File Systems
4.7. Processes
4.8. Daemons, Signals, and Killing Processes
4.9. Shells
4.10. Text Editors
4.11. Devices and Device Nodes
4.12. Binary Formats
4.13. For More Information

4.1.Â Synopsis

This chapter covers the basic commands and functionality of the FreeBSD
operating system. Much of this material is relevant for any UNIXÂ®-like
operating system. New FreeBSD users are encouraged to read through this chapter
carefully.

After reading this chapter, you will know:

  * How to use the â  virtual consolesâ   of FreeBSD.

  * How UNIXÂ® file permissions and FreeBSD file flags work.

  * The default FreeBSD file system layout.

  * The FreeBSD disk organization.

  * How to mount and unmount file systems.

  * What processes, daemons, and signals are.

  * What a shell is, and how to change your default login environment.

  * How to use basic text editors.

  * What devices and device nodes are.

  * What binary format is used under FreeBSD.

  * How to read manual pages for more information.

4.2.Â Virtual Consoles and Terminals

FreeBSD can be used in various ways. One of them is typing commands to a text
terminal. A lot of the flexibility and power of a UNIXÂ® operating system is
readily available at your hands when using FreeBSD this way. This section
describes what â  terminalsâ   and â  consolesâ   are, and how you can use them
in FreeBSD.

4.2.1.Â The Console

Unless FreeBSD has been configured to automatically start a graphical
environment during startup, the system will boot into a command line login
prompt, as seen in this example:

FreeBSD/amd64 (pc3.example.org) (ttyv0) login:

The first line contains some information about the system. The amd64 indicates
that the system in this example is running a 64-bit version of FreeBSD. The
hostname is pc3.example.org, and ttyv0 indicates that this is the system
console.

The second line is the login prompt. The next section describes how to log into
FreeBSD at this prompt.

4.2.2.Â Logging into FreeBSD

FreeBSD is a multiuser, multiprocessing system. This is the formal description
that is usually given to a system that can be used by many different people,
who simultaneously run a lot of programs on a single machine.

Every multiuser system needs some way to distinguish one â  userâ   from the
rest. In FreeBSD (and all the UNIXÂ®-like operating systems), this is
accomplished by requiring that every user must â  log intoâ   the system before
being able to run programs. Every user has a unique name (the â  usernameâ  )
and a personal, secret key (the â  passwordâ  ). FreeBSD will ask for these two
before allowing a user to run any programs.

When a FreeBSD system boots, startup scripts are automatically executed in
order to prepare the system and to start any services which have been
configured to start at system boot. Once the system finishes running its
startup scripts, it will present a login prompt:

login:

Type the username that was configured during system installation and press 
Enter. Then enter the password associated with the username and press Enter.
The password is not echoed for security reasons.

Once the correct password is input, the message of the day (MOTD) will be
displayed followed by a command prompt (a #, $, or % character). You are now
logged into the FreeBSD console and ready to try the available commands.

4.2.3.Â Virtual Consoles

FreeBSD can be configured to provide many virtual consoles for inputting
commands. Each virtual console has its own login prompt and output channel, and
FreeBSD takes care of properly redirecting keyboard input and monitor output as
you switch between virtual consoles.

Special key combinations have been reserved by FreeBSD for switching consoles.^
[1]. Use Alt+F1, Alt+F2, through Alt+F8 to switch to a different virtual
console in FreeBSD.

When switching from one console to the next, FreeBSD takes care of saving and
restoring the screen output. The result is an â  illusionâ   of having multiple
â  virtualâ   screens and keyboards that can be used to type commands for
FreeBSD to run. The programs that are launched in one virtual console do not
stop running when that console is not visible because the user has switched to
a different virtual console.

4.2.4.Â The /etc/ttys File

By default, FreeBSD is configured to start eight virtual consoles. The
configuration can be customized to start more or fewer virtual consoles. To
change the number of and the settings of the virtual consoles, edit /etc/ttys.

Each uncommented line in /etc/ttys (lines that do not start with a # character)
contains settings for a single terminal or virtual console. The default version
configures nine virtual consoles, and enables eight of them. They are the lines
that start with ttyv:

# name getty type status comments # ttyv0 "/usr/libexec/getty Pc" cons25 on
secure # Virtual terminals ttyv1 "/usr/libexec/getty Pc" cons25 on secure ttyv2
"/usr/libexec/getty Pc" cons25 on secure ttyv3 "/usr/libexec/getty Pc" cons25
on secure ttyv4 "/usr/libexec/getty Pc" cons25 on secure ttyv5 "/usr/libexec/
getty Pc" cons25 on secure ttyv6 "/usr/libexec/getty Pc" cons25 on secure ttyv7
"/usr/libexec/getty Pc" cons25 on secure ttyv8 "/usr/X11R6/bin/xdm -nodaemon"
xterm off secure

For a detailed description of every column in this file and the available
options for the virtual consoles, refer to ttys(5).

4.2.5.Â Single User Mode Console

A detailed description of â  single user modeâ   can be found here. There is
only one console when FreeBSD is in single user mode as no other virtual
consoles are available in this mode. The settings for single user mode are
found in this section of /etc/ttys:

# name getty type status comments # # If console is marked "insecure", then
init will ask for the root password # when going to single-user mode. console
none unknown off secure

Note:

As the comments above the console line indicate, editing secure to insecure
will prompt for the root password when booting into single user mode. The
default setting enters single user mode without prompting for a password.

Be careful when changing this setting to insecure. If you ever forget the root
password, booting into single user mode is still possible, but may be difficult
for someone who is not comfortable with the FreeBSD booting process.

4.2.6.Â Changing Console Video Modes

The FreeBSD console default video mode may be adjusted to 1024x768, 1280x1024,
or any other size supported by the graphics chip and monitor. To use a
different video mode load the VESA module:

# kldload vesa

To determine which video modes are supported by the hardware, use vidcontrol(1)
. To get a list of supported video modes issue the following:

# vidcontrol -i mode

The output of this command lists the video modes that are supported by the
hardware. To select a new video mode, specify the mode using vidcontrol(1) as
the root user:

# vidcontrol MODE_279

If the new video mode is acceptable, it can be permanently set on boot by
adding it to /etc/rc.conf:

allscreens_flags="MODE_279"

4.3.Â Permissions

FreeBSD, being a direct descendant of BSD UNIXÂ®, is based on several key UNIXÂ
® concepts. The first and most pronounced is that FreeBSD is a multi-user
operating system that can handle several users working simultaneously on
completely unrelated tasks. The system is responsible for properly sharing and
managing requests for hardware devices, peripherals, memory, and CPU time
fairly to each user.

Because the system is capable of supporting multiple users, everything the
system manages has a set of permissions governing who can read, write, and
execute the resource. These permissions are stored as three octets broken into
three pieces, one for the owner of the file, one for the group that the file
belongs to, and one for everyone else. This numerical representation works like
this:

Note:

This section will discuss the traditional UNIXÂ® permissions. For finer grained
file system access control, see the File System Access Control Lists section.

 Value                   Permission                      Directory Listing
0       No read, no write, no execute                ---
1       No read, no write, execute                   --x
2       No read, write, no execute                   -w-
3       No read, write, execute                      -wx
4       Read, no write, no execute                   r--
5       Read, no write, execute                      r-x
6       Read, write, no execute                      rw-
7       Read, write, execute                         rwx

Use the -l argument to ls(1) to view a long directory listing that includes a
column of information about a file's permissions for the owner, group, and
everyone else. For example, a ls -l in an arbitrary directory may show:

% ls -l total 530 -rw-r--r-- 1 root wheel 512 Sep 5 12:31 myfile -rw-r--r-- 1
root wheel 512 Sep 5 12:31 otherfile -rw-r--r-- 1 root wheel 7680 Sep 5 12:31
email.txt

The first (leftmost) character in the first column indicates whether this file
is a regular file, a directory, a special character device, a socket, or any
other special pseudo-file device. In this example, the - indicates a regular
file. The next three characters, rw- in this example, give the permissions for
the owner of the file. The next three characters, r--, give the permissions for
the group that the file belongs to. The final three characters, r--, give the
permissions for the rest of the world. A dash means that the permission is
turned off. In this example, the permissions are set so the owner can read and
write to the file, the group can read the file, and the rest of the world can
only read the file. According to the table above, the permissions for this file
would be 644, where each digit represents the three parts of the file's
permission.

How does the system control permissions on devices? FreeBSD treats most
hardware devices as a file that programs can open, read, and write data to.
These special device files are stored in /dev/.

Directories are also treated as files. They have read, write, and execute
permissions. The executable bit for a directory has a slightly different
meaning than that of files. When a directory is marked executable, it means it
is possible to change into that directory using cd. This also means that it is
possible to access the files within that directory, subject to the permissions
on the files themselves.

In order to perform a directory listing, the read permission must be set on the
directory. In order to delete a file that one knows the name of, it is
necessary to have write and execute permissions to the directory containing the
file.

There are more permission bits, but they are primarily used in special
circumstances such as setuid binaries and sticky directories. For more
information on file permissions and how to set them, refer to chmod(1).

4.3.1.Â Symbolic Permissions

Contributed by Tom Rhodes.

Symbolic permissions use characters instead of octal values to assign
permissions to files or directories. Symbolic permissions use the syntax of
(who) (action) (permissions), where the following values are available:

        Option           Letter                    Represents
(who)                  u          User
(who)                  g          Group owner
(who)                  o          Other
(who)                  a          All (â  worldâ  )
(action)               +          Adding permissions
(action)               -          Removing permissions
(action)               =          Explicitly set permissions
(permissions)          r          Read
(permissions)          w          Write
(permissions)          x          Execute
(permissions)          t          Sticky bit
(permissions)          s          Set UID or GID

These values are used with chmod(1), but with letters instead of numbers. For
example, the following command would block other users from accessing FILE:

% chmod go= FILE

A comma separated list can be provided when more than one set of changes to a
file must be made. For example, the following command removes the group and â  
worldâ   write permission on FILE, and adds the execute permissions for
everyone:

% chmod go-w,a+x FILE

4.3.2.Â FreeBSD File Flags

Contributed by Tom Rhodes.

In addition to file permissions, FreeBSD supports the use of â  file flagsâ  .
These flags add an additional level of security and control over files, but not
directories. With file flags, even root can be prevented from removing or
altering files.

File flags are modified using chflags(1). For example, to enable the system
undeletable flag on the file file1, issue the following command:

# chflags sunlink file1

To disable the system undeletable flag, put a â  noâ   in front of the sunlink:

# chflags nosunlink file1

To view the flags of a file, use -lo with ls(1):

# ls -lo file1
-rw-r--r-- 1 trhodes trhodes sunlnk 0 Mar 1 05:54 file1

Several file flags may only be added or removed by the root user. In other
cases, the file owner may set its file flags. Refer to chflags(1) and chflags
(2) for more information.

4.3.3.Â The setuid, setgid, and sticky Permissions

Contributed by Tom Rhodes.

Other than the permissions already discussed, there are three other specific
settings that all administrators should know about. They are the setuid,
setgid, and sticky permissions.

These settings are important for some UNIXÂ® operations as they provide
functionality not normally granted to normal users. To understand them, the
difference between the real user ID and effective user ID must be noted.

The real user ID is the UID who owns or starts the process. The effective UID
is the user ID the process runs as. As an example, passwd(1) runs with the real
user ID when a user changes their password. However, in order to update the
password database, the command runs as the effective ID of the root user. This
allows users to change their passwords without seeing a Permission Denied
error.

The setuid permission may be set by prefixing a permission set with the number
four (4) as shown in the following example:

# chmod 4755 suidexample.sh

The permissions on suidexample.sh now look like the following:

-rwsr-xr-x 1 trhodes trhodes 63 Aug 29 06:36 suidexample.sh

Note that a s is now part of the permission set designated for the file owner,
replacing the executable bit. This allows utilities which need elevated
permissions, such as passwd.

Note:

The nosuid mount(8) option will cause such binaries to silently fail without
alerting the user. That option is not completely reliable as a nosuid wrapper
may be able to circumvent it.

To view this in real time, open two terminals. On one, start the passwd process
as a normal user. While it waits for a new password, check the process table
and look at the user information for passwd:

In terminal A:

Changing local password for trhodes Old Password:

In terminal B:

# ps aux | grep passwd
trhodes 5232 0.0 0.2 3420 1608 0 R+ 2:10AM 0:00.00 grep passwd root 5211 0.0
0.2 3620 1724 2 I+ 2:09AM 0:00.01 passwd

As stated above, the passwd is run by a normal user, but is using the effective
UID of root.

The setgid permission performs the same function as the setuid permission;
except that it alters the group settings. When an application or utility
executes with this setting, it will be granted the permissions based on the
group that owns the file, not the user who started the process.

To set the setgid permission on a file, provide chmod with a leading two (2):

# chmod 2755 sgidexample.sh

In the following listing, notice that the s is now in the field designated for
the group permission settings:

-rwxr-sr-x 1 trhodes trhodes 44 Aug 31 01:49 sgidexample.sh

Note:

In these examples, even though the shell script in question is an executable
file, it will not run with a different EUID or effective user ID. This is
because shell scripts may not access the setuid(2) system calls.

The setuid and setgid permission bits may lower system security, by allowing
for elevated permissions. The third special permission, the sticky bit, can
strengthen the security of a system.

When the sticky bit is set on a directory, it allows file deletion only by the
file owner. This is useful to prevent file deletion in public directories, such
as /tmp, by users who do not own the file. To utilize this permission, prefix
the permission set with a one (1):

# chmod 1777 /tmp

The sticky bit permission will display as a t at the very end of the permission
set:

# ls -al / | grep tmp
drwxrwxrwt 10 root wheel 512 Aug 31 01:49 tmp

4.4.Â Directory Structure

The FreeBSD directory hierarchy is fundamental to obtaining an overall
understanding of the system. The most important directory is root or, â  /â  .
This directory is the first one mounted at boot time and it contains the base
system necessary to prepare the operating system for multi-user operation. The
root directory also contains mount points for other file systems that are
mounted during the transition to multi-user operation.

A mount point is a directory where additional file systems can be grafted onto
a parent file system (usually the root file system). This is further described
in SectionÂ 4.5, â  Disk Organizationâ  . Standard mount points include /usr/,
/var/, /tmp/, /mnt/, and /cdrom/. These directories are usually referenced to
entries in /etc/fstab. This file is a table of various file systems and mount
points and is read by the system. Most of the file systems in /etc/fstab are
mounted automatically at boot time from the script rc(8) unless their entry
includes noauto. Details can be found in SectionÂ 4.6.1, â  The fstab Fileâ  .

A complete description of the file system hierarchy is available in hier(7).
The following table provides a brief overview of the most common directories.

Directory                              Description
/         Root directory of the file system.
/bin/     User utilities fundamental to both single-user and multi-user
          environments.
/boot/    Programs and configuration files used during operating system
          bootstrap.
/boot/    Default boot configuration files. Refer to loader.conf(5) for
defaults/ details.
/dev/     Device nodes. Refer to intro(4) for details.
/etc/     System configuration files and scripts.
/etc/     Default system configuration files. Refer to rc(8) for details.
defaults/
/etc/mail Configuration files for mail transport agents such as sendmail(8).
/
/etc/     named configuration files. Refer to named(8) for details.
namedb/
/etc/     Scripts that run daily, weekly, and monthly, via cron(8). Refer to
periodic/ periodic(8) for details.
/etc/ppp/ ppp configuration files as described in ppp(8).
/mnt/     Empty directory commonly used by system administrators as a temporary
          mount point.
/proc/    Process file system. Refer to procfs(5), mount_procfs(8) for details.
/rescue/  Statically linked programs for emergency recovery as described in
          rescue(8).
/root/    Home directory for the root account.
/sbin/    System programs and administration utilities fundamental to both
          single-user and multi-user environments.
/tmp/     Temporary files which are usually not preserved across a system
          reboot. A memory-based file system is often mounted at /tmp. This can
          be automated using the tmpmfs-related variables of rc.conf(5) or with
          an entry in /etc/fstab; refer to mdmfs(8) for details.
/usr/     The majority of user utilities and applications.
/usr/bin/ Common utilities, programming tools, and applications.
/usr/     Standard C include files.
include/
/usr/lib/ Archive libraries.
/usr/     Miscellaneous utility data files.
libdata/
/usr/     System daemons and system utilities executed by other programs.
libexec/
/usr/     Local executables and libraries. Also used as the default destination
local/    for the FreeBSD ports framework. Within /usr/local, the general
          layout sketched out by hier(7) for /usr should be used. Exceptions
          are the man directory, which is directly under /usr/local rather than
          under /usr/local/share, and the ports documentation is in share/doc/
          port.
/usr/obj/ Architecture-specific target tree produced by building the /usr/src
          tree.
/usr/     The FreeBSD Ports Collection (optional).
ports/
/usr/sbin System daemons and system utilities executed by users.
/
/usr/     Architecture-independent files.
share/
/usr/src/ BSD and/or local source files.
/var/     Multi-purpose log, temporary, transient, and spool files. A
          memory-based file system is sometimes mounted at /var. This can be
          automated using the varmfs-related variables in rc.conf(5) or with an
          entry in /etc/fstab; refer to mdmfs(8) for details.
/var/log/ Miscellaneous system log files.
/var/mail User mailbox files.
/
/var/     Miscellaneous printer and mail system spooling directories.
spool/
/var/tmp/ Temporary files which are usually preserved across a system reboot,
          unless /var is a memory-based file system.
/var/yp/  NIS maps.

4.5.Â Disk Organization

The smallest unit of organization that FreeBSD uses to find files is the
filename. Filenames are case-sensitive, which means that readme.txt and
README.TXT are two separate files. FreeBSD does not use the extension of a file
to determine whether the file is a program, document, or some other form of
data.

Files are stored in directories. A directory may contain no files, or it may
contain many hundreds of files. A directory can also contain other directories,
allowing you to build up a hierarchy of directories within one another in order
to organize data.

Files and directories are referenced by giving the file or directory name,
followed by a forward slash, /, followed by any other directory names that are
necessary. For example, if the directory foo contains a directory bar which
contains the file readme.txt, the full name, or path, to the file is foo/bar/
readme.txt. Note that this is different from WindowsÂ® which uses \ to separate
file and directory names. FreeBSD does not use drive letters, or other drive
names in the path. For example, you would not type c:/foo/bar/readme.txt on
FreeBSD.

Directories and files are stored in a file system. Each file system contains
exactly one directory at the very top level, called the root directory for that
file system. This root directory can contain other directories. One file system
is designated the root file system or /. Every other file system is mounted
under the root file system. No matter how many disks you have on your FreeBSD
system, every directory appears to be part of the same disk.

Suppose you have three file systems, called A, B, and C. Each file system has
one root directory, which contains two other directories, called A1, A2 (and
likewise B1, B2 and C1, C2).

Call A the root file system. If you used ls to view the contents of this
directory you would see two subdirectories, A1 and A2. The directory tree looks
like this:

[example-di]

A file system must be mounted on to a directory in another file system. When
mounting file system B on to the directory A1, the root directory of B replaces
A1, and the directories in B appear accordingly:

[example-di]

Any files that are in the B1 or B2 directories can be reached with the path /A1
/B1 or /A1/B2 as necessary. Any files that were in /A1 have been temporarily
hidden. They will reappear if B is unmounted from A.

If B had been mounted on A2 then the diagram would look like this:

[example-di]

and the paths would be /A2/B1 and /A2/B2 respectively.

File systems can be mounted on top of one another. Continuing the last example,
the C file system could be mounted on top of the B1 directory in the B file
system, leading to this arrangement:

[example-di]

Or C could be mounted directly on to the A file system, under the A1 directory:

[example-di]

Typically you create file systems when installing FreeBSD and decide where to
mount them, and then never change them unless you add a new disk.

It is entirely possible to have one large root file system, and not need to
create any others. There are some drawbacks to this approach, and one
advantage.

Benefits of Multiple File Systems

  * Different file systems can have different mount options. For example, the
    root file system can be mounted read-only, making it impossible for users
    to inadvertently delete or edit a critical file. Separating user-writable
    file systems, such as /home, from other file systems allows them to be
    mounted nosuid. This option prevents the suid/guid bits on executables
    stored on the file system from taking effect, possibly improving security.

  * FreeBSD automatically optimizes the layout of files on a file system,
    depending on how the file system is being used. So a file system that
    contains many small files that are written frequently will have a different
    optimization to one that contains fewer, larger files. By having one big
    file system this optimization breaks down.

  * FreeBSD's file systems are very robust should you lose power. However, a
    power loss at a critical point could still damage the structure of the file
    system. By splitting data over multiple file systems it is more likely that
    the system will still come up, making it easier to restore from backup as
    necessary.

Benefit of a Single File System

  * File systems are a fixed size. If you create a file system when you install
    FreeBSD and give it a specific size, you may later discover that you need
    to make the partition bigger. This is not easily accomplished without
    backing up, recreating the file system with the new size, and then
    restoring the backed up data.

    Important:

    FreeBSD features the growfs(8) command, which makes it possible to increase
    the size of file system on the fly, removing this limitation.

File systems are contained in partitions. This does not have the same meaning
as the common usage of the term partition (for example, MS-DOSÂ® partition),
because of FreeBSD's UNIXÂ® heritage. Each partition is identified by a letter
from a through to h. Each partition can contain only one file system, which
means that file systems are often described by either their typical mount point
in the file system hierarchy, or the letter of the partition they are contained
in.

FreeBSD also uses disk space for swap space to provide virtual memory. This
allows your computer to behave as though it has much more memory than it
actually does. When FreeBSD runs out of memory, it moves some of the data that
is not currently being used to the swap space, and moves it back in (moving
something else out) when it needs it.

Some partitions have certain conventions associated with them.

Partition                              Convention
a         Normally contains the root file system.
b         Normally contains swap space.
c         Normally the same size as the enclosing slice. This allows utilities
          that need to work on the entire slice, such as a bad block scanner,
          to work on the c partition. You would not normally create a file
          system on this partition.
d         Partition d used to have a special meaning associated with it,
          although that is now gone and d may work as any normal partition.

Disks in FreeBSD are divided into slices, referred to in WindowsÂ® as
partitions, which are numbered from 1 to 4. These are then then divided into
partitions, which contain file systems, and are labeled using letters.

Slice numbers follow the device name, prefixed with an s, starting at 1. So â  
da0s1â   is the first slice on the first SCSI drive. There can only be four
physical slices on a disk, but you can have logical slices inside physical
slices of the appropriate type. These extended slices are numbered starting at
5, so â  ad0s5â   is the first extended slice on the first IDE disk. These
devices are used by file systems that expect to occupy a slice.

Slices, â  dangerously dedicatedâ   physical drives, and other drives contain
partitions, which are represented as letters from a to h. This letter is
appended to the device name, so â  da0aâ   is the a partition on the first da
drive, which is â  dangerously dedicatedâ  . â  ad1s3eâ   is the fifth
partition in the third slice of the second IDE disk drive.

Finally, each disk on the system is identified. A disk name starts with a code
that indicates the type of disk, and then a number, indicating which disk it
is. Unlike slices, disk numbering starts at 0. Common codes that you will see
are listed in TableÂ 4.1, â  Disk Device Codesâ  .

When referring to a partition, include the disk name, s, the slice number, and
then the partition letter. Examples are shown in ExampleÂ 4.1, â  Sample Disk,
Slice, and Partition Namesâ  .

ExampleÂ 4.2, â  Conceptual Model of a Diskâ   shows a conceptual model of a
disk layout.

When installing FreeBSD, configure the disk slices, create partitions within
the slice to be used for FreeBSD, create a file system or swap space in each
partition, and decide where each file system will be mounted.

TableÂ 4.1.Â Disk Device Codes

    Code                                  Meaning
ad           ATAPI (IDE) disk
da           SCSI direct access disk
acd          ATAPI (IDE) CDROM
cd           SCSI CDROM
fd           Floppy disk


ExampleÂ 4.1.Â Sample Disk, Slice, and Partition Names

 Name                                  Meaning
ad0s1a The first partition (a) on the first slice (s1) on the first IDE disk
       (ad0).
da1s2e The fifth partition (e) on the second slice (s2) on the second SCSI disk
       (da1).


ExampleÂ 4.2.Â Conceptual Model of a Disk

This diagram shows FreeBSD's view of the first IDE disk attached to the system.
Assume that the disk is 4Â GB in size, and contains two 2Â GB slices (MS-DOSÂ®
partitions). The first slice contains a MS-DOSÂ® disk, C:, and the second slice
contains a FreeBSD installation. This example FreeBSD installation has three
data partitions, and a swap partition.

The three partitions will each hold a file system. Partition a will be used for
the root file system, e for the /var/ directory hierarchy, and f for the /usr/
directory hierarchy.

[disk-layou]


4.6.Â Mounting and Unmounting File Systems

The file system is best visualized as a tree, rooted, as it were, at /. /dev, /
usr, and the other directories in the root directory are branches, which may
have their own branches, such as /usr/local, and so on.

There are various reasons to house some of these directories on separate file
systems. /var contains the directories log/, spool/, and various types of
temporary files, and as such, may get filled up. Filling up the root file
system is not a good idea, so splitting /var from / is often favorable.

Another common reason to contain certain directory trees on other file systems
is if they are to be housed on separate physical disks, or are separate virtual
disks, such as Network File System mounts, or CDROM drives.

4.6.1.Â The fstab File

During the boot process, file systems listed in /etc/fstab are automatically
mounted except for the entries containing noauto. This file contains entries in
the following format:

device /mount-point fstype options dumpfreq passno

device

    An existing device name as explained in SectionÂ 19.2, â  Device Namesâ  .

mount-point

    An existing directory on which to mount the file system.

fstype

    The file system type to pass to mount(8). The default FreeBSD file system
    is ufs.

options

    Either rw for read-write file systems, or ro for read-only file systems,
    followed by any other options that may be needed. A common option is noauto
    for file systems not normally mounted during the boot sequence. Other
    options are listed in mount(8).

dumpfreq

    Used by dump(8) to determine which file systems require dumping. If the
    field is missing, a value of zero is assumed.

passno

    Determines the order in which file systems should be checked. File systems
    that should be skipped should have their passno set to zero. The root file
    system needs to be checked before everything else and should have its
    passno set to one. The other file systems should be set to values greater
    than one. If more than one file system has the same passno, fsck(8) will
    attempt to check file systems in parallel if possible.

Refer to fstab(5) for more information on the format of /etc/fstab and its
options.

4.6.2.Â The mount Command

File systems are mounted using mount(8). The most basic syntax is as follows:

# mount device mountpoint

This command provides many options which are described in mount(8), The most
commonly used options include:

Mount Options

-a

    Mount all the file systems listed in /etc/fstab, except those marked as â  
    noautoâ  , excluded by the -t flag, or those that are already mounted.

-d

    Do everything except for the actual mount system call. This option is
    useful in conjunction with the -v flag to determine what mount(8) is
    actually trying to do.

-f

    Force the mount of an unclean file system (dangerous), or the revocation of
    write access when downgrading a file system's mount status from read-write
    to read-only.

-r

    Mount the file system read-only. This is identical to using -o ro.

-t fstype

    Mount the specified file system type or mount only file systems of the
    given type, if -a is included. â  ufsâ   is the default file system type.

-u

    Update mount options on the file system.

-v

    Be verbose.

-w

    Mount the file system read-write.

The following options can be passed to -o as a comma-separated list:

nosuid

    Do not interpret setuid or setgid flags on the file system. This is also a
    useful security option.

4.6.3.Â The umount Command

To unmount a filesystem use umount(8). This command takes one parameter which
can be a mountpoint, device name, -a or -A.

All forms take -f to force unmounting, and -v for verbosity. Be warned that -f
is not generally a good idea as it might crash the computer or damage data on
the file system.

To unmount all mounted file systems, or just the file system types listed after
-t, use -a or -A. Note that -A does not attempt to unmount the root file
system.

4.7.Â Processes

FreeBSD is a multi-tasking operating system. Each program running at any one
time is called a process. Every running command starts at least one new process
and there are a number of system processes that are run by FreeBSD.

Each process is uniquely identified by a number called a process ID (PID).
Similar to files, each process has one owner and group, and the owner and group
permissions are used to determine which files and devices the process can open.
Most processes also have a parent process that started them. For example, the
shell is a process, and any command started in the shell is a process which has
the shell as its parent process. The exception is a special process called init
(8) which is always the first process to start at boot time and which always
has a PID of 1.

To see the processes on the system, use ps(1) and top(1). To display a static
list of the currently running processes, their PIDs, how much memory they are
using, and the command they were started with, use ps. To display all the
running processes and update the display every few seconds so that you can
interactively see what the computer is doing, use top.

By default, ps only shows the commands that are running and owned by the user.
For example:

% ps PID TT STAT TIME COMMAND 298 p0 Ss 0:01.10 tcsh 7078 p0 S 2:40.88 xemacs
mdoc.xsl (xemacs-21.1.14) 37393 p0 I 0:03.11 xemacs freebsd.dsl
(xemacs-21.1.14) 72210 p0 R+ 0:00.00 ps 390 p1 Is 0:01.14 tcsh 7059 p2 Is+
1:36.18 /usr/local/bin/mutt -y 6688 p3 IWs 0:00.00 tcsh 10735 p4 IWs 0:00.00
tcsh 20256 p5 IWs 0:00.00 tcsh 262 v0 IWs 0:00.00 -tcsh (tcsh) 270 v0 IW+
0:00.00 /bin/sh /usr/X11R6/bin/startx -- -bpp 16 280 v0 IW+ 0:00.00 xinit /home
/nik/.xinitrc -- -bpp 16 284 v0 IW 0:00.00 /bin/sh /home/nik/.xinitrc 285 v0 S
0:38.45 /usr/X11R6/bin/sawfish

The output from ps(1) is organized into a number of columns. The PID column
displays the process ID. PIDs are assigned starting at 1, go up to 99999, then
wrap around back to the beginning. However, a PID is not reassigned if it is
already in use. The TT column shows the tty the program is running on and STAT
shows the program's state. TIME is the amount of time the program has been
running on the CPU. This is usually not the elapsed time since the program was
started, as most programs spend a lot of time waiting for things to happen
before they need to spend time on the CPU. Finally, COMMAND is the command that
was used to start the program.

ps(1) supports a number of different options to change the information that is
displayed. One of the most useful sets is auxww. a displays information about
all the running processes of all users. u displays the username of the process'
owner, as well as memory usage. x displays information about daemon processes,
and ww causes ps(1) to display the full command line for each process, rather
than truncating it once it gets too long to fit on the screen.

The output from top(1) is similar. A sample session looks like this:

% top last pid: 72257; load averages: 0.13, 0.09, 0.03 up 0+13:38:33 22:39:10
47 processes: 1 running, 46 sleeping CPU states: 12.6% user, 0.0% nice, 7.8%
system, 0.0% interrupt, 79.7% idle Mem: 36M Active, 5256K Inact, 13M Wired,
6312K Cache, 15M Buf, 408K Free Swap: 256M Total, 38M Used, 217M Free, 15%
Inuse PID USERNAME PRI NICE SIZE RES STATE TIME WCPU CPU COMMAND 72257 nik 28 0
1960K 1044K RUN 0:00 14.86% 1.42% top 7078 nik 2 0 15280K 10960K select 2:54
0.88% 0.88% xemacs-21.1.14 281 nik 2 0 18636K 7112K select 5:36 0.73% 0.73%
XF86_SVGA 296 nik 2 0 3240K 1644K select 0:12 0.05% 0.05% xterm 175 root 2 0
924K 252K select 1:41 0.00% 0.00% syslogd 7059 nik 2 0 7260K 4644K poll 1:38
0.00% 0.00% mutt ...

The output is split into two sections. The header (the first five lines) shows
the PID of the last process to run, the system load averages (which are a
measure of how busy the system is), the system uptime (time since the last
reboot) and the current time. The other figures in the header relate to how
many processes are running (47 in this case), how much memory and swap space
has been used, and how much time the system is spending in different CPU
states.

Below the header is a series of columns containing similar information to the
output from ps(1), such as the PID, username, amount of CPU time, and the
command that started the process. By default, top(1) also displays the amount
of memory space taken by the process. This is split into two columns: one for
total size and one for resident size. Total size is how much memory the
application has needed and the resident size is how much it is actually using
at the moment. In this example, mutt has required almost 8Â MB of RAM, but is
currently only using 5Â MB.

top(1) automatically updates the display every two seconds. A different
interval can be specified with -s.

4.8.Â Daemons, Signals, and Killing Processes

When using an editor, it is easy to control the editor and load files because
the editor provides facilities to do so, and because the editor is attached to
a terminal. Some programs are not designed to be run with continuous user input
and disconnect from the terminal at the first opportunity. For example, a web
server responds to web requests, rather than user input. Mail servers are
another example of this type of application.

These programs are known as daemons. The term daemon comes from Greek mythology
and represents an entity that is neither good or evil, and which invisibly
performs useful tasks. This is why the BSD mascot is the cheerful-looking
daemon with sneakers and a pitchfork.

There is a convention to name programs that normally run as daemons with a
trailing â  dâ  . BIND is the Berkeley Internet Name Domain, but the actual
program that executes is named. The Apache web server program is httpd and the
line printer spooling daemon is lpd. This is only a naming convention. For
example, the main mail daemon for the Sendmail application is sendmail, and not
maild.

One way to communicate with a daemon, or any running process, is to send a
signal using kill(1). There are a number of different signals; some have a
specific meaning while others are described in the application's documentation.
A user can only send a signal to a process they own and sending a signal to
someone else's process will result in a permission denied error. The exception
is the root user, who can send signals to anyone's processes.

FreeBSD can also send a signal to a process. If an application is badly written
and tries to access memory that it is not supposed to, FreeBSD will send the
process the Segmentation Violation signal (SIGSEGV). If an application has used
the alarm(3) system call to be alerted after a period of time has elapsed, it
will be sent the Alarm signal (SIGALRM).

Two signals can be used to stop a process: SIGTERM and SIGKILL. SIGTERM is the
polite way to kill a process as the process can read the signal, close any log
files it may have open, and attempt to finish what it is doing before shutting
down. In some cases, a process may ignore SIGTERM if it is in the middle of
some task that can not be interrupted.

SIGKILL can not be ignored by a process. This is the â  I do not care what you
are doing, stop right nowâ   signal. Sending a SIGKILL to a process will
usually stop that process there and then.^[2].

Other commonly used signals are SIGHUP, SIGUSR1, and SIGUSR2. These are general
purpose signals and different applications will respond differently.

For example, after changing a web server's configuration file, the web server
needs to be told to re-read its configuration. Restarting httpd would result in
a brief outage period on the web server. Instead, send the daemon the SIGHUP
signal. Be aware that different daemons will have different behavior, so refer
to the documentation for the daemon to determine if SIGHUP will achieve the
desired results.

ProcedureÂ 4.1.Â Sending a Signal to a Process

This example shows how to send a signal to inetd(8). The inetd configuration
file is /etc/inetd.conf, and inetd will re-read this configuration file when it
is sent a SIGHUP.

 1. Find the PID of the process you want to send the signal to using pgrep(1).
    In this example, the PID for inetd(8) is 198:

    % pgrep -l inetd 198 inetd -wW
 2. Use kill(1) to send the signal. Because inetd(8) is owned by root, use su
    (1) to become root first.

    % su Password: # /bin/kill -s HUP 198

    Like most UNIXÂ® commands, kill(1) will not print any output if it is
    successful. If you send a signal to a process that you do not own, you will
    instead see kill: PID: Operation not permitted. Mistyping the PID will
    either send the signal to the wrong process, which could have negative
    results, or will send the signal to a PID that is not currently in use,
    resulting in the error kill: PID: No such process.

    Why Use /bin/kill?:

    Many shells provide kill as a built in command, meaning that the shell will
    send the signal directly, rather than running /bin/kill. Be aware that
    different shells have a different syntax for specifying the name of the
    signal to send. Rather than try to learn all of them, it can be simpler to
    use /bin/kill ... directly.

When sending other signals, substitute TERM or KILL in the command line as
necessary.

Important:

Killing a random process on the system can be a bad idea. In particular, init
(8), PID 1, is special. Running /bin/kill -s KILL 1 is a quick, and
unrecommended, way to shutdown the system. Always double check the arguments to
kill(1) before pressing Return.

4.9.Â Shells

FreeBSD provides a command line interface called a shell. A shell receives
commands from the input channel and executes them. Many shells provide built in
functions to help with everyday tasks such as file management, file globbing,
command line editing, command macros, and environment variables. FreeBSD comes
with several shells, including sh, the Bourne Shell, and tcsh, the improved
C-shell. Other shells are available from the FreeBSD Ports Collection, such as
zsh and bash.

The shell that is used is really a matter of taste. A C programmer might feel
more comfortable with a C-like shell such as tcsh. A Linux user might prefer
bash. Each shell has unique properties that may or may not work with a user's
preferred working environment, which is why there is a choice of which shell to
use.

One common shell feature is filename completion. After a user types the first
few letters of a command or filename and presses Tab, the shell will
automatically complete the rest of the command or filename. Consider two files
called foobar and foo.bar. To delete foo.bar, type rm fo[Tab].[Tab].

The shell should print out rm foo[BEEP].bar.

The [BEEP] is the console bell, which the shell used to indicate it was unable
to complete the filename because there is more than one match. Both foobar and
foo.bar start with fo. By typing ., then pressing Tab again, the shell would be
able to fill in the rest of the filename.

Another feature of the shell is the use of environment variables. Environment
variables are a variable/key pair stored in the shell's environment. This
environment can be read by any program invoked by the shell, and thus contains
a lot of program configuration. Here is a list of common environment variables
and their meanings:

Variable                              Description
USER     Current logged in user's name.
PATH     Colon-separated list of directories to search for binaries.
DISPLAY  Network name of the Xorg display to connect to, if available.
SHELL    The current shell.
TERM     The name of the user's type of terminal. Used to determine the
         capabilities of the terminal.
TERMCAP  Database entry of the terminal escape codes to perform various
         terminal functions.
OSTYPE   Type of operating system.
MACHTYPE The system's CPU architecture.
EDITOR   The user's preferred text editor.
PAGER    The user's preferred text pager.
MANPATH  Colon-separated list of directories to search for manual pages.

How to set an environment variable differs between shells. In tcsh and csh, use
setenv to set environment variables. In sh and bash, use export to set the
current environment variables. This example sets the default EDITOR to /usr/
local/bin/emacs for the tcsh shell:

% setenv EDITOR /usr/local/bin/emacs

The equivalent command for bash would be:

% export EDITOR="/usr/local/bin/emacs"

To expand an environment variable in order to see its current setting, type a $
character in front of its name on the command line. For example, echo $TERM
displays the current $TERM setting.

Shells treat special characters, known as meta-characters, as special
representations of data. The most common meta-character is *, which represents
any number of characters in a filename. Meta-characters can be used to perform
filename globbing. For example, echo * is equivalent to ls because the shell
takes all the files that match * and echo lists them on the command line.

To prevent the shell from interpreting a special character, escape it from the
shell by starting it with a backslash (\). For example, echo $TERM prints the
terminal setting whereas echo \$TERM literally prints the string $TERM.

4.9.1.Â Changing Your Shell

The easiest way to permanently change the default shell is to use chsh. Running
this command will open the editor that is configured in the EDITOR environment
variable, which by default is set to vi. Change the â  Shell:â   line to the
full path of the new shell.

Alternately, use chsh -s which will set the specified shell without opening an
editor. For example, to change the shell to bash:

% chsh -s /usr/local/bin/bash

Note:

The new shell must be present in /etc/shells. If the shell was installed from
the FreeBSD Ports Collection, it should be automatically added to this file. If
it is missing, add it using this command, replacing the path with the path of
the shell:

# echo /usr/local/bin/bash &gt;&gt; /etc/shells

Then rerun chsh.

4.10.Â Text Editors

Most FreeBSD configuration is done by editing text files. Because of this, it
is a good idea to become familiar with a text editor. FreeBSD comes with a few
as part of the base system, and many more are available in the Ports
Collection.

A simple editor to learn is ee, which stands for easy editor. To start this
editor, type ee filename where filename is the name of the file to be edited.
Once inside the editor, all of the commands for manipulating the editor's
functions are listed at the top of the display. The caret ^ represents Ctrl, so
^e expands to Ctrl+e. To leave ee, press Esc, then choose the â  leave editorâ 
  option from the main menu. The editor will prompt you to save any changes if
the file has been modified.

FreeBSD also comes with more powerful text editors such as vi as part of the
base system. Other editors, like editors/emacs and editors/vim, are part of the
FreeBSD Ports Collection. These editors offer more functionality at the expense
of being a more complicated to learn. Learning a more powerful editor such as 
vim or Emacs can save more time in the long run.

Many applications which modify files or require typed input will automatically
open a text editor. To alter the default editor used, set the EDITOR
environment variable as described in the shells section.

4.11.Â Devices and Device Nodes

A device is a term used mostly for hardware-related activities in a system,
including disks, printers, graphics cards, and keyboards. When FreeBSD boots,
the majority of the boot messages refer to devices being detected. A copy of
the boot messages are saved to /var/run/dmesg.boot.

Each device has a device name and number. For example, acd0 is the first IDE
CD-ROM drive, while kbd0 represents the keyboard.

Most devices in a FreeBSD must be accessed through special files called device
nodes, which are located in /dev.

4.12.Â Binary Formats

To understand why FreeBSD uses the elf(5) format,the three currently â  
dominantâ   executable formats for UNIXÂ® must be described:

  * a.out(5)

    The oldest and â  classicâ   UNIXÂ® object format. It uses a short and
    compact header with a magic(5) number at the beginning that is often used
    to characterize the format. It contains three loaded segments: .text,
    .data, and .bss, plus a symbol table and a string table.

  * COFF

    The SVR3 object format. The header comprises a section table which can
    contain more than just .text, .data, and .bss sections.

  * elf(5)

    The successor to COFF, featuring multiple sections and 32-bit or 64-bit
    possible values. One major drawback is that ELF was designed with the
    assumption that there would be only one ABI per system architecture. That
    assumption is actually incorrect, and not even in the commercial SYSV world
    (which has at least three ABIs: SVR4, Solaris, SCO) does it hold true.

    FreeBSD tries to work around this problem somewhat by providing a utility
    for branding a known ELF executable with information about its compliant
    ABI. Refer to brandelf(1) for more information.

FreeBSD comes from the â  classicâ   camp and used the a.out(5) format, a
technology tried and proven through many generations of BSD releases, until the
beginning of the 3.X branch. Though it was possible to build and run native ELF
binaries and kernels on a FreeBSD system for some time before that, FreeBSD
initially resisted the â  pushâ   to switch to ELF as the default format. Why?
When Linux made its painful transition to ELF, it was due to their inflexible
jump-table based shared library mechanism, which made the construction of
shared libraries difficult for vendors and developers. Since ELF tools offered
a solution to the shared library problem and were generally seen as â  the way
forwardâ  , the migration cost was accepted as necessary and the transition
made. FreeBSD's shared library mechanism is based more closely on the SunOSâ ¢
style shared library mechanism and is easy to use.

So, why are there so many different formats? Back in the PDP-11 days when
simple hardware supported a simple, small system, a.out was adequate for the
job of representing binaries. As UNIXÂ® was ported, the a.out format was
retained because it was sufficient for the early ports of UNIXÂ® to
architectures like the Motorola 68k or VAXen.

Then some hardware engineer decided that if he could force software to do some
sleazy tricks, a few gates could be shaved off the design and the CPU core
could run faster. a.out was ill-suited for this new kind of hardware, known as 
RISC. Many formats were developed to get better performance from this hardware
than the limited, simple a.out format could offer. COFF, ECOFF, and a few
others were invented and their limitations explored before settling on ELF.

In addition, program sizes were getting huge while disks and physical memory
were still relatively small, so the concept of a shared library was born. The
virtual memory system became more sophisticated. While each advancement was
done using the a.out format, its usefulness was stretched with each new
feature. In addition, people wanted to dynamically load things at run time, or
to junk parts of their program after the init code had run to save in core
memory and swap space. Languages became more sophisticated and people wanted
code called before the main() function automatically. Lots of hacks were done
to the a.out format to allow all of these things to happen, and they basically
worked for a time. In time, a.out was not up to handling all these problems
without an ever increasing overhead in code and complexity. While ELF solved
many of these problems, it would be painful to switch from the system that
basically worked. So ELF had to wait until it was more painful to remain with
a.out than it was to migrate to ELF.

As time passed, the build tools that FreeBSD derived their build tools from,
especially the assembler and loader, evolved in two parallel trees. The FreeBSD
tree added shared libraries and fixed some bugs. The GNU folks that originally
wrote these programs rewrote them and added simpler support for building cross
compilers and plugging in different formats. Those who wanted to build cross
compilers targeting FreeBSD were out of luck since the older sources that
FreeBSD had for as and ld were not up to the task. The new GNU tools chain (
binutils) supports cross compiling, ELF, shared libraries, and C++ extensions.
In addition, many vendors release ELF binaries, and FreeBSD should be able to
run them.

ELF is more expressive than a.out and allows more extensibility in the base
system. The ELF tools are better maintained and offer cross compilation
support. ELF may be a little slower than a.out, but trying to measure it can be
difficult. There are also numerous details that are different between the two
such as how they map pages and handle init code.

4.13.Â For More Information

4.13.1.Â Manual Pages

The most comprehensive documentation on FreeBSD is in the form of manual pages.
Nearly every program on the system comes with a short reference manual
explaining the basic operation and available arguments. These manuals can be
viewed using man:

% man command

where command is the name of the command you wish to learn about. For example,
to learn more about ls, type:

% man ls

The online manual is divided into numbered sections:

 1. User commands.

 2. System calls and error numbers.

 3. Functions in the C libraries.

 4. Device drivers.

 5. File formats.

 6. Games and other diversions.

 7. Miscellaneous information.

 8. System maintenance and operation commands.

 9. Kernel developers.

In some cases, the same topic may appear in more than one section of the online
manual. For example, there is a chmod user command and a chmod() system call.
To tell man which section to display, specify the section number:

% man 1 chmod

This will display the manual page for the user command chmod. References to a
particular section of the online manual are traditionally placed in parenthesis
in written documentation, so chmod(1) refers to the chmod user command and
chmod(2) refers to the system call.

If you do not know the command name, use man -k to search for keywords in the
command descriptions:

% man -k mail

This command displays a list of commands that have the keyword â  mailâ   in
their descriptions. This is equivalent to using apropos(1).

To determine what the commands in /usr/bin do, type:

% cd /usr/bin % man -f *

or

% cd /usr/bin % whatis *

4.13.2.Â GNU Info Files

FreeBSD includes many applications and utilities produced by the Free Software
Foundation (FSF). In addition to manual pages, these programs may include
hypertext documents called info files. These can be viewed using info or, if
editors/emacs is installed, the info mode of emacs.

To use info(1), type:

% info

For a brief introduction, type h. For a quick command reference, type ?.


------------

^[1] Refer to syscons(4), atkbd(4), vidcontrol(1) and kbdcontrol(1) for a more
technical description of the FreeBSD console and its keyboard drivers.

^[2] There are a few tasks that can not be interrupted. For example, if the
process is trying to read from a file that is on another computer on the
network, and the other computer is unavailable, the process is said to be â  
uninterruptibleâ  . Eventually the process will time out, typically after two
minutes. As soon as this time out occurs the process will be killed.

ChapterÂ 5.Â Installing Applications: Packages and Ports

Table of Contents

5.1. Synopsis
5.2. Overview of Software Installation
5.3. Finding Software
5.4. Using Binary Packages
5.5. Using pkgng for Binary Package Management
5.6. Using the Ports Collection
5.7. Post-installation Activities
5.8. Dealing with Broken Ports

5.1.Â Synopsis

FreeBSD is bundled with a rich collection of system tools as part of the base
system. However, there is only so much one can do before needing to install an
additional third-party application to get real work done. FreeBSD provides two
complementary technologies for installing third-party software: the FreeBSD
Ports Collection (for installing from source), and packages (for installing
from pre-built binaries). Either method may be used to install software from
local media or from the network.

After reading this chapter, you will know how to:

  * Install third-party binary software packages.

  * Build third-party software from source by using the Ports Collection.

  * Remove previously installed packages or ports.

  * Override the default values used by the Ports Collection.

  * Find the appropriate software package.

  * Upgrade installed software.

5.2.Â Overview of Software Installation

The typical steps for installing third-party software on a UNIXÂ® system
include:

 1. Download the software, which might be distributed in source code format, or
    as a binary.

 2. Unpack the software from its distribution format (typically a tarball
    compressed with compress(1), gzip(1), or bzip2(1)).

 3. Locate the documentation in INSTALL, README or some file in a doc/
    subdirectory and read up on how to install the software.

 4. If the software was distributed in source format, compile it. This may
    involve editing a Makefile, or running a configure script, and other work.

 5. Test and install the software.

If you are installing a software package that was not deliberately ported to
FreeBSD you may even have to go in and edit the code to make it work properly.

FreeBSD provides two technologies which perform these steps for you. At the
time of writing, over 24,000 third-party applications are available.

A FreeBSD package contains pre-compiled copies of all the commands for an
application, as well as any configuration files and documentation. A package
can be manipulated with FreeBSD package management commands, such as pkg_add(1)
, pkg_delete(1), and pkg_info(1).

A FreeBSD port is a collection of files designed to automate the process of
compiling an application from source code. The files that comprise a port
contain all the necessary information to automatically download, extract,
patch, compile, and install the application.

The ports system can also be used to generate packages which can be manipulated
with the FreeBSD package management commands.

Both packages and ports understand dependencies. If pkg_add(1) or the Ports
Collection is used to install an application and a dependent library is not
already installed, the library will automatically be installed first.

While the two technologies are quite similar, packages and ports each have
their own strengths. Select the technology that meets your requirements for
installing a particular application.

Package Benefits

  * A compressed package tarball is typically smaller than the compressed
    tarball containing the source code for the application.

  * Packages do not require compilation time. For large applications, such as 
    Mozilla, KDE, or GNOME this can be important, on a slow system.

  * Packages do not require any understanding of the process involved in
    compiling software on FreeBSD.

Ports Benefits

  * Packages are normally compiled with conservative options because they have
    to run on the maximum number of systems. By compiling from the port, one
    can change the compilation options.

  * Some applications have compile-time options relating to which features are
    installed. For example, Apache can be configured with a wide variety of
    different built-in options.

    In some cases, multiple packages will exist for the same application to
    specify certain settings. For example, Ghostscript is available as a
    ghostscript package and a ghostscript-nox11 package, depending on whether
    or not Xorg is installed. Creating multiple packages rapidly becomes
    impossible if an application has more than one or two different
    compile-time options.

  * The licensing conditions of some software forbid binary distribution. These
    must be distributed as source code which must be compiled by the end-user.

  * Some people do not trust binary distributions or prefer to read through
    source code in order to look for potential problems.

  * If you have local patches, you will need the source in order to apply them.

To keep track of updated ports, subscribe to the FreeBSD ports mailing list and
the FreeBSD ports bugs mailing list.

Warning:

Before installing any application, check http://vuxml.freebsd.org/ for security
issues related to the application or install ports-mgmt/portaudit. Once
installed, type portaudit -F -a to check all installed applications for known
vulnerabilities.

The remainder of this chapter explains how to use packages and ports to install
and manage third-party software on FreeBSD.

5.3.Â Finding Software

FreeBSD's list of available applications is growing all the time. There are a
number of ways to find software to install:

  * The FreeBSD web site maintains an up-to-date searchable list of all the
    available applications, at http://www.FreeBSD.org/ports/. The ports can be
    searched by application name or by software category.

  * Dan Langille maintains FreshPorts which provides a comprehensive search
    utility and also tracks changes to the applications in the Ports
    Collection. Registered users can create a customized watch list in order to
    receive an automated email when their watched ports are updated.

  * If you do not know the name of the application you want, try using a site
    like Freecode (http://www.freecode.com/) to find an application, then check
    back at the FreeBSD site to see if the application has been ported yet.

  * To find out which category a port is in, type whereis file, where file is
    the program to be installed:

    # whereis lsof lsof: /usr/ports/sysutils/lsof

    Alternately, an echo(1) statement can be used:

    # echo /usr/ports/*/*lsof* /usr/ports/sysutils/lsof

    Note that this will return any matched files downloaded into the /usr/ports
    /distfiles directory.

  * Another way to find software is by using the Ports Collection's built-in
    search mechanism. To use the search feature, cd to /usr/ports then run make
    search name=program-name where program-name is the name of the software.
    For example, to search for lsof:

    # cd /usr/ports # make search name=lsof Port: lsof-4.56.4 Path: /usr/ports/
    sysutils/lsof Info: Lists information about open files (similar to fstat
    (1)) Maint: obrien@FreeBSD.org Index: sysutils B-deps: R-deps:

    Tip:

    make search searches through a file of index information. If a message
    indicates the INDEX is required, run make fetchindex to download the
    current index file. With the INDEX present, make search will be able to
    perform the requested search.

    The â  Path:â   line indicates where to find the port.

    To receive less information, use the quicksearch feature:

    # cd /usr/ports # make quicksearch name=lsof Port: lsof-4.87.a,7 Path: /usr
    /ports/sysutils/lsof Info: Lists information about open files (similar to
    fstat(1))

    For more in-depth searching, use make search key=string or make quicksearch
    key=string, where string is some text to search for. The text can be in
    comments, descriptions, or dependencies in order to find ports which relate
    to a particular subject when the name of the program is unknown.

    When using (search and quicksearch), the search string is case-insensitive.
    Searching for â  LSOFâ   will yield the same results as searching for â  
    lsofâ  .

5.4.Â Using Binary Packages

Contributed by Chern Lee.

There are several different tools used to manage packages on FreeBSD:

  * The sysinstall utility can be invoked on a running system to install,
    delete, and list available and installed packages. For more information,
    see SectionÂ 3.10.10, â  Install Packagesâ  .

  * The package management command line tools, which are the subject of the
    rest of this section.

5.4.1.Â Installing a Package

Use pkg_add(1) to install a FreeBSD binary package from a local file or from a
server on the network.

ExampleÂ 5.1.Â Downloading a Package Manually and Installing It Locally
# ftp -a ftp2.FreeBSD.org Connected to ftp2.FreeBSD.org. 220 ftp2.FreeBSD.org
FTP server (Version 6.00LS) ready. 331 Guest login ok, send your email address
as password. 230- 230- This machine is in Vienna, VA, USA, hosted by Verio.
230- Questions? E-mail freebsd@vienna.verio.net. 230- 230- 230 Guest login ok,
access restrictions apply. Remote system type is UNIX. Using binary mode to
transfer files. ftp&gt; cd /pub/FreeBSD/ports/packages/sysutils/ 250 CWD command
successful. ftp&gt; get lsof-4.56.4.tgz local: lsof-4.56.4.tgz remote:
lsof-4.56.4.tgz 200 PORT command successful. 150 Opening BINARY mode data
connection for 'lsof-4.56.4.tgz' (92375 bytes). 100% |
**************************************************| 92375 00:00 ETA 226
Transfer complete. 92375 bytes received in 5.60 seconds (16.11 KB/s) ftp&gt; exit
# pkg_add lsof-4.56.4.tgz


If you do not have a source of local packages, such as a FreeBSD CD-ROM set,
include -r with pkg_add(1). This automatically determines the correct object
format and release, and then fetches and installs the package from an FTP site
without any further user intervention.

# pkg_add -r lsof

To specify an alternative FreeBSD FTP mirror, specify the mirror in the
PACKAGESITE environment variable. pkg_add(1) uses fetch(3) to download files,
which uses various environment variables, including FTP_PASSIVE_MODE,
FTP_PROXY, and FTP_PASSWORD. You may need to set one or more of these if you
are behind a firewall, or need to use an FTP/HTTP proxy. See fetch(3) for the
complete list of variables. Note that in the example above lsof is used instead
of lsof-4.56.4. When the remote fetching feature is used, the version number of
the package must be removed.

Note:

pkg_add(1) will automatically download the latest version of the application if
you are using FreeBSD-CURRENT or FreeBSD-STABLE. If you run a -RELEASE version,
it instead installs the version of the package that was built with that
release. It is possible to change this behavior by overriding PACKAGESITE. For
example, on a FreeBSDÂ 8.1-RELEASE system, by default pkg_add(1) will try to
fetch packages from ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/
packages-8.1-release/Latest/. To force pkg_add(1) to download FreeBSDÂ 8-STABLE
packages, set PACKAGESITE to ftp://ftp.freebsd.org/pub/FreeBSD/ports/i386/
packages-8-stable/Latest/.

Package files are distributed in .tgz and .tbz formats. Packages are available
from ftp://ftp.FreeBSD.org/pub/FreeBSD/ports/packages/, or the /packages
directory of the FreeBSD DVD distribution. The layout of the packages directory
is similar to that of the /usr/ports tree. Each category has its own directory,
and every package can be found within the All directory.

5.4.2.Â Managing Packages

pkg_info(1) can be used to list and describe installed packages:

# pkg_info colordiff-1.0.13 A tool to colorize diff output docbook-1.2
Meta-port for the different versions of the DocBook DTD ...

pkg_version(1) summarizes the versions of all installed packages and compares
the package version to the current version found in the ports tree.

# pkg_version colordiff = docbook = ...

The symbols in the second column indicate the relative age of the installed
version and the version available in the local ports tree.

Symbol                                 Meaning
=      The version of the installed package matches the one in the local ports
       tree.
&lt;      The version of the installed package is older than the one in the local
       ports tree.
&gt;      The version of the installed package is newer than the one in the local
       ports tree, meaning that the local ports tree is probably out of date.
       The installed package cannot be found in the ports index. This can
?      happen when an installed port is removed from the Ports Collection or is
       renamed.
*      There are multiple versions of the package.
       The installed package exists in the index but for some reason,
!      pkg_version was unable to compare the version number of the installed
       package with the corresponding entry in the index.

5.4.3.Â Deleting a Package

To remove a previously installed software package, use pkg_delete(1):

# pkg_delete xchat-1.7.1

Note that pkg_delete(1) requires the full package name and number; the above
command would not work if xchat was given instead of xchat-1.7.1. Use
pkg_version(1) to find the version of the installed package, or use a wildcard:

# pkg_delete xchat\*

in this case, all packages whose names start with xchat will be deleted.

5.4.4.Â Miscellaneous

All package information, including the file list and descriptions of each
installed package is stored within the /var/db/pkg directory.

5.5.Â Using pkgng for Binary Package Management

pkgng is an improved replacement for the traditional FreeBSD package management
tools, offering many features that make dealing with binary packages faster and
easier. The first release of pkgng was in August, 2012.

pkgng is not a replacement for port management tools like ports-mgmt/portmaster
or ports-mgmt/portupgrade. While ports-mgmt/portmaster and ports-mgmt/
portupgrade can install third-party software from both binary packages and the
Ports Collection, pkgng installs only binary packages.

5.5.1.Â Getting Started with pkgng

FreeBSDÂ 9.1 and later includes a "bootstrap" utility for pkgng. The bootstrap
utility will download and install pkgng.

To bootstrap the system, run:

# /usr/sbin/pkg

For earlier FreeBSD versions, pkgng must be installed from the Ports
Collection, or as a binary package.

To install the pkgng port, run:

# cd /usr/ports/ports-mgmt/pkg # make # make install clean

To install the binary package, run:

# pkg_add -r pkg

Existing FreeBSD installations require conversion of the pkg_install package
database to the new format. To convert the package database, run:

# pkg2ng

This step is not required for new installations that do not have third-party
software installed.

Important:

This step is not reversible. Once the package database has been converted to
the pkgng format, the pkg_install tools should not be used.

Note:

The package database conversion may emit errors as the contents are converted
to the new version. Generally, these errors can be safely ignored, however a
list of third-party software that was not successfully converted will be listed
after pkg2ng has finished. These must be fixed by hand.

To ensure the FreeBSDÂ Ports Collection registers new software with pkgng, and
not pkg_install, FreeBSD versions earlier than 10.X require this line in /etc/
make.conf:

WITH_PKGNG= yes

5.5.2.Â Configuring the pkgng Environment

The pkgng package management system uses a package repository for most
operations. The default package repository location is defined in /usr/local/
etc/pkg.conf or the PACKAGESITE environment variable, which overrides the
configuration file.

Additional pkgng configuration options are described in pkg.conf(5).

5.5.3.Â Basic pkgng Operations

Usage information for pkgng is available in the pkg(8) manual page, or by
running pkg without additional arguments.

Each pkgng command argument is documented in a command-specific manual page. To
read the manual page for pkg install, for example, run either:

# pkg help install
# man pkg-install

5.5.3.1.Â Obtaining Information About Installed Packages with pkgng

Information about the packages installed on a system can be viewed by running
pkg info. Similar to pkg_info(1), the package version and description for all
packages will be listed.

Information about a specific package is available by running:

# pkg info packagename

For example, to see which version of pkgng is installed on the system, run:

# pkg info pkg pkg-1.0.2 New generation package manager

5.5.3.2.Â Installing and Removing Packages with pkgng

In general, most FreeBSD users will install binary packages by running:

# pkg install packagename

pkg install uses repository data, as mentioned in SectionÂ 5.5.2, â  
Configuring the pkgng Environmentâ  . Conversely, pkg-add(8) does not use
repository data, nor does it use the defined PACKAGESITE, so dependencies may
not be properly tracked, and missing dependencies will not be fetched from a
remote source. This section covers usage of pkg install. For information on
usage of pkg add, see pkg-add(8).

Additional binary packages can be installed with pkg install. For example, to
install curl:

# pkg install curl Updating repository catalogue Repository catalogue is
up-to-date, no need to fetch fresh copy The following packages will be
installed: Installing ca_root_nss: 3.13.5 Installing curl: 7.24.0 The
installation will require 4 MB more space 1 MB to be downloaded Proceed with
installing packages [y/N]: y ca_root_nss-3.13.5.txz 100% 255KB 255.1KB/s
255.1KB/s 00:00 curl-7.24.0.txz 100% 1108KB 1.1MB/s 1.1MB/s 00:00 Checking
integrity... done Installing ca_root_nss-3.13.5... done Installing
curl-7.24.0... done

The new package and any additional packages that were installed as dependencies
can be seen in the installed packages list:

# pkg info ca_root_nss-3.13.5 The root certificate bundle from the Mozilla
Project curl-7.24.0 Non-interactive tool to get files from FTP, GOPHER, HTTP(S)
servers pkg-1.0.2 New generation package manager

Packages that are no longer needed can be removed with pkg delete. For example,
if it turns out that curl is not needed after all:

# pkg delete curl The following packages will be deleted: curl-7.24.0_1 The
deletion will free 3 MB Proceed with deleting packages [y/N]: y Deleting
curl-7.24.0_1... done

5.5.3.3.Â Upgrading Installed Packages with pkgng

Packages that are outdated can be found with pkg version. If a local ports tree
does not exist, pkg-version(8) will use the remote repository catalogue,
otherwise the local ports tree will be used to identify package versions.

Packages can be upgraded to newer versions with pkgng. Suppose a new version of
curl has been released. The local package can be upgraded to the new version:

# pkg upgrade Updating repository catalogue repo.txz 100% 297KB 296.5KB/s
296.5KB/s 00:00 The following packages will be upgraded: Upgrading curl: 7.24.0
-&gt; 7.24.0_1 1 MB to be downloaded Proceed with upgrading packages [y/N]: y
curl-7.24.0_1.txz 100% 1108KB 1.1MB/s 1.1MB/s 00:00 Checking integrity... done
Upgrading curl from 7.24.0 to 7.24.0_1... done

5.5.3.4.Â Auditing Installed Packages with pkgng

Occasionally, software vulnerabilities may be discovered in software within the
Ports Collection. pkgng includes built-in auditing, similar to the ports-mgmt/
portaudit package. To audit the software installed on the system, run:

# pkg audit -F

5.5.4.Â Advanced pkgng Operations

5.5.4.1.Â Automatically Removing Leaf Dependencies with pkgng

Removing a package may leave behind unnecessary dependencies, like security/
ca_root_nss in the example above. Such packages are still installed, but
nothing depends on them any more. Unneeded packages that were installed as
dependencies can be automatically detected and removed:

# pkg autoremove Packages to be autoremoved: ca_root_nss-3.13.5 The autoremoval
will free 723 kB Proceed with autoremoval of packages [y/N]: y Deinstalling
ca_root_nss-3.13.5... done

5.5.4.2.Â Backing Up the pkgng Package Database

Unlike the traditional package management system, pkgng includes its own
package database backup mechanism. To manually back up the package database
contents, run:

# pkg backup -d pkgng.db

Note:

Replace the file name pkgng.db to a suitable file name.

Additionally, pkgng includes a periodic(8) script to automatically back up the
package database daily if daily_backup_pkgng_enable is set to YES in
periodic.conf(5).

Tip:

To prevent the pkg_install periodic script from also backing up the package
database, set daily_backup_pkgdb_enable to NO in periodic.conf(5).

To restore the contents of a previous package database backup, run:

# pkg backup -r /path/to/pkgng.db

5.5.4.3.Â Removing Stale pkgng Packages

By default, pkgng stores binary packages in a cache directory as defined by
PKG_CACHEDIR in pkg.conf(5). When upgrading packages with pkg upgrade, old
versions of the upgraded packages are not automatically removed.

To remove the outdated binary packages, run:

# pkg clean

5.5.4.4.Â Modifying pkgng Package Metadata

Historically, software within the FreeBSDÂ Ports Collection can undergo major
version number changes. Unlike pkg_install, pkgng has a built-in command to
update package origins. For example, if lang/php5 was originally at version
5.3, but has been renamed to lang/php53 for the inclusion of version 5.4, 
pkg_install would require the use of additional software such as ports-mgmt/
portmaster to update the package database, reflecting from which port the
installation originated.

Unlike the ports-mgmt/portmaster and ports-mgmt/portupgrade ports, the order in
which the new and old versions are listed differ. For pkgng, the syntax is:

# pkg set -o category/oldport:category/newport

For example, to change the package origin for the above example, run:

# pkg set -o lang/php5:lang/php53

As another example, to update lang/ruby18 to lang/ruby19, run:

# pkg set -o lang/ruby18:lang/ruby19

As a final example, to change the origin of the libglut shared libraries from
graphics/libglut to graphics/freeglut, run:

# pkg set -o graphics/libglut:graphics/freeglut

Note:

When changing package origins, in most cases it is important to reinstall
packages that are dependent on the package that has had the origin changed. To
force a reinstallation of dependent packages, run:

# pkg install -Rf graphics/freeglut

5.6.Â Using the Ports Collection

This section provides basic instructions on using the Ports Collection to
install or remove software. The detailed description of available make targets
and environment variables is available in ports(7).

Warning:

As of mid 2012, the FreeBSD Ports Project has migrated revision control systems
from CVS to Subversion. The preferred method for obtaining and maintaining the
ports tree is Portsnap. Users requiring local customization of ports (that is,
maintaining additional local patches) will probably prefer to use Subversion
directly. The CVSup service was phased out as of February 28, 2013.

5.6.1.Â Obtaining the Ports Collection

The Ports Collection is a set of Makefiles, patches, and description files
stored in /usr/ports. This set of files is used to compile and install
applications on FreeBSD. The instructions below show several methods of
obtaining the Ports Collection if it was not installed during initial FreeBSD
setup.

ProcedureÂ 5.1.Â Portsnap Method

Portsnap is a fast and user-friendly tool for retrieving the Ports Collection,
the preferred choice for most users. See Using Portsnap for a detailed
description of Portsnap.

 1. Download a compressed snapshot of the Ports Collection into /var/db/
    portsnap.

    # portsnap fetch
 2. When running Portsnap for the first time, extract the snapshot into /usr/
    ports:

    # portsnap extract
 3. After the first use of Portsnap has been completed as shown above, /usr/
    ports can be updated with:

    # portsnap fetch # portsnap update

ProcedureÂ 5.2.Â Subversion Method

If more control over the ports tree is needed (for example, for maintaining
local changes), Subversion can be used to obtain the Ports Collection. Refer to
the Subversion Primer for a detailed description of Subversion.

 1. Subversion must be installed before it can be used to check out the ports
    tree. If a copy of the ports tree is already present, install Subversion
    like this:

    # cd /usr/ports/devel/subversion # make install clean

    If the ports tree is not available, Subversion can be installed as a
    package:

    # pkg_add -r subversion

    If pkgng is being used to manage packages, Subversion can be installed with
    it instead:

    # pkg install subversion
 2. Check out a copy of the ports tree. Use a specific Subversion mirror close
    to your geographic location instead of svn0.us-east.FreeBSD.org in the
    command below for better performance. Committers should read the Subversion
    Primer first to be sure the correct protocol is chosen.

    # svn checkout https://svn0.us-east.FreeBSD.org/ports/head /usr/ports
 3. To update /usr/ports after the initial Subversion checkout:

    # svn update /usr/ports

ProcedureÂ 5.3.Â Sysinstall Method

This method involves using sysinstall to install the Ports Collection from the
installation media. Note that the old copy of Ports Collection from the date of
the release will be installed. If you have Internet access, you should always
use one of the methods mentioned above.

 1. As root, run sysinstall as shown below:

    # sysinstall
 2. Scroll down and select Configure, press Enter.

 3. Scroll down and select Distributions, press Enter.

 4. Scroll down to ports, press Space.

 5. Scroll up to Exit, press Enter.

 6. Select your desired installation media, such as CDROM, FTP, and so on.

 7. Scroll up to Exit and press Enter.

 8. Press X to exit sysinstall.

5.6.2.Â Migrating from CVSup/csup to portsnap

Warning:

By February 28, 2013, the ports tree will no longer be exported to CVS and
therefore CVSup and csup will no longer provide updates for the ports tree.

ProcedureÂ 5.4.Â Migration to Portsnap

The migration will require about 1Â GB of disk space on /usr, plus Portsnap
requires about 150Â MB disk space on /var.

 1. Disable any automated ports updates you may use, such as a cron(8) job
    calling CVSup or csup.

 2. Move the existing ports tree to a temporary location:

    # mv /usr/ports /usr/ports.old
 3. Fetch the new ports tree with Portsnap and extract it to /usr/ports:

    # portsnap fetch extract
 4. Move distfiles and saved packages to the new ports tree:

    # mv /usr/ports.old/distfiles /usr/ports # mv /usr/ports.old/packages /usr/
    ports
 5. Delete the old ports tree:

    # rm -rf /usr/ports.old
 6. If CVSup was used before, it can now be uninstalled:

    # pkg_delete -r -v cvsup-without-gui-\*

    Users of pkgng can use the following command:

    # pkg delete cvsup-without-gui

See Using Portsnap for a detailed description of Portsnap and how to update the
ports tree with Portsnap.

5.6.3.Â Installing Ports

A port skeleton is a set of files that tell FreeBSD system how to compile and
install a program. Each port skeleton includes:

  * Makefile: The Makefile contains statements that specify how the application
    should be compiled and where its components should be installed.

  * distinfo: This file contains information about the files that must be
    downloaded to build the port, and their checksums (using sha256(1)), to
    verify that files have not been corrupted during the download.

  * files/: This directory contains any patches needed for the program to
    compile and install on FreeBSD. This directory may also contain other files
    used to build the port.

  * pkg-descr: This file provides a more detailed description of the program.

  * pkg-plist: This is a list of all the files that will be installed by the
    port. It also tells the ports system what files to remove upon
    deinstallation.

Some ports include other files, such as pkg-message. The ports system uses
these files to handle special situations. If you want more details on these
files, and on ports in general, refer to the FreeBSD Porter's Handbook.

The port does not include the actual source code, also known as a â  distfileâ 
 . Source code is distributed in whatever manner the software author desires.
The two methods for installing a FreeBSD port are described below.

Note:

You must be logged in as root to install ports.

Warning:

Before compiling any port, be sure to have an up-to-date Ports Collection and
check http://vuxml.freebsd.org/ for security issues related to your port. If
ports-mgmt/portaudit is installed, run portaudit -F before installing a new
port, to fetch the current vulnerabilities database. A security audit and an
update of the database will be performed during the daily security system
check. For more information read the portaudit(1) and periodic(8) manual pages.

Using the Ports Collection assumes a working Internet connection. Otherwise,
manually obtain and place a copy of the distfile into /usr/ports/distfiles.

To begin, change to the directory of the port to be installed:

# cd /usr/ports/sysutils/lsof

To compile, or â  buildâ  , the port, type make at the prompt. You should see
messages similar to the ones in this example:

# make &gt;&gt; lsof_4.57D.freebsd.tar.gz doesn't seem to exist in /usr/ports/
distfiles/. &gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/
unix/lsof/. ===&gt; Extracting for lsof-4.57 ... [extraction output snipped] ...
&gt;&gt; Checksum OK for lsof_4.57D.freebsd.tar.gz. ===&gt; Patching for lsof-4.57 ===&gt;
Applying FreeBSD patches for lsof-4.57 ===&gt; Configuring for lsof-4.57 ...
[configure output snipped] ... ===&gt; Building for lsof-4.57 ... [compilation
output snipped] ... #

Once the compile is complete, you are returned to the prompt. The next step is
to install the port using make install:

# make install ===&gt; Installing for lsof-4.57 ... [installation output snipped]
... ===&gt; Generating temporary packing list ===&gt; Compressing manual pages for
lsof-4.57 ===&gt; Registering installation for lsof-4.57 ===&gt; SECURITY NOTE: This
port has installed the following binaries which execute with increased
privileges. #

Once you are returned to the prompt, you should be able to run the installed
application. Since lsof is a program that runs with increased privileges, a
security warning is shown. During the building and installation of ports, take
heed of any other warnings that may appear.

It is a good idea to delete the working subdirectory, which contains all the
temporary files used during compilation. Doing so saves disk space and
minimizes the chance of problems later when upgrading to the newer version of
the port.

# make clean ===&gt; Cleaning for lsof-4.57 #

Note:

You can save two extra steps by just running make install clean instead of
make, make install and make clean as three separate steps.

Note:

Using only make install means there will potentially be many waiting periods
between user interaction as the default behaviour is to prompt the user for
options. To avoid this when there are many dependencies, first run make
config-recursive to do the configuration in one batch. Then run make install
[clean] afterwards.

Tip:

When using config-recursive, the list of ports to configure are gathered by the
all-depends-list make(1) target. It is often recommended to run make
config-recursive until all dependent ports options have been defined, and ports
options dialog(1) screens no longer appear, to be certain all ports options
have been configured as intended.

Note:

Some shells keep a cache of the commands that are available in the directories
listed in the PATH environment variable, to speed up lookup operations for the
executable file of these commands. If you are using tcsh, you might have to
type rehash so that a newly installed command can be used without specifying
its full path. Use hash -r instead for the sh shell. Refer to the documentation
for the shell for more information.

Some third-party DVD products such as the FreeBSD Toolkit from the FreeBSD Mall
contain distfiles. They can be used with the Ports Collection. Mount the DVD on
/cdrom. If you use a different mount point, set CD_MOUNTPTS make variable. The
needed distfiles will be automatically used if they are present on the disk.

Note:

The licenses of a few ports do not allow their inclusion on the DVD. This could
be because a registration form needs to be filled out before downloading or
redistribution is not allowed. If you wish to install a port not included on
the DVD, you will need to be connected to the Internet.

The ports system uses fetch(1) to download the files, which honors various
environment variables, including FTP_PASSIVE_MODE, FTP_PROXY, and FTP_PASSWORD.
You may need to set one or more of these if you are behind a firewall, or need
to use an FTP/HTTP proxy. See fetch(3) for the complete list.

For users which cannot be connected all the time, the make fetch option is
provided. Run this command within /usr/ports and the required files will be
downloaded. This command also works in the lower level categories, such as /usr
/ports/net. Note that if a port depends on libraries or other ports, this will 
not fetch the distfiles of ports from another category. Use make
fetch-recursive to fetch all the dependencies of a port.

Note:

You can build all the ports in a category or as a whole by running make in the
top level directory. This is dangerous, however, as some ports cannot co-exist.
In other cases, some ports can install two different files with the same
filename.

In some rare cases, users may need to acquire the tarballs from a site other
than the default MASTER_SITES. You can override the MASTER_SITES option with
the following command:

# cd /usr/ports/directory # make MASTER_SITE_OVERRIDE= \ ftp://ftp.FreeBSD.org/
pub/FreeBSD/ports/distfiles/ fetch

In this example, MASTER_SITES is changed to ftp.FreeBSD.org/pub/FreeBSD/ports/
distfiles/.

Note:

Some ports provide build options which can be used to enable/disable parts of
the application which are unneeded, provide security options, or allow for
other customizations. Examples include www/firefox, security/gpgme, and mail/
sylpheed-claws. A menu will be displayed at the beginning of a port compile
when compile options are available.

5.6.3.1.Â Overriding the Default Ports Directories

The WRKDIRPREFIX and PREFIX variables can override the default working and
target directories. For example:

# make WRKDIRPREFIX=/usr/home/example/ports install

will compile the port in /usr/home/example/ports and install everything under /
usr/local.

# make PREFIX=/usr/home/example/local install

will compile the port in /usr/ports and install it in /usr/home/example/local.

And

# make WRKDIRPREFIX=../ports PREFIX=../local install

will combine the two.

Alternatively, these can be set as environmental variables. Refer to the manual
page for your shell for instructions on how to set an environmental variable.

5.6.3.2.Â Reconfiguring Ports

Certain ports provide an ncurses-based menu containing build options. There are
several ways to revisit this menu in order to add, remove, or change these
options after a port has been built. One method is to cd into the directory
containing the port and type make config. Another option is to use make
showconfig. Another option is to execute make rmconfig which will remove all
selected options and allow you to start over. All of these options, and others,
are explained in great detail in the manual page for ports(7).

5.6.4.Â Removing Installed Ports

Installed ports and packages are uninstalled using the pkg_delete(1) command:

# pkg_delete lsof-4.57

5.6.5.Â Upgrading Ports

First, list outdated ports that have a newer version available in the Ports
Collection with the pkg_version(1) command:

# pkg_version -v

5.6.5.1.Â Read /usr/ports/UPDATING

Once you have updated your Ports Collection, before attempting a port upgrade,
you should check /usr/ports/UPDATING. This file describes various issues and
additional steps users may encounter and need to perform when updating a port,
including such things as file format changes, changes in locations of
configuration files, or other such incompatibilities with previous versions.

If UPDATING contradicts something you read here, UPDATING takes precedence.

5.6.5.2.Â Upgrading Ports Using Portupgrade

The portupgrade utility is designed to easily upgrade installed ports. It is
available from the ports-mgmt/portupgrade port. Install it like any other port,
using make install clean:

# cd /usr/ports/ports-mgmt/portupgrade # make install clean

Scan the list of installed ports using pkgdb -F and fix all the inconsistencies
it reports. It is a good idea to do this regularly, before every upgrade.

Use portupgrade -a to upgrade all the outdated ports installed on the system.
Include -i to be asked for confirmation of every individual upgrade.

# portupgrade -ai

To upgrade only a specified application instead of all available ports, use
portupgrade pkgname. Include -R to first upgrade all the ports required by the
given application.

# portupgrade -R firefox

To use packages instead of ports, include the -P flag. With this option, 
portupgrade searches the local directories listed in PKG_PATH, then fetches
packages from a remote site if not found locally. If packages can not be found
locally or fetched remotely, portupgrade will use ports. To avoid using ports,
specify -PP.

# portupgrade -PP gnome2

To just fetch distfiles (or packages, if -P is specified) without building or
installing anything, use -F. For further information see portupgrade(1).

5.6.5.3.Â Upgrading Ports Using portmaster

ports-mgmt/portmaster is another utility for upgrading installed ports. 
portmaster was designed to use the tools found in the â  baseâ   system without
depending upon other ports. It uses the information in /var/db/pkg/ to
determine which ports to upgrade. To install the port:

# cd /usr/ports/ports-mgmt/portmaster # make install clean

Portmaster groups ports into four categories:

  * Root ports: no dependencies and is not depended on by other ports

  * Trunk ports: no dependencies, but other ports depend upon it

  * Branch ports: have dependencies and are depended upon by other ports

  * Leaf ports: have dependencies but are not depended upon by other ports

To list all installed software and search for updates, use -L:

# portmaster -L ===&gt;&gt;&gt; Root ports (No dependencies, not depended on) ===&gt;&gt;&gt;
ispell-3.2.06_18 ===&gt;&gt;&gt; screen-4.0.3 ===&gt;&gt;&gt; New version available:
screen-4.0.3_1 ===&gt;&gt;&gt; tcpflow-0.21_1 ===&gt;&gt;&gt; 7 root ports ... ===&gt;&gt;&gt; Branch
ports (Have dependencies, are depended on) ===&gt;&gt;&gt; apache22-2.2.3 ===&gt;&gt;&gt; New
version available: apache22-2.2.8 ... ===&gt;&gt;&gt; Leaf ports (Have dependencies, not
depended on) ===&gt;&gt;&gt; automake-1.9.6_2 ===&gt;&gt;&gt; bash-3.1.17 ===&gt;&gt;&gt; New version
available: bash-3.2.33 ... ===&gt;&gt;&gt; 32 leaf ports ===&gt;&gt;&gt; 137 total installed
ports ===&gt;&gt;&gt; 83 have new versions available

All the installed ports can be upgraded using this command:

# portmaster -a

Note:

By default, portmaster will make a backup package before deleting the existing
port. If the installation of the new version is successful, portmaster will
delete the backup. Using -b will instruct portmaster not to automatically
delete the backup. Adding -i will start portmaster in interactive mode,
prompting for confirmation before upgrading each port.

If you encounter errors during the upgrade process, use -f to upgrade/rebuild
all ports:

# portmaster -af

You can also use portmaster to install new ports on the system, upgrading all
dependencies before building and installing the new port:

# portmaster shells/bash

Refer to portmaster(8) for more information.

5.6.6.Â Ports and Disk Space

Using the Ports Collection will use up disk space over time. After building and
installing a port, make clean will clean up the temporary work directory. To
sweep the whole Ports Collection:

# portsclean -C

A lot of out-dated source distribution files will collect in distfiles over
time. The following command will delete all the distfiles that are no longer
referenced by any ports:

# portsclean -D

To remove all distfiles not referenced by any port currently installed on the
system:

# portsclean -DD

Note:

The portsclean utility is part of the ports-mgmt/portupgrade suite.

ports-mgmt/pkg_cutleaves automates the task of removing installed ports that
are no longer needed.

5.7.Â Post-installation Activities

After installing a new application you will normally want to read any
documentation it may have included, edit any required configuration files, and
ensure that the application's service starts at boot time.

The exact steps you need to take to configure each application will obviously
be different. However, if you have just installed a new application and are
wondering â  What now?â   these tips might help:

  * Use pkg_info(1) to find out which files were installed, and where. For
    example, if you have just installed FooPackage version 1.0.0, then this
    command

    # pkg_info -L foopackage-1.0.0 | less

    will show all the files installed by the package. Pay special attention to
    files located in man/, which will be manual pages, etc/, which will be
    configuration files, and doc/, which will be more comprehensive
    documentation.

    To determine which version of the application was installed:

    # pkg_info | grep -i foopackage

    will find all the installed packages that have foopackage in the package
    name. Replace foopackage as necessary.

  * Once you have identified where the application's manual pages have been
    installed, review them using man(1). Review the sample configuration files
    and any additional documentation that may have been provided.

  * If the application has a web site, check it for additional documentation,
    frequently asked questions, and so forth. If you are not sure of the web
    site address it may be listed in the output from

    # pkg_info foopackage-1.0.0

    A WWW: line, if present, should provide a URL for the application's web
    site.

  * Ports that should start at boot time usually install a startup script in /
    usr/local/etc/rc.d. Review this script for correctness and edit or rename
    it if needed. See Starting Services for more information.

5.8.Â Dealing with Broken Ports

When coming across a port that does not build or install:

 1. Find out if there is a fix pending for the port in the Problem Report
    database. If so, the proposed fix may work.

 2. Ask the maintainer of the port for help. Type make maintainer or read the
    Makefile to find the maintainer's email address. Remember to include the
    name and version of the port (send the $FreeBSD: line from the Makefile)
    and the output leading up to the error when you email the maintainer.

    Note:

    Some ports are not maintained by an individual but instead by a mailing
    list. Many, but not all, of these addresses look like &lt;
    freebsd-listname@FreeBSD.org&gt;. Please take this into account when phrasing
    your questions.

    In particular, ports shown as maintained by &lt;ports@FreeBSD.org&gt; are
    actually not maintained by anyone. Fixes and support, if any, come from the
    general community who subscribe to that mailing list. More volunteers are
    always needed!

    If you do not get a response, use send-pr(1) to submit a bug report (see
    Writing FreeBSD Problem Reports).

 3. Fix it! The Porter's Handbook includes detailed information on the â  Ports
    â   infrastructure so that you can fix the occasional broken port or even
    submit your own!

 4. Use pkg_add(1) to instead install the package.

ChapterÂ 6.Â The X Window System

Updated for X.Org's X11 server by Ken Tom and Marc Fonvieille.
Table of Contents

6.1. Synopsis
6.2. Understanding X
6.3. Installing X11
6.4. X11 Configuration
6.5. Using Fonts in X11
6.6. The X Display Manager
6.7. Desktop Environments

6.1.Â Synopsis

FreeBSD uses X11 to provide users with a powerful graphical user interface. X11
is a freely available version of the X Window System that is implemented in 
Xorg (and other software packages not discussed here). The default and official
flavor of X11 in FreeBSD is Xorg, the X11 server developed by the X.Org
Foundation under a license very similar to the one used by FreeBSD.

For more information on the video hardware that X11 supports, check the Xorg
web site.

After reading this chapter, you will know:

  * The various components of the X Window System, and how they interoperate.

  * How to install and configure X11.

  * How to install and use different window managers.

  * How to use TrueTypeÂ® fonts in X11.

  * How to set up your system for graphical logins (XDM).

Before reading this chapter, you should:

  * Know how to install additional third-party software (ChapterÂ 5, Installing
    Applications: Packages and Ports).

6.2.Â Understanding X

Using X for the first time can be somewhat of a shock to someone familiar with
other graphical environments, such as MicrosoftÂ®Â WindowsÂ® or MacÂ OSÂ®.

While it is not necessary to understand all of the details of various X
components and how they interact, some basic knowledge makes it possible to
take advantage of X's strengths.

6.2.1.Â Why X?

X is not the first window system written for UNIXÂ®, but it is the most popular
of them. X's original development team had worked on another window system
prior to writing X. That system's name was â  Wâ   (for â  Windowâ  ). X was
just the next letter in the Roman alphabet.

X can be called â  Xâ  , â  X Window Systemâ  , â  X11â  , and a number of
other terms. You may find that using the term â  X Windowsâ   to describe X11
can be offensive to some people; for a bit more insight on this, see X(7).

6.2.2.Â The X Client/Server Model

X was designed from the beginning to be network-centric, and adopts a â  
client-serverâ   model.

In the X model, the â  X serverâ   runs on the computer that has the keyboard,
monitor, and mouse attached. The server's responsibility includes tasks such as
managing the display, handling input from the keyboard and mouse, and other
input or output devices (i.e., a â  tabletâ   can be used as an input device,
and a video projector may be an alternative output device). Each X application
(such as XTerm or Firefox) is a â  clientâ  . A client sends messages to the
server such as â  Please draw a window at these coordinatesâ  , and the server
sends back messages such as â  The user just clicked on the OK buttonâ  .

In a home or small office environment, the X server and the X clients commonly
run on the same computer. However, it is perfectly possible to run the X server
on a less powerful desktop computer, and run X applications (the clients) on,
say, the powerful and expensive machine that serves the office. In this
scenario the communication between the X client and server takes place over the
network.

This confuses some people, because the X terminology is exactly backward to
what they expect. They expect the â  X serverâ   to be the big powerful machine
down the hall, and the â  X clientâ   to be the machine on their desk.

It is important to remember that the X server is the machine with the monitor
and keyboard, and the X clients are the programs that display the windows.

There is nothing in the protocol that forces the client and server machines to
be running the same operating system, or even to be running on the same type of
computer. It is certainly possible to run an X server on MicrosoftÂ®Â WindowsÂ®
or Apple's MacÂ OSÂ®, and there are various free and commercial applications
available that do exactly that.

6.2.3.Â The Window Manager

The X design philosophy is much like the UNIXÂ® design philosophy, â  tools,
not policyâ  . This means that X does not try to dictate how a task is to be
accomplished. Instead, tools are provided to the user, and it is the user's
responsibility to decide how to use those tools.

This philosophy extends to X not dictating what windows should look like on
screen, how to move them around with the mouse, what keystrokes should be used
to move between windows (i.e., Alt+Tab, in the case of MicrosoftÂ®Â WindowsÂ®),
what the title bars on each window should look like, whether or not they have
close buttons on them, and so on.

Instead, X delegates this responsibility to an application called a â  Window
Managerâ  . There are dozens of window managers available for X. Each of these
window managers provides a different look and feel; some of them support â  
virtual desktopsâ  ; some of them allow customized keystrokes to manage the
desktop; some have a â  Startâ   button or similar device; some are â  
themeableâ  , allowing a complete change of look-and-feel by applying a new
theme. Window managers are available in the x11-wm category of the Ports
Collection.

In addition, the KDE and GNOME desktop environments both have their own window
managers which integrate with the desktop.

Each window manager also has a different configuration mechanism; some expect
configuration file written by hand, others feature GUI tools for most of the
configuration tasks; at least one (Sawfish) has a configuration file written in
a dialect of the Lisp language.

Focus Policy:

Another feature the window manager is responsible for is the mouse â  focus
policyâ  . Every windowing system needs some means of choosing a window to be
actively receiving keystrokes, and should visibly indicate which window is
active as well.

A familiar focus policy is called â  click-to-focusâ  . This is the model
utilized by MicrosoftÂ®Â WindowsÂ®, in which a window becomes active upon
receiving a mouse click.

X does not support any particular focus policy. Instead, the window manager
controls which window has the focus at any one time. Different window managers
will support different focus methods. All of them support click to focus, and
the majority of them support several others.

The most popular focus policies are:

focus-follows-mouse

    The window that is under the mouse pointer is the window that has the
    focus. This may not necessarily be the window that is on top of all the
    other windows. The focus is changed by pointing at another window, there is
    no need to click in it as well.

sloppy-focus

    This policy is a small extension to focus-follows-mouse. With
    focus-follows-mouse, if the mouse is moved over the root window (or
    background) then no window has the focus, and keystrokes are simply lost.
    With sloppy-focus, focus is only changed when the cursor enters a new
    window, and not when exiting the current window.

click-to-focus

    The active window is selected by mouse click. The window may then be â  
    raisedâ  , and appear in front of all other windows. All keystrokes will
    now be directed to this window, even if the cursor is moved to another
    window.

Many window managers support other policies, as well as variations on these. Be
sure to consult the documentation for the window manager itself.

6.2.4.Â Widgets

The X approach of providing tools and not policy extends to the widgets seen on
screen in each application.

â  Widgetâ   is a term for all the items in the user interface that can be
clicked or manipulated in some way; buttons, check boxes, radio buttons, icons,
lists, and so on. MicrosoftÂ®Â WindowsÂ® calls these â  controlsâ  .

MicrosoftÂ®Â WindowsÂ® and Apple's MacÂ OSÂ® both have a very rigid widget
policy. Application developers are supposed to ensure that their applications
share a common look and feel. With X, it was not considered sensible to mandate
a particular graphical style, or set of widgets to adhere to.

As a result, do not expect X applications to have a common look and feel. There
are several popular widget sets and variations, including Qt, used by KDE, and
GTK+, used by the GNOME project. In this respect, there is some convergence in
look-and-feel of the UNIXÂ® desktop, which certainly makes things easier for
the novice user.

6.3.Â Installing X11

Xorg is the X11 implementation for FreeBSD. Xorg is the X server of the open
source X Window System implementation released by the X.Org Foundation. Xorg is
based on the code of XFree86â ¢Â 4.4RC2 and X11R6.6. The version of Xorg
currently available in the FreeBSD Ports Collection is 7.7.

To build and install Xorg from the Ports Collection:

# cd /usr/ports/x11/xorg # make install clean

Note:

To build Xorg in its entirety, be sure to have at least 4Â GB of free space
available.

Alternatively, X11 can be installed directly from packages. Binary packages to
use with pkg_add(1) tool are also available for X11. When the remote fetching
feature of pkg_add(1) is used, the version number of the package must be
removed. pkg_add(1) will automatically fetch the latest version of the
application.

So to fetch and install the package of Xorg, simply type:

# pkg_add -r xorg

Note:

The examples above will install the complete X11 distribution including the
servers, clients, fonts etc. Separate packages and ports of X11 are also
available.

To install a minimal X11 distribution you can alternatively install x11/
xorg-minimal.

The rest of this chapter will explain how to configure X11, and how to set up a
productive desktop environment.

6.4.Â X11 Configuration

Contributed by Christopher Shumway.

6.4.1.Â Before Starting

In most cases, X11 is self-configuring. Those with older or unusual equipment
may find it helpful to gather some hardware information before beginning
configuration.

  * Monitor sync frequencies

  * Video card chipset

  * Video card memory

Screen resolution and refresh rate are determined by the monitor's horizontal
and vertical sync frequencies. Almost all monitors support electronic
autodetection of these values. A few monitors do not provide these values, and
the specifications must be determined from the printed manual or manufacturer
web site.

The video card chipset is also autodetected, and used to select the proper
video driver. It is beneficial for the user to be aware of which chipset is
installed for when autodetection does not provide the desired result.

Video card memory determines the maximum resolution and color depth which can
be displayed.

6.4.2.Â Configuring X11

Xorg uses HAL to autodetect keyboards and mice. The sysutils/hal and devel/dbus
ports are installed as dependencies of x11/xorg, but must be enabled by the
following entries in the /etc/rc.conf file:

hald_enable="YES" dbus_enable="YES"

These services should be started (either manually or by rebooting) before
further Xorg configuration or use is attempted.

Xorg can often work without any further configuration steps by simply typing at
prompt:

% startx

The automatic configuration may fail to work with some hardware, or may not set
things up quite as desired. In these cases, manual configuration will be
necessary.

Note:

Desktop environments like GNOME, KDE or Xfce have tools allowing the user to
easily set the screen parameters such as the resolution. So if the default
configuration is not acceptable and you planned to install a desktop
environment then just continue with the installation of the desktop environment
and use the appropriate screen settings tool.

Configuration of X11 is a multi-step process. The first step is to build an
initial configuration file. As the super user, simply run:

# Xorg -configure

This will generate an X11 configuration skeleton file in the /root directory
called xorg.conf.new (whether you su(1) or do a direct login affects the
inherited supervisor $HOME directory variable). The X11 program will attempt to
probe the graphics hardware on the system and write a configuration file to
load the proper drivers for the detected hardware on the target system.

The next step is to test the existing configuration to verify that Xorg can
work with the graphics hardware on the target system. Type:

# Xorg -config xorg.conf.new -retro

If a black and grey grid and an X mouse cursor appear, the configuration was
successful. To exit the test, switch to the virtual console used to start it by
pressing Ctrl+Alt+Fn (F1 for the first virtual console) and press Ctrl+C.

Note:

The Ctrl+Alt+Backspace key combination may also be used to break out of Xorg.
To enable it, you can either type the following command from any X terminal
emulator:

% setxkbmap -option terminate:ctrl_alt_bksp

or create a keyboard configuration file for hald called x11-input.fdi and saved
in the /usr/local/etc/hal/fdi/policy directory. This file should contain the
following lines:

&lt;?xml version="1.0" encoding="iso-8859-1"?&gt; &lt;deviceinfo version="0.2"&gt; &lt;device&gt;
&lt;match key="info.capabilities" contains="input.keyboard"&gt; &lt;merge key=
"input.x11_options.XkbOptions" type="string"&gt;terminate:ctrl_alt_bksp&lt;/merge&gt; &lt;/
match&gt; &lt;/device&gt; &lt;/deviceinfo&gt;

You will have to reboot your machine to force hald to read this file.

The following line will also have to be added to xorg.conf.new, in the
ServerLayout or ServerFlags section:

Option "DontZap" "off"

If the mouse does not work, you will need to first configure it before
proceeding. See SectionÂ 3.10.9, â  Mouse Settingsâ   in the FreeBSD install
chapter. In recent Xorg versions, the InputDevice sections in xorg.conf are
ignored in favor of the autodetected devices. To restore the old behavior, add
the following line to the ServerLayout or ServerFlags section of this file:

Option "AutoAddDevices" "false"

Input devices may then be configured as in previous versions, along with any
other options needed (e.g., keyboard layout switching).

Note:

As previously explained the hald daemon will, by default, automatically detect
your keyboard. There are chances that your keyboard layout or model will not be
correct, desktop environments like GNOME, KDE or Xfce provide tools to
configure the keyboard. However, it is possible to set the keyboard properties
directly either with the help of the setxkbmap(1) utility or with a hald's
configuration rule.

For example if one wants to use a PC 102 keys keyboard coming with a french
layout, we have to create a keyboard configuration file for hald called
x11-input.fdi and saved in the /usr/local/etc/hal/fdi/policy directory. This
file should contain the following lines:

&lt;?xml version="1.0" encoding="iso-8859-1"?&gt; &lt;deviceinfo version="0.2"&gt; &lt;device&gt;
&lt;match key="info.capabilities" contains="input.keyboard"&gt; &lt;merge key=
"input.x11_options.XkbModel" type="string"&gt;pc102&lt;/merge&gt; &lt;merge key=
"input.x11_options.XkbLayout" type="string"&gt;fr&lt;/merge&gt; &lt;/match&gt; &lt;/device&gt; &lt;/
deviceinfo&gt;

If this file already exists, just copy and add to your file the lines regarding
the keyboard configuration.

You will have to reboot your machine to force hald to read this file.

It is possible to do the same configuration from an X terminal or a script with
this command line:

% setxkbmap -model pc102 -layout fr

The /usr/local/share/X11/xkb/rules/base.lst file lists the various keyboard,
layouts and options available.

The xorg.conf.new configuration file may now be tuned to taste. Open the file
in a text editor such as emacs(1) or ee(1). If the monitor is an older or
unusual model that does not support autodetection of sync frequencies, those
settings can be added to xorg.conf.new under the "Monitor" section:

Section "Monitor" Identifier "Monitor0" VendorName "Monitor Vendor" ModelName
"Monitor Model" HorizSync 30-107 VertRefresh 48-120 EndSection

Most monitors support sync frequency autodetection, making manual entry of
these values unnecessary. For the few monitors that do not support
autodetection, avoid potential damage by only entering values provided by the
manufacturer.

X allows DPMS (Energy Star) features to be used with capable monitors. The xset
(1) program controls the time-outs and can force standby, suspend, or off
modes. If you wish to enable DPMS features for your monitor, you must add the
following line to the monitor section:

Option "DPMS"

While the xorg.conf.new configuration file is still open in an editor, select
the default resolution and color depth desired. This is defined in the "Screen"
section:

Section "Screen" Identifier "Screen0" Device "Card0" Monitor "Monitor0"
DefaultDepth 24 SubSection "Display" Viewport 0 0 Depth 24 Modes "1024x768"
EndSubSection EndSection

The DefaultDepth keyword describes the color depth to run at by default. This
can be overridden with the -depth command line switch to Xorg(1). The Modes
keyword describes the resolution to run at for the given color depth. Note that
only VESA standard modes are supported as defined by the target system's
graphics hardware. In the example above, the default color depth is twenty-four
bits per pixel. At this color depth, the accepted resolution is 1024 by 768
pixels.

Finally, write the configuration file and test it using the test mode given
above.

Note:

One of the tools available to assist you during troubleshooting process are the
X11 log files, which contain information on each device that the X11 server
attaches to. Xorg log file names are in the format of /var/log/Xorg.0.log. The
exact name of the log can vary from Xorg.0.log to Xorg.8.log and so forth.

If all is well, the configuration file needs to be installed in a common
location where Xorg(1) can find it. This is typically /etc/X11/xorg.conf or /
usr/local/etc/X11/xorg.conf.

# cp xorg.conf.new /etc/X11/xorg.conf

The X11 configuration process is now complete. Xorg may be now started with the
startx(1) utility. The X11 server may also be started with the use of xdm(1).

6.4.3.Â Advanced Configuration Topics

6.4.3.1.Â Configuration with IntelÂ® i810 Graphics Chipsets

Configuration with IntelÂ® i810 integrated chipsets requires the agpgart AGP
programming interface for X11 to drive the card. See the agp(4) driver manual
page for more information.

This will allow configuration of the hardware as any other graphics board. Note
on systems without the agp(4) driver compiled in the kernel, trying to load the
module with kldload(8) will not work. This driver has to be in the kernel at
boot time through being compiled in or using /boot/loader.conf.

6.4.3.2.Â Adding a Widescreen Flatpanel to the Mix

This section assumes a bit of advanced configuration knowledge. If attempts to
use the standard configuration tools above have not resulted in a working
configuration, there is information enough in the log files to be of use in
getting the setup working. Use of a text editor will be necessary.

Current widescreen (WSXGA, WSXGA+, WUXGA, WXGA, WXGA+, et.al.) formats support
16:10 and 10:9 formats or aspect ratios that can be problematic. Examples of
some common screen resolutions for 16:10 aspect ratios are:

  * 2560x1600

  * 1920x1200

  * 1680x1050

  * 1440x900

  * 1280x800

At some point, it will be as easy as adding one of these resolutions as a
possible Mode in the Section "Screen" as such:

Section "Screen" Identifier "Screen0" Device "Card0" Monitor "Monitor0"
DefaultDepth 24 SubSection "Display" Viewport 0 0 Depth 24 Modes "1680x1050"
EndSubSection EndSection

Xorg is smart enough to pull the resolution information from the widescreen via
I2C/DDC information so it knows what the monitor can handle as far as
frequencies and resolutions.

If those ModeLines do not exist in the drivers, one might need to give Xorg a
little hint. Using /var/log/Xorg.0.log one can extract enough information to
manually create a ModeLine that will work. Simply look for information
resembling this:

(II) MGA(0): Supported additional Video Mode: (II) MGA(0): clock: 146.2 MHz
Image Size: 433 x 271 mm (II) MGA(0): h_active: 1680 h_sync: 1784 h_sync_end
1960 h_blank_end 2240 h_border: 0 (II) MGA(0): v_active: 1050 v_sync: 1053
v_sync_end 1059 v_blanking: 1089 v_border: 0 (II) MGA(0): Ranges: V min: 48 V
max: 85 Hz, H min: 30 H max: 94 kHz, PixClock max 170 MHz

This information is called EDID information. Creating a ModeLine from this is
just a matter of putting the numbers in the correct order:

ModeLine &lt;name&gt; &lt;clock&gt; &lt;4 horiz. timings&gt; &lt;4 vert. timings&gt;

So that the ModeLine in Section "Monitor" for this example would look like
this:

Section "Monitor" Identifier "Monitor1" VendorName "Bigname" ModelName
"BestModel" ModeLine "1680x1050" 146.2 1680 1784 1960 2240 1050 1053 1059 1089
Option "DPMS" EndSection

Now having completed these simple editing steps, X should start on your new
widescreen monitor.

6.5.Â Using Fonts in X11

Contributed by Murray Stokely.

6.5.1.Â Type1 Fonts

The default fonts that ship with X11 are less than ideal for typical desktop
publishing applications. Large presentation fonts show up jagged and
unprofessional looking, and small fonts are almost completely unintelligible.
However, there are several free, high quality Type1 (PostScriptÂ®) fonts
available which can be readily used with X11. For instance, the URW font
collection (x11-fonts/urwfonts) includes high quality versions of standard
type1 fonts (Times RomanÂ®, HelveticaÂ®, PalatinoÂ® and others). The Freefonts
collection (x11-fonts/freefonts) includes many more fonts, but most of them are
intended for use in graphics software such as the Gimp, and are not complete
enough to serve as screen fonts. In addition, X11 can be configured to use 
TrueTypeÂ® fonts with a minimum of effort. For more details on this, see the X
(7) manual page or the section on TrueTypeÂ® fonts.

To install the above Type1 font collections from the Ports Collection, run the
following commands:

# cd /usr/ports/x11-fonts/urwfonts # make install clean

And likewise with the freefont or other collections. To have the X server
detect these fonts, add an appropriate line to the X server configuration file
(/etc/X11/xorg.conf), which reads:

FontPath "/usr/local/lib/X11/fonts/URW/"

Alternatively, at the command line in the X session run:

% xset fp+ /usr/local/lib/X11/fonts/URW % xset fp rehash

This will work but will be lost when the X session is closed, unless it is
added to the startup file (~/.xinitrc for a normal startx session, or ~
/.xsession when logging in through a graphical login manager like XDM). A third
way is to use the new /usr/local/etc/fonts/local.conf file: see the section on
anti-aliasing.

6.5.2.Â TrueTypeÂ® Fonts

Xorg has built in support for rendering TrueTypeÂ® fonts. There are two
different modules that can enable this functionality. The freetype module is
used in this example because it is more consistent with the other font
rendering back-ends. To enable the freetype module just add the following line
to the "Module" section of the /etc/X11/xorg.conf file.

Load "freetype"

Now make a directory for the TrueTypeÂ® fonts (for example, /usr/local/lib/X11/
fonts/TrueType) and copy all of the TrueTypeÂ® fonts into this directory. Keep
in mind that TrueTypeÂ® fonts cannot be directly taken from a MacintoshÂ®; they
must be in UNIXÂ®/MS-DOSÂ®/WindowsÂ® format for use by X11. Once the files have
been copied into this directory, use ttmkfdir to create a fonts.dir file, so
that the X font renderer knows that these new files have been installed.
ttmkfdir is available from the FreeBSD Ports Collection as x11-fonts/ttmkfdir.

# cd /usr/local/lib/X11/fonts/TrueType # ttmkfdir -o fonts.dir

Now add the TrueTypeÂ® directory to the font path. This is just the same as
described above for Type1 fonts, that is, use

% xset fp+ /usr/local/lib/X11/fonts/TrueType % xset fp rehash

or add a FontPath line to the xorg.conf file.

That's it. Now Gimp, Apache OpenOffice, and all of the other X applications
should now recognize the installed TrueTypeÂ® fonts. Extremely small fonts (as
with text in a high resolution display on a web page) and extremely large fonts
(within StarOfficeâ ¢) will look much better now.

6.5.3.Â Anti-Aliased Fonts

Updated by Joe Marcus Clarke.

All fonts in X11 that are found in /usr/local/lib/X11/fonts/ and ~/.fonts/ are
automatically made available for anti-aliasing to Xft-aware applications. Most
recent applications are Xft-aware, including KDE, GNOME, and Firefox.

In order to control which fonts are anti-aliased, or to configure anti-aliasing
properties, create (or edit, if it already exists) the file /usr/local/etc/
fonts/local.conf. Several advanced features of the Xft font system can be tuned
using this file; this section describes only some simple possibilities. For
more details, please see fonts-conf(5).

This file must be in XML format. Pay careful attention to case, and make sure
all tags are properly closed. The file begins with the usual XML header
followed by a DOCTYPE definition, and then the &lt;fontconfig&gt; tag:

&lt;?xml version="1.0"?&gt; &lt;!DOCTYPE fontconfig SYSTEM "fonts.dtd"&gt; &lt;fontconfig&gt;

As previously stated, all fonts in /usr/local/lib/X11/fonts/ as well as ~
/.fonts/ are already made available to Xft-aware applications. If you wish to
add another directory outside of these two directory trees, add a line similar
to the following to /usr/local/etc/fonts/local.conf:

&lt;dir&gt;/path/to/my/fonts&lt;/dir&gt;

After adding new fonts, and especially new font directories, you should run the
following command to rebuild the font caches:

# fc-cache -f

Anti-aliasing makes borders slightly fuzzy, which makes very small text more
readable and removes â  staircasesâ   from large text, but can cause eyestrain
if applied to normal text. To exclude font sizes smaller than 14 point from
anti-aliasing, include these lines:

&lt;match target="font"&gt; &lt;test name="size" compare="less"&gt; &lt;double&gt;14&lt;/double&gt; &lt;/
test&gt; &lt;edit name="antialias" mode="assign"&gt; &lt;bool&gt;false&lt;/bool&gt; &lt;/edit&gt; &lt;/match&gt;
&lt;match target="font"&gt; &lt;test name="pixelsize" compare="less" qual="any"&gt;
&lt;double&gt;14&lt;/double&gt; &lt;/test&gt; &lt;edit mode="assign" name="antialias"&gt; &lt;bool&gt;false&lt;/
bool&gt; &lt;/edit&gt; &lt;/match&gt;

Spacing for some monospaced fonts may also be inappropriate with anti-aliasing.
This seems to be an issue with KDE, in particular. One possible fix for this is
to force the spacing for such fonts to be 100. Add the following lines:

&lt;match target="pattern" name="family"&gt; &lt;test qual="any" name="family"&gt; &lt;string&gt;
fixed&lt;/string&gt; &lt;/test&gt; &lt;edit name="family" mode="assign"&gt; &lt;string&gt;mono&lt;/string&gt;
&lt;/edit&gt; &lt;/match&gt; &lt;match target="pattern" name="family"&gt; &lt;test qual="any" name=
"family"&gt; &lt;string&gt;console&lt;/string&gt; &lt;/test&gt; &lt;edit name="family" mode="assign"&gt;
&lt;string&gt;mono&lt;/string&gt; &lt;/edit&gt; &lt;/match&gt;

(this aliases the other common names for fixed fonts as "mono"), and then add:

&lt;match target="pattern" name="family"&gt; &lt;test qual="any" name="family"&gt; &lt;string&gt;
mono&lt;/string&gt; &lt;/test&gt; &lt;edit name="spacing" mode="assign"&gt; &lt;int&gt;100&lt;/int&gt; &lt;/
edit&gt; &lt;/match&gt;

Certain fonts, such as Helvetica, may have a problem when anti-aliased. Usually
this manifests itself as a font that seems cut in half vertically. At worst, it
may cause applications to crash. To avoid this, consider adding the following
to local.conf:

&lt;match target="pattern" name="family"&gt; &lt;test qual="any" name="family"&gt; &lt;string&gt;
Helvetica&lt;/string&gt; &lt;/test&gt; &lt;edit name="family" mode="assign"&gt; &lt;string&gt;
sans-serif&lt;/string&gt; &lt;/edit&gt; &lt;/match&gt;

Once you have finished editing local.conf make sure you end the file with the
&lt;/fontconfig&gt; tag. Not doing this will cause your changes to be ignored.

Finally, users can add their own settings via their personal .fonts.conf files.
To do this, each user should simply create a ~/.fonts.conf. This file must also
be in XML format.

One last point: with an LCD screen, sub-pixel sampling may be desired. This
basically treats the (horizontally separated) red, green and blue components
separately to improve the horizontal resolution; the results can be dramatic.
To enable this, add the line somewhere in the local.conf file:

&lt;match target="font"&gt; &lt;test qual="all" name="rgba"&gt; &lt;const&gt;unknown&lt;/const&gt; &lt;/
test&gt; &lt;edit name="rgba" mode="assign"&gt; &lt;const&gt;rgb&lt;/const&gt; &lt;/edit&gt; &lt;/match&gt;

Note:

Depending on the sort of display, rgb may need to be changed to bgr, vrgb or
vbgr: experiment and see which works best.

6.6.Â The X Display Manager

Contributed by Seth Kingsley.

6.6.1.Â Overview

The X Display Manager (XDM) is an optional part of the X Window System that is
used for login session management. This is useful for several types of
situations, including minimal â  X Terminalsâ  , desktops, and large network
display servers. Since the X Window System is network and protocol independent,
there are a wide variety of possible configurations for running X clients and
servers on different machines connected by a network. XDM provides a graphical
interface for choosing which display server to connect to, and entering
authorization information such as a login and password combination.

Think of XDM as providing the same functionality to the user as the getty(8)
utility (see SectionÂ 27.3.2, â  Configurationâ   for details). That is, it
performs system logins to the display being connected to and then runs a
session manager on behalf of the user (usually an X window manager). XDM then
waits for this program to exit, signaling that the user is done and should be
logged out of the display. At this point, XDM can display the login and display
chooser screens for the next user to login.

6.6.2.Â Using XDM

To start using XDM, install the x11/xdm port (it is not installed by default in
recent versions of Xorg). The XDM daemon program may then be found in /usr/
local/bin/xdm. This program can be run at any time as root and it will start
managing the X display on the local machine. If XDM is to be run every time the
machine boots up, a convenient way to do this is by adding an entry to /etc/
ttys. For more information about the format and usage of this file, see
SectionÂ 27.3.2.1, â  Adding an Entry to /etc/ttysâ  . There is a line in the
default /etc/ttys file for running the XDM daemon on a virtual terminal:

ttyv8 "/usr/local/bin/xdm -nodaemon" xterm off secure

By default this entry is disabled; in order to enable it change field 5 from
off to on and restart init(8) using the directions in SectionÂ 27.3.2.2, â  
Force init to Reread /etc/ttysâ  . The first field, the name of the terminal
this program will manage, is ttyv8. This means that XDM will start running on
the 9th virtual terminal.

6.6.3.Â Configuring XDM

The XDM configuration directory is located in /usr/local/lib/X11/xdm. In this
directory there are several files used to change the behavior and appearance of
XDM. Typically these files will be found:

   File                                 Description
Xaccess     Client authorization ruleset.
Xresources  Default X resource values.
Xservers    List of remote and local displays to manage.
Xsession    Default session script for logins.
Xsetup_*    Script to launch applications before the login interface.
xdm-config  Global configuration for all displays running on this machine.
xdm-errors  Errors generated by the server program.
xdm-pid     The process ID of the currently running XDM.

Also in this directory are a few scripts and programs used to set up the
desktop when XDM is running. The purpose of each of these files will be briefly
described. The exact syntax and usage of all of these files is described in xdm
(1).

The default configuration is a simple rectangular login window with the
hostname of the machine displayed at the top in a large font and â  Login:â  
and â  Password:â   prompts below. This is a good starting point for changing
the look and feel of XDM screens.

6.6.3.1.Â Xaccess

The protocol for connecting to XDM-controlled displays is called the X Display
Manager Connection Protocol (XDMCP). This file is a ruleset for controlling
XDMCP connections from remote machines. It is ignored unless the xdm-config is
changed to listen for remote connections. By default, it does not allow any
clients to connect.

6.6.3.2.Â Xresources

This is an application-defaults file for the display chooser and login screens.
In it, the appearance of the login program can be modified. The format is
identical to the app-defaults file described in the X11 documentation.

6.6.3.3.Â Xservers

This is a list of the remote displays the chooser should provide as choices.

6.6.3.4.Â Xsession

This is the default session script for XDM to run after a user has logged in.
Normally each user will have a customized session script in ~/.xsession that
overrides this script.

6.6.3.5.Â Xsetup_*

These will be run automatically before displaying the chooser or login
interfaces. There is a script for each display being used, named Xsetup_
followed by the local display number (for instance Xsetup_0). Typically these
scripts will run one or two programs in the background such as xconsole.

6.6.3.6.Â xdm-config

This contains settings in the form of app-defaults that are applicable to every
display that this installation manages.

6.6.3.7.Â xdm-errors

This contains the output of the X servers that XDM is trying to run. If a
display that XDM is trying to start hangs for some reason, this is a good place
to look for error messages. These messages are also written to the user's ~
/.xsession-errors file on a per-session basis.

6.6.4.Â Running a Network Display Server

In order for other clients to connect to the display server, you must edit the
access control rules and enable the connection listener. By default these are
set to conservative values. To make XDM listen for connections, first comment
out a line in the xdm-config file:

! SECURITY: do not listen for XDMCP or Chooser requests ! Comment out this line
if you want to manage X terminals with xdm DisplayManager.requestPort: 0

and then restart XDM. Remember that comments in app-defaults files begin with a
â  !â   character, not the usual â  #â  . More strict access controls may be
desired â   look at the example entries in Xaccess, and refer to the xdm(1)
manual page for further information.

6.6.5.Â Replacements for XDM

Several replacements for the default XDM program exist. One of them, KDM
(bundled with KDE) is described later in this chapter. The KDM display manager
offers many visual improvements and cosmetic frills, as well as the
functionality to allow users to choose their window manager of choice at login
time.

6.7.Â Desktop Environments

Contributed by Valentino Vaschetto.

This section describes the different desktop environments available for X on
FreeBSD. A â  desktop environmentâ   can mean anything ranging from a simple
window manager to a complete suite of desktop applications, such as KDE or 
GNOME.

6.7.1.Â GNOME

6.7.1.1.Â About GNOME

GNOME is a user-friendly desktop environment that enables users to easily use
and configure their computers. GNOME includes a panel (for starting
applications and displaying status), a desktop (where data and applications can
be placed), a set of standard desktop tools and applications, anda set of
conventions that make it easy for applications to cooperate and be consistent
with each other. Users of other operating systems or environments should feel
right at home using the powerful graphics-driven environment that GNOME
provides. More information regarding GNOME on FreeBSD can be found on the
FreeBSD GNOME Project's web site. The web site also contains fairly
comprehensive FAQs about installing, configuring, and managing GNOME.

6.7.1.2.Â Installing GNOME

The software can be easily installed from a package or the Ports Collection:

To install the GNOME package from the network, simply type:

# pkg_add -r gnome2

To build GNOME from source, use the ports tree:

# cd /usr/ports/x11/gnome2 # make install clean

For proper operation, GNOME requires the /proc filesystem to be mounted. Add

proc /proc procfs rw 0 0

to /etc/fstab to mount procfs(5) automatically during startup.

Once GNOME is installed, the X server must be told to start GNOME instead of a
default window manager.

The easiest way to start GNOME is with GDM, the GNOME Display Manager. GDM is
installed as part of the GNOME desktop, although it is disabled by default. It
can be enabled by adding this line to /etc/rc.conf:

gdm_enable="YES"

Once you have rebooted, GDM will start automatically.

It is often desirable to start all GNOME services together with GDM. To achieve
this, add the following line to /etc/rc.conf:

gnome_enable="YES"

GNOME may also be started from the command-line by properly configuring a file
named .xinitrc. If a custom .xinitrc is already in place, simply replace the
line that starts the current window manager with one that starts /usr/local/bin
/gnome-session instead. If nothing special has been done to the configuration
file, then it is enough simply to type:

% echo "/usr/local/bin/gnome-session" &gt; ~/.xinitrc

Next, type startx, and the GNOME desktop environment will be started.

Note:

If an older display manager, like XDM, is being used, this will not work.
Instead, create an executable .xsession file with the same command in it. To do
this, edit the file and replace the existing window manager command with /usr/
local/bin/gnome-session:

% echo "#!/bin/sh" &gt; ~/.xsession % echo "/usr/local/bin/gnome-session" &gt;&gt; ~
/.xsession % chmod +x ~/.xsession

Yet another option is to configure the display manager to allow choosing the
window manager at login time; the section on KDE details explains how to do
this for KDM, the display manager of KDE.

6.7.2.Â KDE

6.7.2.1.Â About KDE

KDE is an easy to use contemporary desktop environment. Some of the things that
KDE brings to the user are:

  * A beautiful contemporary desktop

  * A desktop exhibiting complete network transparency

  * An integrated help system allowing for convenient, consistent access to
    help on the use of the KDE desktop and its applications

  * Consistent look and feel of all KDE applications

  * Standardized menu and toolbars, keybindings, color-schemes, etc.

  * Internationalization: KDE is available in more than 55 languages

  * Centralized, consistent, dialog-driven desktop configuration

  * A great number of useful KDE applications

KDE comes with a web browser called Konqueror, which is a solid competitor to
other existing web browsers on UNIXÂ® systems. More information on KDE can be
found on the KDE website. For FreeBSD specific information and resources on KDE
, consult the KDE/FreeBSD initiative's website.

There are two versions of KDE available on FreeBSD. Version 3 has been around
for a long time, and is still available in the Ports Collection though it's now
unmaintained and partially broken. Version 4 is punctually updated and is the
default choice for KDE users. They can even be installed side by side.

6.7.2.2.Â Installing KDE

Just as with GNOME or any other desktop environment, the software can be easily
installed from a package or the Ports Collection:

To install the KDE 3 package from the network, type:

# pkg_add -r kde

To install the KDE 4 package from the network, type:

# pkg_add -r kde4

pkg_add(1) will automatically fetch the latest version of the application.

To build KDE 3 from source, use the ports tree:

# cd /usr/ports/x11/kde3 # make install clean

To build KDE 4 from source, use the ports tree:

# cd /usr/ports/x11/kde4 # make install clean

After KDE has been installed, the X server must be told to launch this
application instead of the default window manager. This is accomplished by
editing the .xinitrc file:

For KDE 3:

% echo "exec startkde" &gt; ~/.xinitrc

For KDE 4:

% echo "exec /usr/local/kde4/bin/startkde" &gt; ~/.xinitrc

Now, whenever the X Window System is invoked with startx, KDE will be the
desktop.

If a display manager such as XDM is being used, the configuration is slightly
different. Edit the .xsession file instead. Instructions for KDM are described
later in this chapter.

6.7.3.Â More Details on KDE

Now that KDE is installed on the system, most things can be discovered through
the help pages, or just by pointing and clicking at various menus. WindowsÂ® or
MacÂ® users will feel quite at home.

The best reference for KDE is the on-line documentation. KDE comes with its own
web browser, Konqueror, dozens of useful applications, and extensive
documentation. The remainder of this section discusses the technical items that
are difficult to learn by random exploration.

6.7.3.1.Â The KDE Display Manager

An administrator of a multi-user system may wish to have a graphical login
screen to welcome users. XDM can be used, as described earlier. However, KDE
includes an alternative, KDM, which is designed to look more attractive and
include more login-time options. In particular, users can easily choose (via a
menu) which desktop environment (KDE, GNOME, or something else) to run after
logging on.

To enable KDM, different files need to be edited depending on the version of 
KDE.

For KDE 3, the ttyv8 entry in /etc/ttys has to be adapted as follows:

ttyv8 "/usr/local/bin/kdm -nodaemon" xterm on secure

For KDE 4, you have to mount procfs(5) and add the following line to /etc/
rc.conf:

kdm4_enable="YES"

6.7.4.Â Xfce

6.7.4.1.Â About Xfce

Xfce is a desktop environment based on the GTK+ toolkit used by GNOME, but is
much more lightweight and meant for those who want a simple, efficient desktop
which is nevertheless easy to use and configure. Visually, it looks very much
like CDE, found on commercial UNIXÂ® systems. Some of Xfce's features are:

  * A simple, easy-to-handle desktop

  * Fully configurable via mouse, with drag and drop, etc.

  * Main panel similar to CDE, with menus, applets and applications launchers

  * Integrated window manager, file manager, sound manager, GNOME compliance
    module, and more

  * Themeable (since it uses GTK+)

  * Fast, light and efficient: ideal for older/slower machines or machines with
    memory limitations

More information on Xfce can be found on the Xfce website.

6.7.4.2.Â Installing Xfce

A binary package for Xfce exists (at the time of writing). To install, simply
type:

# pkg_add -r xfce4

Alternatively, to build from source, use the Ports Collection:

# cd /usr/ports/x11-wm/xfce4 # make install clean

Now, tell the X server to launch Xfce the next time X is started. Simply type
this:

% echo "/usr/local/bin/startxfce4" &gt; ~/.xinitrc

The next time X is started, Xfce will be the desktop. As before, if a display
manager like XDM is being used, create an .xsession, as described in the
section on GNOME, but with the /usr/local/bin/startxfce4 command; or, configure
the display manager to allow choosing a desktop at login time, as explained in
the section on kdm.

PartÂ II.Â Common Tasks

Now that the basics have been covered, this part of the FreeBSD Handbook will
discuss some frequently used features of FreeBSD. These chapters:

  * Introduce you to popular and useful desktop applications: browsers,
    productivity tools, document viewers, etc.

  * Introduce you to a number of multimedia tools available for FreeBSD.

  * Explain the process of building a customized FreeBSD kernel, to enable
    extra functionality on your system.

  * Describe the print system in detail, both for desktop and network-connected
    printer setups.

  * Show you how to run Linux applications on your FreeBSD system.

Some of these chapters recommend that you do some prior reading, and this is
noted in the synopsis at the beginning of each chapter.

Table of Contents

7. Desktop Applications

    7.1. Synopsis
    7.2. Browsers
    7.3. Productivity
    7.4. Document Viewers
    7.5. Finance

8. Multimedia

    8.1. Synopsis
    8.2. Setting Up the Sound Card
    8.3. MP3 Audio
    8.4. Video Playback
    8.5. Setting Up TV Cards
    8.6. MythTV
    8.7. Image Scanners

9. Configuring the FreeBSD Kernel

    9.1. Synopsis
    9.2. Why Build a Custom Kernel?
    9.3. Finding the System Hardware
    9.4. Kernel Drivers, Subsystems, and Modules
    9.5. Building and Installing a Custom Kernel
    9.6. The Configuration File
    9.7. If Something Goes Wrong

10. Printing

    10.1. Synopsis
    10.2. Introduction
    10.3. Basic Setup
    10.4. Advanced Printer Setup
    10.5. Using Printers
    10.6. Alternatives to the Standard Spooler
    10.7. Troubleshooting

11. LinuxÂ® Binary Compatibility

    11.1. Synopsis
    11.2. Installation
    11.3. Installing MathematicaÂ®
    11.4. Installing Mapleâ ¢
    11.5. Installing MATLABÂ®
    11.6. Installing OracleÂ®
    11.7. Advanced Topics

ChapterÂ 7.Â Desktop Applications

Contributed by Christophe Juniet.
Table of Contents

7.1. Synopsis
7.2. Browsers
7.3. Productivity
7.4. Document Viewers
7.5. Finance

7.1.Â Synopsis

While FreeBSD is popular as a server for its performance and stability, it is
also suited for day-to-day use as a desktop. With over 24,000 applications
available as packages or ports, it is easy to build a customized desktop that
runs a wide variety of desktop applications. This chapter demonstrates how to
install some popular desktop applications effortlessly using packages or the
FreeBSD Ports Collection.

As FreeBSD features LinuxÂ® binary compatibility, many applications developed
for LinuxÂ® can be installed on a FreeBSD desktop. Many of the ports using 
LinuxÂ® binary compatibility start with â  linux-â  . This chapter assumes that
LinuxÂ® binary compatibility has been enabled before any LinuxÂ® applications
are installed.

This chapter demonstrates how to install the following desktop applications:

    Type of     Application Name         Package Name             Ports Name
  Application
Browser         Firefox          firefox                       www/firefox
Browser         Opera            opera                         www/opera
Browser         Konqueror        kde4-baseapps                 x11/
                                                               kde4-baseapps
Browser         Chromium         chromium                      www/chromium
Productivity    Calligra         calligra                      editors/calligra
Productivity    AbiWord          abiword                       editors/abiword
Productivity    The GIMP         gimp                          graphics/gimp
Productivity    Apache           openoffice                    editors/
                OpenOffice                                     openoffice-3
Productivity    LibreOffice      libreoffice                   editors/
                                                               libreoffice
Document Viewer AcrobatÂ ReaderÂ no package due to license     print/acroread9
                ®                restriction
Document Viewer gv               gv                            print/gv
Document Viewer Xpdf             xpdf                          graphics/xpdf
Document Viewer GQview           gqview                        graphics/gqview
Finance         GnuCash          gnucash                       finance/gnucash
Finance         Gnumeric         gnumeric                      math/gnumeric
Finance         KMyMoney         kmymoney-kde4                 finance/
                                                               kmymoney-kde4

Before reading this chapter, you should know how to:

  * Install additional software using packages or ports.

  * Enable LinuxÂ® binary compatibility.

For information on how to configure a multimedia environment, refer to
ChapterÂ 8, Multimedia. For information on how to set up and use electronic
mail, refer to ChapterÂ 29, Electronic Mail.

7.2.Â Browsers

FreeBSD does not come with a pre-installed web browser. Instead, the www
category of the Ports Collection contains many browsers which can be installed
as a package or compiled from the Ports Collection.

The KDE and GNOME desktop environments include their own HTML browser. Refer to
SectionÂ 6.7, â  Desktop Environmentsâ   for more information on how to set up
these complete desktops.

Some light-weight browsers include www/dillo2, www/links, and www/w3m.

This section demonstrates how to install the following popular web browsers and
indicates if the application is resource-heavy, takes time to compile from
ports, or has any major dependencies.

 Application    Resources   Installation from                Notes
    Name         Needed           Ports
Firefox       medium        heavy              FreeBSD and LinuxÂ® versions are
                                               available
Opera         light         light              FreeBSD and LinuxÂ® versions are
                                               available
Konqueror     medium        heavy              Requires KDE libraries
Chromium      medium        heavy              Requires Gtk+

7.2.1.Â Firefox

Firefox is a modern, free, open source browser that is fully ported to FreeBSD.
It features a standards-compliant HTML display engine, tabbed browsing, popup
blocking, extensions, improved security, and more. Firefox is based on the 
Mozilla codebase.

Install the package of the latest release version of Firefox by typing:

# pkg_add -r firefox

To instead install Firefox Extended Support Release (ESR) version, use:

# pkg_add -r firefox-esr

Localized versions are available in www/firefox-i18n and www/firefox-esr-i18n.

The Ports Collection can instead be used to compile the desired version of 
firefox from source code. This example builds www/firefox, where firefox can be
replaced with the ESR or localized version to install.

# cd /usr/ports/www/firefox # make install clean

7.2.1.1.Â Firefox and Javaâ ¢ Plugin

Note:

The following sections assume that Firefox is already installed.

java/icedtea-web provides a free software web browser plugin for running Java
applets. It can be installed as a package. To alternately compile the port:

# cd /usr/ports/java/icedtea-web # make install clean

Keep the default configuration options when compiling the port.

Once installed, start firefox, enter about:plugins in the location bar and
press Enter. A page listing the installed plugins will be displayed. The Javaâ 
¢ plugin should be listed.

If the browser is unable to find the plugin, each user will have to run the
following command and relaunch the browser:

% ln -s /usr/local/lib/IcedTeaPlugin.so \ $HOME/.mozilla/plugins/

7.2.1.2.Â Firefox and AdobeÂ® Flashâ ¢ Plugin

A native AdobeÂ® Flashâ ¢ plugin is not available for FreeBSD. However, a
software layer (wrapper) for running the LinuxÂ® version of the plugin exists.
This wrapper also provides support for other browser plugins such as RealPlayer
Â®.

To install and enable this plugin:

 1. Install the www/nspluginwrapper port. Due to licensing restrictions, a
    package is not available. This port requires emulators/linux_base-f10 which
    is a large port.

 2. Install the www/linux-f10-flashplugin11 port. Due to licensing
    restrictions, a package is not available.

 3. # ln -s /usr/local/lib/npapi/linux-f10-flashplugin/libflashplayer.so \ /usr
    /local/lib/browser_plugins/

    Create the /usr/local/lib/browser_plugins directory if it is not already
    present.

 4. Before the plugin is first used, each user must run:

    % nspluginwrapper -v -a -i

    When the plugin port has been updated and reinstalled, each user must run:

    % nspluginwrapper -v -a -u

    Start the browser, enter about:plugins in the location bar and press Enter.
    A list of all the currently available plugins will be shown.

7.2.1.3.Â Firefox and Swfdec Flashâ ¢ Plugin

Swfdec is the library for decoding and rendering Flashâ ¢ animations.
Swfdec-Mozilla is a plugin for Firefox browsers that uses the Swfdec library
for playing SWF files. It is still in heavy development.

To install the package:

# pkg_add -r swfdec-plugin

If the package is not available, compile and install it from the Ports
Collection:

# cd /usr/ports/www/swfdec-plugin # make install clean

Restart the browser for this plugin to take effect.

7.2.2.Â Opera

Opera is a full-featured and standards-compliant browser which is still
lightweight and fast. It comes with a built-in mail and news reader, an IRC
client, an RSS/Atom feeds reader, and more. It is available as a native FreeBSD
version and as a version that runs under LinuxÂ® emulation.

This command installs the package of the FreeBSD version of Opera. Replace
opera with linux-opera to instead install the LinuxÂ® version.

# pkg_add -r opera

Alternately, install either version through the Ports Collection. This example
compiles the native version:

# cd /usr/ports/www/opera # make install clean

To install the LinuxÂ® version, substitute linux-opera in place of opera.

To install AdobeÂ® Flashâ ¢ plugin support, first compile the www/
linux-f10-flashplugin11 port, as a package is not available due to licensing
restrictions. Then install either the www/opera-linuxplugins port or package.
This example compiles both from ports:

# cd /usr/ports/www/linux-f10-flashplugin11 # make install clean # cd /usr/
ports/www/opera-linuxplugins # make install clean

Once installed, check the presence of the plugin by starting the browser,
entering opera:plugins in the location bar and pressing Enter. A list should
appear with all the currently available plugins.

To add the Javaâ ¢ plugin, follow the instructions for Firefox.

7.2.3.Â Konqueror

Konqueror is part of x11/kde4-baseapps. Konqueror is more than a web browser as
it is also a file manager and a multimedia viewer.

Konqueror supports WebKit as well as its own KHTML. WebKit is a rendering
engine used by many modern browsers including Chromium. To use WebKit with 
Konqueror on FreeBSD, install the www/kwebkitpart package or port. This example
compiles the port:

# cd /usr/ports/www/kwebkitpart # make install clean

To enable WebKit within Konqueror, click â  Settingsâ  , â  Configure Konqueror
â  . In the â  Generalâ   settings page, click the drop-down menu next to â  
Default web browser engineâ   and change â  KHTMLâ   to â  WebKitâ  .

Konqueror also supports Flashâ ¢. A â  How Toâ   guide for getting Flashâ ¢
support on Konqueror is available at http://freebsd.kde.org/howtos/
konqueror-flash.php.

7.2.4.Â Chromium

Chromium is an open source browser project that aims to build a safer, faster,
and more stable web browsing experience. Chromium features tabbed browsing,
popup blocking, extensions, and much more. Chromium is the open source project
upon which the Google Chrome web browser is based.

Chromium can be installed as a package by typing:

# pkg_add -r chromium

Alternatively, Chromium can be compiled from source using the Ports Collection:

# cd /usr/ports/www/chromium # make install clean

Note:

The executable for Chromium is /usr/local/bin/chrome, not /usr/local/bin/
chromium.

7.2.4.1.Â Chromium and Javaâ ¢ Plugin

Note:

The following sections assume that Chromium is already installed.

To install Javaâ ¢ plugin support, follow the instructions in SectionÂ 7.2.1.1,
â  Firefox and Javaâ ¢ Pluginâ  .

Once Javaâ ¢ support is installed, start Chromium, and enter about:plugins in
the address bar. IcedTea-Web should be listed as one of the installed plugins.

If Chromium does not display the IcedTea-Web plugin, run the following
commands, and restart the web browser:

# mkdir -p /usr/local/share/chromium/plugins # ln -s /usr/local/lib/
IcedTeaPlugin.so \ /usr/local/share/chromium/plugins/

7.2.4.2.Â Chromium and AdobeÂ®Â Flashâ ¢ Plugin

Configuring Chromium and AdobeÂ®Â Flashâ ¢ is similar to the instructions for
Firefox. No additional configuration should be necessary, since Chromium is
able to use some plugins from other browsers.

7.3.Â Productivity

When it comes to productivity, new users often look for a good office suite or
a friendly word processor. While some desktop environments like KDE already
provide an office suite, there is no default productivity package. Several
office suites and word processors are available for FreeBSD, regardless of the
installed desktop environment.

This section demonstrates how to install the following popular productivity
software and indicates if the application is resource-heavy, takes time to
compile from ports, or has any major dependencies.

  Application     Resources     Installation from       Major Dependencies
     Name           Needed            Ports
Calligra        light          heavy                KDE
AbiWord         light          light                Gtk+ or GNOME
The Gimp        light          heavy                Gtk+
Apache          heavy          huge                 JDKâ ¢ and Mozilla
OpenOffice
LibreOffice     somewhat heavy huge                 Gtk+, or KDE/ GNOME, or JDK
                                                    â ¢

7.3.1.Â Calligra

The KDE community provides its desktop environment with an office suite which
can be used outside of KDE. Calligra includes standard components that can be
found in other office suites. Words is the word processor, Sheets is the
spreadsheet program, Stage manages slide presentations, and Karbon is used to
draw graphical documents.

editors/calligra can be installed as a package or a port. To install the
package:

# pkg_add -r calligra

If the package is not available, use the Ports Collection instead:

# cd /usr/ports/editors/calligra # make install clean

7.3.2.Â AbiWord

AbiWord is a free word processing program similar in look and feel to Microsoft
Â® Word. It is suitable for typing papers, letters, reports, memos, and so
forth. It is fast, contains many features, and is user-friendly.

AbiWord can import or export many file formats, including some proprietary ones
like MicrosoftÂ® .doc.

To install the AbiWord package:

# pkg_add -r abiword

If the package is not available, it can be compiled from the Ports Collection:

# cd /usr/ports/editors/abiword # make install clean

7.3.3.Â The GIMP

For image authoring or picture retouching, The GIMP provides a sophisticated
image manipulation program. It can be used as a simple paint program or as a
quality photo retouching suite. It supports a large number of plugins and
features a scripting interface. The GIMP can read and write a wide range of
file formats and supports interfaces with scanners and tablets.

To install the package:

# pkg_add -r gimp

Alternately, use the Ports Collection:

# cd /usr/ports/graphics/gimp # make install clean

The graphics category of the Ports Collection contains several GIMP-related
plugins, help files, and user manuals.

7.3.4.Â Apache OpenOffice

On 1 June 2011, OracleÂ® donated the OpenOffice.org code base to the Apache
Software Foundation. OpenOffice.org is now known as Apache OpenOffice and is
developed under the wing of the Apache Software Foundation's Incubator.

Apache OpenOffice includes all of the mandatory applications in a complete
office productivity suite: a word processor, spreadsheet, presentation manager,
and drawing program. Its user interface is very similar to other office suites,
and it can import and export in various popular file formats. It is available
in a number of different languages and internationalization has been extended
to interfaces, spell checkers, and dictionaries.

The word processor of Apache OpenOffice uses a native XML file format for
increased portability and flexibility. The spreadsheet program features a macro
language which can be interfaced with external databases. Apache OpenOffice is
stable and runs natively on WindowsÂ®, Solarisâ ¢, LinuxÂ®, FreeBSD, and 
MacÂ OSÂ®Â X. More information about Apache OpenOffice can be found on the
Apache OpenOffice web site. For FreeBSD specific information, and to directly
download packages, refer to the web site of the FreeBSD Apache OpenOffice
Porting Team.

To install the Apache OpenOffice package:

# pkg_add -r apache-openoffice

Note:

When running a -RELEASE version of FreeBSD, this should work. Otherwise,
download the latest package from the website of the FreeBSD Apache OpenOffice
Porting Team and install it using pkg_add(1). Both the current release and
development versions are available for download at this web site.

Once the package is installed, type the following command to launch Apache
OpenOffice:

% openoffice-X.Y.Z

where X.Y.Z is the version number of the installed version of Apache OpenOffice
.

Note:

During the first launch, some questions will be asked and a .openoffice.org
folder will be created in the user's home directory.

If the desired Apache OpenOffice package is not available, compiling the port
is still an opton. However, this requires a lot of disk space and a fairly long
time to compile:

# cd /usr/ports/editors/openoffice-3 # make install clean

Note:

To build a localized version, replace the previous command with:

# make LOCALIZED_LANG=your_language install clean

Replace your_language with the correct language ISO-code. A list of supported
language codes is available in files/Makefile.localized, located in the port's
directory.

7.3.5.Â LibreOffice

LibreOffice is a free software office suite developed by The Document
Foundation. It is compatible with other major office suites and available on a
variety of platforms. It is a rebranded fork of OpenOffice.org which includes
all of the mandatory applications in a complete office productivity suite: a
word processor, spreadsheet, presentation manager, drawing program, database
management program, and a tool for creating and editing mathematical formula.
It is available in a number of different languages and internationalization has
been extended to interfaces, spell checkers, and dictionaries.

The word processor of LibreOffice uses a native XML file format for increased
portability and flexibility. The spreadsheet program features a macro language
which can be interfaced with external databases. LibreOffice is stable and runs
natively on WindowsÂ®, LinuxÂ®, FreeBSD, and MacÂ OSÂ®Â X. More information
about LibreOffice can be found on the LibreOffice web site.

To install the English version of the LibreOffice package:

# pkg_add -r libreoffice

The editors category of the Ports Collection contains several localizations for
LibreOffice. When installing a localized package, replace libreoffice with the
name of the localized package.

Once the package is installed, type the following command to run LibreOffice:

% libreoffice

Note:

During the first launch, some questions will be asked and a .libreoffice folder
will be created in the user's home directory.

If the desired LibreOffice package is not available, compiling the port is
still an option. However, this requires a lot of disk space and a fairly long
time to compile. This example compiles the English version:

# cd /usr/ports/editors/libreoffice # make install clean

Note:

To build a localized version, cd into the port directory of the desired
language. Supported languages can be found in the editors category of the Ports
Collection.

7.4.Â Document Viewers

Some new document formats have gained popularity since the advent of UNIXÂ® and
the viewers they require may not be available in the base system. This section
demonstrates how to install the following viewers:

Application Name   Resources      Installation from      Major Dependencies
                     Needed             Ports
AcrobatÂ ReaderÂ light          light                 LinuxÂ® binary
®                                                     compatibility
gv               light          light                 Xaw3d
Xpdf             light          light                 FreeType
GQview           light          light                 Gtk+ or GNOME

7.4.1.Â AcrobatÂ ReaderÂ®

Many documents are now distributed as Portable Document Format (PDF) files. One
popular viewer for PDFs is AcrobatÂ ReaderÂ®, released by AdobeÂ® for LinuxÂ®.
As FreeBSD can run LinuxÂ® binaries, it is also available for FreeBSD. Due to
licensing restrictions, a package is not available so it must be compiled from
ports. Several localizations are available from the print category of the Ports
Collection.

This command installs the English version of AcrobatÂ ReaderÂ® 9 from the Ports
Collection. To instead install a localized version, cd into the desired port's
directory.

# cd /usr/ports/print/acroread9 # make install clean

7.4.2.Â gv

gv is a PostScriptÂ® and PDF viewer. It is based on ghostview, but has a nicer
look due to the Xaw3d library. It is fast with a clean interface. gv has many
configurable features, such as orientation, paper size, scale, and
anti-aliasing. Almost any operation can be performed with either the keyboard
or the mouse.

To install gv as a package:

# pkg_add -r gv

If a package is unavailable, use the Ports Collection:

# cd /usr/ports/print/gv # make install clean

7.4.3.Â Xpdf

For users that prefer a small FreeBSD PDF viewer, xpdf provides a light-weight
and efficient viewer which requires few resources. It uses the standard X fonts
and does not require MotifÂ® or any other X toolkit.

To install the Xpdf package:

# pkg_add -r xpdf

If the package is not available, use the Ports Collection:

# cd /usr/ports/graphics/xpdf # make install clean

Once the installation is complete, launch xpdf and use the right mouse button
to activate the menu.

7.4.4.Â GQview

GQview is an image manager which supports viewing a file with a single click,
launching an external editor, and thumbnail previews. It also features a
slideshow mode and some basic file operations, making it easy to manage image
collections and to find duplicate files. GQview supports full screen viewing
and internationalization.

To install the GQview package:

# pkg_add -r gqview

If the package is not available, use the Ports Collection:

# cd /usr/ports/graphics/gqview # make install clean

7.5.Â Finance

For managing personal finances on a FreeBSD desktop, some powerful and
easy-to-use applications can be installed. Some are compatible with widespread
file formats, such as the formats used by QuickenÂ® and Excel.

This section covers these programs:

Application Name  Resources Needed  Installation from Ports  Major Dependencies
GnuCash           light             heavy                    GNOME
Gnumeric          light             heavy                    GNOME
KMyMoney          light             heavy                    KDE

7.5.1.Â GnuCash

GnuCash is part of the GNOME effort to provide user-friendly, yet powerful,
applications to end-users. GnuCash can be used to keep track of income and
expenses, bank accounts, and stocks. It features an intuitive interface while
remaining professional.

GnuCash provides a smart register, a hierarchical system of accounts, and many
keyboard accelerators and auto-completion methods. It can split a single
transaction into several more detailed pieces. GnuCash can import and merge 
Quicken QIF files. It also handles most international date and currency
formats.

To install the GnuCash package:

# pkg_add -r gnucash

If the package is not available, use the Ports Collection:

# cd /usr/ports/finance/gnucash # make install clean

7.5.2.Â Gnumeric

Gnumeric is a spreadsheet program developed by the GNOME community. It features
convenient automatic â  guessingâ   of user input according to the cell format
with an autofill system for many sequences. It can import files in a number of
popular formats, including Excel, Lotus 1-2-3, and Quattro Pro. It has a large
number of built-in functions and allows all of the usual cell formats such as
number, currency, date, time, and much more.

To install Gnumeric as a package:

# pkg_add -r gnumeric

If the package is not available, use the Ports Collection:

# cd /usr/ports/math/gnumeric # make install clean

7.5.3.Â KMyMoney

KMyMoney is a personal finance created by the KDE community. KMyMoney intends
to provide and incorporate all the important features found in commercial
personal finance manager applications. It also highlights ease-of-use and
proper double-entry accounting among its features. KMyMoney imports from
standard Quicken Interchange Format (QIF) files, tracks investments, handles
multiple currencies, and provides a wealth of reports.

To install KMyMoney as a package:

# pkg_add -r kmymoney-kde4

If the package is not available, use the Ports Collection:

# cd /usr/ports/finance/kmymoney-kde4 # make install clean

ChapterÂ 8.Â Multimedia

Edited by Ross Lippert.
Table of Contents

8.1. Synopsis
8.2. Setting Up the Sound Card
8.3. MP3 Audio
8.4. Video Playback
8.5. Setting Up TV Cards
8.6. MythTV
8.7. Image Scanners

8.1.Â Synopsis

FreeBSD supports a wide variety of sound cards, allowing you to enjoy high
fidelity output from your computer. This includes the ability to record and
playback audio in the MPEG Audio Layer 3 (MP3), WAV, and Ogg Vorbis formats as
well as many other formats. The FreeBSD Ports Collection also contains
applications allowing you to edit your recorded audio, add sound effects, and
control attached MIDI devices.

With some experimentation, FreeBSD can support playback of video files and
DVDs. The number of applications to encode, convert, and playback various video
media is more limited than the number of sound applications. For example as of
this writing, there are no good re-encoding applications in the FreeBSD Ports
Collection that could be used to convert between formats, as there is with
audio/sox. However, the software landscape in this area is changing rapidly.

This chapter will describe the necessary steps to configure your sound card.
The configuration and installation of X11 (ChapterÂ 6, The X Window System) has
already taken care of the hardware issues for your video card, though there may
be some tweaks to apply for better playback.

After reading this chapter, you will know:

  * How to configure your system so that your sound card is recognized.

  * Methods to test whether your card is working.

  * How to troubleshoot your sound setup.

  * How to playback and encode MP3s and other audio.

  * How video is supported by the X server.

  * Some video player/encoder ports which give good results.

  * How to playback DVDs, .mpg and .avi files.

  * How to rip CD and DVD content into files.

  * How to configure a TV card.

  * How to configure an image scanner.

Before reading this chapter, you should:

  * Know how to configure and install a new kernel (ChapterÂ 9, Configuring the
    FreeBSD Kernel).

Warning:

Trying to mount audio CDs with the mount(8) command will result in an error, at
least, and a kernel panic, at worst. These media have specialized encodings
which differ from the usual ISO-filesystem.

8.2.Â Setting Up the Sound Card

Contributed by Moses Moore.
Enhanced by Marc Fonvieille.

8.2.1.Â Configuring the System

Before you begin, you should know the model of the card you have, the chip it
uses, and whether it is a PCI or ISA card. FreeBSD supports a wide variety of
both PCI and ISA cards. Check the supported audio devices list of the Hardware
Notes to see if your card is supported. The Hardware Notes will also mention
which driver supports your card.

To use your sound device, you will need to load the proper device driver. This
may be accomplished in one of two ways. The easiest way is to simply load a
kernel module for your sound card with kldload(8) which can either be done from
the command line:

# kldload snd_emu10k1

or by adding the appropriate line to the file /boot/loader.conf like this:

snd_emu10k1_load="YES"

These examples are for a Creative SoundBlasterÂ® Live! sound card. Other
available loadable sound modules are listed in /boot/defaults/loader.conf. If
you are not sure which driver to use, you may try to load the snd_driver
module:

# kldload snd_driver

This is a metadriver loading the most common device drivers at once. This
speeds up the search for the correct driver. It is also possible to load all
sound drivers via the /boot/loader.conf facility.

If you wish to find out the driver selected for your soundcard after loading
the snd_driver metadriver, you may check the /dev/sndstat file with the cat /
dev/sndstat command.

A second method is to statically compile in support for your sound card in your
kernel. The section below provides the information you need to add support for
your hardware in this manner. For more information about recompiling your
kernel, please see ChapterÂ 9, Configuring the FreeBSD Kernel.

8.2.1.1.Â Configuring a Custom Kernel with Sound Support

The first thing to do is add the audio framework driver sound(4) to the kernel;
for that you will need to add the following line to the kernel configuration
file:

device sound

Next, you have to add the support for your sound card. Therefore, you need to
know which driver supports the card. Check the supported audio devices list of
the Hardware Notes, to determine the correct driver for your sound card. For
example, a Creative SoundBlasterÂ® Live! sound card is supported by the
snd_emu10k1(4) driver. To add the support for this card, use the following:

device snd_emu10k1

Be sure to read the manual page of the driver for the syntax to use. The
explicit syntax for the kernel configuration of every supported sound driver
can also be found in the /usr/src/sys/conf/NOTES file.

Non-PnP ISA sound cards may require you to provide the kernel with information
on the card settings (IRQ, I/O port, etc), as is true of all non-PnP ISA cards.
This is done via the /boot/device.hints file. During the boot process, the
loader(8) will read this file and pass the settings to the kernel. For example,
an old Creative SoundBlasterÂ® 16 ISA non-PnP card will use the snd_sbc(4)
driver in conjunction with snd_sb16. For this card the following lines must be
added to the kernel configuration file:

device snd_sbc device snd_sb16

and these to /boot/device.hints:

hint.sbc.0.at="isa" hint.sbc.0.port="0x220" hint.sbc.0.irq="5" hint.sbc.0.drq=
"1" hint.sbc.0.flags="0x15"

In this case, the card uses the 0x220 I/O port and the IRQ 5.

The syntax used in the /boot/device.hints file is covered in the sound(4)
driver manual page and the manual page for the driver in question.

The settings shown above are the defaults. In some cases, you may need to
change the IRQ or the other settings to match your card. See the snd_sbc(4)
manual page for more information about this card.

8.2.2.Â Testing the Sound Card

After rebooting with the modified kernel, or after loading the required module,
the sound card should appear in your system message buffer (dmesg(8)) as
something like:

pcm0: &lt;Intel ICH3 (82801CA)&gt; port 0xdc80-0xdcbf,0xd800-0xd8ff irq 5 at device
31.5 on pci0 pcm0: [GIANT-LOCKED] pcm0: &lt;Cirrus Logic CS4205 AC97 Codec&gt;

The status of the sound card may be checked via the /dev/sndstat file:

# cat /dev/sndstat FreeBSD Audio Driver (newpcm) Installed devices: pcm0:
&lt;Intel ICH3 (82801CA)&gt; at io 0xd800, 0xdc80 irq 5 bufsz 16384 kld snd_ich (1p/
2r/0v channels duplex default)

The output from your system may vary. If no pcm devices are listed, go back and
review what was done earlier. Go through your kernel configuration file again
and make sure the correct device driver was chosen. Common problems are listed
in SectionÂ 8.2.2.1, â  Common Problemsâ  .

If all goes well, you should now have a functioning sound card. If your CD-ROM
or DVD-ROM drive's audio-out pins are properly connected to your sound card,
you can put a CD in the drive and play it with cdcontrol(1):

% cdcontrol -f /dev/acd0 play 1

Various applications, such as audio/workman can provide a friendlier interface.
You may want to install an application such as audio/mpg123 to listen to MP3
audio files.

Another quick way to test the card is sending data to /dev/dsp, like this:

% cat filename &gt; /dev/dsp

where filename can be any file. This command line should produce some noise,
confirming the sound card is actually working.

Note:

The device nodes /dev/dsp* will be created automatically when needed. If they
are not used, they do not exist and will not appear in the output of ls(1).

Sound card mixer levels can be changed via the mixer(8) command. More details
can be found in the mixer(8) manual page.

8.2.2.1.Â Common Problems

       Error                                 Solution
sb_dspwr(XX) timed  The I/O port is not set correctly.
out
                    The IRQ is set incorrectly. Make sure that the set IRQ and
bad irq XX          the sound IRQ are the same.

xxx: gus pcm not    There is not enough available memory to use the device.
attached, out of
memory
xxx: can't open /   Check with fstat | grep dsp if another application is
dev/dsp!            holding the device open. Noteworthy troublemakers are 
                    esound and KDE's sound support.

Another issue is that modern graphics cards often come with their own sound
driver, for use with HDMI and similar. This sound device will sometimes be
enumerated before the actual soundcard and the soundcard will subsequently not
be used as the default playback device. To check if this is the case, run dmesg
and look for pcm. The output looks something like this:

... hdac0: HDA Driver Revision: 20100226_0142 hdac1: HDA Driver Revision:
20100226_0142 hdac0: HDA Codec #0: NVidia (Unknown) hdac0: HDA Codec #1: NVidia
(Unknown) hdac0: HDA Codec #2: NVidia (Unknown) hdac0: HDA Codec #3: NVidia
(Unknown) pcm0: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 0 nid 1 on
hdac0 pcm1: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 1 nid 1 on hdac0
pcm2: &lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 2 nid 1 on hdac0 pcm3:
&lt;HDA NVidia (Unknown) PCM #0 DisplayPort&gt; at cad 3 nid 1 on hdac0 hdac1: HDA
Codec #2: Realtek ALC889 pcm4: &lt;HDA Realtek ALC889 PCM #0 Analog&gt; at cad 2 nid
1 on hdac1 pcm5: &lt;HDA Realtek ALC889 PCM #1 Analog&gt; at cad 2 nid 1 on hdac1
pcm6: &lt;HDA Realtek ALC889 PCM #2 Digital&gt; at cad 2 nid 1 on hdac1 pcm7: &lt;HDA
Realtek ALC889 PCM #3 Digital&gt; at cad 2 nid 1 on hdac1 ...

Here the graphics card (NVidia) has been enumerated before the sound card
(Realtek ALC889). To use the sound card as default playback device, change
hw.snd.default_unit to the unit that should be used for playback, enter the
following:

# sysctl hw.snd.default_unit=n

Here, n is the number of the sound device to use, in this example 4. You can
make this change permanent by adding the following line to /etc/sysctl.conf:

hw.snd.default_unit=4

8.2.3.Â Utilizing Multiple Sound Sources

Contributed by Munish Chopra.

It is often desirable to have multiple sources of sound that are able to play
simultaneously, such as when esound or artsd do not support sharing of the
sound device with a certain application.

FreeBSD lets you do this through Virtual Sound Channels, which can be enabled
with the sysctl(8) facility. Virtual channels allow you to multiplex your sound
card's playback by mixing sound in the kernel.

To set the number of virtual channels, there are three sysctl knobs which, if
you are the root user, can be set like this:

# sysctl dev.pcm.0.play.vchans=4 # sysctl dev.pcm.0.rec.vchans=4 # sysctl
hw.snd.maxautovchans=4

The above example allocates four virtual channels, which is a practical number
for everyday use. Both dev.pcm.0.play.vchans=4 and dev.pcm.0.rec.vchans=4 are
the number of virtual channels pcm0 has for playback and recording, and are
configurable once a device has been attached. hw.snd.maxautovchans is the
number of virtual channels a new audio device is given when it is attached
using kldload(8). Since the pcm module can be loaded independently of the
hardware drivers, hw.snd.maxautovchans can store how many virtual channels any
devices which are attached later will be given. Refer to pcm(4) manual page for
more information.

Note:

You cannot change the number of virtual channels for a device while it is in
use. First close any programs using the device, such as music players or sound
daemons.

The correct pcm device will automatically be allocated transparently to a
program that requests /dev/dsp0.

8.2.4.Â Setting Default Values for Mixer Channels

Contributed by Josef El-Rayes.

The default values for the different mixer channels are hardcoded in the
sourcecode of the pcm(4) driver. There are many different applications and
daemons that allow you to set values for the mixer that are remembered between
invocations, but this is not a clean solution. It is possible to set default
mixer values at the driver level â   this is accomplished by defining the
appropriate values in /boot/device.hints, e.g.:

hint.pcm.0.vol="50"

This will set the volume channel to a default value of 50 when the pcm(4)
module is loaded.

8.3.Â MP3 Audio

Contributed by Chern Lee.

MP3 (MPEG Layer 3 Audio) accomplishes near CD-quality sound, leaving no reason
to let your FreeBSD workstation fall short of its offerings.

8.3.1.Â MP3 Players

By far, the most popular X11 MP3 player is XMMS (X Multimedia System). Winamp
skins can be used with XMMS since the GUI is almost identical to that of
Nullsoft's Winamp. XMMS also has native plug-in support.

XMMS can be installed from the multimedia/xmms port or package.

XMMS's interface is intuitive, with a playlist, graphic equalizer, and more.
Those familiar with Winamp will find XMMS simple to use.

The audio/mpg123 port is an alternative, command-line MP3 player.

mpg123 can be run by specifying the sound device and the MP3 file on the
command line. Assuming your audio device is /dev/dsp1.0 and you want to play
the MP3 file Foobar-GreatestHits.mp3 you would enter the following:

# mpg123 -a /dev/dsp1.0 Foobar-GreatestHits.mp3 High Performance MPEG 1.0/2.0/
2.5 Audio Player for Layer 1, 2 and 3. Version 0.59r (1999/Jun/15). Written and
copyrights by Michael Hipp. Uses code from various people. See 'README' for
more! THIS SOFTWARE COMES WITH ABSOLUTELY NO WARRANTY! USE AT YOUR OWN RISK!
Playing MPEG stream from Foobar-GreatestHits.mp3 ... MPEG 1.0 layer III, 128
kbit/s, 44100 Hz joint-stereo

8.3.2.Â Ripping CD Audio Tracks

Before encoding a CD or CD track to MP3, the audio data on the CD must be
ripped onto the hard drive. This is done by copying the raw CDDA (CD Digital
Audio) data to WAV files.

The cdda2wav tool, which is a part of the sysutils/cdrtools suite, is used for
ripping audio information from CDs and the information associated with them.

With the audio CD in the drive, the following command can be issued (as root)
to rip an entire CD into individual (per track) WAV files:

# cdda2wav -D 0,1,0 -B

cdda2wav will support ATAPI (IDE) CDROM drives. To rip from an IDE drive,
specify the device name in place of the SCSI unit numbers. For example, to rip
track 7 from an IDE drive:

# cdda2wav -D /dev/acd0 -t 7

The -D 0,1,0 indicates the SCSI device 0,1,0, which corresponds to the output
of cdrecord -scanbus.

To rip individual tracks, make use of the -t option as shown:

# cdda2wav -D 0,1,0 -t 7

This example rips track seven of the audio CDROM. To rip a range of tracks, for
example, track one to seven, specify a range:

# cdda2wav -D 0,1,0 -t 1+7

The utility dd(1) can also be used to extract audio tracks on ATAPI drives,
read SectionÂ 19.6.5, â  Duplicating Audio CDsâ   for more information on that
possibility.

8.3.3.Â Encoding MP3s

Nowadays, the mp3 encoder of choice is lame. Lame can be found at audio/lame in
the ports tree.

Using the ripped WAV files, the following command will convert audio01.wav to
audio01.mp3:

# lame -h -b 128 \ --tt "Foo Song Title" \ --ta "FooBar Artist" \ --tl "FooBar
Album" \ --ty "2001" \ --tc "Ripped and encoded by Foo" \ --tg "Genre" \
audio01.wav audio01.mp3

128Â kbits seems to be the standard MP3 bitrate in use. Many enjoy the higher
quality 160, or 192. The higher the bitrate, the more disk space the resulting
MP3 will consume--but the quality will be higher. The -h option turns on the â 
 higher quality but a little slowerâ   mode. The options beginning with --t
indicate ID3 tags, which usually contain song information, to be embedded
within the MP3 file. Additional encoding options can be found by consulting the
lame man page.

8.3.4.Â Decoding MP3s

In order to burn an audio CD from MP3s, they must be converted to a
non-compressed WAV format. Both XMMS and mpg123 support the output of MP3 to an
uncompressed file format.

Writing to Disk in XMMS:

 1. Launch XMMS.

 2. Right-click on the window to bring up the XMMS menu.

 3. Select Preference under Options.

 4. Change the Output Plugin to â  Disk Writer Pluginâ  .

 5. Press Configure.

 6. Enter (or choose browse) a directory to write the uncompressed files to.

 7. Load the MP3 file into XMMS as usual, with volume at 100% and EQ settings
    turned off.

 8. Press Play â   XMMS will appear as if it is playing the MP3, but no music
    will be heard. It is actually playing the MP3 to a file.

 9. Be sure to set the default Output Plugin back to what it was before in
    order to listen to MP3s again.

Writing to stdout in mpg123:

  * Run mpg123 -s audio01.mp3 &gt; audio01.pcm

XMMS writes a file in the WAV format, while mpg123 converts the MP3 into raw
PCM audio data. Both of these formats can be used with cdrecord to create audio
CDs. You have to use raw PCM with burncd(8). If you use WAV files, you will
notice a small tick sound at the beginning of each track, this sound is the
header of the WAV file. You can simply remove the header of a WAV file with the
utility SoX (it can be installed from the audio/sox port or package):

% sox -t wav -r 44100 -s -w -c 2 track.wav track.raw

Read SectionÂ 19.6, â  Creating and Using CD Mediaâ   for more information on
using a CD burner in FreeBSD.

8.4.Â Video Playback

Contributed by Ross Lippert.

Video playback is a very new and rapidly developing application area. Be
patient. Not everything is going to work as smoothly as it did with sound.

Before you begin, you should know the model of the video card you have and the
chip it uses. While Xorg supports a wide variety of video cards, fewer give
good playback performance. To obtain a list of extensions supported by the X
server using your card use the command xdpyinfo(1) while X11 is running.

It is a good idea to have a short MPEG file which can be treated as a test file
for evaluating various players and options. Since some DVD players will look
for DVD media in /dev/dvd by default, or have this device name hardcoded in
them, you might find it useful to make symbolic links to the proper devices:

# ln -sf /dev/acd0 /dev/dvd # ln -sf /dev/acd0 /dev/rdvd

Note that due to the nature of devfs(5), manually created links like these will
not persist if you reboot your system. In order to create the symbolic links
automatically whenever you boot your system, add the following lines to /etc/
devfs.conf:

link acd0 dvd link acd0 rdvd

Additionally, DVD decryption, which requires invoking special DVD-ROM
functions, requires write permission on the DVD devices.

To enhance the shared memory X11 interface, it is recommended that the values
of some sysctl(8) variables should be increased:

kern.ipc.shmmax=67108864 kern.ipc.shmall=32768

8.4.1.Â Determining Video Capabilities

There are several possible ways to display video under X11. What will really
work is largely hardware dependent. Each method described below will have
varying quality across different hardware. Secondly, the rendering of video in
X11 is a topic receiving a lot of attention lately, and with each version of 
Xorg, there may be significant improvement.

A list of common video interfaces:

 1. X11: normal X11 output using shared memory.

 2. XVideo: an extension to the X11 interface which supports video in any X11
    drawable.

 3. SDL: the Simple Directmedia Layer.

 4. DGA: the Direct Graphics Access.

 5. SVGAlib: low level console graphics layer.

8.4.1.1.Â XVideo

Xorg has an extension called XVideo (aka Xvideo, aka Xv, aka xv) which allows
video to be directly displayed in drawable objects through a special
acceleration. This extension provides very good quality playback even on
low-end machines.

To check whether the extension is running, use xvinfo:

% xvinfo

XVideo is supported for your card if the result looks like:

X-Video Extension version 2.2 screen #0 Adaptor #0: "Savage Streams Engine"
number of ports: 1 port base: 43 operations supported: PutImage supported
visuals: depth 16, visualID 0x22 depth 16, visualID 0x23 number of attributes:
5 "XV_COLORKEY" (range 0 to 16777215) client settable attribute client gettable
attribute (current value is 2110) "XV_BRIGHTNESS" (range -128 to 127) client
settable attribute client gettable attribute (current value is 0) "XV_CONTRAST"
(range 0 to 255) client settable attribute client gettable attribute (current
value is 128) "XV_SATURATION" (range 0 to 255) client settable attribute client
gettable attribute (current value is 128) "XV_HUE" (range -180 to 180) client
settable attribute client gettable attribute (current value is 0) maximum
XvImage size: 1024 x 1024 Number of image formats: 7 id: 0x32595559 (YUY2)
guid: 59555932-0000-0010-8000-00aa00389b71 bits per pixel: 16 number of planes:
1 type: YUV (packed) id: 0x32315659 (YV12) guid:
59563132-0000-0010-8000-00aa00389b71 bits per pixel: 12 number of planes: 3
type: YUV (planar) id: 0x30323449 (I420) guid:
49343230-0000-0010-8000-00aa00389b71 bits per pixel: 12 number of planes: 3
type: YUV (planar) id: 0x36315652 (RV16) guid:
52563135-0000-0000-0000-000000000000 bits per pixel: 16 number of planes: 1
type: RGB (packed) depth: 0 red, green, blue masks: 0x1f, 0x3e0, 0x7c00 id:
0x35315652 (RV15) guid: 52563136-0000-0000-0000-000000000000 bits per pixel: 16
number of planes: 1 type: RGB (packed) depth: 0 red, green, blue masks: 0x1f,
0x7e0, 0xf800 id: 0x31313259 (Y211) guid: 59323131-0000-0010-8000-00aa00389b71
bits per pixel: 6 number of planes: 3 type: YUV (packed) id: 0x0 guid:
00000000-0000-0000-0000-000000000000 bits per pixel: 0 number of planes: 0
type: RGB (packed) depth: 1 red, green, blue masks: 0x0, 0x0, 0x0

Also note that the formats listed (YUV2, YUV12, etc) are not present with every
implementation of XVideo and their absence may hinder some players.

If the result looks like:

X-Video Extension version 2.2 screen #0 no adaptors present

Then XVideo is probably not supported for your card.

If XVideo is not supported for your card, this only means that it will be more
difficult for your display to meet the computational demands of rendering
video. Depending on your video card and processor, though, you might still be
able to have a satisfying experience. You should probably read about ways of
improving performance in the advanced reading SectionÂ 8.4.3, â  Further
Readingâ  .

8.4.1.2.Â Simple Directmedia Layer

The Simple Directmedia Layer, SDL, is a porting layer for many operating
systems allowing cross-platform applications to be developed which make
efficient use of sound and graphics. The SDL layer provides a low-level
abstraction to the hardware which can sometimes be more efficient than the X11
interface.

The SDL can be found at devel/sdl12.

8.4.1.3.Â Direct Graphics Access

Direct Graphics Access is an X11 extension which allows a program to bypass the
X server and directly alter the framebuffer. Because it relies on a low level
memory mapping to effect this sharing, programs using it must be run as root.

The DGA extension can be tested and benchmarked by dga(1). When dga is running,
it changes the colors of the display whenever a key is pressed. To quit, use q.

8.4.2.Â Ports and Packages Dealing with Video

This section discusses the software available from the FreeBSD Ports Collection
which can be used for video playback. Video playback is a very active area of
software development, and the capabilities of various applications are bound to
diverge somewhat from the descriptions given here.

Firstly, it is important to know that many of the video applications which run
on FreeBSD were developed as Linux applications. Many of these applications are
still beta-quality. Some of the problems that you may encounter with video
packages on FreeBSD include:

 1. An application cannot playback a file which another application produced.

 2. An application cannot playback a file which the application itself
    produced.

 3. The same application on two different machines, rebuilt on each machine for
    that machine, plays back the same file differently.

 4. A seemingly trivial filter like rescaling of the image size results in very
    bad artifacts from a buggy rescaling routine.

 5. An application frequently dumps core.

 6. Documentation is not installed with the port and can be found either on the
    web or under the port's work directory.

Many of these applications may also exhibit â  Linux-ismsâ  . That is, there
may be issues resulting from the way some standard libraries are implemented in
the Linux distributions, or some features of the Linux kernel which have been
assumed by the authors of the applications. These issues are not always noticed
and worked around by the port maintainers, which can lead to problems like
these:

 1. The use of /proc/cpuinfo to detect processor characteristics.

 2. A misuse of threads which causes a program to hang upon completion instead
    of truly terminating.

 3. Software not yet in the FreeBSD Ports Collection which is commonly used in
    conjunction with the application.

So far, these application developers have been cooperative with port
maintainers to minimize the work-arounds needed for port-ing.

8.4.2.1.Â MPlayer

MPlayer is a recently developed and rapidly developing video player. The goals
of the MPlayer team are speed and flexibility on Linux and other Unices. The
project was started when the team founder got fed up with bad playback
performance on then available players. Some would say that the graphical
interface has been sacrificed for a streamlined design. However, once you get
used to the command line options and the key-stroke controls, it works very
well.

8.4.2.1.1.Â Building MPlayer

MPlayer resides in multimedia/mplayer. MPlayer performs a variety of hardware
checks during the build process, resulting in a binary which will not be
portable from one system to another. Therefore, it is important to build it
from ports and not to use a binary package. Additionally, a number of options
can be specified in the make command line, as described in the Makefile and at
the start of the build:

# cd /usr/ports/multimedia/mplayer # make N - O - T - E Take a careful look
into the Makefile in order to learn how to tune mplayer towards you personal
preferences! For example, make WITH_GTK1 builds MPlayer with GTK1-GUI support.
If you want to use the GUI, you can either install /usr/ports/multimedia/
mplayer-skins or download official skin collections from http://
www.mplayerhq.hu/homepage/dload.html

The default port options should be sufficient for most users. However, if you
need the XviD codec, you have to specify the WITH_XVID option in the command
line. The default DVD device can also be defined with the WITH_DVD_DEVICE
option, by default /dev/acd0 will be used.

As of this writing, the MPlayer port will build its HTML documentation and two
executables, mplayer, and mencoder, which is a tool for re-encoding video.

The HTML documentation for MPlayer is very informative. If the reader finds the
information on video hardware and interfaces in this chapter lacking, the 
MPlayer documentation is a very thorough supplement. You should definitely take
the time to read the MPlayer documentation if you are looking for information
about video support in UNIXÂ®.

8.4.2.1.2.Â Using MPlayer

Any user of MPlayer must set up a .mplayer subdirectory of her home directory.
To create this necessary subdirectory, you can type the following:

% cd /usr/ports/multimedia/mplayer % make install-user

The command options for mplayer are listed in the manual page. For even more
detail there is HTML documentation. In this section, we will describe only a
few common uses.

To play a file, such as testfile.avi, through one of the various video
interfaces set the -vo option:

% mplayer -vo xv testfile.avi
% mplayer -vo sdl testfile.avi
% mplayer -vo x11 testfile.avi
# mplayer -vo dga testfile.avi
# mplayer -vo 'sdl:dga' testfile.avi

It is worth trying all of these options, as their relative performance depends
on many factors and will vary significantly with hardware.

To play from a DVD, replace the testfile.avi with dvd://N -dvd-device DEVICE
where N is the title number to play and DEVICE is the device node for the
DVD-ROM. For example, to play title 3 from /dev/dvd:

# mplayer -vo xv dvd://3 -dvd-device /dev/dvd

Note:

The default DVD device can be defined during the build of the MPlayer port via
the WITH_DVD_DEVICE option. By default, this device is /dev/acd0. More details
can be found in the port Makefile.

To stop, pause, advance and so on, consult the keybindings, which are output by
running mplayer -h or read the manual page.

Additional important options for playback are: -fs -zoom which engages the
fullscreen mode and -framedrop which helps performance.

In order for the mplayer command line to not become too large, the user can
create a file .mplayer/config and set default options there:

vo=xv fs=yes zoom=yes

Finally, mplayer can be used to rip a DVD title into a .vob file. To dump out
the second title from a DVD, type this:

# mplayer -dumpstream -dumpfile out.vob dvd://2 -dvd-device /dev/dvd

The output file, out.vob, will be MPEG and can be manipulated by the other
packages described in this section.

8.4.2.1.3.Â mencoder

Before using mencoder it is a good idea to familiarize yourself with the
options from the HTML documentation. There is a manual page, but it is not very
useful without the HTML documentation. There are innumerable ways to improve
quality, lower bitrate, and change formats, and some of these tricks may make
the difference between good or bad performance. Here are a couple of examples
to get you going. First a simple copy:

% mencoder input.avi -oac copy -ovc copy -o output.avi

Improper combinations of command line options can yield output files that are
unplayable even by mplayer. Thus, if you just want to rip to a file, stick to
the -dumpfile in mplayer.

To convert input.avi to the MPEG4 codec with MPEG3 audio encoding (audio/lame
is required):

% mencoder input.avi -oac mp3lame -lameopts br=192 \ -ovc lavc -lavcopts vcodec
=mpeg4:vhq -o output.avi

This has produced output playable by mplayer and xine.

input.avi can be replaced with dvd://1 -dvd-device /dev/dvd and run as root to
re-encode a DVD title directly. Since you are likely to be dissatisfied with
your results the first time around, it is recommended you dump the title to a
file and work on the file.

8.4.2.2.Â The xine Video Player

The xine video player is a project of wide scope aiming not only at being an
all in one video solution, but also in producing a reusable base library and a
modular executable which can be extended with plugins. It comes both as a
package and as a port, multimedia/xine.

The xine player is still very rough around the edges, but it is clearly off to
a good start. In practice, xine requires either a fast CPU with a fast video
card, or support for the XVideo extension. The GUI is usable, but a bit clumsy.

As of this writing, there is no input module shipped with xine which will play
CSS encoded DVDs. There are third party builds which do have modules for this
built in them, but none of these are in the FreeBSD Ports Collection.

Compared to MPlayer, xine does more for the user, but at the same time, takes
some of the more fine-grained control away from the user. The xine video player
performs best on XVideo interfaces.

By default, xine player will start up in a graphical user interface. The menus
can then be used to open a specific file:

% xine

Alternatively, it may be invoked to play a file immediately without the GUI
with the command:

% xine -g -p mymovie.avi

8.4.2.3.Â The transcode Utilities

The software transcode is not a player, but a suite of tools for re-encoding
video and audio files. With transcode, one has the ability to merge video
files, repair broken files, using command line tools with stdin/stdout stream
interfaces.

A great number of options can be specified during the build from the multimedia
/transcode port, we recommend the following command line to build transcode:

# make WITH_OPTIMIZED_CFLAGS=yes WITH_LIBA52=yes WITH_LAME=yes WITH_OGG=yes \
WITH_MJPEG=yes -DWITH_XVID=yes

The proposed settings should be sufficient for most users.

To illustrate transcode capacities, one example to show how to convert a DivX
file into a PAL MPEG-1 file (PAL VCD):

% transcode -i input.avi -V --export_prof vcd-pal -o output_vcd % mplex -f 1 -o
output_vcd.mpg output_vcd.m1v output_vcd.mpa

The resulting MPEG file, output_vcd.mpg, is ready to be played with MPlayer.
You could even burn the file on a CD-R media to create a Video CD, in this case
you will need to install and use both multimedia/vcdimager and sysutils/cdrdao
programs.

There is a manual page for transcode, but you should also consult the transcode
wiki for further information and examples.

8.4.3.Â Further Reading

The various video software packages for FreeBSD are developing rapidly. It is
quite possible that in the near future many of the problems discussed here will
have been resolved. In the mean time, those who want to get the very most out
of FreeBSD's A/V capabilities will have to cobble together knowledge from
several FAQs and tutorials and use a few different applications. This section
exists to give the reader pointers to such additional information.

The MPlayer documentation is very technically informative. These documents
should probably be consulted by anyone wishing to obtain a high level of
expertise with UNIXÂ® video. The MPlayer mailing list is hostile to anyone who
has not bothered to read the documentation, so if you plan on making bug
reports to them, RTFM.

The xine HOWTO contains a chapter on performance improvement which is general
to all players.

Finally, there are some other promising applications which the reader may try:

  * Avifile which is also a port multimedia/avifile.

  * Ogle which is also a port multimedia/ogle.

  * Xtheater

  * multimedia/dvdauthor, an open source package for authoring DVD content.

8.5.Â Setting Up TV Cards

Original contribution by Josef El-Rayes.
Enhanced and adapted by Marc Fonvieille.

8.5.1.Â Introduction

TV cards allow you to watch broadcast or cable TV on your computer. Most of
them accept composite video via an RCA or S-video input and some of these cards
come with a FM radio tuner.

FreeBSD provides support for PCI-based TV cards using a Brooktree Bt848/849/878
/879 or a Conexant CN-878/Fusion 878a Video Capture Chip with the bktr(4)
driver. You must also ensure the board comes with a supported tuner, consult
the bktr(4) manual page for a list of supported tuners.

8.5.2.Â Adding the Driver

To use your card, you will need to load the bktr(4) driver, this can be done by
adding the following line to the /boot/loader.conf file like this:

bktr_load="YES"

Alternatively, you may statically compile the support for the TV card in your
kernel, in that case add the following lines to your kernel configuration:

device bktr device iicbus device iicbb device smbus

These additional device drivers are necessary because of the card components
being interconnected via an I2C bus. Then build and install a new kernel.

Once the support was added to your system, you have to reboot your machine.
During the boot process, your TV card should show up, like this:

bktr0: &lt;BrookTree 848A&gt; mem 0xd7000000-0xd7000fff irq 10 at device 10.0 on pci0
iicbb0: &lt;I2C bit-banging driver&gt; on bti2c0 iicbus0: &lt;Philips I2C bus&gt; on iicbb0
master-only iicbus1: &lt;Philips I2C bus&gt; on iicbb0 master-only smbus0: &lt;System
Management Bus&gt; on bti2c0 bktr0: Pinnacle/Miro TV, Philips SECAM tuner.

Of course these messages can differ according to your hardware. However you
should check if the tuner is correctly detected; it is still possible to
override some of the detected parameters with sysctl(8) MIBs and kernel
configuration file options. For example, if you want to force the tuner to a
Philips SECAM tuner, you should add the following line to your kernel
configuration file:

options OVERRIDE_TUNER=6

or you can directly use sysctl(8):

# sysctl hw.bt848.tuner=6

See the bktr(4) manual page and the /usr/src/sys/conf/NOTES file for more
details on the available options.

8.5.3.Â Useful Applications

To use your TV card you need to install one of the following applications:

  * multimedia/fxtv provides TV-in-a-window and image/audio/video capture
    capabilities.

  * multimedia/xawtv is also a TV application, with the same features as fxtv.

  * misc/alevt decodes and displays Videotext/Teletext.

  * audio/xmradio, an application to use the FM radio tuner coming with some TV
    cards.

  * audio/wmtune, a handy desktop application for radio tuners.

More applications are available in the FreeBSD Ports Collection.

8.5.4.Â Troubleshooting

If you encounter any problem with your TV card, you should check at first if
the video capture chip and the tuner are really supported by the bktr(4) driver
and if you used the right configuration options. For more support and various
questions about your TV card you may want to contact and use the archives of
the freebsd-multimedia mailing list.

8.6.Â MythTV

MythTV is an open source PVR software project.

It is well-known in the LinuxÂ® world as a complex application with many
dependencies, and therefore difficult to install. The FreeBSD ports system
simplifies much of the process, but some components must be set up manually.
This section is intended to help and guide in setting up MythTV.

8.6.1.Â Hardware

MythTV is designed to utilise V4L to access video input devices such as
encoders and tuners. At this time, MythTV works best with USB DVB-S/C/T cards
supported by multimedia/webcamd because webcamd provides a V4L userland
application. Any DVB card supported by webcamd should work with MythTV, but a
list of known working cards can be found here. There are also drivers available
for Hauppauge cards in the following packages: multimedia/pvr250 and multimedia
/pvrxxx, but they provide a non-standard driver interface that does not work
with versions of MythTV greater than 0.23.

HTPC contains a list of all available DVB drivers.

8.6.2.Â Dependencies

Being flexible and modular, MythTV allows the user to have the frontend and
backend on different machines.

For the frontend, multimedia/mythtv-frontend is required, as well as an X
server, which can be found in x11/xorg. Ideally, the frontend computer also has
a video card that supports XvMC and, optionally, a LIRC-compatible remote.

For the backend, multimedia/mythtv is required, as well as a MySQLâ ¢ database,
and optionally a tuner and storage for recordings. The MySQLâ ¢ package should
be automatically installed as a dependency when installing multimedia/mythtv.

8.6.3.Â Setting up MythTV

To install MythTV, use the following steps. First, install MythTV from the
FreeBSD Ports collection:

# cd /usr/ports/multimedia/mythtv # make install

Set up the MythTV database:

# mysql -uroot -p &lt; /usr/local/share/mythtv/database/mc.sql

Configure the backend:

# mythtv-setup

Start the backend:

# echo 'mythbackend_enable="YES"' &gt;&gt; /etc/rc.conf # service mythbackend start

8.7.Â Image Scanners

Written by Marc Fonvieille.

8.7.1.Â Introduction

In FreeBSD, access to image scanners is provided by the SANE (Scanner Access
Now Easy) API available through the FreeBSD Ports Collection. SANE will also
use some FreeBSD device drivers to access to the scanner hardware.

FreeBSD supports both SCSI and USB scanners. Be sure your scanner is supported
by SANE prior to performing any configuration. SANE has a supported devices
list that can provide you with information about the support for a scanner and
its status.

8.7.2.Â Kernel Configuration

As mentioned above both SCSI and USB interfaces are supported. According to
your scanner interface, different device drivers are required.

8.7.2.1.Â USB Interface

The GENERIC kernel by default includes the device drivers needed to support USB
scanners. Should you decide to use a custom kernel, be sure that the following
lines are present in your kernel configuration file:

device usb device uhci device ohci device ehci

After rebooting with the correct kernel, plug in your USB scanner. A line
showing the detection of your scanner should appear in the system message
buffer (dmesg(8)):

ugen0.2: &lt;EPSON&gt; at usbus0

These messages show that our scanner is using either /dev/ugen0.2 as device
node. For this example, a EPSON PerfectionÂ®Â 1650 USB scanner was used.

8.7.2.2.Â SCSI Interface

If your scanner comes with a SCSI interface, it is important to know which SCSI
controller board you will use. According to the SCSI chipset used, you will
have to tune your kernel configuration file. The GENERIC kernel supports the
most common SCSI controllers. Be sure to read the NOTES file and add the
correct line to your kernel configuration file. In addition to the SCSI adapter
driver, you need to have the following lines in your kernel configuration file:

device scbus device pass

Once your kernel has been properly compiled and installed, you should be able
to see the devices in the system message buffer, when booting:

pass2 at aic0 bus 0 target 2 lun 0 pass2: &lt;AGFA SNAPSCAN 600 1.10&gt; Fixed
Scanner SCSI-2 device pass2: 3.300MB/s transfers

If your scanner was not powered-on at system boot, it is still possible to
manually force the detection by performing a SCSI bus scan with the camcontrol
(8) command:

# camcontrol rescan all Re-scan of bus 0 was successful Re-scan of bus 1 was
successful Re-scan of bus 2 was successful Re-scan of bus 3 was successful

Then the scanner will appear in the SCSI devices list:

# camcontrol devlist &lt;IBM DDRS-34560 S97B&gt; at scbus0 target 5 lun 0 (pass0,da0)
&lt;IBM DDRS-34560 S97B&gt; at scbus0 target 6 lun 0 (pass1,da1) &lt;AGFA SNAPSCAN 600
1.10&gt; at scbus1 target 2 lun 0 (pass3) &lt;PHILIPS CDD3610 CD-R/RW 1.00&gt; at scbus2
target 0 lun 0 (pass2,cd0)

More details about SCSI devices are available in the scsi(4) and camcontrol(8)
manual pages.

8.7.3.Â SANE Configuration

The SANE system is split in two parts: the backends (graphics/sane-backends)
and the frontends (graphics/sane-frontends). The backends part provides access
to the scanner itself. The SANE's supported devices list specifies which
backend will support your image scanner. It is mandatory to determine the
correct backend for your scanner if you want to be able to use your device. The
frontends part provides the graphical scanning interface (xscanimage).

The first step is to install the graphics/sane-backends port or package. Then,
use the sane-find-scanner command to check the scanner detection by the SANE
system:

# sane-find-scanner -q found SCSI scanner "AGFA SNAPSCAN 600 1.10" at /dev/
pass3

The output will show the interface type of the scanner and the device node used
to attach the scanner to the system. The vendor and the product model may not
appear, it is not important.

Note:

Some USB scanners require you to load a firmware, this is explained in the
backend manual page. You should also read sane-find-scanner(1) and sane(7)
manual pages.

Now we have to check if the scanner will be identified by a scanning frontend.
By default, the SANE backends comes with a command line tool called scanimage
(1). This command allows you to list the devices and to perform an image
acquisition from the command line. The -L option is used to list the scanner
devices:

# scanimage -L device `snapscan:/dev/pass3' is a AGFA SNAPSCAN 600 flatbed
scanner

Or, for example with the USB scanner used in the SectionÂ 8.7.2.1, â  USB
Interfaceâ  :

# scanimage -L device 'epson2:libusb:/dev/usb:/dev/ugen0.2' is a Epson GT-8200
flatbed scanner

This output comes from a FreeBSDÂ 8.X system, the 'epson2:libusb:/dev/usb:/dev/
ugen0.2' item gives us the backend name (epson2) and the device node (/dev/
ugen0.2) used by our scanner.

Note:

No output or a message saying that no scanners were identified indicates that
scanimage(1) is unable to identify the scanner. If this happens, you will need
to edit the backend configuration file and define the scanner device used. The
/usr/local/etc/sane.d/ directory contains all backend configuration files. This
identification problem does appear with certain USB scanners.

For example, with the USB scanner used in the SectionÂ 8.7.2.1, â  USB
Interfaceâ  , under FreeBSDÂ 8.X the scanner is perfectly detected and working
but under prior versions of FreeBSD (where uscanner(4) driver is used)
sane-find-scanner gives us the following information:

# sane-find-scanner -q found USB scanner (UNKNOWN vendor and product) at device
/dev/uscanner0

The scanner is correctly detected, it uses the USB interface and is attached to
the /dev/uscanner0 device node. We can now check if the scanner is correctly
identified:

# scanimage -L No scanners were identified. If you were expecting something
different, check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation which
came with this software (README, FAQ, manpages).

Since the scanner is not identified, we will need to edit the /usr/local/etc/
sane.d/epson2.conf file. The scanner model used was the EPSON PerfectionÂ®
Â 1650, so we know the scanner will use the epson2 backend. Be sure to read the
help comments in the backends configuration files. Line changes are quite
simple: comment out all lines that have the wrong interface for your scanner
(in our case, we will comment out all lines starting with the word scsi as our
scanner uses the USB interface), then add at the end of the file a line
specifying the interface and the device node used. In this case, we add the
following line:

usb /dev/uscanner0

Please be sure to read the comments provided in the backend configuration file
as well as the backend manual page for more details and correct syntax to use.
We can now verify if the scanner is identified:

# scanimage -L device `epson:/dev/uscanner0' is a Epson GT-8200 flatbed scanner

Our USB scanner has been identified. It is not important if the brand and the
model do not match the scanner. The key item to be concerned with is the
`epson:/dev/uscanner0' field, which give us the right backend name and the
right device node.

Once the scanimage -L command is able to see the scanner, the configuration is
complete. The device is now ready to scan.

While scanimage(1) does allow us to perform an image acquisition from the
command line, it is preferable to use a graphical user interface to perform
image scanning. SANE offers a simple but efficient graphical interface: 
xscanimage (graphics/sane-frontends).

Xsane (graphics/xsane) is another popular graphical scanning frontend. This
frontend offers advanced features such as various scanning mode (photocopy,
fax, etc.), color correction, batch scans, etc. Both of these applications are
usable as a GIMP plugin.

8.7.4.Â Giving Other Users Access to the Scanner

All previous operations have been done with root privileges. You may however,
need other users to have access to the scanner. The user will need read and
write permissions to the device node used by the scanner. As an example, our
USB scanner uses the device node /dev/ugen0.2 which is in fact just a symlink
to the real device node called /dev/usb/0.2.0 (a quick look at the contents of
the /dev directory will confirm it). Both, the symlink and the device node, are
owned respectively by the wheel and the operator groups. Adding the user joe to
these groups will allow him to use the scanner but, for obvious security
reasons, you should think twice before adding a user to any group, especially
the wheel group. A better solution would be creating a specific group for using
the USB devices and make the scanner device accessible to members of this
group.

So we will use, for example, a group called usb. The first step is the creation
of this group with the help of the pw(8) command:

# pw groupadd usb

Then we have to make the /dev/ugen0.2 symlink and the /dev/usb/0.2.0 device
node accessible to the usb group with the correct write permissions (0660 or
0664), because by default only the owner of these files (root) can write to
them. All of this is done by adding the following lines to the /etc/devfs.rules
file:

[system=5] add path ugen0.2 mode 0660 group usb add path usb/0.2.0 mode 0666
group usb

Now, one will just have to add users to the usb group to allow the access to
the scanner:

# pw groupmod usb -m joe

For more details read the pw(8) manual page.

ChapterÂ 9.Â Configuring the FreeBSD Kernel

Updated and restructured by Jim Mock.
Originally contributed by Jake Hamby.
Table of Contents

9.1. Synopsis
9.2. Why Build a Custom Kernel?
9.3. Finding the System Hardware
9.4. Kernel Drivers, Subsystems, and Modules
9.5. Building and Installing a Custom Kernel
9.6. The Configuration File
9.7. If Something Goes Wrong

9.1.Â Synopsis

The kernel is the core of the FreeBSD operating system. It is responsible for
managing memory, enforcing security controls, networking, disk access, and much
more. While much of FreeBSD is dynamically configurable, it is still
occasionally necessary to configure and compile a custom kernel.

After reading this chapter, you will know:

  * When to build a custom kernel.

  * How to customize a kernel configuration file.

  * How to use the kernel configuration file to create and build a new kernel.

  * How to install the new kernel.

  * How to troubleshoot if things go wrong.

All of the commands listed in the examples in this chapter should be executed
as root.

9.2.Â Why Build a Custom Kernel?

Traditionally, FreeBSD used a â  monolithicâ   kernel. The kernel was one large
program, supported a fixed list of devices, and in order to change the kernel's
behavior, one had to compile a new kernel, and then reboot into the new kernel.

Today, most of the functionality in the FreeBSD kernel is contained in modules
which can be dynamically loaded and unloaded from the kernel as necessary. This
allows the running kernel to adapt immediately to new hardware or for new
functionality to be brought into the kernel. This is known as a modular kernel.

Occasionally, it is still necessary to perform static kernel configuration.
This may be because the functionality is so tied to the kernel that it can not
be made dynamically loadable. Some security environments prevent the loading
and unloading of kernel modules, and require that only needed functionality is
statically compiled into the kernel.

Building a custom kernel is often a rite of passage for advanced BSD users.
This process, while time consuming, can provide benefits to the FreeBSD system.
Unlike the GENERIC kernel, which must support a wide range of hardware, a
custom kernel can be stripped down to only provide support for that computer's
hardware. This has a number of benefits, such as:

  * Faster boot time. Since the kernel will only probe the hardware on the
    system, the time it takes the system to boot can decrease.

  * Lower memory usage. A custom kernel often uses less memory than the GENERIC
    kernel by omitting unused features and device drivers. This is important
    because the kernel code remains resident in physical memory at all times,
    preventing that memory from being used by applications. For this reason, a
    custom kernel is useful on a system with a small amount of RAM.

  * Additional hardware support. A custom kernel can add in support for devices
    which are not present in the GENERIC kernel.

9.3.Â Finding the System Hardware

Written by Tom Rhodes.

Before venturing into kernel configuration, it would be wise to get an
inventory of the machine's hardware. In cases where FreeBSD is not the primary
operating system, the inventory list can be created by viewing the current
operating system configuration. For example, MicrosoftÂ®'s Device Manager
contains information about installed devices.

Note:

Some versions of MicrosoftÂ®Â WindowsÂ® have a System icon which will display a
screen where Device Manager may be accessed.

If another operating system does not exist on the machine, the administrator
must find this information out manually. One method is using dmesg(8) and man
(1). Most device drivers on FreeBSD have a manual page, listing supported
hardware. During the boot probe, found hardware will be listed. For example,
the following lines indicate that the psm(4) driver found a mouse:

psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0 psm0: [GIANT-LOCKED] psm0: [ITHREAD] psm0:
model Generic PS/2 mouse, device ID 0

This driver will need to be included in the custom kernel configuration file or
loaded using loader.conf(5).

On occasion, the data from dmesg will only show system messages instead of the
boot probe output. In these situations, the output may be obtained by reading /
var/run/dmesg.boot.

Another method for finding hardware is to use pciconf(8) which provides more
verbose output. For example:

ath0@pci0:3:0:0: class=0x020000 card=0x058a1014 chip=0x1014168c rev=0x01 hdr=
0x00 vendor = 'Atheros Communications Inc.' device = 'AR5212 Atheros AR5212
802.11abg wireless' class = network subclass = ethernet

This output, obtained by using pciconf -lv, shows that the ath driver located a
wireless Ethernet device. Type man ath to read ath(4).

The -k flag, when passed to man(1) can be used to provide useful information.
For example, to display a list of manual pages which contain the specified
word:

# man -k Atheros
ath(4) - Atheros IEEE 802.11 wireless network driver ath_hal(4) - Atheros
Hardware Access Layer (HAL)

Armed with a hardware inventory list, the process of building a custom kernel
should appear less daunting.

9.4.Â Kernel Drivers, Subsystems, and Modules

Before building a custom kernel, consider the reason for doing so. If there is
a need for specific hardware support, it may already exist as a module.

Kernel modules exist in /boot/kernel and may be dynamically loaded into the
running kernel using kldload(8). Most, if not all kernel drivers have a
loadable module and manual page. For example, the ath(4) wireless Ethernet
driver has the following information in its manual page:

Alternatively, to load the driver as a module at boot time, place the following
line in loader.conf(5): if_ath_load="YES"

Adding if_ath_load="YES" to /boot/loader.conf will enable loading this module
dynamically at boot time.

In some cases, there is no associated module. This is mostly true for certain
subsystems. One way to tell if a driver is available is to check for the module
itself.

Warning:

It is easy to remove support for a device or option and end up with a broken
kernel. For example, if the ata(4) driver is removed from the kernel
configuration file, a system using ATA disk drivers may not boot. When in
doubt, just leave support in the kernel.

9.5.Â Building and Installing a Custom Kernel

Note:

It is required to have the full FreeBSD source tree installed to build the
kernel.

The kernel build is located at /usr/src/sys. It contains a number of
subdirectories representing different parts of the kernel. These include arch/
conf, which contains the kernel configuration file, and compile, which is the
staging area where the kernel will be built. arch contains subdirectories for
each supported architecture: i386, amd64, ia64, powerpc, sparc64, and pc98.
Everything inside a particular architecture's directory deals with that
architecture only and the rest of the code is machine independent code common
to all platforms. Notice the logical organization of the directory structure,
with each supported device, file system, and option in its own subdirectory.

The examples in this chapter assume the i386 architecture. If the system has a
different architecture, change the path names accordingly.

Note:

If /usr/src/ does not exist or it is empty, source has not been installed. The
easiest way to install source is to use svn as described in SectionÂ A.5, â  
Using Subversionâ  . One should also create a symlink to /usr/src/sys/:

# ln -s /usr/src/sys /sys

Next, cd to arch/conf and copy the GENERIC configuration file to the name of
the custom kernel. For example:

# cd /usr/src/sys/i386/conf # cp GENERIC MYKERNEL

Traditionally, this name is in all capital letters. When maintaining multiple
FreeBSD machines with different hardware, it is a good idea to name it after
the machine's hostname. This example uses MYKERNEL.

Tip:

When finished customizing the kernel configuration file, save a backup copy to
a location outside of /usr/src. Do not edit GENERIC directly.

Alternately, keep the kernel configuration file elsewhere and create a symbolic
link to the file in i386.

For example:

# cd /usr/src/sys/i386/conf # mkdir /root/kernels # cp GENERIC /root/kernels/
MYKERNEL # ln -s /root/kernels/MYKERNEL

Edit MYKERNEL with a text editor. The default editor is vi, whose usage is
covered well in many books in the bibliography. An easier editor for beginners,
called ee, is also available. Feel free to change the comment lines at the top
to reflect the configuration or the changes made to differentiate it from
GENERIC.

If the GENERIC configuration file seems overwhelming, follow the descriptions
in the Configuration File section slowly and carefully.

Note:

After syncing the source tree with the latest sources, always read /usr/src/
UPDATING before performing any update steps. This file describes any important
issues or areas requiring special attention within the updated source code. /
usr/src/UPDATING always matches the version of the FreeBSD source and contains
more up-to-date information than this Handbook.

After saving the edits, compile the source code for the kernel.

ProcedureÂ 9.1.Â Building a Kernel

Note:

It is required to have the full FreeBSD source tree installed to build the
kernel.

 1. cd to /usr/src:

    # cd /usr/src
 2. Compile the new kernel by specifying the name of the custom kernel
    configuration file:

    # make buildkernel KERNCONF=MYKERNEL
 3. Install the new kernel:

    # make installkernel KERNCONF=MYKERNEL

Tip:

By default, when a custom kernel is compiled, all kernel modules are rebuilt as
well. To update a kernel faster or to build only custom modules, edit /etc/
make.conf before starting to build the kernel:

MODULES_OVERRIDE = linux acpi sound/sound sound/driver/ds1 ntfs

This variable specifies the list of modules to build instead the default of
building of all of them.

WITHOUT_MODULES = linux acpi sound ntfs

This variable sets up a list of top level modules to exclude from the build
process. For other available variables, refer to make.conf(5).

The new kernel will be copied to /boot/kernel as /boot/kernel/kernel and the
old kernel will be moved to /boot/kernel.old/kernel. Now, shutdown the system
and reboot into the new kernel. If something goes wrong, refer to the
troubleshooting instructions and the section which explains how to recover when
the new kernel does not boot.

Note:

Other files relating to the boot process, such as the boot loader(8) and
configuration, are stored in /boot. Third party or custom modules can be placed
in /boot/kernel, although users should be aware that keeping modules in sync
with the compiled kernel is very important. Modules not intended to run with
the compiled kernel may result in instability.

9.6.Â The Configuration File

Updated by Joel Dahl.

The general format of a configuration file is quite simple. Each line contains
a keyword and one or more arguments. For simplicity, most lines only contain
one argument. Anything following a # is considered a comment and ignored. The
following sections describe each keyword, in the order they are listed in
GENERIC. For an exhaustive list of architecture dependent options and devices,
refer to NOTES in the same directory as GENERIC for that architecture. For
architecture independent options, refer to /usr/src/sys/conf/NOTES.

An include directive is available for use in configuration files. This allows
another configuration file to be included in the current one, making it easy to
maintain small changes relative to an existing file. For example, if only a
small number of additional options or drivers are required, this allows a delta
to be maintained with respect to GENERIC:

include GENERIC ident MYKERNEL options IPFIREWALL options DUMMYNET options
IPFIREWALL_DEFAULT_TO_ACCEPT options IPDIVERT

Using this method, the local configuration file expresses local differences
from a GENERIC kernel. As upgrades are performed, new features added to GENERIC
will be also be added to the local kernel unless they are specifically
prevented using nooptions or nodevice. A comprehensive list of configuration
directives and their descriptions may be found in config(5).

The remainder of this chapter addresses the contents of a typical configuration
file and the role various options and devices play.

Note:

To build a file which contains all available options, run the following command
as root:

# cd /usr/src/sys/i386/conf && make LINT

The following is an example of the GENERIC kernel configuration file with
various additional comments where needed for clarity. This example should match
the copy in /usr/src/sys/i386/conf/GENERIC fairly closely.

machine i386

This is the machine architecture. It must be either amd64, i386, ia64, pc98,
powerpc, or sparc64.

cpu I486_CPU cpu I586_CPU cpu I686_CPU

This option specifies the type of CPU. It is fine to have multiple instances of
the CPU entries, but for a custom kernel it is best to specify the CPU. To
determine the CPU type, review the boot messages in /var/run/dmesg.boot.

ident GENERIC

This is the identification of the kernel. Change this to the new kernel name,
such as MYKERNEL. The value in the ident string will print when the kernel
boots.

#To statically compile in device wiring instead of /boot/device.hints #hints
"GENERIC.hints" # Default places to look for devices.

device.hints(5) is used to configure options for device drivers. The default
location is /boot/device.hints. The hints option compiles these hints
statically into the kernel so that there is no need to create /boot/
device.hints.

makeoptions DEBUG=-g # Build kernel with gdb(1) debug symbols

This option enables debugging information when passed to gcc(1).

options SCHED_ULE # ULE scheduler

The default system scheduler for FreeBSD. Keep this.

options PREEMPTION # Enable kernel thread preemption

Allows kernel threads to be preempted by higher priority threads. This helps
with interactivity and allows interrupt threads to run sooner rather than
waiting.

options INET # InterNETworking

Networking support. This is mandatory as most programs require at least
loopback networking.

options INET6 # IPv6 communications protocols

This enables the IPv6 communication protocols.

options FFS # Berkeley Fast Filesystem

This is the basic hard drive file system. Leave it in if the system boots from
the hard disk.

options SOFTUPDATES # Enable FFS Soft Updates support

This option enables Soft Updates in the kernel which helps to speed up write
access on the disks. Even when this functionality is provided by the kernel, it
must be turned on for specific disks. Review the output of mount(8) to
determine if Soft Updates is enabled. If the soft-updates option is not in the
output, it can be activated using tunefs(8) for existing file systems or newfs
(8) for new file systems.

options UFS_ACL # Support for access control lists

This option enables kernel support for access control lists (ACLs). This relies
on the use of extended attributes and UFS2, and the feature is described in
detail in SectionÂ 15.11, â  File System Access Control Lists (ACLs)â  . ACLs
are enabled by default and should not be disabled in the kernel if they have
been used previously on a file system, as this will remove the ACLs, changing
the way files are protected in unpredictable ways.

options UFS_DIRHASH # Improve performance on big directories

This option includes functionality to speed up disk operations on large
directories, at the expense of using additional memory. Keep this for a large
server or interactive workstation, and remove it from smaller systems where
memory is at a premium and disk access speed is less important, such as a
firewall.

options MD_ROOT # MD is a potential root device

This option enables support for a memory backed virtual disk used as a root
device.

options NFSCLIENT # Network Filesystem Client options NFSSERVER # Network
Filesystem Server options NFS_ROOT # NFS usable as /, requires NFSCLIENT

The network file system (NFS). These lines can be commented unless the system
needs to mount partitions from a NFS file server over TCP/IP.

options MSDOSFS # MSDOS Filesystem

The MS-DOSÂ® file system. Unless the system needs to mount a DOS formatted hard
drive partition at boot time, comment this out. It will be automatically loaded
the first time a DOS partition is mounted. The emulators/mtools package allows
access to DOS floppies without having to mount and unmount them and does not
require MSDOSFS.

options CD9660 # ISO 9660 Filesystem

The ISO 9660 file system for CDROMs. Comment it out if the system does not have
a CDROM drive or only mounts data CDs occasionally since it will be dynamically
loaded the first time a data CD is mounted. Audio CDs do not need this file
system.

options PROCFS # Process filesystem (requires PSEUDOFS)

The process file system. This is a â  pretendâ   file system mounted on /proc
which allows some programs to provide more information on what processes are
running. Use of PROCFS is not required under most circumstances, as most
debugging and monitoring tools have been adapted to run without PROCFS. The
default installation will not mount this file system by default.

options PSEUDOFS # Pseudo-filesystem framework

Kernels making use of PROCFS must also include support for PSEUDOFS.

options GEOM_PART_GPT # GUID Partition Tables.

Adds support for GUID Partition Tables (GPT. GPT provides the ability to have a
large number of partitions per disk, 128 in the standard configuration.

options COMPAT_43 # Compatible with BSD 4.3 [KEEP THIS!]

Compatibility with 4.3BSD. Leave this in as some programs will act strangely if
this is commented out.

options COMPAT_FREEBSD4 # Compatible with FreeBSD4

This option is required to support applications compiled on older versions of
FreeBSD that use older system call interfaces. It is recommended that this
option be used on all i386â ¢ systems that may run older applications.
Platforms that gained support after FreeBSDÂ 4.X, such as ia64 and SPARC64Â®,
do not require this option.

options COMPAT_FREEBSD5 # Compatible with FreeBSD5

This option is required to support applications compiled on FreeBSDÂ 5.X
versions that use FreeBSDÂ 5.X system call interfaces.

options COMPAT_FREEBSD6 # Compatible with FreeBSD6

This option is required to support applications compiled on FreeBSDÂ 6.X
versions that use FreeBSDÂ 6.X system call interfaces.

options COMPAT_FREEBSD7 # Compatible with FreeBSD7

This option is required on FreeBSDÂ 8 and above to support applications
compiled on FreeBSDÂ 7.X versions that use FreeBSDÂ 7.X system call interfaces.

options SCSI_DELAY=5000 # Delay (in ms) before probing SCSI

This causes the kernel to pause for 5 seconds before probing each SCSI device
in the system. If the system only has IDE hard drives, ignore this or lower the
number to speed up booting. However, if FreeBSD has trouble recognizing the
SCSI devices, the number will have to be raised again.

options KTRACE # ktrace(1) support

This enables kernel process tracing, which is useful in debugging.

options SYSVSHM # SYSV-style shared memory

This option provides for SystemÂ V shared memory. The most common use of this
is the XSHM extension in X, which many graphics-intensive programs will
automatically take advantage of for extra speed. If Xorg is installed, include
this.

options SYSVMSG # SYSV-style message queues

Support for SystemÂ V messages. This option only adds a few hundred bytes to
the kernel.

options SYSVSEM # SYSV-style semaphores

Support for SystemÂ V semaphores. Less commonly used, but only adds a few
hundred bytes to the kernel.

Note:

Using -p with ipcs(1) will list any processes using each of these SystemÂ V
facilities.

options _KPOSIX_PRIORITY_SCHEDULING # POSIX P1003_1B real-time extensions

Real-time extensions added in the 1993 POSIXÂ®. Certain applications in the
Ports Collection use these.

options KBD_INSTALL_CDEV # install a CDEV entry in /dev

This option is required to allow the creation of keyboard device nodes in /dev.

options ADAPTIVE_GIANT # Giant mutex is adaptive.

Giant is the name of a mutual exclusion mechanism, a sleep mutex, that protects
a large set of kernel resources. Today, this is an unacceptable performance
bottleneck which is actively being replaced with locks that protect individual
resources. The ADAPTIVE_GIANT option causes Giant to be included in the set of
mutexes adaptively spun on. When a thread wants to lock the Giant mutex, but it
is already locked by a thread on another CPU, the first thread will keep
running and wait for the lock to be released. Normally, the thread would
instead go back to sleep and wait for its next chance to run. If unsure, leave
this in.

Note:

Beginning with FreeBSDÂ 8.0, all mutexes are adaptive by default, unless
explicitly set to non-adaptive by compiling with the NO_ADAPTIVE_MUTEXES
option. As a result, Giant is adaptive by default now, and the ADAPTIVE_GIANT
option has been removed from the kernel configuration.

device apic # I/O APIC

This device enables the use of the I/O APIC for interrupt delivery. It can be
used in both uni-processor and SMP kernels, but is required for SMP kernels.
Add options SMP to include support for multiple processors.

Note:

This device exists only on the i386 architecture and this configuration line
should not be used on other architectures.

device eisa

Include this for systems with an EISA motherboard. This enables auto-detection
and configuration support for all devices on the EISA bus.

device pci

Include this for systems with a PCI motherboard. This enables auto-detection of
PCI cards and gatewaying from the PCI to ISA bus.

# Floppy drives device fdc

This is the floppy drive controller.

# ATA and ATAPI devices device ata

This driver supports all ATA and ATAPI devices. Only one device ata line is
needed for the kernel to detect all PCI ATA/ATAPI devices on modern machines.

device atadisk # ATA disk drives

This is needed along with device ata for ATA disk drives.

device ataraid # ATA RAID drives

This is needed along with device ata for ATA RAID drives.

device atapicd # ATAPI CDROM drives

This is needed along with device ata for ATAPI CDROM drives.

device atapifd # ATAPI floppy drives

This is needed along with device ata for ATAPI floppy drives.

device atapist # ATAPI tape drives

This is needed along with device ata for ATAPI tape drives.

options ATA_STATIC_ID # Static device numbering

This makes the controller number static. Without this, the device numbers are
dynamically allocated.

# SCSI Controllers device ahb # EISA AHA1742 family device ahc # AHA2940 and
onboard AIC7xxx devices options AHC_REG_PRETTY_PRINT # Print register bitfields
in debug # output. Adds ~128k to driver. device ahd # AHA39320/29320 and
onboard AIC79xx devices options AHD_REG_PRETTY_PRINT # Print register bitfields
in debug # output. Adds ~215k to driver. device amd # AMD 53C974 (Teckram
DC-390(T)) device isp # Qlogic family #device ispfw # Firmware for QLogic HBAs-
normally a module device mpt # LSI-Logic MPT-Fusion #device ncr # NCR/Symbios
Logic device sym # NCR/Symbios Logic (newer chipsets + those of `ncr') device
trm # Tekram DC395U/UW/F DC315U adapters device adv # Advansys SCSI adapters
device adw # Advansys wide SCSI adapters device aha # Adaptec 154x SCSI
adapters device aic # Adaptec 15[012]x SCSI adapters, AIC-6[23]60. device bt #
Buslogic/Mylex MultiMaster SCSI adapters device ncv # NCR 53C500 device nsp #
Workbit Ninja SCSI-3 device stg # TMC 18C30/18C50

In this section, comment out any SCSI controllers not on the system. For an IDE
only system, these lines can be removed. The *_REG_PRETTY_PRINT lines are
debugging options for their respective drivers.

# SCSI peripherals device scbus # SCSI bus (required for SCSI) device ch # SCSI
media changers device da # Direct Access (disks) device sa # Sequential Access
(tape etc) device cd # CD device pass # Passthrough device (direct SCSI access)
device ses # SCSI Environmental Services (and SAF-TE)

Comment out any SCSI peripherals not on the system. If the system only has IDE
hardware, these lines can be removed completely.

Note:

The USB umass(4) driver and a few other drivers use the SCSI subsystem even
though they are not real SCSI devices. Do not remove SCSI support if any such
drivers are included in the kernel configuration.

# RAID controllers interfaced to the SCSI subsystem device amr # AMI MegaRAID
device arcmsr # Areca SATA II RAID device asr # DPT SmartRAID V, VI and Adaptec
SCSI RAID device ciss # Compaq Smart RAID 5* device dpt # DPT Smartcache III,
IV - See NOTES for options device hptmv # Highpoint RocketRAID 182x device
hptrr # Highpoint RocketRAID 17xx, 22xx, 23xx, 25xx device iir # Intel
Integrated RAID device ips # IBM (Adaptec) ServeRAID device mly # Mylex
AcceleRAID/eXtremeRAID device twa # 3ware 9000 series PATA/SATA RAID # RAID
controllers device aac # Adaptec FSA RAID device aacp # SCSI passthrough for
aac (requires CAM) device ida # Compaq Smart RAID device mfi # LSI MegaRAID SAS
device mlx # Mylex DAC960 family device pst # Promise Supertrak SX6000 device
twe # 3ware ATA RAID

Supported RAID controllers. If the system does not have any of these, comment
them out or remove them.

# atkbdc0 controls both the keyboard and the PS/2 mouse device atkbdc # AT
keyboard controller

The atkbdc keyboard controller provides I/O services for the AT keyboard and PS
/2 style pointing devices. This controller is required by atkbd(4) and psm(4).

device atkbd # AT keyboard

The atkbd(4) driver, together with the atkbdc(4) controller, provides access to
the AT 84 keyboard or the AT enhanced keyboard which is connected to the AT
keyboard controller.

device psm # PS/2 mouse

Use this device if the mouse plugs into the PS/2 mouse port.

device kbdmux # keyboard multiplexer

Basic support for keyboard multiplexing. If the system does not use more than
one keyboard, this line can be safely removed.

device vga # VGA video card driver

The vga(4) video card driver.

device splash # Splash screen and screen saver support

Required by the boot splash screen and screen savers.

# syscons is the default console driver, resembling an SCO console device sc

sc(4) is the default console driver and resembles a SCO console. Since most
full-screen programs access the console through a terminal database library
like termcap, it should not matter whether this or vt, the VT220 compatible
console driver, is used. When a user logs in, the TERM variable can be set to
scoansi if full-screen programs have trouble running under this console.

# Enable this for the pcvt (VT220 compatible) console driver #device vt #
options XSERVER # support for X server on a vt console #options FAT_CURSOR #
start with block cursor

This is a VT220-compatible console driver, backward compatible to VT100/102. It
works well on some laptops which have hardware incompatibilities with sc. Users
may need to set TERM to vt100 or vt220 after login. This driver is useful when
connecting to a large number of different machines over the network, where
termcap or terminfo entries for the sc device are not available as vt100 should
be available on virtually any platform.

device agp

Include this if the system has an AGP card. This will enable support for AGP
and AGP GART for boards which have these features.

# Add suspend/resume support for the i8254. device pmtimer

Timer device driver for power management events, such as APM and ACPI.

# PCCARD (PCMCIA) support # PCMCIA and cardbus bridge support device cbb #
cardbus (yenta) bridge device pccard # PC Card (16-bit) bus device cardbus #
CardBus (32-bit) bus

PCMCIA support. Keep this on laptop systems.

# Serial (COM) ports device sio # 8250, 16[45]50 based serial ports

These are the serial ports referred to as COM ports in WindowsÂ®.

Note:

If the system has an internal modem on COM4 and a serial port at COM2, change
the IRQ of the modem to 2. For a multiport serial card, refer to sio(4) for
more information on the proper values to add to /boot/device.hints. Some video
cards, notably those based on S3 chips, use I/O addresses in the form of
0x*2e8. Since many cheap serial cards do not fully decode the 16-bit I/O
address space, they clash with these cards, making the COM4 port practically
unavailable.

Each serial port is required to have a unique IRQ and the default IRQs for COM3
and COM4 cannot be used. The exception is multiport cards where shared
interrupts are supported.

# Parallel port device ppc

This is the ISA bus parallel port interface.

device ppbus # Parallel port bus (required)

Provides support for the parallel port bus.

device lpt # Printer

Adds support for parallel port printers.

Note:

All three of the above are required to enable parallel printer support.

device ppi # Parallel port interface device

The general-purpose I/O (â  geek portâ  ) + IEEE1284 I/O.

#device vpo # Requires scbus and da

This is for an Iomega Zip drive. It requires scbus and da support. Best
performance is achieved with ports in EPP 1.9 mode.

#device puc

Uncomment this device if the system has a â  dumbâ   serial or parallel PCI
card that is supported by the puc(4) glue driver.

# PCI Ethernet NICs. device de # DEC/Intel DC21x4x (â  Tulipâ  ) device em #
Intel PRO/1000 adapter Gigabit Ethernet Card device ixgb # Intel PRO/10GbE
Ethernet Card device txp # 3Com 3cR990 (â  Typhoonâ  ) device vx # 3Com 3c590,
3c595 (â  Vortexâ  )

Various PCI network card drivers. Comment out or remove any of these which are
not present in the system.

# PCI Ethernet NICs that use the common MII bus controller code. # NOTE: Be
sure to keep the 'device miibus' line in order to use these NICs! device miibus
# MII bus support

MII bus support is required for some PCI 10/100 Ethernet NICs, namely those
which use MII-compliant transceivers or implement transceiver control
interfaces that operate like an MII. Adding device miibus to the kernel config
pulls in support for the generic miibus API and all of the PHY drivers,
including a generic one for PHYs that are not specifically handled by an
individual driver.

device bce # Broadcom BCM5706/BCM5708 Gigabit Ethernet device bfe # Broadcom
BCM440x 10/100 Ethernet device bge # Broadcom BCM570xx Gigabit Ethernet device
dc # DEC/Intel 21143 and various workalikes device fxp # Intel EtherExpress PRO
/100B (82557, 82558) device lge # Level 1 LXT1001 gigabit ethernet device msk #
Marvell/SysKonnect Yukon II Gigabit Ethernet device nge # NatSemi DP83820
gigabit ethernet device nve # nVidia nForce MCP on-board Ethernet Networking
device pcn # AMD Am79C97x PCI 10/100 (precedence over 'lnc') device re #
RealTek 8139C+/8169/8169S/8110S device rl # RealTek 8129/8139 device sf #
Adaptec AIC-6915 (â  Starfireâ  ) device sis # Silicon Integrated Systems SiS
900/SiS 7016 device sk # SysKonnect SK-984x & SK-982x gigabit Ethernet device
ste # Sundance ST201 (D-Link DFE-550TX) device stge # Sundance/Tamarack TC9021
gigabit Ethernet device ti # Alteon Networks Tigon I/II gigabit Ethernet device
tl # Texas Instruments ThunderLAN device tx # SMC EtherPower II (83c170 â  EPIC
â  ) device vge # VIA VT612x gigabit ethernet device vr # VIA Rhine, Rhine II
device wb # Winbond W89C840F device xl # 3Com 3c90x (â  Boomerangâ  , â  
Cycloneâ  )

Drivers that use the MII bus controller code.

# ISA Ethernet NICs. pccard NICs included. device cs # Crystal Semiconductor
CS89x0 NIC # 'device ed' requires 'device miibus' device ed # NE[12]000, SMC
Ultra, 3c503, DS8390 cards device ex # Intel EtherExpress Pro/10 and Pro/10+
device ep # Etherlink III based cards device fe # Fujitsu MB8696x based cards
device ie # EtherExpress 8/16, 3C507, StarLAN 10 etc. device lnc # NE2100,
NE32-VL Lance Ethernet cards device sn # SMC's 9000 series of Ethernet chips
device xe # Xircom pccard Ethernet # ISA devices that use the old ISA shims #
device le

ISA Ethernet drivers. See /usr/src/sys/i386/conf/NOTES for details of which
cards are supported by which driver.

# Wireless NIC cards device wlan # 802.11 support

Generic 802.11 support. This line is required for wireless networking.

device wlan_wep # 802.11 WEP support device wlan_ccmp # 802.11 CCMP support
device wlan_tkip # 802.11 TKIP support

Crypto support for 802.11 devices. These lines are needed on systems which use
encryption and 802.11i security protocols.

device an # Aironet 4500/4800 802.11 wireless NICs. device ath # Atheros pci/
cardbus NIC's device ath_hal # Atheros HAL (Hardware Access Layer) device
ath_rate_sample # SampleRate tx rate control for ath device awi # BayStack 660
and others device ral # Ralink Technology RT2500 wireless NICs. device wi #
WaveLAN/Intersil/Symbol 802.11 wireless NICs. #device wl # Older non 802.11
Wavelan wireless NIC.

Support for various wireless cards.

# Pseudo devices device loop # Network loopback

This is the generic loopback device for TCP/IP. This is mandatory.

device random # Entropy device

Cryptographically secure random number generator.

device ether # Ethernet support

ether is only needed if the system has an Ethernet card. It includes generic
Ethernet protocol code.

device sl # Kernel SLIP

sl provides SLIP support. This has been almost entirely supplanted by PPP,
which is easier to set up, better suited for modem-to-modem connection, and
more powerful.

device ppp # Kernel PPP

This is for kernel PPP support for dial-up connections. There is also a version
of PPP implemented as a userland application that uses tun and offers more
flexibility and features such as demand dialing.

device tun # Packet tunnel.

This is used by the userland PPP software. See the PPP section of the Handbook
for more information.

device pty # Pseudo-ttys (telnet etc)

This is a â  pseudo-terminalâ   or simulated login port. It is used by incoming
telnet and rlogin sessions, xterm, and some other applications such as Emacs.

device md # Memory â  disksâ  

Memory disk pseudo-devices.

device gif # IPv6 and IPv4 tunneling

This implements IPv6 over IPv4 tunneling, IPv4 over IPv6 tunneling, IPv4 over
IPv4 tunneling, and IPv6 over IPv6 tunneling. The gif device is â  auto-cloning
â  , and will create device nodes as needed.

device faith # IPv6-to-IPv4 relaying (translation)

This pseudo-device captures packets that are sent to it and diverts them to the
IPv4/IPv6 translation daemon.

# The `bpf' device enables the Berkeley Packet Filter. # Be aware of the
administrative consequences of enabling this! # Note that 'bpf' is required for
DHCP. device bpf # Berkeley packet filter

The Berkeley Packet Filter pseudo-device allows network interfaces to be placed
in promiscuous mode, capturing every packet on a broadcast network such as an
Ethernet network. These packets can be captured to disk and or examined using
tcpdump(1).

Note:

The bpf(4) device is also used by dhclient(8). If DHCP is used, leave this
uncommented.

# USB support device uhci # UHCI PCI-&gt;USB interface device ohci # OHCI PCI-&gt;USB
interface device ehci # EHCI PCI-&gt;USB interface (USB 2.0) device usb # USB Bus
(required) #device udbp # USB Double Bulk Pipe devices device ugen # Generic
device uhid # â  Human Interface Devicesâ   device ukbd # Keyboard device ulpt
# Printer device umass # Disks/Mass storage - Requires scbus and da device ums
# Mouse device ural # Ralink Technology RT2500USB wireless NICs device urio #
Diamond Rio 500 MP3 player device uscanner # Scanners # USB Ethernet, requires
mii device aue # ADMtek USB Ethernet device axe # ASIX Electronics USB Ethernet
device cdce # Generic USB over Ethernet device cue # CATC USB Ethernet device
kue # Kawasaki LSI USB Ethernet device rue # RealTek RTL8150 USB Ethernet

Support for various USB devices.

# FireWire support device firewire # FireWire bus code device sbp # SCSI over
FireWire (Requires scbus and da) device fwe # Ethernet over FireWire
(non-standard!)

Support for various Firewire devices.

For more information and additional devices supported by FreeBSD, see /usr/src/
sys/i386/conf/NOTES.

9.6.1.Â Large Memory Configurations (PAE)

Large memory configuration machines require access to more than the 4 gigabyte
limit on User+Kernel Virtual Address (KVA) space. Due to this limitation, Intel
added support for 36-bit physical address space access in the PentiumÂ® Pro and
later line of CPUs.

The Physical Address Extension (PAE) capability of the IntelÂ® PentiumÂ® Pro
and later CPUs allows memory configurations of up to 64 gigabytes. FreeBSD
provides support for this capability via the PAE kernel configuration option,
available in all current release versions of FreeBSD. Due to the limitations of
the Intel memory architecture, no distinction is made for memory above or below
4 gigabytes. Memory allocated above 4 gigabytes is simply added to the pool of
available memory.

To enable PAE support in the kernel, add the following line to the kernel
configuration file:

options PAE

Note:

The PAE support in FreeBSD is only available for IntelÂ® IA-32 processors. It
should also be noted that the PAE support in FreeBSD has not received wide
testing, and should be considered beta quality compared to other stable
features of FreeBSD.

PAE support in FreeBSD has a few limitations:

  * A process is not able to access more than 4 gigabytes of virtual memory
    space.

  * Device drivers that do not use the bus_dma(9) interface will cause data
    corruption in a PAE enabled kernel and are not recommended for use. For
    this reason, a PAE kernel configuration file is provided in FreeBSD which
    excludes all drivers not known to work in a PAE enabled kernel.

  * Some system tunables determine memory resource usage by the amount of
    available physical memory. Such tunables can unnecessarily over-allocate
    due to the large memory nature of a PAE system. One such example is the
    kern.maxvnodes sysctl, which controls the maximum number of vnodes allowed
    in the kernel. It is advised to adjust this and other such tunables to a
    reasonable value.

  * It might be necessary to increase the kernel virtual address (KVA) space or
    to reduce the amount of specific kernel resource that is heavily used in
    order to avoid KVA exhaustion. The KVA_PAGES kernel option can be used for
    increasing the KVA space.

For performance and stability concerns, it is advised to consult tuning(7). pae
(4) contains up-to-date information on FreeBSD's PAE support.

9.7.Â If Something Goes Wrong

There are four categories of trouble that can occur when building a custom
kernel. They are:

config fails:

    If config(8) fails, it is probably a simple error. Fortunately, config(8)
    will print the line number that it had trouble with. For example, for this
    message:

    config: line 17: syntax error

    Make sure the keyword on line 17 is typed correctly by comparing it to the
    GENERIC kernel or another reference.

make fails:

    If make fails, it usually signals an error in the kernel description which
    is not severe enough for config(8) to catch. Review the configuration, and
    if you still cannot resolve the problem, send an email to the FreeBSD
    general questions mailing list with the kernel configuration.

The kernel does not boot:

    If the new kernel does not boot, or fails to recognize devices, do not
    panic! Fortunately, FreeBSD has an excellent mechanism for recovering from
    incompatible kernels. Simply choose the kernel to boot from at the FreeBSD
    boot loader. This can be accessed when the system boot menu appears by
    selecting the â  Escape to a loader promptâ   option. At the prompt, type
    boot kernel.old, or the name of any other kernel that will boot properly.
    When reconfiguring a kernel, it is always a good idea to keep a kernel that
    is known to work on hand.

    After booting with a good kernel, check over the configuration file and try
    to build it again. One helpful resource is /var/log/messages which records
    the kernel messages from every successful boot. Also, dmesg(8) will print
    the kernel messages from the current boot.

    Note:

    When troubleshooting a kernel, make sure to keep GENERIC, or some other
    kernel that is known to work, on hand as a different name that will not get
    erased on the next build. Do not rely on kernel.old because when installing
    a new kernel, kernel.old is overwritten with the last installed kernel
    which may be non-functional. As soon as possible, move the working kernel
    to the proper /boot/kernel location or commands such as ps(1) may not work
    properly. To do this, simply rename the directory containing the good
    kernel:

    # mv /boot/kernel /boot/kernel.bad # mv /boot/kernel.good /boot/kernel
The kernel works, but ps(1) does not work any more:

    If the kernel version differs from the one that the system utilities have
    been built with, for example, a -CURRENT kernel on a -RELEASE, many system
    status commands like ps(1) and vmstat(8) will not work. To fix this,
    recompile and install a world built with the same version of the source
    tree as the kernel. This is one reason why it is not a good idea to use a
    different version of the kernel than the rest of the operating system.

ChapterÂ 10.Â Printing

Contributed by Sean Kelly.
Restructured and updated by Jim Mock.
Table of Contents

10.1. Synopsis
10.2. Introduction
10.3. Basic Setup
10.4. Advanced Printer Setup
10.5. Using Printers
10.6. Alternatives to the Standard Spooler
10.7. Troubleshooting

10.1.Â Synopsis

FreeBSD can be used to print with a wide variety of printers, from the oldest
impact printer to the latest laser printers, and everything in between,
allowing you to produce high-quality printed output from the applications you
run.

FreeBSD can also be configured to act as a print server on a network; in this
capacity FreeBSD can receive print jobs from a variety of other computers,
including other FreeBSD computers, WindowsÂ® and MacÂ OSÂ® hosts. FreeBSD will
ensure that one job at a time is printed, and can keep statistics on which
users and machines are doing the most printing, produce â  bannerâ   pages
showing whose printout is whose, and more.

After reading this chapter, you will know:

  * How to configure the FreeBSD print spooler.

  * How to install print filters, to handle special print jobs differently,
    including converting incoming documents to print formats that your printers
    understand.

  * How to enable header, or banner pages on your printout.

  * How to print with printers connected to other computers.

  * How to print with printers connected directly to the network.

  * How to control printer restrictions, including limiting the size of print
    jobs, and preventing certain users from printing.

  * How to keep printer statistics, and account for printer usage.

  * How to troubleshoot printing problems.

Before reading this chapter, you should:

  * Know how to configure and install a new kernel (ChapterÂ 9, Configuring the
    FreeBSD Kernel).

10.2.Â Introduction

In order to use printers with FreeBSD you may set them up to work with the
Berkeley line printer spooling system, also known as the LPD spooling system,
or just LPD. It is the standard printer control system in FreeBSD. This chapter
introduces LPD and will guide you through its configuration.

If you are already familiar with LPD or another printer spooling system, you
may wish to skip to section Basic Setup.

LPD controls everything about a host's printers. It is responsible for a number
of things:

  * It controls access to attached printers and printers attached to other
    hosts on the network.

  * It enables users to submit files to be printed; these submissions are known
    as jobs.

  * It prevents multiple users from accessing a printer at the same time by
    maintaining a queue for each printer.

  * It can print header pages (also known as banner or burst pages) so users
    can easily find jobs they have printed in a stack of printouts.

  * It takes care of communications parameters for printers connected on serial
    ports.

  * It can send jobs over the network to a LPD spooler on another host.

  * It can run special filters to format jobs to be printed for various printer
    languages or printer capabilities.

  * It can account for printer usage.

Through a configuration file (/etc/printcap), and by providing the special
filter programs, you can enable the LPD system to do all or some subset of the
above for a great variety of printer hardware.

10.2.1.Â Why You Should Use the Spooler

The spooler still provides benefit on a single-user system and should be used
because:

  * LPD prints jobs in the background; you do not have to wait for data to be
    copied to the printer.

  * LPD can conveniently run a job to be printed through filters to add date/
    time headers or convert a special file format (such as a TeX DVI file) into
    a format the printer will understand. You will not have to do these steps
    manually.

  * Many free and commercial programs that provide a print feature usually
    expect to talk to the spooler on your system. By setting up the spooling
    system, you will more easily support other software you may later add or
    already have.

10.3.Â Basic Setup

To use printers with the LPD spooling system, you will need to set up both your
printer hardware and the LPD software. This document describes two levels of
setup:

  * See section Simple Printer Setup to learn how to connect a printer, tell 
    LPD how to communicate with it, and print plain text files to the printer.

  * See section Advanced Printer Setup to learn how to print a variety of
    special file formats, to print header pages, to print across a network, to
    control access to printers, and to do printer accounting.

10.3.1.Â Simple Printer Setup

This section tells how to configure printer hardware and the LPD software to
use the printer. It teaches the basics:

  * Section Hardware Setup gives some hints on connecting the printer to a port
    on your computer.

  * Section Software Setup shows how to set up the LPD spooler configuration
    file (/etc/printcap).

If you are setting up a printer that uses a network protocol to accept data to
print instead of a computer's local interfaces, see Printers With Networked
Data Stream Interfaces.

Although this section is called â  Simple Printer Setupâ  , it is actually
fairly complex. Getting the printer to work with your computer and the LPD
spooler is the hardest part. The advanced options like header pages and
accounting are fairly easy once you get the printer working.

10.3.1.1.Â Hardware Setup

This section tells about the various ways you can connect a printer to your PC.
It talks about the kinds of ports and cables, and also the kernel configuration
you may need to enable FreeBSD to speak to the printer.

If you have already connected your printer and have successfully printed with
it under another operating system, you can probably skip to section Software
Setup.

10.3.1.1.1.Â Ports and Cables

Printers sold for use on PC's today generally come with one or more of the
following three interfaces:

  * Serial interfaces, also known as RS-232 or COM ports, use a serial port on
    your computer to send data to the printer. Serial interfaces are common in
    the computer industry and cables are readily available and also easy to
    construct. Serial interfaces sometimes need special cables and might
    require you to configure somewhat complex communications options. Most PC
    serial ports have a maximum transmission rate of 115200Â bps, which makes
    printing large graphic print jobs with them impractical.

  * Parallel interfaces use a parallel port on your computer to send data to
    the printer. Parallel interfaces are common in the PC market and are faster
    than RS-232 serial. Cables are readily available but more difficult to
    construct by hand. There are usually no communications options with
    parallel interfaces, making their configuration exceedingly simple.

    Parallel interfaces are sometimes known as â  Centronicsâ   interfaces,
    named after the connector type on the printer.

  * USB interfaces, named for the Universal Serial Bus, can run at even faster
    speeds than parallel or RS-232 serial interfaces. Cables are simple and
    cheap. USB is superior to RS-232 Serial and to Parallel for printing, but
    it is not as well supported under UNIXÂ® systems. A way to avoid this
    problem is to purchase a printer that has both a USB interface and a
    Parallel interface, as many printers do.

In general, Parallel interfaces usually offer just one-way communication
(computer to printer) while serial and USB gives you two-way. Newer parallel
ports (EPP and ECP) and printers can communicate in both directions under
FreeBSD when a IEEE-1284-compliant cable is used.

Two-way communication to the printer over a parallel port is generally done in
one of two ways. The first method uses a custom-built printer driver for
FreeBSD that speaks the proprietary language used by the printer. This is
common with inkjet printers and can be used for reporting ink levels and other
status information. The second method is used when the printer supports 
PostScriptÂ®.

PostScriptÂ® jobs are actually programs sent to the printer; they need not
produce paper at all and may return results directly to the computer. 
PostScriptÂ® also uses two-way communication to tell the computer about
problems, such as errors in the PostScriptÂ® program or paper jams. Your users
may be appreciative of such information. Furthermore, the best way to do
effective accounting with a PostScriptÂ® printer requires two-way
communication: you ask the printer for its page count (how many pages it has
printed in its lifetime), then send the user's job, then ask again for its page
count. Subtract the two values and you know how much paper to charge to the
user.

10.3.1.1.2.Â Parallel Ports

To hook up a printer using a parallel interface, connect the Centronics cable
between the printer and the computer. The instructions that came with the
printer, the computer, or both should give you complete guidance.

Remember which parallel port you used on the computer. The first parallel port
is ppc0 to FreeBSD; the second is ppc1, and so on. The printer device name uses
the same scheme: /dev/lpt0 for the printer on the first parallel ports etc.

10.3.1.1.3.Â Serial Ports

To hook up a printer using a serial interface, connect the proper serial cable
between the printer and the computer. The instructions that came with the
printer, the computer, or both should give you complete guidance.

If you are unsure what the â  proper serial cableâ   is, you may wish to try
one of the following alternatives:

  * A modem cable connects each pin of the connector on one end of the cable
    straight through to its corresponding pin of the connector on the other
    end. This type of cable is also known as a â  DTE-to-DCEâ   cable.

  * A null-modem cable connects some pins straight through, swaps others (send
    data to receive data, for example), and shorts some internally in each
    connector hood. This type of cable is also known as a â  DTE-to-DTEâ  
    cable.

  * A serial printer cable, required for some unusual printers, is like the
    null-modem cable, but sends some signals to their counterparts instead of
    being internally shorted.

You should also set up the communications parameters for the printer, usually
through front-panel controls or DIP switches on the printer. Choose the highest
bps (bits per second, sometimes baud rate) that both your computer and the
printer can support. Choose 7 or 8 data bits; none, even, or odd parity; and 1
or 2 stop bits. Also choose a flow control protocol: either none, or XON/XOFF
(also known as â  in-bandâ   or â  softwareâ  ) flow control. Remember these
settings for the software configuration that follows.

10.3.1.2.Â Software Setup

This section describes the software setup necessary to print with the LPD
spooling system in FreeBSD.

Here is an outline of the steps involved:

 1. Configure your kernel, if necessary, for the port you are using for the
    printer; section Kernel Configuration tells you what you need to do.

 2. Set the communications mode for the parallel port, if you are using a
    parallel port; section Setting the Communication Mode for the Parallel Port
    gives details.

 3. Test if the operating system can send data to the printer. Section Checking
    Printer Communications gives some suggestions on how to do this.

 4. Set up LPD for the printer by modifying the file /etc/printcap. You will
    find out how to do this later in this chapter.

10.3.1.2.1.Â Kernel Configuration

The operating system kernel is compiled to work with a specific set of devices.
The serial or parallel interface for your printer is a part of that set.
Therefore, it might be necessary to add support for an additional serial or
parallel port if your kernel is not already configured for one.

To find out if the kernel you are currently using supports a serial interface,
type:

# grep sioN /var/run/dmesg.boot

Where N is the number of the serial port, starting from zero. If you see output
similar to the following:

sio2 at port 0x3e8-0x3ef irq 5 on isa sio2: type 16550A

then the kernel supports the port.

To find out if the kernel supports a parallel interface, type:

# grep ppcN /var/run/dmesg.boot

Where N is the number of the parallel port, starting from zero. If you see
output similar to the following:

ppc0: &lt;Parallel port&gt; at port 0x378-0x37f irq 7 on isa0 ppc0: SMC-like chipset
(ECP/EPP/PS2/NIBBLE) in COMPATIBLE mode ppc0: FIFO with 16/16/8 bytes threshold

then the kernel supports the port.

You might have to reconfigure your kernel in order for the operating system to
recognize and use the parallel or serial port you are using for the printer.

To add support for a serial port, see the section on kernel configuration. To
add support for a parallel port, see that section and the section that follows.

10.3.1.3.Â Setting the Communication Mode for the Parallel Port

When you are using the parallel interface, you can choose whether FreeBSD
should use interrupt-driven or polled communication with the printer. The
generic printer device driver (lpt(4)) on FreeBSD uses the ppbus(4) system,
which controls the port chipset with the ppc(4) driver.

  * The interrupt-driven method is the default with the GENERIC kernel. With
    this method, the operating system uses an IRQ line to determine when the
    printer is ready for data.

  * The polled method directs the operating system to repeatedly ask the
    printer if it is ready for more data. When it responds ready, the kernel
    sends more data.

The interrupt-driven method is usually somewhat faster but uses up a precious
IRQ line. Some newer HP printers are claimed not to work correctly in interrupt
mode, apparently due to some (not yet exactly understood) timing problem. These
printers need polled mode. You should use whichever one works. Some printers
will work in both modes, but are painfully slow in interrupt mode.

You can set the communications mode in two ways: by configuring the kernel or
by using the lptcontrol(8) program.

To set the communications mode by configuring the kernel:

 1. Edit your kernel configuration file. Look for an ppc0 entry. If you are
    setting up the second parallel port, use ppc1 instead. Use ppc2 for the
    third port, and so on.

      * If you want interrupt-driven mode, edit the following line:

        hint.ppc.0.irq="N"

        in the /boot/device.hints file and replace N with the right IRQ number.
        The kernel configuration file must also contain the ppc(4) driver:

        device ppc
      * If you want polled mode, remove in your /boot/device.hints file, the
        following line:

        hint.ppc.0.irq="N"

        In some cases, this is not enough to put the port in polled mode under
        FreeBSD. Most of time it comes from acpi(4) driver, this latter is able
        to probe and attach devices, and therefore, control the access mode to
        the printer port. You should check your acpi(4) configuration to
        correct this problem.

 2. Save the file. Then configure, build, and install the kernel, then reboot.
    See kernel configuration for more details.

To set the communications mode with lptcontrol(8):

 1. Type:

    # lptcontrol -i -d /dev/lptN

    to set interrupt-driven mode for lptN.

 2. Type:

    # lptcontrol -p -d /dev/lptN

    to set polled-mode for lptN.

You could put these commands in your /etc/rc.local file to set the mode each
time your system boots. See lptcontrol(8) for more information.

10.3.1.4.Â Checking Printer Communications

Before proceeding to configure the spooling system, you should make sure the
operating system can successfully send data to your printer. It is a lot easier
to debug printer communication and the spooling system separately.

To test the printer, we will send some text to it. For printers that can
immediately print characters sent to them, the program lptest(1) is perfect: it
generates all 96 printable ASCII characters in 96 lines.

For a PostScriptÂ® (or other language-based) printer, we will need a more
sophisticated test. A small PostScriptÂ® program, such as the following, will
suffice:

%!PS 100 100 moveto 300 300 lineto stroke 310 310 moveto /Helvetica findfont 12
scalefont setfont (Is this thing working?) show showpage

The above PostScriptÂ® code can be placed into a file and used as shown in the
examples appearing in the following sections.

Note:

When this document refers to a printer language, it is assuming a language like
PostScriptÂ®, and not Hewlett Packard's PCL. Although PCL has great
functionality, you can intermingle plain text with its escape sequences. 
PostScriptÂ® cannot directly print plain text, and that is the kind of printer
language for which we must make special accommodations.

10.3.1.4.1.Â Checking a Parallel Printer

This section tells you how to check if FreeBSD can communicate with a printer
connected to a parallel port.

To test a printer on a parallel port:

 1. Become root with su(1).

 2. Send data to the printer.

      * If the printer can print plain text, then use lptest(1). Type:

        # lptest &gt; /dev/lptN

        Where N is the number of the parallel port, starting from zero.

      * If the printer understands PostScriptÂ® or other printer language, then
        send a small program to the printer. Type:

        # cat &gt; /dev/lptN

        Then, line by line, type the program carefully as you cannot edit a
        line once you have pressed RETURN or ENTER. When you have finished
        entering the program, press CONTROL+D, or whatever your end of file key
        is.

        Alternatively, you can put the program in a file and type:

        # cat file &gt; /dev/lptN

        Where file is the name of the file containing the program you want to
        send to the printer.

You should see something print. Do not worry if the text does not look right;
we will fix such things later.

10.3.1.4.2.Â Checking a Serial Printer

This section tells you how to check if FreeBSD can communicate with a printer
on a serial port.

To test a printer on a serial port:

 1. Become root with su(1).

 2. Edit the file /etc/remote. Add the following entry:

    printer:dv=/dev/port:br#bps-rate:pa=parity
   
    Where port is the device entry for the serial port (ttyu0, ttyu1, etc.),
    bps-rate is the bits-per-second rate at which the printer communicates, and
    parity is the parity required by the printer (either even, odd, none, or
    zero).

    Here is a sample entry for a printer connected via a serial line to the
    third serial port at 19200Â bps with no parity:

    printer:dv=/dev/ttyu2:br#19200:pa=none
 3. Connect to the printer with tip(1). Type:

    # tip printer

    If this step does not work, edit the file /etc/remote again and try using /
    dev/cuaaN instead of /dev/ttyuN.

 4. Send data to the printer.

      * If the printer can print plain text, then use lptest(1). Type:

        % $lptest
      * If the printer understands PostScriptÂ® or other printer language, then
        send a small program to the printer. Type the program, line by line, 
        very carefully as backspacing or other editing keys may be significant
        to the printer. You may also need to type a special end-of-file key for
        the printer so it knows it received the whole program. For PostScriptÂ®
        printers, press CONTROL+D.

        Alternatively, you can put the program in a file and type:

        % &gt;file

        Where file is the name of the file containing the program. After tip(1)
        sends the file, press any required end-of-file key.

You should see something print. Do not worry if the text does not look right;
we will fix that later.

10.3.1.5.Â Enabling the Spooler: the /etc/printcap File

At this point, your printer should be hooked up, your kernel configured to
communicate with it (if necessary), and you have been able to send some simple
data to the printer. Now, we are ready to configure LPD to control access to
your printer.

You configure LPD by editing the file /etc/printcap. The LPD spooling system
reads this file each time the spooler is used, so updates to the file take
immediate effect.

The format of the printcap(5) file is straightforward. Use your favorite text
editor to make changes to /etc/printcap. The format is identical to other
capability files like /usr/share/misc/termcap and /etc/remote. For complete
information about the format, see the cgetent(3).

The simple spooler configuration consists of the following steps:

 1. Pick a name (and a few convenient aliases) for the printer, and put them in
    the /etc/printcap file; see the Naming the Printer section for more
    information on naming.

 2. Turn off header pages (which are on by default) by inserting the sh
    capability; see the Suppressing Header Pages section for more information.

 3. Make a spooling directory, and specify its location with the sd capability;
    see the Making the Spooling Directory section for more information.

 4. Set the /dev entry to use for the printer, and note it in /etc/printcap
    with the lp capability; see the Identifying the Printer Device for more
    information. Also, if the printer is on a serial port, set up the
    communication parameters with the ms# capability which is discussed in the
    Configuring Spooler Communications Parameters section.

 5. Install a plain text input filter; see the Installing the Text Filter
    section for details.

 6. Test the setup by printing something with the lpr(1) command. More details
    are available in the Trying It Out and Troubleshooting sections.

Note:

Language-based printers, such as PostScriptÂ® printers, cannot directly print
plain text. The simple setup outlined above and described in the following
sections assumes that if you are installing such a printer you will print only
files that the printer can understand.

Users often expect that they can print plain text to any of the printers
installed on your system. Programs that interface to LPD to do their printing
usually make the same assumption. If you are installing such a printer and want
to be able to print jobs in the printer language and print plain text jobs, you
are strongly urged to add an additional step to the simple setup outlined
above: install an automatic plain-text-to-PostScriptÂ® (or other printer
language) conversion program. The section entitled Accommodating Plain Text
Jobs on PostScriptÂ® Printers tells how to do this.

10.3.1.5.1.Â Naming the Printer

The first (easy) step is to pick a name for your printer. It really does not
matter whether you choose functional or whimsical names since you can also
provide a number of aliases for the printer.

At least one of the printers specified in the /etc/printcap should have the
alias lp. This is the default printer's name. If users do not have the PRINTER
environment variable nor specify a printer name on the command line of any of
the LPD commands, then lp will be the default printer they get to use.

Also, it is common practice to make the last alias for a printer be a full
description of the printer, including make and model.

Once you have picked a name and some common aliases, put them in the /etc/
printcap file. The name of the printer should start in the leftmost column.
Separate each alias with a vertical bar and put a colon after the last alias.

In the following example, we start with a skeletal /etc/printcap that defines
two printers (a Diablo 630 line printer and a Panasonic KX-P4455 PostScriptÂ®
laser printer):

# # /etc/printcap for host rose # rattan|line|diablo|lp|Diablo 630 Line
Printer: bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:

In this example, the first printer is named rattan and has as aliases line,
diablo, lp, and Diablo 630 Line Printer. Since it has the alias lp, it is also
the default printer. The second is named bamboo, and has as aliases ps, PS, S,
panasonic, and Panasonic KX-P4455 PostScript v51.4.

10.3.1.5.2.Â Suppressing Header Pages

The LPD spooling system will by default print a header page for each job. The
header page contains the user name who requested the job, the host from which
the job came, and the name of the job, in nice large letters. Unfortunately,
all this extra text gets in the way of debugging the simple printer setup, so
we will suppress header pages.

To suppress header pages, add the sh capability to the entry for the printer in
/etc/printcap. Here is an example /etc/printcap with sh added:

# # /etc/printcap for host rose - no header pages anywhere # rattan|line|diablo
|lp|Diablo 630 Line Printer:\ :sh: bamboo|ps|PS|S|panasonic|Panasonic KX-P4455
PostScript v51.4:\ :sh:

Note how we used the correct format: the first line starts in the leftmost
column, and subsequent lines are indented. Every line in an entry except the
last ends in a backslash character.

10.3.1.5.3.Â Making the Spooling Directory

The next step in the simple spooler setup is to make a spooling directory, a
directory where print jobs reside until they are printed, and where a number of
other spooler support files live.

Because of the variable nature of spooling directories, it is customary to put
these directories under /var/spool. It is not necessary to backup the contents
of spooling directories, either. Recreating them is as simple as running mkdir
(1).

It is also customary to make the directory with a name that is identical to the
name of the printer, as shown below:

# mkdir /var/spool/printer-name

However, if you have a lot of printers on your network, you might want to put
the spooling directories under a single directory that you reserve just for
printing with LPD. We will do this for our two example printers rattan and
bamboo:

# mkdir /var/spool/lpd # mkdir /var/spool/lpd/rattan # mkdir /var/spool/lpd/
bamboo

Note:

If you are concerned about the privacy of jobs that users print, you might want
to protect the spooling directory so it is not publicly accessible. Spooling
directories should be owned and be readable, writable, and searchable by user
daemon and group daemon, and no one else. We will do this for our example
printers:

# chown daemon:daemon /var/spool/lpd/rattan # chown daemon:daemon /var/spool/
lpd/bamboo # chmod 770 /var/spool/lpd/rattan # chmod 770 /var/spool/lpd/bamboo

Finally, you need to tell LPD about these directories using the /etc/printcap
file. You specify the pathname of the spooling directory with the sd
capability:

# # /etc/printcap for host rose - added spooling directories # rattan|line|
diablo|lp|Diablo 630 Line Printer:\ :sh:sd=/var/spool/lpd/rattan: bamboo|ps|PS|
S|panasonic|Panasonic KX-P4455 PostScript v51.4:\ :sh:sd=/var/spool/lpd/bamboo:

Note that the name of the printer starts in the first column but all other
entries describing the printer should be indented and each line end escaped
with a backslash.

If you do not specify a spooling directory with sd, the spooling system will
use /var/spool/lpd as a default.

10.3.1.5.4.Â Identifying the Printer Device

In the Hardware Setup section, we identified the port and the relevant /dev
directory entry that FreeBSD will use to communicate with the printer. Now, we
tell LPD that information. When the spooling system has a job to print, it will
open the specified device on behalf of the filter program (which is responsible
for passing data to the printer).

List the /dev entry pathname in the /etc/printcap file using the lp capability.

In our running example, let us assume that rattan is on the first parallel
port, and bamboo is on a sixth serial port; here are the additions to /etc/
printcap:

# # /etc/printcap for host rose - identified what devices to use # rattan|line|
diablo|lp|Diablo 630 Line Printer:\ :sh:sd=/var/spool/lpd/rattan:\ :lp=/dev/
lpt0: bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\ :sh:sd=/
var/spool/lpd/bamboo:\ :lp=/dev/ttyu5:

If you do not specify the lp capability for a printer in your /etc/printcap
file, LPD uses /dev/lp as a default. /dev/lp currently does not exist in
FreeBSD.

If the printer you are installing is connected to a parallel port, skip to the
section entitled, Installing the Text Filter. Otherwise, be sure to follow the
instructions in the next section.

10.3.1.5.5.Â Configuring Spooler Communication Parameters

For printers on serial ports, LPD can set up the bps rate, parity, and other
serial communication parameters on behalf of the filter program that sends data
to the printer. This is advantageous since:

  * It lets you try different communication parameters by simply editing the /
    etc/printcap file; you do not have to recompile the filter program.

  * It enables the spooling system to use the same filter program for multiple
    printers which may have different serial communication settings.

The following /etc/printcap capabilities control serial communication
parameters of the device listed in the lp capability:

br#bps-rate

    Sets the communications speed of the device to bps-rate, where bps-rate can
    be 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800, 9600,
    19200, 38400, 57600, or 115200 bits-per-second.

ms#stty-mode

    Sets the options for the terminal device after opening the device. stty(1)
    explains the available options.

When LPD opens the device specified by the lp capability, it sets the
characteristics of the device to those specified with the ms# capability. Of
particular interest will be the parenb, parodd, cs5, cs6, cs7, cs8, cstopb,
crtscts, and ixon modes, which are explained in the stty(1) manual page.

Let us add to our example printer on the sixth serial port. We will set the bps
rate to 38400. For the mode, we will set no parity with -parenb, 8-bit
characters with cs8, no modem control with clocal and hardware flow control
with crtscts:

bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\ :sh:sd=/var/
spool/lpd/bamboo:\ :lp=/dev/ttyu5:ms#-parenb cs8 clocal crtscts:

10.3.1.5.6.Â Installing the Text Filter

We are now ready to tell LPD what text filter to use to send jobs to the
printer. A text filter, also known as an input filter, is a program that LPD
runs when it has a job to print. When LPD runs the text filter for a printer,
it sets the filter's standard input to the job to print, and its standard
output to the printer device specified with the lp capability. The filter is
expected to read the job from standard input, perform any necessary translation
for the printer, and write the results to standard output, which will get
printed. For more information on the text filter, see the Filters section.

For our simple printer setup, the text filter can be a small shell script that
just executes /bin/cat to send the job to the printer. FreeBSD comes with
another filter called lpf that handles backspacing and underlining for printers
that might not deal with such character streams well. And, of course, you can
use any other filter program you want. The filter lpf is described in detail in
section entitled lpf: a Text Filter.

First, let us make the shell script /usr/local/libexec/if-simple be a simple
text filter. Put the following text into that file with your favorite text
editor:

#!/bin/sh # # if-simple - Simple text input filter for lpd # Installed in /usr/
local/libexec/if-simple # # Simply copies stdin to stdout. Ignores all filter
arguments. /bin/cat && exit 0 exit 2

Make the file executable:

# chmod 555 /usr/local/libexec/if-simple

And then tell LPD to use it by specifying it with the if capability in /etc/
printcap. We will add it to the two printers we have so far in the example /etc
/printcap:

# # /etc/printcap for host rose - added text filter # rattan|line|diablo|lp|
Diablo 630 Line Printer:\ :sh:sd=/var/spool/lpd/rattan:\ :lp=/dev/lpt0:\ :if=/
usr/local/libexec/if-simple: bamboo|ps|PS|S|panasonic|Panasonic KX-P4455
PostScript v51.4:\ :sh:sd=/var/spool/lpd/bamboo:\ :lp=/dev/ttyu5:ms#-parenb cs8
clocal crtscts:\ :if=/usr/local/libexec/if-simple:

Note:

A copy of the if-simple script can be found in the /usr/share/examples/printing
directory.

10.3.1.5.7.Â Turn on LPD

lpd(8) is run from /etc/rc, controlled by the lpd_enable variable. This
variable defaults to NO. If you have not done so already, add the line:

lpd_enable="YES"

to /etc/rc.conf, and then either restart your machine, or just run lpd(8).

# lpd

10.3.1.5.8.Â Trying It Out

You have reached the end of the simple LPD setup. Unfortunately,
congratulations are not quite yet in order, since we still have to test the
setup and correct any problems. To test the setup, try printing something. To
print with the LPD system, you use the command lpr(1), which submits a job for
printing.

You can combine lpr(1) with the lptest(1) program, introduced in section
Checking Printer Communications to generate some test text.

To test the simple LPD setup:

Type:

# lptest 20 5 | lpr -Pprinter-name

Where printer-name is a the name of a printer (or an alias) specified in /etc/
printcap. To test the default printer, type lpr(1) without any -P argument.
Again, if you are testing a printer that expects PostScriptÂ®, send a 
PostScriptÂ® program in that language instead of using lptest(1). You can do so
by putting the program in a file and typing lpr file.

For a PostScriptÂ® printer, you should get the results of the program. If you
are using lptest(1), then your results should look like the following:

!"#$%&'()*+,-./01234 "#$%&'()*+,-./012345 #$%&'()*+,-./0123456 $%&'()*+,-./
01234567 %&'()*+,-./012345678

To further test the printer, try downloading larger programs (for
language-based printers) or running lptest(1) with different arguments. For
example, lptest 80 60 will produce 60 lines of 80 characters each.

If the printer did not work, see the Troubleshooting section.

10.4.Â Advanced Printer Setup

This section describes filters for printing specially formatted files, header
pages, printing across networks, and restricting and accounting for printer
usage.

10.4.1.Â Filters

Although LPD handles network protocols, queuing, access control, and other
aspects of printing, most of the real work happens in the filters. Filters are
programs that communicate with the printer and handle its device dependencies
and special requirements. In the simple printer setup, we installed a plain
text filterâ  an extremely simple one that should work with most printers
(section Installing the Text Filter).

However, in order to take advantage of format conversion, printer accounting,
specific printer quirks, and so on, you should understand how filters work. It
will ultimately be the filter's responsibility to handle these aspects. And the
bad news is that most of the time you have to provide filters yourself. The
good news is that many are generally available; when they are not, they are
usually easy to write.

Also, FreeBSD comes with one, /usr/libexec/lpr/lpf, that works with many
printers that can print plain text. (It handles backspacing and tabs in the
file, and does accounting, but that is about all it does.) There are also
several filters and filter components in the FreeBSD Ports Collection.

Here is what you will find in this section:

  * Section How Filters Work, tries to give an overview of a filter's role in
    the printing process. You should read this section to get an understanding
    of what is happening â  under the hoodâ   when LPD uses filters. This
    knowledge could help you anticipate and debug problems you might encounter
    as you install more and more filters for each of your printers.

  * LPD expects every printer to be able to print plain text by default. This
    presents a problem for PostScriptÂ® printers (or other language-based
    printers) which cannot directly print plain text. Section Accommodating
    Plain Text Jobs on PostScriptÂ® Printers tells you what you should do to
    overcome this problem. You should read this section if you have a 
    PostScriptÂ® printer.

  * PostScriptÂ® is a popular output format for many programs. Some people even
    write PostScriptÂ® code directly. Unfortunately, PostScriptÂ® printers are
    expensive. Section Simulating PostScriptÂ® on Non PostScriptÂ® Printers
    tells how you can further modify a printer's text filter to accept and
    print PostScriptÂ® data on a non PostScriptÂ® printer. You should read this
    section if you do not have a PostScriptÂ® printer.

  * Section Conversion Filters tells about a way you can automate the
    conversion of specific file formats, such as graphic or typesetting data,
    into formats your printer can understand. After reading this section, you
    should be able to set up your printers such that users can type lpr -t to
    print troff data, or lpr -d to print TeX DVI data, or lpr -v to print
    raster image data, and so forth. The reading of this section is
    recommended.

  * Section Output Filters tells all about a not often used feature of LPD:
    output filters. Unless you are printing header pages (see Header Pages),
    you can probably skip that section altogether.

  * Section lpf: a Text Filter describes lpf, a fairly complete if simple text
    filter for line printers (and laser printers that act like line printers)
    that comes with FreeBSD. If you need a quick way to get printer accounting
    working for plain text, or if you have a printer which emits smoke when it
    sees backspace characters, you should definitely consider lpf.

Note:

A copy of the various scripts described below can be found in the /usr/share/
examples/printing directory.

10.4.1.1.Â How Filters Work

As mentioned before, a filter is an executable program started by LPD to handle
the device-dependent part of communicating with the printer.

When LPD wants to print a file in a job, it starts a filter program. It sets
the filter's standard input to the file to print, its standard output to the
printer, and its standard error to the error logging file (specified in the lf
capability in /etc/printcap, or /dev/console by default).

Which filter LPD starts and the filter's arguments depend on what is listed in
the /etc/printcap file and what arguments the user specified for the job on the
lpr(1) command line. For example, if the user typed lpr -t, LPD would start the
troff filter, listed in the tf capability for the destination printer. If the
user wanted to print plain text, it would start the if filter (this is mostly
true: see Output Filters for details).

There are three kinds of filters you can specify in /etc/printcap:

  * The text filter, confusingly called the input filter in LPD documentation,
    handles regular text printing. Think of it as the default filter. LPD
    expects every printer to be able to print plain text by default, and it is
    the text filter's job to make sure backspaces, tabs, or other special
    characters do not confuse the printer. If you are in an environment where
    you have to account for printer usage, the text filter must also account
    for pages printed, usually by counting the number of lines printed and
    comparing that to the number of lines per page the printer supports. The
    text filter is started with the following argument list:

    filter-name [-c] -w width -l length -i indent -n login -h host acct-file

    where

    -c

        appears if the job is submitted with lpr -l

    width

        is the value from the pw (page width) capability specified in /etc/
        printcap, default 132

    length

        is the value from the pl (page length) capability, default 66

    indent

        is the amount of the indentation from lpr -i, default 0

    login

        is the account name of the user printing the file

    host

        is the host name from which the job was submitted

    acct-file

        is the name of the accounting file from the af capability.

  * A conversion filter converts a specific file format into one the printer
    can render onto paper. For example, ditroff typesetting data cannot be
    directly printed, but you can install a conversion filter for ditroff files
    to convert the ditroff data into a form the printer can digest and print.
    Section Conversion Filters tells all about them. Conversion filters also
    need to do accounting, if you need printer accounting. Conversion filters
    are started with the following arguments:

    filter-name -x pixel-width -y pixel-height -n login -h host acct-file

    where pixel-width is the value from the px capability (default 0) and
    pixel-height is the value from the py capability (default 0).

  * The output filter is used only if there is no text filter, or if header
    pages are enabled. In our experience, output filters are rarely used.
    Section Output Filters describes them. There are only two arguments to an
    output filter:

    filter-name -w width -l length

    which are identical to the text filters -w and -l arguments.

Filters should also exit with the following exit status:

exit 0

    If the filter printed the file successfully.

exit 1

    If the filter failed to print the file but wants LPD to try to print the
    file again. LPD will restart a filter if it exits with this status.

exit 2

    If the filter failed to print the file and does not want LPD to try again. 
    LPD will throw out the file.

The text filter that comes with the FreeBSD release, /usr/libexec/lpr/lpf,
takes advantage of the page width and length arguments to determine when to
send a form feed and how to account for printer usage. It uses the login, host,
and accounting file arguments to make the accounting entries.

If you are shopping for filters, see if they are LPD-compatible. If they are,
they must support the argument lists described above. If you plan on writing
filters for general use, then have them support the same argument lists and
exit codes.

10.4.1.2.Â Accommodating Plain Text Jobs on PostScriptÂ® Printers

If you are the only user of your computer and PostScriptÂ® (or other
language-based) printer, and you promise to never send plain text to your
printer and to never use features of various programs that will want to send
plain text to your printer, then you do not need to worry about this section at
all.

But, if you would like to send both PostScriptÂ® and plain text jobs to the
printer, then you are urged to augment your printer setup. To do so, we have
the text filter detect if the arriving job is plain text or PostScriptÂ®. All 
PostScriptÂ® jobs must start with %! (for other printer languages, see your
printer documentation). If those are the first two characters in the job, we
have PostScriptÂ®, and can pass the rest of the job directly. If those are not
the first two characters in the file, then the filter will convert the text
into PostScriptÂ® and print the result.

How do we do this?

If you have got a serial printer, a great way to do it is to install lprps.
lprps is a PostScriptÂ® printer filter which performs two-way communication
with the printer. It updates the printer's status file with verbose information
from the printer, so users and administrators can see exactly what the state of
the printer is (such as toner low or paper jam). But more importantly, it
includes a program called psif which detects whether the incoming job is plain
text and calls textps (another program that comes with lprps) to convert it to 
PostScriptÂ®. It then uses lprps to send the job to the printer.

lprps is part of the FreeBSD Ports Collection (see The Ports Collection). You
can install one of the both print/lprps-a4 and print/lprps-letter ports
according to the paper size used. After installing lprps, just specify the
pathname to the psif program that is part of lprps. If you installed lprps from
the Ports Collection, use the following in the serial PostScriptÂ® printer's
entry in /etc/printcap:

:if=/usr/local/libexec/psif:

The rw capability should be also included in order to let LPD to open the
printer in the read-write mode.

If you have a parallel PostScriptÂ® printer (and therefore cannot use two-way
communication with the printer, which lprps needs), you can use the following
shell script as the text filter:

#!/bin/sh # # psif - Print PostScript or plain text on a PostScript printer #
Script version; NOT the version that comes with lprps # Installed in /usr/local
/libexec/psif # IFS="" read -r first_line first_two_chars=`expr "$first_line" :
'\(..\)'` if [ "$first_two_chars" = "%!" ]; then # # PostScript job, print it.
# echo "$first_line" && cat && printf "\004" && exit 0 exit 2 else # # Plain
text, convert it, then print it. # ( echo "$first_line"; cat ) | /usr/local/bin
/textps && printf "\004" && exit 0 exit 2 fi

In the above script, textps is a program we installed separately to convert
plain text to PostScriptÂ®. You can use any text-to-PostScriptÂ® program you
wish. The FreeBSD Ports Collection (see The Ports Collection) includes a full
featured text-to-PostScriptÂ® program called a2ps that you might want to
investigate.

10.4.1.3.Â Simulating PostScriptÂ® on Non PostScriptÂ® Printers

PostScriptÂ® is the de facto standard for high quality typesetting and
printing. PostScriptÂ® is, however, an expensive standard. Thankfully, Aladdin
Enterprises has a free PostScriptÂ® work-alike called Ghostscript that runs
with FreeBSD. Ghostscript can read most PostScriptÂ® files and can render their
pages onto a variety of devices, including many brands of non-PostScriptÂ®
printers. By installing Ghostscript and using a special text filter for your
printer, you can make your non PostScriptÂ® printer act like a real PostScriptÂ
® printer.

Ghostscript is in the FreeBSD Ports Collection, many versions are available,
the most commonly used version is print/ghostscript-gpl.

To simulate PostScriptÂ®, we have the text filter detect if it is printing a 
PostScriptÂ® file. If it is not, then the filter will pass the file directly to
the printer; otherwise, it will use Ghostscript to first convert the file into
a format the printer will understand.

Here is an example: the following script is a text filter for Hewlett Packard
DeskJet 500 printers. For other printers, substitute the -sDEVICE argument to
the gs (Ghostscript) command. (Type gs -h to get a list of devices the current
installation of Ghostscript supports.)

#!/bin/sh # # ifhp - Print Ghostscript-simulated PostScript on a DeskJet 500 #
Installed in /usr/local/libexec/ifhp # # Treat LF as CR+LF (to avoid the
"staircase effect" on HP/PCL # printers): # printf "\033&k2G" || exit 2 # #
Read first two characters of the file # IFS="" read -r first_line
first_two_chars=`expr "$first_line" : '\(..\)'` if [ "$first_two_chars" = "%!"
]; then # # It is PostScript; use Ghostscript to scan-convert and print it. # /
usr/local/bin/gs -dSAFER -dNOPAUSE -q -sDEVICE=djet500 \ -sOutputFile=- - &&
exit 0 else # # Plain text or HP/PCL, so just print it directly; print a form
feed # at the end to eject the last page. # echo "$first_line" && cat && printf
"\033&l0H" && exit 0 fi exit 2

Finally, you need to notify LPD of the filter via the if capability:

:if=/usr/local/libexec/ifhp:

That is it. You can type lpr plain.text and lpr whatever.ps and both should
print successfully.

10.4.1.4.Â Conversion Filters

After completing the simple setup described in Simple Printer Setup, the first
thing you will probably want to do is install conversion filters for your
favorite file formats (besides plain ASCII text).

10.4.1.4.1.Â Why Install Conversion Filters?

Conversion filters make printing various kinds of files easy. As an example,
suppose we do a lot of work with the TeX typesetting system, and we have a 
PostScriptÂ® printer. Every time we generate a DVI file from TeX, we cannot
print it directly until we convert the DVI file into PostScriptÂ®. The command
sequence goes like this:

% dvips seaweed-analysis.dvi % lpr seaweed-analysis.ps

By installing a conversion filter for DVI files, we can skip the hand
conversion step each time by having LPD do it for us. Now, each time we get a
DVI file, we are just one step away from printing it:

% lpr -d seaweed-analysis.dvi

We got LPD to do the DVI file conversion for us by specifying the -d option.
Section Formatting and Conversion Options lists the conversion options.

For each of the conversion options you want a printer to support, install a 
conversion filter and specify its pathname in /etc/printcap. A conversion
filter is like the text filter for the simple printer setup (see section
Installing the Text Filter) except that instead of printing plain text, the
filter converts the file into a format the printer can understand.

10.4.1.4.2.Â Which Conversion Filters Should I Install?

You should install the conversion filters you expect to use. If you print a lot
of DVI data, then a DVI conversion filter is in order. If you have got plenty
of troff to print out, then you probably want a troff filter.

The following table summarizes the filters that LPD works with, their
capability entries for the /etc/printcap file, and how to invoke them with the
lpr command:

    File type            /etc/printcap capability             lpr option
cifplot            cf                                   -c
DVI                df                                   -d
plot               gf                                   -g
ditroff            nf                                   -n
FORTRAN text       rf                                   -f
troff              tf                                   -f
raster             vf                                   -v
plain text         if                                   none, -p, or -l

In our example, using lpr -d means the printer needs a df capability in its
entry in /etc/printcap.

Despite what others might contend, formats like FORTRAN text and plot are
probably obsolete. At your site, you can give new meanings to these or any of
the formatting options just by installing custom filters. For example, suppose
you would like to directly print Printerleaf files (files from the Interleaf
desktop publishing program), but will never print plot files. You could install
a Printerleaf conversion filter under the gf capability and then educate your
users that lpr -g mean â  print Printerleaf files.â  

10.4.1.4.3.Â Installing Conversion Filters

Since conversion filters are programs you install outside of the base FreeBSD
installation, they should probably go under /usr/local. The directory /usr/
local/libexec is a popular location, since they are specialized programs that
only LPD will run; regular users should not ever need to run them.

To enable a conversion filter, specify its pathname under the appropriate
capability for the destination printer in /etc/printcap.

In our example, we will add the DVI conversion filter to the entry for the
printer named bamboo. Here is the example /etc/printcap file again, with the
new df capability for the printer bamboo:

# # /etc/printcap for host rose - added df filter for bamboo # rattan|line|
diablo|lp|Diablo 630 Line Printer:\ :sh:sd=/var/spool/lpd/rattan:\ :lp=/dev/
lpt0:\ :if=/usr/local/libexec/if-simple: bamboo|ps|PS|S|panasonic|Panasonic
KX-P4455 PostScript v51.4:\ :sh:sd=/var/spool/lpd/bamboo:\ :lp=/dev/ttyu5:ms#
-parenb cs8 clocal crtscts:rw:\ :if=/usr/local/libexec/psif:\ :df=/usr/local/
libexec/psdf:

The DVI filter is a shell script named /usr/local/libexec/psdf. Here is that
script:

#!/bin/sh # # psdf - DVI to PostScript printer filter # Installed in /usr/local
/libexec/psdf # # Invoked by lpd when user runs lpr -d # exec /usr/local/bin/
dvips -f | /usr/local/libexec/lprps "$@"

This script runs dvips in filter mode (the -f argument) on standard input,
which is the job to print. It then starts the PostScriptÂ® printer filter lprps
(see section Accommodating Plain Text Jobs on PostScriptÂ® Printers) with the
arguments LPD passed to this script. The lprps utility will use those arguments
to account for the pages printed.

10.4.1.4.4.Â More Conversion Filter Examples

There is no fixed set of steps to install conversion filters, some working
examples are described in this section. Use these as guidance to making your
own filters. Use them directly, if appropriate.

This example script is a raster (well, GIF file, actually) conversion filter
for a Hewlett Packard LaserJet III-Si printer:

#!/bin/sh # # hpvf - Convert GIF files into HP/PCL, then print # Installed in /
usr/local/libexec/hpvf PATH=/usr/X11R6/bin:$PATH; export PATH giftopnm |
ppmtopgm | pgmtopbm | pbmtolj -resolution 300 \ && exit 0 \ || exit 2

It works by converting the GIF file into a portable anymap, converting that
into a portable graymap, converting that into a portable bitmap, and converting
that into LaserJet/PCL-compatible data.

Here is the /etc/printcap file with an entry for a printer using the above
filter:

# # /etc/printcap for host orchid # teak|hp|laserjet|Hewlett Packard LaserJet
3Si:\ :lp=/dev/lpt0:sh:sd=/var/spool/lpd/teak:mx#0:\ :if=/usr/local/libexec/
hpif:\ :vf=/usr/local/libexec/hpvf:

The following script is a conversion filter for troff data from the groff
typesetting system for the PostScriptÂ® printer named bamboo:

#!/bin/sh # # pstf - Convert groff's troff data into PS, then print. #
Installed in /usr/local/libexec/pstf # exec grops | /usr/local/libexec/lprps
"$@"

The above script makes use of lprps again to handle the communication with the
printer. If the printer were on a parallel port, we would use this script
instead:

#!/bin/sh # # pstf - Convert groff's troff data into PS, then print. #
Installed in /usr/local/libexec/pstf # exec grops

That is it. Here is the entry we need to add to /etc/printcap to enable the
filter:

:tf=/usr/local/libexec/pstf:

Here is an example that might make old hands at FORTRAN blush. It is a
FORTRAN-text filter for any printer that can directly print plain text. We will
install it for the printer teak:

#!/bin/sh # # hprf - FORTRAN text filter for LaserJet 3si: # Installed in /usr/
local/libexec/hprf # printf "\033&k2G" && fpr && printf "\033&l0H" && exit 0
exit 2

And we will add this line to the /etc/printcap for the printer teak to enable
this filter:

:rf=/usr/local/libexec/hprf:

Here is one final, somewhat complex example. We will add a DVI filter to the
LaserJet printer teak introduced earlier. First, the easy part: updating /etc/
printcap with the location of the DVI filter:

:df=/usr/local/libexec/hpdf:

Now, for the hard part: making the filter. For that, we need a DVI-to-LaserJet/
PCL conversion program. The FreeBSD Ports Collection (see The Ports Collection)
has one: print/dvi2xx. Installing this port gives us the program we need,
dvilj2p, which converts DVI into LaserJet IIp, LaserJet III, and LaserJet 2000
compatible codes.

The dvilj2p utility makes the filter hpdf quite complex since dvilj2p cannot
read from standard input. It wants to work with a filename. What is worse, the
filename has to end in .dvi so using /dev/fd/0 for standard input is
problematic. We can get around that problem by linking (symbolically) a
temporary file name (one that ends in .dvi) to /dev/fd/0, thereby forcing
dvilj2p to read from standard input.

The only other fly in the ointment is the fact that we cannot use /tmp for the
temporary link. Symbolic links are owned by user and group bin. The filter runs
as user daemon. And the /tmp directory has the sticky bit set. The filter can
create the link, but it will not be able clean up when done and remove it since
the link will belong to a different user.

Instead, the filter will make the symbolic link in the current working
directory, which is the spooling directory (specified by the sd capability in /
etc/printcap). This is a perfect place for filters to do their work, especially
since there is (sometimes) more free disk space in the spooling directory than
under /tmp.

Here, finally, is the filter:

#!/bin/sh # # hpdf - Print DVI data on HP/PCL printer # Installed in /usr/local
/libexec/hpdf PATH=/usr/local/bin:$PATH; export PATH # # Define a function to
clean up our temporary files. These exist # in the current directory, which
will be the spooling directory # for the printer. # cleanup() { rm -f
hpdf$$.dvi } # # Define a function to handle fatal errors: print the given
message # and exit 2. Exiting with 2 tells LPD to do not try to reprint the #
job. # fatal() { echo "$@" 1&gt;&2 cleanup exit 2 } # # If user removes the job,
LPD will send SIGINT, so trap SIGINT # (and a few other signals) to clean up
after ourselves. # trap cleanup 1 2 15 # # Make sure we are not colliding with
any existing files. # cleanup # # Link the DVI input file to standard input
(the file to print). # ln -s /dev/fd/0 hpdf$$.dvi || fatal "Cannot symlink /dev
/fd/0" # # Make LF = CR+LF # printf "\033&k2G" || fatal "Cannot initialize
printer" # # Convert and print. Return value from dvilj2p does not seem to be #
reliable, so we ignore it. # dvilj2p -M1 -q -e- dfhp$$.dvi # # Clean up and
exit # cleanup exit 0

10.4.1.4.5.Â Automated Conversion: an Alternative to Conversion Filters

All these conversion filters accomplish a lot for your printing environment,
but at the cost forcing the user to specify (on the lpr(1) command line) which
one to use. If your users are not particularly computer literate, having to
specify a filter option will become annoying. What is worse, though, is that an
incorrectly specified filter option may run a filter on the wrong type of file
and cause your printer to spew out hundreds of sheets of paper.

Rather than install conversion filters at all, you might want to try having the
text filter (since it is the default filter) detect the type of file it has
been asked to print and then automatically run the right conversion filter.
Tools such as file can be of help here. Of course, it will be hard to determine
the differences between some file typesâ  and, of course, you can still provide
conversion filters just for them.

The FreeBSD Ports Collection has a text filter that performs automatic
conversion called apsfilter (print/apsfilter). It can detect plain text, 
PostScriptÂ®, DVI and almost any kind of files, run the proper conversions, and
print.

10.4.1.5.Â Output Filters

The LPD spooling system supports one other type of filter that we have not yet
explored: an output filter. An output filter is intended for printing plain
text only, like the text filter, but with many simplifications. If you are
using an output filter but no text filter, then:

  * LPD starts an output filter once for the entire job instead of once for
    each file in the job.

  * LPD does not make any provision to identify the start or the end of files
    within the job for the output filter.

  * LPD does not pass the user's login or host to the filter, so it is not
    intended to do accounting. In fact, it gets only two arguments:

    filter-name -wwidth -llength

    Where width is from the pw capability and length is from the pl capability
    for the printer in question.

Do not be seduced by an output filter's simplicity. If you would like each file
in a job to start on a different page an output filter will not work. Use a
text filter (also known as an input filter); see section Installing the Text
Filter. Furthermore, an output filter is actually more complex in that it has
to examine the byte stream being sent to it for special flag characters and
must send signals to itself on behalf of LPD.

However, an output filter is necessary if you want header pages and need to
send escape sequences or other initialization strings to be able to print the
header page. (But it is also futile if you want to charge header pages to the
requesting user's account, since LPD does not give any user or host information
to the output filter.)

On a single printer, LPD allows both an output filter and text or other
filters. In such cases, LPD will start the output filter to print the header
page (see section Header Pages) only. LPD then expects the output filter to 
stop itself by sending two bytes to the filter: ASCII 031 followed by ASCII
001. When an output filter sees these two bytes (031, 001), it should stop by
sending SIGSTOP to itself. When LPD's done running other filters, it will
restart the output filter by sending SIGCONT to it.

If there is an output filter but no text filter and LPD is working on a plain
text job, LPD uses the output filter to do the job. As stated before, the
output filter will print each file of the job in sequence with no intervening
form feeds or other paper advancement, and this is probably not what you want.
In almost all cases, you need a text filter.

The program lpf, which we introduced earlier as a text filter, can also run as
an output filter. If you need a quick-and-dirty output filter but do not want
to write the byte detection and signal sending code, try lpf. You can also wrap
lpf in a shell script to handle any initialization codes the printer might
require.

10.4.1.6.Â lpf: a Text Filter

The program /usr/libexec/lpr/lpf that comes with FreeBSD binary distribution is
a text filter (input filter) that can indent output (job submitted with lpr
-i), allow literal characters to pass (job submitted with lpr -l), adjust the
printing position for backspaces and tabs in the job, and account for pages
printed. It can also act like an output filter.

The lpf filter is suitable for many printing environments. And although it has
no capability to send initialization sequences to a printer, it is easy to
write a shell script to do the needed initialization and then execute lpf.

In order for lpf to do page accounting correctly, it needs correct values
filled in for the pw and pl capabilities in the /etc/printcap file. It uses
these values to determine how much text can fit on a page and how many pages
were in a user's job. For more information on printer accounting, see
Accounting for Printer Usage.

10.4.2.Â Header Pages

If you have lots of users, all of them using various printers, then you
probably want to consider header pages as a necessary evil.

Header pages, also known as banner or burst pages identify to whom jobs belong
after they are printed. They are usually printed in large, bold letters,
perhaps with decorative borders, so that in a stack of printouts they stand out
from the real documents that comprise users' jobs. They enable users to locate
their jobs quickly. The obvious drawback to a header page is that it is yet one
more sheet that has to be printed for every job, their ephemeral usefulness
lasting not more than a few minutes, ultimately finding themselves in a
recycling bin or rubbish heap. (Note that header pages go with each job, not
each file in a job, so the paper waste might not be that bad.)

The LPD system can provide header pages automatically for your printouts if
your printer can directly print plain text. If you have a PostScriptÂ® printer,
you will need an external program to generate the header page; see Header Pages
on PostScriptÂ® Printers.

10.4.2.1.Â Enabling Header Pages

In the Simple Printer Setup section, we turned off header pages by specifying
sh (meaning â  suppress headerâ  ) in the /etc/printcap file. To enable header
pages for a printer, just remove the sh capability.

Sounds too easy, right?

You are right. You might have to provide an output filter to send
initialization strings to the printer. Here is an example output filter for
Hewlett Packard PCL-compatible printers:

#!/bin/sh # # hpof - Output filter for Hewlett Packard PCL-compatible printers
# Installed in /usr/local/libexec/hpof printf "\033&k2G" || exit 2 exec /usr/
libexec/lpr/lpf

Specify the path to the output filter in the of capability. See the Output
Filters section for more information.

Here is an example /etc/printcap file for the printer teak that we introduced
earlier; we enabled header pages and added the above output filter:

# # /etc/printcap for host orchid # teak|hp|laserjet|Hewlett Packard LaserJet
3Si:\ :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:\ :if=/usr/local/libexec/hpif:\
:vf=/usr/local/libexec/hpvf:\ :of=/usr/local/libexec/hpof:

Now, when users print jobs to teak, they get a header page with each job. If
users want to spend time searching for their printouts, they can suppress
header pages by submitting the job with lpr -h; see the Header Page Options
section for more lpr(1) options.

Note:

LPD prints a form feed character after the header page. If your printer uses a
different character or sequence of characters to eject a page, specify them
with the ff capability in /etc/printcap.

10.4.2.2.Â Controlling Header Pages

By enabling header pages, LPD will produce a long header, a full page of large
letters identifying the user, host, and job. Here is an example (kelly printed
the job named â  outlineâ   from host rose):

k ll ll k l l k l l k k eeee l l y y k k e e l l y y k k eeeeee l l y y kk k e
l l y y k k e e l l y yy k k eeee lll lll yyy y y y y yyyy ll t l i t l oooo u
u ttttt l ii n nnn eeee o o u u t l i nn n e e o o u u t l i n n eeeeee o o u u
t l i n n e o o u uu t t l i n n e e oooo uuu u tt lll iii n n eeee r rrr oooo
ssss eeee rr r o o s s e e r o o ss eeeeee r o o ss e r o o s s e e r oooo ssss
eeee Job: outline Date: Sun Sep 17 11:04:58 1995

LPD appends a form feed after this text so the job starts on a new page (unless
you have sf (suppress form feeds) in the destination printer's entry in /etc/
printcap).

If you prefer, LPD can make a short header; specify sb (short banner) in the /
etc/printcap file. The header page will look like this:

rose:kelly Job: outline Date: Sun Sep 17 11:07:51 1995

Also by default, LPD prints the header page first, then the job. To reverse
that, specify hl (header last) in /etc/printcap.

10.4.2.3.Â Accounting for Header Pages

Using LPD's built-in header pages enforces a particular paradigm when it comes
to printer accounting: header pages must be free of charge.

Why?

Because the output filter is the only external program that will have control
when the header page is printed that could do accounting, and it is not
provided with any user or host information or an accounting file, so it has no
idea whom to charge for printer use. It is also not enough to just â  increase
the page count by oneâ   by modifying the text filter or any of the conversion
filters (which do have user and host information) since users can suppress
header pages with lpr -h. They could still be charged for header pages they did
not print. Basically, lpr -h will be the preferred option of
environmentally-minded users, but you cannot offer any incentive to use it.

It is still not enough to have each of the filters generate their own header
pages (thereby being able to charge for them). If users wanted the option of
suppressing the header pages with lpr -h, they will still get them and be
charged for them since LPD does not pass any knowledge of the -h option to any
of the filters.

So, what are your options?

You can:

  * Accept LPD's paradigm and make header pages free.

  * Install an alternative to LPD, such as LPRng. Section Alternatives to the
    Standard Spooler tells more about other spooling software you can
    substitute for LPD.

  * Write a smart output filter. Normally, an output filter is not meant to do
    anything more than initialize a printer or do some simple character
    conversion. It is suited for header pages and plain text jobs (when there
    is no text (input) filter). But, if there is a text filter for the plain
    text jobs, then LPD will start the output filter only for the header pages.
    And the output filter can parse the header page text that LPD generates to
    determine what user and host to charge for the header page. The only other
    problem with this method is that the output filter still does not know what
    accounting file to use (it is not passed the name of the file from the af
    capability), but if you have a well-known accounting file, you can
    hard-code that into the output filter. To facilitate the parsing step, use
    the sh (short header) capability in /etc/printcap. Then again, all that
    might be too much trouble, and users will certainly appreciate the more
    generous system administrator who makes header pages free.

10.4.2.4.Â Header Pages on PostScriptÂ® Printers

As described above, LPD can generate a plain text header page suitable for many
printers. Of course, PostScriptÂ® cannot directly print plain text, so the
header page feature of LPD is uselessâ  or mostly so.

One obvious way to get header pages is to have every conversion filter and the
text filter generate the header page. The filters should use the user and host
arguments to generate a suitable header page. The drawback of this method is
that users will always get a header page, even if they submit jobs with lpr -h.

Let us explore this method. The following script takes three arguments (user
login name, host name, and job name) and makes a simple PostScriptÂ® header
page:

#!/bin/sh # # make-ps-header - make a PostScript header page on stdout #
Installed in /usr/local/libexec/make-ps-header # # # These are PostScript units
(72 to the inch). Modify for A4 or # whatever size paper you are using: #
page_width=612 page_height=792 border=72 # # Check arguments # if [ $# -ne 3 ];
then echo "Usage: `basename $0` &lt;user&gt; &lt;host&gt; &lt;job&gt;" 1&gt;&2 exit 1 fi # # Save
these, mostly for readability in the PostScript, below. # user=$1 host=$2 job=
$3 date=`date` # # Send the PostScript code to stdout. # exec cat &lt;&lt;EOF %!PS %
% Make sure we do not interfere with user's job that will follow % save % %
Make a thick, unpleasant border around the edge of the paper. % $border $border
moveto $page_width $border 2 mul sub 0 rlineto 0 $page_height $border 2 mul sub
rlineto currentscreen 3 -1 roll pop 100 3 1 roll setscreen $border 2 mul
$page_width sub 0 rlineto closepath 0.8 setgray 10 setlinewidth stroke 0
setgray % % Display user's login name, nice and large and prominent % /
Helvetica-Bold findfont 64 scalefont setfont $page_width ($user) stringwidth
pop sub 2 div $page_height 200 sub moveto ($user) show % % Now show the boring
particulars % /Helvetica findfont 14 scalefont setfont /y 200 def [ (Job:)
(Host:) (Date:) ] { 200 y moveto show /y y 18 sub def } forall /Helvetica-Bold
findfont 14 scalefont setfont /y 200 def [ ($job) ($host) ($date) ] { 270 y
moveto show /y y 18 sub def } forall % % That is it % restore showpage EOF

Now, each of the conversion filters and the text filter can call this script to
first generate the header page, and then print the user's job. Here is the DVI
conversion filter from earlier in this document, modified to make a header
page:

#!/bin/sh # # psdf - DVI to PostScript printer filter # Installed in /usr/local
/libexec/psdf # # Invoked by lpd when user runs lpr -d # orig_args="$@" fail()
{ echo "$@" 1&gt;&2 exit 2 } while getopts "x:y:n:h:" option; do case $option in x
|y) ;; # Ignore n) login=$OPTARG ;; h) host=$OPTARG ;; *) echo "LPD started
`basename $0` wrong." 1&gt;&2 exit 2 ;; esac done [ "$login" ] || fail "No login
name" [ "$host" ] || fail "No host name" ( /usr/local/libexec/make-ps-header
$login $host "DVI File" /usr/local/bin/dvips -f ) | eval /usr/local/libexec/
lprps $orig_args

Notice how the filter has to parse the argument list in order to determine the
user and host name. The parsing for the other conversion filters is identical.
The text filter takes a slightly different set of arguments, though (see
section How Filters Work).

As we have mentioned before, the above scheme, though fairly simple, disables
the â  suppress header pageâ   option (the -h option) to lpr. If users wanted
to save a tree (or a few pennies, if you charge for header pages), they would
not be able to do so, since every filter's going to print a header page with
every job.

To allow users to shut off header pages on a per-job basis, you will need to
use the trick introduced in section Accounting for Header Pages: write an
output filter that parses the LPD-generated header page and produces a 
PostScriptÂ® version. If the user submits the job with lpr -h, then LPD will
not generate a header page, and neither will your output filter. Otherwise,
your output filter will read the text from LPD and send the appropriate header
page PostScriptÂ® code to the printer.

If you have a PostScriptÂ® printer on a serial line, you can make use of lprps,
which comes with an output filter, psof, which does the above. Note that psof
does not charge for header pages.

10.4.3.Â Networked Printing

FreeBSD supports networked printing: sending jobs to remote printers. Networked
printing generally refers to two different things:

  * Accessing a printer attached to a remote host. You install a printer that
    has a conventional serial or parallel interface on one host. Then, you set
    up LPD to enable access to the printer from other hosts on the network.
    Section Printers Installed on Remote Hosts tells how to do this.

  * Accessing a printer attached directly to a network. The printer has a
    network interface in addition to (or in place of) a more conventional
    serial or parallel interface. Such a printer might work as follows:

      o It might understand the LPD protocol and can even queue jobs from
        remote hosts. In this case, it acts just like a regular host running 
        LPD. Follow the same procedure in section Printers Installed on Remote
        Hosts to set up such a printer.

      o It might support a data stream network connection. In this case, you â 
         attachâ   the printer to one host on the network by making that host
        responsible for spooling jobs and sending them to the printer. Section
        Printers with Networked Data Stream Interfaces gives some suggestions
        on installing such printers.

10.4.3.1.Â Printers Installed on Remote Hosts

The LPD spooling system has built-in support for sending jobs to other hosts
also running LPD (or are compatible with LPD). This feature enables you to
install a printer on one host and make it accessible from other hosts. It also
works with printers that have network interfaces that understand the LPD
protocol.

To enable this kind of remote printing, first install a printer on one host,
the printer host, using the simple printer setup described in the Simple
Printer Setup section. Do any advanced setup in Advanced Printer Setup that you
need. Make sure to test the printer and see if it works with the features of 
LPD you have enabled. Also ensure that the local host has authorization to use
the LPD service in the remote host (see Restricting Jobs from Remote Hosts).

If you are using a printer with a network interface that is compatible with LPD
, then the printer host in the discussion below is the printer itself, and the 
printer name is the name you configured for the printer. See the documentation
that accompanied your printer and/or printer-network interface.

Tip:

If you are using a Hewlett Packard Laserjet then the printer name text will
automatically perform the LF to CRLF conversion for you, so you will not
require the hpif script.

Then, on the other hosts you want to have access to the printer, make an entry
in their /etc/printcap files with the following:

 1. Name the entry anything you want. For simplicity, though, you probably want
    to use the same name and aliases as on the printer host.

 2. Leave the lp capability blank, explicitly (:lp=:).

 3. Make a spooling directory and specify its location in the sd capability. 
    LPD will store jobs here before they get sent to the printer host.

 4. Place the name of the printer host in the rm capability.

 5. Place the printer name on the printer host in the rp capability.

That is it. You do not need to list conversion filters, page dimensions, or
anything else in the /etc/printcap file.

Here is an example. The host rose has two printers, bamboo and rattan. We will
enable users on the host orchid to print to those printers. Here is the /etc/
printcap file for orchid (back from section Enabling Header Pages). It already
had the entry for the printer teak; we have added entries for the two printers
on the host rose:

# # /etc/printcap for host orchid - added (remote) printers on rose # # # teak
is local; it is connected directly to orchid: # teak|hp|laserjet|Hewlett
Packard LaserJet 3Si:\ :lp=/dev/lpt0:sd=/var/spool/lpd/teak:mx#0:\ :if=/usr/
local/libexec/ifhp:\ :vf=/usr/local/libexec/vfhp:\ :of=/usr/local/libexec/ofhp:
# # rattan is connected to rose; send jobs for rattan to rose: # rattan|line|
diablo|lp|Diablo 630 Line Printer:\ :lp=:rm=rose:rp=rattan:sd=/var/spool/lpd/
rattan: # # bamboo is connected to rose as well: # bamboo|ps|PS|S|panasonic|
Panasonic KX-P4455 PostScript v51.4:\ :lp=:rm=rose:rp=bamboo:sd=/var/spool/lpd/
bamboo:

Then, we just need to make spooling directories on orchid:

# mkdir -p /var/spool/lpd/rattan /var/spool/lpd/bamboo # chmod 770 /var/spool/
lpd/rattan /var/spool/lpd/bamboo # chown daemon:daemon /var/spool/lpd/rattan /
var/spool/lpd/bamboo

Now, users on orchid can print to rattan and bamboo. If, for example, a user on
orchid typed:

% lpr -P bamboo -d sushi-review.dvi

the LPD system on orchid would copy the job to the spooling directory /var/
spool/lpd/bamboo and note that it was a DVI job. As soon as the host rose has
room in its bamboo spooling directory, the two LPDs would transfer the file to
rose. The file would wait in rose's queue until it was finally printed. It
would be converted from DVI to PostScriptÂ® (since bamboo is a PostScriptÂ®
printer) on rose.

10.4.3.2.Â Printers with Networked Data Stream Interfaces

Often, when you buy a network interface card for a printer, you can get two
versions: one which emulates a spooler (the more expensive version), or one
which just lets you send data to it as if you were using a serial or parallel
port (the cheaper version). This section tells how to use the cheaper version.
For the more expensive one, see the previous section Printers Installed on
Remote Hosts.

The format of the /etc/printcap file lets you specify what serial or parallel
interface to use, and (if you are using a serial interface), what baud rate,
whether to use flow control, delays for tabs, conversion of newlines, and more.
But there is no way to specify a connection to a printer that is listening on a
TCP/IP or other network port.

To send data to a networked printer, you need to develop a communications
program that can be called by the text and conversion filters. Here is one such
example: the script netprint takes all data on standard input and sends it to a
network-attached printer. We specify the hostname of the printer as the first
argument and the port number to which to connect as the second argument to
netprint. Note that this supports one-way communication only (FreeBSD to
printer); many network printers support two-way communication, and you might
want to take advantage of that (to get printer status, perform accounting,
etc.).

#!/usr/bin/perl # # netprint - Text filter for printer attached to network #
Installed in /usr/local/libexec/netprint # $#ARGV eq 1 || die "Usage: $0
&lt;printer-hostname&gt; &lt;port-number&gt;"; $printer_host = $ARGV[0]; $printer_port =
$ARGV[1]; require 'sys/socket.ph'; ($ignore, $ignore, $protocol) =
getprotobyname('tcp'); ($ignore, $ignore, $ignore, $ignore, $address) =
gethostbyname($printer_host); $sockaddr = pack('S n a4 x8', &AF_INET,
$printer_port, $address); socket(PRINTER, &PF_INET, &SOCK_STREAM, $protocol) ||
die "Can't create TCP/IP stream socket: $!"; connect(PRINTER, $sockaddr) || die
"Can't contact $printer_host: $!"; while (&lt;STDIN&gt;) { print PRINTER; } exit 0;

We can then use this script in various filters. Suppose we had a Diablo 750-N
line printer connected to the network. The printer accepts data to print on
port number 5100. The host name of the printer is scrivener. Here is the text
filter for the printer:

#!/bin/sh # # diablo-if-net - Text filter for Diablo printer `scrivener'
listening # on port 5100. Installed in /usr/local/libexec/diablo-if-net # exec
/usr/libexec/lpr/lpf "$@" | /usr/local/libexec/netprint scrivener 5100

10.4.4.Â Restricting Printer Usage

This section gives information on restricting printer usage. The LPD system
lets you control who can access a printer, both locally or remotely, whether
they can print multiple copies, how large their jobs can be, and how large the
printer queues can get.

10.4.4.1.Â Restricting Multiple Copies

The LPD system makes it easy for users to print multiple copies of a file.
Users can print jobs with lpr -#5 (for example) and get five copies of each
file in the job. Whether this is a good thing is up to you.

If you feel multiple copies cause unnecessary wear and tear on your printers,
you can disable the -# option to lpr(1) by adding the sc capability to the /etc
/printcap file. When users submit jobs with the -# option, they will see:

lpr: multiple copies are not allowed

Note that if you have set up access to a printer remotely (see section Printers
Installed on Remote Hosts), you need the sc capability on the remote /etc/
printcap files as well, or else users will still be able to submit
multiple-copy jobs by using another host.

Here is an example. This is the /etc/printcap file for the host rose. The
printer rattan is quite hearty, so we will allow multiple copies, but the laser
printer bamboo is a bit more delicate, so we will disable multiple copies by
adding the sc capability:

# # /etc/printcap for host rose - restrict multiple copies on bamboo # rattan|
line|diablo|lp|Diablo 630 Line Printer:\ :sh:sd=/var/spool/lpd/rattan:\ :lp=/
dev/lpt0:\ :if=/usr/local/libexec/if-simple: bamboo|ps|PS|S|panasonic|Panasonic
KX-P4455 PostScript v51.4:\ :sh:sd=/var/spool/lpd/bamboo:sc:\ :lp=/dev/ttyu5:ms
#-parenb cs8 clocal crtscts:rw:\ :if=/usr/local/libexec/psif:\ :df=/usr/local/
libexec/psdf:

Now, we also need to add the sc capability on the host orchid's /etc/printcap
(and while we are at it, let us disable multiple copies for the printer teak):

# # /etc/printcap for host orchid - no multiple copies for local # printer teak
or remote printer bamboo teak|hp|laserjet|Hewlett Packard LaserJet 3Si:\ :lp=/
dev/lpt0:sd=/var/spool/lpd/teak:mx#0:sc:\ :if=/usr/local/libexec/ifhp:\ :vf=/
usr/local/libexec/vfhp:\ :of=/usr/local/libexec/ofhp: rattan|line|diablo|lp|
Diablo 630 Line Printer:\ :lp=:rm=rose:rp=rattan:sd=/var/spool/lpd/rattan:
bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\ :lp=:rm=rose:rp=
bamboo:sd=/var/spool/lpd/bamboo:sc:

By using the sc capability, we prevent the use of lpr -#, but that still does
not prevent users from running lpr(1) multiple times, or from submitting the
same file multiple times in one job like this:

% lpr forsale.sign forsale.sign forsale.sign forsale.sign forsale.sign

There are many ways to prevent this abuse (including ignoring it) which you are
free to explore.

10.4.4.2.Â Restricting Access to Printers

You can control who can print to what printers by using the UNIXÂ® group
mechanism and the rg capability in /etc/printcap. Just place the users you want
to have access to a printer in a certain group, and then name that group in the
rg capability.

If users outside the group (including root) try to print to the controlled
printer then they will be greeted with the following message:

lpr: Not a member of the restricted group

As with the sc (suppress multiple copies) capability, you need to specify rg on
remote hosts that also have access to your printers, if you feel it is
appropriate (see section Printers Installed on Remote Hosts).

For example, we will let anyone access the printer rattan, but only those in
group artists can use bamboo. Here is the familiar /etc/printcap for host rose:

# # /etc/printcap for host rose - restricted group for bamboo # rattan|line|
diablo|lp|Diablo 630 Line Printer:\ :sh:sd=/var/spool/lpd/rattan:\ :lp=/dev/
lpt0:\ :if=/usr/local/libexec/if-simple: bamboo|ps|PS|S|panasonic|Panasonic
KX-P4455 PostScript v51.4:\ :sh:sd=/var/spool/lpd/bamboo:sc:rg=artists:\ :lp=/
dev/ttyu5:ms#-parenb cs8 clocal crtscts:rw:\ :if=/usr/local/libexec/psif:\ :df=
/usr/local/libexec/psdf:

Let us leave the other example /etc/printcap file (for the host orchid) alone.
Of course, anyone on orchid can print to bamboo. It might be the case that we
only allow certain logins on orchid anyway, and want them to have access to the
printer. Or not.

Note:

There can be only one restricted group per printer.

10.4.4.3.Â Controlling Sizes of Jobs Submitted

If you have many users accessing the printers, you probably need to put an
upper limit on the sizes of the files users can submit to print. After all,
there is only so much free space on the filesystem that houses the spooling
directories, and you also need to make sure there is room for the jobs of other
users.

LPD enables you to limit the maximum byte size a file in a job can be with the
mx capability. The units are in BUFSIZ blocks, which are 1024 bytes. If you put
a zero for this capability, there will be no limit on file size; however, if no
mx capability is specified, then a default limit of 1000 blocks will be used.

Note:

The limit applies to files in a job, and not the total job size.

LPD will not refuse a file that is larger than the limit you place on a
printer. Instead, it will queue as much of the file up to the limit, which will
then get printed. The rest will be discarded. Whether this is correct behavior
is up for debate.

Let us add limits to our example printers rattan and bamboo. Since those
artists' PostScriptÂ® files tend to be large, we will limit them to five
megabytes. We will put no limit on the plain text line printer:

# # /etc/printcap for host rose # # # No limit on job size: # rattan|line|
diablo|lp|Diablo 630 Line Printer:\ :sh:mx#0:sd=/var/spool/lpd/rattan:\ :lp=/
dev/lpt0:\ :if=/usr/local/libexec/if-simple: # # Limit of five megabytes: #
bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\ :sh:sd=/var/
spool/lpd/bamboo:sc:rg=artists:mx#5000:\ :lp=/dev/ttyu5:ms#-parenb cs8 clocal
crtscts:rw:\ :if=/usr/local/libexec/psif:\ :df=/usr/local/libexec/psdf:

Again, the limits apply to the local users only. If you have set up access to
your printers remotely, remote users will not get those limits. You will need
to specify the mx capability in the remote /etc/printcap files as well. See
section Printers Installed on Remote Hosts for more information on remote
printing.

There is another specialized way to limit job sizes from remote printers; see
section Restricting Jobs from Remote Hosts.

10.4.4.4.Â Restricting Jobs from Remote Hosts

The LPD spooling system provides several ways to restrict print jobs submitted
from remote hosts:

Host restrictions

    You can control from which remote hosts a local LPD accepts requests with
    the files /etc/hosts.equiv and /etc/hosts.lpd. LPD checks to see if an
    incoming request is from a host listed in either one of these files. If
    not, LPD refuses the request.

    The format of these files is simple: one host name per line. Note that the
    file /etc/hosts.equiv is also used by the ruserok(3) protocol, and affects
    programs like rsh(1) and rcp(1), so be careful.

    For example, here is the /etc/hosts.lpd file on the host rose:

    orchid violet madrigal.fishbaum.de

    This means rose will accept requests from the hosts orchid, violet, and
    madrigal.fishbaum.de. If any other host tries to access rose's LPD, the job
    will be refused.

Size restrictions

    You can control how much free space there needs to remain on the filesystem
    where a spooling directory resides. Make a file called minfree in the
    spooling directory for the local printer. Insert in that file a number
    representing how many disk blocks (512 bytes) of free space there has to be
    for a remote job to be accepted.

    This lets you insure that remote users will not fill your filesystem. You
    can also use it to give a certain priority to local users: they will be
    able to queue jobs long after the free disk space has fallen below the
    amount specified in the minfree file.

    For example, let us add a minfree file for the printer bamboo. We examine /
    etc/printcap to find the spooling directory for this printer; here is
    bamboo's entry:

    bamboo|ps|PS|S|panasonic|Panasonic KX-P4455 PostScript v51.4:\ :sh:sd=/var/
    spool/lpd/bamboo:sc:rg=artists:mx#5000:\ :lp=/dev/ttyu5:ms#-parenb cs8
    clocal crtscts:rw:mx#5000:\ :if=/usr/local/libexec/psif:\ :df=/usr/local/
    libexec/psdf:

    The spooling directory is given in the sd capability. We will make three
    megabytes (which is 6144 disk blocks) the amount of free disk space that
    must exist on the filesystem for LPD to accept remote jobs:

    # echo 6144 &gt; /var/spool/lpd/bamboo/minfree
User restrictions

    You can control which remote users can print to local printers by
    specifying the rs capability in /etc/printcap. When rs appears in the entry
    for a locally-attached printer, LPD will accept jobs from remote hosts if
    the user submitting the job also has an account of the same login name on
    the local host. Otherwise, LPD refuses the job.

    This capability is particularly useful in an environment where there are
    (for example) different departments sharing a network, and some users
    transcend departmental boundaries. By giving them accounts on your systems,
    they can use your printers from their own departmental systems. If you
    would rather allow them to use only your printers and not your computer
    resources, you can give them â  tokenâ   accounts, with no home directory
    and a useless shell like /usr/bin/false.

10.4.5.Â Accounting for Printer Usage

So, you need to charge for printouts. And why not? Paper and ink cost money.
And then there are maintenance costsâ  printers are loaded with moving parts
and tend to break down. You have examined your printers, usage patterns, and
maintenance fees and have come up with a per-page (or per-foot, per-meter, or
per-whatever) cost. Now, how do you actually start accounting for printouts?

Well, the bad news is the LPD spooling system does not provide much help in
this department. Accounting is highly dependent on the kind of printer in use,
the formats being printed, and your equirements in charging for printer usage.

To implement accounting, you have to modify a printer's text filter (to charge
for plain text jobs) and the conversion filters (to charge for other file
formats), to count pages or query the printer for pages printed. You cannot get
away with using the simple output filter, since it cannot do accounting. See
section Filters.

Generally, there are two ways to do accounting:

  * Periodic accounting is the more common way, possibly because it is easier.
    Whenever someone prints a job, the filter logs the user, host, and number
    of pages to an accounting file. Every month, semester, year, or whatever
    time period you prefer, you collect the accounting files for the various
    printers, tally up the pages printed by users, and charge for usage. Then
    you truncate all the logging files, starting with a clean slate for the
    next period.

  * Timely accounting is less common, probably because it is more difficult.
    This method has the filters charge users for printouts as soon as they use
    the printers. Like disk quotas, the accounting is immediate. You can
    prevent users from printing when their account goes in the red, and might
    provide a way for users to check and adjust their â  print quotasâ  . But
    this method requires some database code to track users and their quotas.

The LPD spooling system supports both methods easily: since you have to provide
the filters (well, most of the time), you also have to provide the accounting
code. But there is a bright side: you have enormous flexibility in your
accounting methods. For example, you choose whether to use periodic or timely
accounting. You choose what information to log: user names, host names, job
types, pages printed, square footage of paper used, how long the job took to
print, and so forth. And you do so by modifying the filters to save this
information.

10.4.5.1.Â Quick and Dirty Printer Accounting

FreeBSD comes with two programs that can get you set up with simple periodic
accounting right away. They are the text filter lpf, described in section lpf:
a Text Filter, and pac(8), a program to gather and total entries from printer
accounting files.

As mentioned in the section on filters (Filters), LPD starts the text and the
conversion filters with the name of the accounting file to use on the filter
command line. The filters can use this argument to know where to write an
accounting file entry. The name of this file comes from the af capability in /
etc/printcap, and if not specified as an absolute path, is relative to the
spooling directory.

LPD starts lpf with page width and length arguments (from the pw and pl
capabilities). The lpf filter uses these arguments to determine how much paper
will be used. After sending the file to the printer, it then writes an
accounting entry in the accounting file. The entries look like this:

2.00 rose:andy 3.00 rose:kelly 3.00 orchid:mary 5.00 orchid:mary 2.00
orchid:zhang

You should use a separate accounting file for each printer, as lpf has no file
locking logic built into it, and two lpfs might corrupt each other's entries if
they were to write to the same file at the same time. An easy way to insure a
separate accounting file for each printer is to use af=acct in /etc/printcap.
Then, each accounting file will be in the spooling directory for a printer, in
a file named acct.

When you are ready to charge users for printouts, run the pac(8) program. Just
change to the spooling directory for the printer you want to collect on and
type pac. You will get a dollar-centric summary like the following:

Login pages/feet runs price orchid:kelly 5.00 1 $ 0.10 orchid:mary 31.00 3 $
0.62 orchid:zhang 9.00 1 $ 0.18 rose:andy 2.00 1 $ 0.04 rose:kelly 177.00 104 $
3.54 rose:mary 87.00 32 $ 1.74 rose:root 26.00 12 $ 0.52 total 337.00 154 $
6.74

These are the arguments pac(8) expects:

-Pprinter

    Which printer to summarize. This option works only if there is an absolute
    path in the af capability in /etc/printcap.

-c

    Sort the output by cost instead of alphabetically by user name.

-m

    Ignore host name in the accounting files. With this option, user smith on
    host alpha is the same user smith on host gamma. Without, they are
    different users.

-pprice

    Compute charges with price dollars per page or per foot instead of the
    price from the pc capability in /etc/printcap, or two cents (the default).
    You can specify price as a floating point number.

-r

    Reverse the sort order.

-s

    Make an accounting summary file and truncate the accounting file.

name â Š

    Print accounting information for the given user names only.

In the default summary that pac(8) produces, you see the number of pages
printed by each user from various hosts. If, at your site, host does not matter
(because users can use any host), run pac -m, to produce the following summary:

Login pages/feet runs price andy 2.00 1 $ 0.04 kelly 182.00 105 $ 3.64 mary
118.00 35 $ 2.36 root 26.00 12 $ 0.52 zhang 9.00 1 $ 0.18 total 337.00 154 $
6.74

To compute the dollar amount due, pac(8) uses the pc capability in the /etc/
printcap file (default of 200, or 2 cents per page). Specify, in hundredths of
cents, the price per page or per foot you want to charge for printouts in this
capability. You can override this value when you run pac(8) with the -p option.
The units for the -p option are in dollars, though, not hundredths of cents.
For example,

# pac -p1.50

makes each page cost one dollar and fifty cents. You can really rake in the
profits by using this option.

Finally, running pac -s will save the summary information in a summary
accounting file, which is named the same as the printer's accounting file, but
with _sum appended to the name. It then truncates the accounting file. When you
run pac(8) again, it rereads the summary file to get starting totals, then adds
information from the regular accounting file.

10.4.5.2.Â How Can You Count Pages Printed?

In order to perform even remotely accurate accounting, you need to be able to
determine how much paper a job uses. This is the essential problem of printer
accounting.

For plain text jobs, the problem is not that hard to solve: you count how many
lines are in a job and compare it to how many lines per page your printer
supports. Do not forget to take into account backspaces in the file which
overprint lines, or long logical lines that wrap onto one or more additional
physical lines.

The text filter lpf (introduced in lpf: a Text Filter) takes into account these
things when it does accounting. If you are writing a text filter which needs to
do accounting, you might want to examine lpf's source code.

How do you handle other file formats, though?

Well, for DVI-to-LaserJet or DVI-to-PostScriptÂ® conversion, you can have your
filter parse the diagnostic output of dvilj or dvips and look to see how many
pages were converted. You might be able to do similar things with other file
formats and conversion programs.

But these methods suffer from the fact that the printer may not actually print
all those pages. For example, it could jam, run out of toner, or explodeâ  and
the user would still get charged.

So, what can you do?

There is only one sure way to do accurate accounting. Get a printer that can
tell you how much paper it uses, and attach it via a serial line or a network
connection. Nearly all PostScriptÂ® printers support this notion. Other makes
and models do as well (networked Imagen laser printers, for example). Modify
the filters for these printers to get the page usage after they print each job
and have them log accounting information based on that value only. There is no
line counting nor error-prone file examination required.

Of course, you can always be generous and make all printouts free.

10.5.Â Using Printers

This section tells you how to use printers you have set up with FreeBSD. Here
is an overview of the user-level commands:

lpr(1)

    Print jobs

lpq(1)

    Check printer queues

lprm(1)

    Remove jobs from a printer's queue

There is also an administrative command, lpc(8), described in the section
Administering Printers, used to control printers and their queues.

All three of the commands lpr(1), lprm(1), and lpq(1) accept an option -P
printer-name to specify on which printer/queue to operate, as listed in the /
etc/printcap file. This enables you to submit, remove, and check on jobs for
various printers. If you do not use the -P option, then these commands use the
printer specified in the PRINTER environment variable. Finally, if you do not
have a PRINTER environment variable, these commands default to the printer
named lp.

Hereafter, the terminology default printer means the printer named in the
PRINTER environment variable, or the printer named lp when there is no PRINTER
environment variable.

10.5.1.Â Printing Jobs

To print files, type:

% lpr filename ...

This prints each of the listed files to the default printer. If you list no
files, lpr(1) reads data to print from standard input. For example, this
command prints some important system files:

% lpr /etc/host.conf /etc/hosts.equiv

To select a specific printer, type:

% lpr -P printer-name filename ...

This example prints a long listing of the current directory to the printer
named rattan:

% ls -l | lpr -P rattan

Because no files were listed for the lpr(1) command, lpr read the data to print
from standard input, which was the output of the ls -l command.

The lpr(1) command can also accept a wide variety of options to control
formatting, apply file conversions, generate multiple copies, and so forth. For
more information, see the section Printing Options.

10.5.2.Â Checking Jobs

When you print with lpr(1), the data you wish to print is put together in a
package called a â  print jobâ  , which is sent to the LPD spooling system.
Each printer has a queue of jobs, and your job waits in that queue along with
other jobs from yourself and from other users. The printer prints those jobs in
a first-come, first-served order.

To display the queue for the default printer, type lpq(1). For a specific
printer, use the -P option. For example, the command

% lpq -P bamboo

shows the queue for the printer named bamboo. Here is an example of the output
of the lpq command:

bamboo is ready and printing Rank Owner Job Files Total Size active kelly 9 /
etc/host.conf, /etc/hosts.equiv 88 bytes 2nd kelly 10 (standard input) 1635
bytes 3rd mary 11 ... 78519 bytes

This shows three jobs in the queue for bamboo. The first job, submitted by user
kelly, got assigned â  job numberâ   9. Every job for a printer gets a unique
job number. Most of the time you can ignore the job number, but you will need
it if you want to cancel the job; see section Removing Jobs for details.

Job number nine consists of two files; multiple files given on the lpr(1)
command line are treated as part of a single job. It is the currently active
job (note the word active under the â  Rankâ   column), which means the printer
should be currently printing that job. The second job consists of data passed
as the standard input to the lpr(1) command. The third job came from user mary;
it is a much larger job. The pathname of the file she is trying to print is too
long to fit, so the lpq(1) command just shows three dots.

The very first line of the output from lpq(1) is also useful: it tells what the
printer is currently doing (or at least what LPD thinks the printer is doing).

The lpq(1) command also support a -l option to generate a detailed long
listing. Here is an example of lpq -l:

waiting for bamboo to become ready (offline ?) kelly: 1st [job 009rose] /etc/
host.conf 73 bytes /etc/hosts.equiv 15 bytes kelly: 2nd [job 010rose] (standard
input) 1635 bytes mary: 3rd [job 011rose] /home/orchid/mary/research/venus/
alpha-regio/mapping 78519 bytes

10.5.3.Â Removing Jobs

If you change your mind about printing a job, you can remove the job from the
queue with the lprm(1) command. Often, you can even use lprm(1) to remove an
active job, but some or all of the job might still get printed.

To remove a job from the default printer, first use lpq(1) to find the job
number. Then type:

% lprm job-number

To remove the job from a specific printer, add the -P option. The following
command removes job number 10 from the queue for the printer bamboo:

% lprm -P bamboo 10

The lprm(1) command has a few shortcuts:

lprm -

    Removes all jobs (for the default printer) belonging to you.

lprm user

    Removes all jobs (for the default printer) belonging to user. The superuser
    can remove other users' jobs; you can remove only your own jobs.

lprm

    With no job number, user name, or - appearing on the command line, lprm(1)
    removes the currently active job on the default printer, if it belongs to
    you. The superuser can remove any active job.

Just use the -P option with the above shortcuts to operate on a specific
printer instead of the default. For example, the following command removes all
jobs for the current user in the queue for the printer named rattan:

% lprm -P rattan -

Note:

If you are working in a networked environment, lprm(1) will let you remove jobs
only from the host from which the jobs were submitted, even if the same printer
is available from other hosts. The following command sequence demonstrates
this:

% lpr -P rattan myfile % rlogin orchid % lpq -P rattan Rank Owner Job Files
Total Size active seeyan 12 ... 49123 bytes 2nd kelly 13 myfile 12 bytes % lprm
-P rattan 13 rose: Permission denied % logout % lprm -P rattan 13 dfA013rose
dequeued cfA013rose dequeued

10.5.4.Â Beyond Plain Text: Printing Options

The lpr(1) command supports a number of options that control formatting text,
converting graphic and other file formats, producing multiple copies, handling
of the job, and more. This section describes the options.

10.5.4.1.Â Formatting and Conversion Options

The following lpr(1) options control formatting of the files in the job. Use
these options if the job does not contain plain text or if you want plain text
formatted through the pr(1) utility.

For example, the following command prints a DVI file (from the TeX typesetting
system) named fish-report.dvi to the printer named bamboo:

% lpr -P bamboo -d fish-report.dvi

These options apply to every file in the job, so you cannot mix (say) DVI and
ditroff files together in a job. Instead, submit the files as separate jobs,
using a different conversion option for each job.

Note:

All of these options except -p and -T require conversion filters installed for
the destination printer. For example, the -d option requires the DVI conversion
filter. Section Conversion Filters gives details.

-c

    Print cifplot files.

-d

    Print DVI files.

-f

    Print FORTRAN text files.

-g

    Print plot data.

-i number

    Indent the output by number columns; if you omit number, indent by 8
    columns. This option works only with certain conversion filters.

    Note:

    Do not put any space between the -i and the number.

-l

    Print literal text data, including control characters.

-n

    Print ditroff (device independent troff) data.

-p

    Format plain text with pr(1) before printing. See pr(1) for more
    information.

-T title

    Use title on the pr(1) header instead of the file name. This option has
    effect only when used with the -p option.

-t

    Print troff data.

-v

    Print raster data.

Here is an example: this command prints a nicely formatted version of the ls(1)
manual page on the default printer:

% zcat /usr/share/man/man1/ls.1.gz | troff -t -man | lpr -t

The zcat(1) command uncompresses the source of the ls(1) manual page and passes
it to the troff(1) command, which formats that source and makes GNU troff
output and passes it to lpr(1), which submits the job to the LPD spooler.
Because we used the -t option to lpr(1), the spooler will convert the GNU troff
output into a format the default printer can understand when it prints the job.

10.5.4.2.Â Job Handling Options

The following options to lpr(1) tell LPD to handle the job specially:

-# copies

    Produce a number of copies of each file in the job instead of just one
    copy. An administrator may disable this option to reduce printer
    wear-and-tear and encourage photocopier usage. See section Restricting
    Multiple Copies.

    This example prints three copies of parser.c followed by three copies of
    parser.h to the default printer:

    % lpr -#3 parser.c parser.h
-m

    Send mail after completing the print job. With this option, the LPD system
    will send mail to your account when it finishes handling your job. In its
    message, it will tell you if the job completed successfully or if there was
    an error, and (often) what the error was.

-s

    Do not copy the files to the spooling directory, but make symbolic links to
    them instead.

    If you are printing a large job, you probably want to use this option. It
    saves space in the spooling directory (your job might overflow the free
    space on the filesystem where the spooling directory resides). It saves
    time as well since LPD will not have to copy each and every byte of your
    job to the spooling directory.

    There is a drawback, though: since LPD will refer to the original files
    directly, you cannot modify or remove them until they have been printed.

    Note:

    If you are printing to a remote printer, LPD will eventually have to copy
    files from the local host to the remote host, so the -s option will save
    space only on the local spooling directory, not the remote. It is still
    useful, though.

-r

    Remove the files in the job after copying them to the spooling directory,
    or after printing them with the -s option. Be careful with this option!

10.5.4.3.Â Header Page Options

These options to lpr(1) adjust the text that normally appears on a job's header
page. If header pages are suppressed for the destination printer, these options
have no effect. See section Header Pages for information about setting up
header pages.

-C text

    Replace the hostname on the header page with text. The hostname is normally
    the name of the host from which the job was submitted.

-J text

    Replace the job name on the header page with text. The job name is normally
    the name of the first file of the job, or stdin if you are printing
    standard input.

-h

    Do not print any header page.

    Note:

    At some sites, this option may have no effect due to the way header pages
    are generated. See Header Pages for details.

10.5.5.Â Administering Printers

As an administrator for your printers, you have had to install, set up, and
test them. Using the lpc(8) command, you can interact with your printers in yet
more ways. With lpc(8), you can

  * Start and stop the printers

  * Enable and disable their queues

  * Rearrange the order of the jobs in each queue.

First, a note about terminology: if a printer is stopped, it will not print
anything in its queue. Users can still submit jobs, which will wait in the
queue until the printer is started or the queue is cleared.

If a queue is disabled, no user (except root) can submit jobs for the printer.
An enabled queue allows jobs to be submitted. A printer can be started for a
disabled queue, in which case it will continue to print jobs in the queue until
the queue is empty.

In general, you have to have root privileges to use the lpc(8) command.
Ordinary users can use the lpc(8) command to get printer status and to restart
a hung printer only.

Here is a summary of the lpc(8) commands. Most of the commands take a
printer-name argument to tell on which printer to operate. You can use all for
the printer-name to mean all printers listed in /etc/printcap.

abort printer-name

    Cancel the current job and stop the printer. Users can still submit jobs if
    the queue is enabled.

clean printer-name

    Remove old files from the printer's spooling directory. Occasionally, the
    files that make up a job are not properly removed by LPD, particularly if
    there have been errors during printing or a lot of administrative activity.
    This command finds files that do not belong in the spooling directory and
    removes them.

disable printer-name

    Disable queuing of new jobs. If the printer is running, it will continue to
    print any jobs remaining in the queue. The superuser (root) can always
    submit jobs, even to a disabled queue.

    This command is useful while you are testing a new printer or filter
    installation: disable the queue and submit jobs as root. Other users will
    not be able to submit jobs until you complete your testing and re-enable
    the queue with the enable command.

down printer-name message

    Take a printer down. Equivalent to disable followed by stop. The message
    appears as the printer's status whenever a user checks the printer's queue
    with lpq(1) or status with lpc status.

enable printer-name

    Enable the queue for a printer. Users can submit jobs but the printer will
    not print anything until it is started.

help command-name

    Print help on the command command-name. With no command-name, print a
    summary of the commands available.

restart printer-name

    Start the printer. Ordinary users can use this command if some
    extraordinary circumstance hangs LPD, but they cannot start a printer
    stopped with either the stop or down commands. The restart command is
    equivalent to abort followed by start.

start printer-name

    Start the printer. The printer will print jobs in its queue.

stop printer-name

    Stop the printer. The printer will finish the current job and will not
    print anything else in its queue. Even though the printer is stopped, users
    can still submit jobs to an enabled queue.

topq printer-name job-or-username

    Rearrange the queue for printer-name by placing the jobs with the listed
    job numbers or the jobs belonging to username at the top of the queue. For
    this command, you cannot use all as the printer-name.

up printer-name

    Bring a printer up; the opposite of the down command. Equivalent to start
    followed by enable.

lpc(8) accepts the above commands on the command line. If you do not enter any
commands, lpc(8) enters an interactive mode, where you can enter commands until
you type exit, quit, or end-of-file.

10.6.Â Alternatives to the Standard Spooler

If you have been reading straight through this manual, by now you have learned
just about everything there is to know about the LPD spooling system that comes
with FreeBSD. You can probably appreciate many of its shortcomings, which
naturally leads to the question: â  What other spooling systems are out there
(and work with FreeBSD)?â  

LPRng
   
    LPRng, which purportedly means â  LPR: the Next Generationâ   is a complete
    rewrite of PLP. Patrick Powell and Justin Mason (the principal maintainer
    of PLP) collaborated to make LPRng. The main site for LPRng is http://
    www.lprng.org/.

CUPS
   
    CUPS, the Common UNIX Printing System, provides a portable printing layer
    for UNIXÂ®-based operating systems. It has been developed by Easy Software
    Products to promote a standard printing solution for all UNIXÂ® vendors and
    users.

    CUPS uses the Internet Printing Protocol (IPP) as the basis for managing
    print jobs and queues. The Line Printer Daemon (LPD), Server Message Block
    (SMB), and AppSocket (aka JetDirect) protocols are also supported with
    reduced functionality. CUPS adds network printer browsing and PostScript
    Printer Description (PPD) based printing options to support real-world
    printing under UNIXÂ®.

    The main site for CUPS is http://www.cups.org/.

HPLIP
   
    HPLIP, the HP LinuxÂ® Imaging and Printing system, is an HP-developed suite
    of programs that supports printing, scanning and fax facilities for HP
    appliances. This suite of programs utilizes the CUPS printing system as a
    backend for some of its printing features.

    The main site for HPLIP is http://hplipopensource.com/hplip-web/index.html.

10.7.Â Troubleshooting

After performing the simple test with lptest(1), you might have gotten one of
the following results instead of the correct printout:

It worked, after a while; or, it did not eject a full sheet.

    The printer printed the above, but it sat for a while and did nothing. In
    fact, you might have needed to press a PRINT REMAINING or FORM FEED button
    on the printer to get any results to appear.

    If this is the case, the printer was probably waiting to see if there was
    any more data for your job before it printed anything. To fix this problem,
    you can have the text filter send a FORM FEED character (or whatever is
    necessary) to the printer. This is usually sufficient to have the printer
    immediately print any text remaining in its internal buffer. It is also
    useful to make sure each print job ends on a full sheet, so the next job
    does not start somewhere on the middle of the last page of the previous
    job.

    The following replacement for the shell script /usr/local/libexec/if-simple
    prints a form feed after it sends the job to the printer:

    #!/bin/sh # # if-simple - Simple text input filter for lpd # Installed in /
    usr/local/libexec/if-simple # # Simply copies stdin to stdout. Ignores all
    filter arguments. # Writes a form feed character (\f) after printing job. /
    bin/cat && printf "\f" && exit 0 exit 2
It produced the â  staircase effect.â  

    You got the following on paper:

    !"#$%&'()*+,-./01234 "#$%&'()*+,-./012345 #$%&'()*+,-./0123456
   
    You have become another victim of the staircase effect, caused by
    conflicting interpretations of what characters should indicate a new line. 
    UNIXÂ® style operating systems use a single character: ASCII code 10, the
    line feed (LF). MS-DOSÂ®, OS/2Â®, and others uses a pair of characters,
    ASCII code 10 and ASCII code 13 (the carriage return or CR). Many printers
    use the MS-DOSÂ® convention for representing new-lines.

    When you print with FreeBSD, your text used just the line feed character.
    The printer, upon seeing a line feed character, advanced the paper one
    line, but maintained the same horizontal position on the page for the next
    character to print. That is what the carriage return is for: to move the
    location of the next character to print to the left edge of the paper.

    Here is what FreeBSD wants your printer to do:

    Printer received CR                Printer prints CR
    Printer received LF                Printer prints CR + LF

    Here are some ways to achieve this:

      * Use the printer's configuration switches or control panel to alter its
        interpretation of these characters. Check your printer's manual to find
        out how to do this.

        Note:

        If you boot your system into other operating systems besides FreeBSD,
        you may have to reconfigure the printer to use a an interpretation for
        CR and LF characters that those other operating systems use. You might
        prefer one of the other solutions, below.

      * Have FreeBSD's serial line driver automatically convert LF to CR+LF. Of
        course, this works with printers on serial ports only. To enable this
        feature, use the ms# capability and set the onlcr mode in the /etc/
        printcap file for the printer.

      * Send an escape code to the printer to have it temporarily treat LF
        characters differently. Consult your printer's manual for escape codes
        that your printer might support. When you find the proper escape code,
        modify the text filter to send the code first, then send the print job.

        Here is an example text filter for printers that understand the
        Hewlett-Packard PCL escape codes. This filter makes the printer treat
        LF characters as a LF and CR; then it sends the job; then it sends a
        form feed to eject the last page of the job. It should work with nearly
        all Hewlett Packard printers.

        #!/bin/sh # # hpif - Simple text input filter for lpd for HP-PCL based
        printers # Installed in /usr/local/libexec/hpif # # Simply copies stdin
        to stdout. Ignores all filter arguments. # Tells printer to treat LF as
        CR+LF. Ejects the page when done. printf "\033&k2G" && cat && printf "\
        033&l0H" && exit 0 exit 2

        Here is an example /etc/printcap from a host called orchid. It has a
        single printer attached to its first parallel port, a Hewlett Packard
        LaserJet 3Si named teak. It is using the above script as its text
        filter:

        # # /etc/printcap for host orchid # teak|hp|laserjet|Hewlett Packard
        LaserJet 3Si:\ :lp=/dev/lpt0:sh:sd=/var/spool/lpd/teak:mx#0:\ :if=/usr/
        local/libexec/hpif:
It overprinted each line.

    The printer never advanced a line. All of the lines of text were printed on
    top of each other on one line.

    This problem is the â  oppositeâ   of the staircase effect, described
    above, and is much rarer. Somewhere, the LF characters that FreeBSD uses to
    end a line are being treated as CR characters to return the print location
    to the left edge of the paper, but not also down a line.

    Use the printer's configuration switches or control panel to enforce the
    following interpretation of LF and CR characters:

               Printer receives                       Printer prints
    CR                                      CR
    LF                                      CR + LF

The printer lost characters.

    While printing, the printer did not print a few characters in each line.
    The problem might have gotten worse as the printer ran, losing more and
    more characters.

    The problem is that the printer cannot keep up with the speed at which the
    computer sends data over a serial line (this problem should not occur with
    printers on parallel ports). There are two ways to overcome the problem:

      * If the printer supports XON/XOFF flow control, have FreeBSD use it by
        specifying the ixon mode in the ms# capability.

      * If the printer supports the Request to Send / Clear to Send hardware
        handshake (commonly known as RTS/CTS), specify the crtscts mode in the
        ms# capability. Make sure the cable connecting the printer to the
        computer is correctly wired for hardware flow control.

It printed garbage.

    The printer printed what appeared to be random garbage, but not the desired
    text.

    This is usually another symptom of incorrect communications parameters with
    a serial printer. Double-check the bps rate in the br capability, and the
    parity setting in the ms# capability; make sure the printer is using the
    same settings as specified in the /etc/printcap file.

Nothing happened.

    If nothing happened, the problem is probably within FreeBSD and not the
    hardware. Add the log file (lf) capability to the entry for the printer you
    are debugging in the /etc/printcap file. For example, here is the entry for
    rattan, with the lf capability:

    rattan|line|diablo|lp|Diablo 630 Line Printer:\ :sh:sd=/var/spool/lpd/
    rattan:\ :lp=/dev/lpt0:\ :if=/usr/local/libexec/if-simple:\ :lf=/var/log/
    rattan.log

    Then, try printing again. Check the log file (in our example, /var/log/
    rattan.log) to see any error messages that might appear. Based on the
    messages you see, try to correct the problem.

    If you do not specify a lf capability, LPD uses /dev/console as a default.

ChapterÂ 11.Â LinuxÂ® Binary Compatibility

Restructured and parts updated by Jim Mock.
Originally contributed by Brian N. Handy and Rich Murphey.
Table of Contents

11.1. Synopsis
11.2. Installation
11.3. Installing MathematicaÂ®
11.4. Installing Mapleâ ¢
11.5. Installing MATLABÂ®
11.6. Installing OracleÂ®
11.7. Advanced Topics

11.1.Â Synopsis

FreeBSD provides binary compatibility with LinuxÂ®, allowing users to install
and run LinuxÂ® binaries on a FreeBSD system. Many companies and developers
develop only for LinuxÂ®, and binary compatibility allows FreeBSD users to run
about 90% of all LinuxÂ® applications without modification. This includes
productivity applications, games, and more. It has even been reported that, in
some situations, LinuxÂ® binaries perform better on FreeBSD than they do on 
LinuxÂ®.

However, some LinuxÂ®-specific operating system features are not supported
under FreeBSD. For example, LinuxÂ® binaries will not work on FreeBSD if they
overly use i386â ¢ specific calls, such as enabling virtual 8086 mode.

After reading this chapter, you will know:

  * How to enable LinuxÂ® binary compatibility on a FreeBSD system.

  * How to install additional LinuxÂ® shared libraries.

  * How to install LinuxÂ® applications on a FreeBSD system.

  * The implementation details of LinuxÂ® compatibility in FreeBSD.

Before reading this chapter, you should:

  * Know how to install additional third-party software.

11.2.Â Installation

LinuxÂ® libararies are not installed on FreeBSD by default and LinuxÂ® binary
compatibility is not enabled by default. LinuxÂ® libraries can be installed
using the FreeBSD Ports Collection. Alternately, LinuxÂ® libraries can be
installed manually.

Using the Ports Collection is by far the easiest way to install LinuxÂ®
libraries:

# cd /usr/ports/emulators/linux_base-f10 # make install distclean

Once the port is installed, enable LinuxÂ® binary compatibility by loading the
linux module. Type the following as root:

# kldload linux

In order for LinuxÂ® compatibility to always be enabled at boot time, add the
following line to /etc/rc.conf:

linux_enable="YES"

To verify that the module is loaded, use kldstat(8):

% kldstat Id Refs Address Size Name 1 2 0xc0100000 16bdb8 kernel 7 1 0xc24db000
d000 linux.ko

Users who prefer to statically link LinuxÂ® binary compatibility into the
kernel should add options COMPAT_LINUX to the custom kernel configuration file.
Compile and install the new kernel as described in ChapterÂ 9, Configuring the
FreeBSD Kernel.

11.2.1.Â Installing Libraries Manually

While using the Ports Collection is recommended, LinuxÂ® libraries can be
installed manually. The LinuxÂ® shared libraries required by a program and the
runtime linker should be copied to /compat/linux. Any shared libraries opened
by LinuxÂ® programs run under FreeBSD will look in this directory first. For
example, if a LinuxÂ® program loads /lib/libc.so, FreeBSD will first try to
open /compat/linux/lib/libc.so, and if that does not exist, it will then try /
lib/libc.so. Shared libraries should be installed to /compat/linux/lib rather
than to the paths that the LinuxÂ® ld.so reports.

Generally, one will need to look for the shared libraries that LinuxÂ® binaries
depend on only the first few times that a LinuxÂ® program is installed on
FreeBSD. After a while, there will be a sufficient set of LinuxÂ® shared
libraries on the system to be able to run newly imported LinuxÂ® binaries
without any extra work.

11.2.1.1.Â How to Install Additional Shared Libraries

If the linux_base port is installed and an application still complains about
missing shared libraries, there are two methods root can use to determine which
shared libraries the LinuxÂ® binaries need.

If a LinuxÂ® system is available, determine which shared libraries the
application needs, and copy them to the FreeBSD system.

In this example, FTP was used to download the LinuxÂ® binary of Doom on a Linux
Â® system . To check which shared libraries it needs, run ldd linuxdoom:

% ldd linuxdoom libXt.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libX11.so.3.1.0 libc.so.4 (DLL Jump
4.5pl26) =&gt; /lib/libc.so.4.6.29

Copy all the files in the last column into /compat/linux on the FreeBSD system,
with the names in the first column as symbolic links pointing to them. This
example will result in the following files on the FreeBSD system:

/compat/linux/usr/X11/lib/libXt.so.3.1.0 /compat/linux/usr/X11/lib/libXt.so.3
-&gt; libXt.so.3.1.0 /compat/linux/usr/X11/lib/libX11.so.3.1.0 /compat/linux/usr/
X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0 /compat/linux/lib/libc.so.4.6.29 /compat
/linux/lib/libc.so.4 -&gt; libc.so.4.6.29

    Note:

    If a LinuxÂ® shared library already exists with a matching major revision
    number to the first column of the ldd output, it does not need to be copied
    to the file named in the last column, as the existing library should work.
    It is advisable to copy the shared library if it is a newer version,
    though. The old one can be removed, as long as the symbolic link points to
    the new one. For example, these libraries exist on the system:

    /compat/linux/lib/libc.so.4.6.27 /compat/linux/lib/libc.so.4 -&gt;
    libc.so.4.6.27

    and a binary claims to require a later version according to the output of
    ldd:

    libc.so.4 (DLL Jump 4.5pl26) -&gt; libc.so.4.6.29

    If it is only one or two versions out of date in the trailing digit, do not
    worry about copying /lib/libc.so.4.6.29, because the program should work
    fine with the slightly older version. However, it is safe to replace the
    libc.so:

    /compat/linux/lib/libc.so.4.6.29 /compat/linux/lib/libc.so.4 -&gt;
    libc.so.4.6.29

    Note:

    The symbolic link mechanism is only needed for LinuxÂ® binaries as the
    FreeBSD runtime linker takes care of looking for matching major revision
    numbers.

11.2.2.Â Installing LinuxÂ® ELF Binaries

ELF binaries sometimes require an extra step of â  brandingâ  . If an unbranded
ELF binary is executed, it will generate an error message like the following:

% ./my-linux-elf-binary ELF binary type not known Abort

To help the FreeBSD kernel distinguish between a FreeBSD ELF binary and a Linux
Â® binary, use brandelf(1):

% brandelf -t Linux my-linux-elf-binary

Since the GNU toolchain places the appropriate branding information into ELF
binaries automatically, this step is usually not necessary.

11.2.3.Â Installing a LinuxÂ® RPM Based Application

FreeBSD uses its own package database to track all software installed from the
Ports Collection. However, the LinuxÂ® RPM database is not supported.

In order to install a LinuxÂ® RPM-based application, first install the
archivers/rpm2cpio package or port. Once installed, root can use this command
to install a .rpm as follows:

# cd /compat/linux # rpm2cpio -q &lt; /path/to/linux.archive.rpm | cpio -id

If necessary, brandelf the installed ELF binaries, but not the libraries. Note
that this will prevent a clean uninstall.

11.2.4.Â Configuring the Hostname Resolver

If DNS does not work or this error appears:

resolv+: "bind" is an invalid keyword resolv+: "hosts" is an invalid keyword

Configure /compat/linux/etc/host.conf as follows:

order hosts, bind multi on

This order specifies that /etc/hosts is searched first and DNS is searched
second. When /compat/linux/etc/host.conf does not exist, LinuxÂ® applications
use /etc/host.conf and complain about the incompatible FreeBSD syntax. Remove
bind if a name server is not configured using /etc/resolv.conf.

11.3.Â Installing MathematicaÂ®

Updated for Mathematica 5.X by Boris Hollas.

This section describes the process of installing the LinuxÂ® version of 
MathematicaÂ® 5.X onto a FreeBSD system. MathematicaÂ® is a commercial,
computational software program used in scientific, engineering, and
mathematical fields. It is available from Wolfram Research.

11.3.1.Â Running the MathematicaÂ® Installer

First, tell FreeBSD that MathematicaÂ®'s LinuxÂ® binaries use the LinuxÂ®
Application Binary Interface ABI. The easiest way to do this is to set the
default ELF brand to LinuxÂ® for all unbranded binaries with the command:

# sysctl kern.fallback_elf_brand=3

FreeBSD will now assume that unbranded ELF binaries use the LinuxÂ® ABI which
should allow the installer to execute from the CDROM.

Copy the MathInstaller to the hard drive:

# mount /cdrom # cp /cdrom/Unix/Installers/Linux/MathInstaller /localdir/

In this file, replace /bin/sh in the first line with /compat/linux/bin/sh. This
ensures that the installer is executed by the LinuxÂ® version of sh(1). Next,
replace all occurrences of Linux) with FreeBSD) using a text editor or the
script below in the next section. This tells the MathematicaÂ® installer, to
treat FreeBSD as a LinuxÂ®-like operating system. Invoking MathInstaller should
now install MathematicaÂ®.

11.3.2.Â Modifying the MathematicaÂ® Executables

The shell scripts that MathematicaÂ® created during installation have to be
modified before use. When using /usr/local/bin as the directory for the 
MathematicaÂ® executables, symlinks in this directory will point to files
called math, mathematica, Mathematica, and MathKernel. In each of these,
replace Linux) with FreeBSD) using a text editor or the following shell script:

#!/bin/sh cd /usr/local/bin for i in math mathematica Mathematica MathKernel do
sed 's/Linux)/FreeBSD)/g' $i &gt; $i.tmp sed 's/\/bin\/sh/\/compat\/linux\/bin\/sh
/g' $i.tmp &gt; $i rm $i.tmp chmod a+x $i done

11.3.3.Â Obtaining a MathematicaÂ® Password

When MathematicaÂ® is started for the first time, it will ask for a password.
If a password had not yet been obtained from Wolfram Research, run mathinfo in
the installation directory to obtain the â  machine IDâ  . This machine ID is
based solely on the MAC address of the first Ethernet card, as the copy of 
MathematicaÂ® cannot run on different machines.

When registering with Wolfram Research, provide the â  machine IDâ   and they
will respond with a corresponding password consisting of groups of numbers.

11.3.4.Â Running the MathematicaÂ® Frontend over a Network

MathematicaÂ® uses some special fonts to display characters not present in any
of the standard font sets. Xorg requires these fonts to be installed locally.
This means that these fonts need to be copied from the CDROM or from a host
with MathematicaÂ® installed to the local machine. These fonts are normally
stored in /cdrom/Unix/Files/SystemFiles/Fonts on the CDROM, or /usr/local/
mathematica/SystemFiles/Fonts on the hard drive. The actual fonts are in the
subdirectories Type1 and X. There are several ways to use them, as described
below.

The first way is to copy the fonts into one of the existing font directories in
/usr/local/lib/X11/fonts then running mkfontdir(1) within the directory
containing the new fonts.

The second way to do this is to copy the directories to /usr/local/lib/X11/
fonts:

# cd /usr/local/lib/X11/fonts # mkdir X # mkdir MathType1 # cd /cdrom/Unix/
Files/SystemFiles/Fonts # cp X/* /usr/local/lib/X11/fonts/X # cp Type1/* /usr/
local/lib/X11/fonts/MathType1 # cd /usr/local/lib/X11/fonts/X # mkfontdir # cd
../MathType1 # mkfontdir

Now add the new font directories to the font path:

# xset fp+ /usr/local/lib/X11/fonts/X # xset fp+ /usr/local/lib/X11/fonts/
MathType1 # xset fp rehash

When using the Xorg server, these font directories can be loaded automatically
by adding them to /etc/X11/xorg.conf.

If /usr/local/lib/X11/fonts/Type1 does not already exist, change the name of
the MathType1 directory in the example above to Type1.

11.4.Â Installing Mapleâ ¢

Contributed by Aaron Kaplan.
Thanks to Robert Getschmann.

Mapleâ ¢ is a commercial mathematics program similar to MathematicaÂ®. This
software must be purchased and licensed from Maplesoft. To install the LinuxÂ®
version of this software on FreeBSD, follow these steps.

 1. Execute the INSTALL shell script from the product distribution. Choose the 
    â  RedHatâ   option when prompted by the installation program. A typical
    installation directory might be /usr/local/maple.

 2. Copy the license to /usr/local/maple/license/license.dat.

 3. Install the FLEXlm license manager by running the INSTALL_LIC install shell
    script that comes with Mapleâ ¢. Specify the primary hostname for the
    machine for the license server.

 4. Patch /usr/local/maple/bin/maple.system.type with the following:

    ----- snip ------------------ *** maple.system.type.orig Sun Jul 8 16:35:33
    2001 --- maple.system.type Sun Jul 8 16:35:51 2001 *************** ***
    72,77 **** --- 72,78 ---- # the IBM RS/6000 AIX case MAPLE_BIN=
    "bin.IBM_RISC_UNIX" ;; + "FreeBSD"|\ "Linux") # the Linux/x86 case # We
    have two Linux implementations, one for Red Hat and ----- snip end of patch
    -----

    Note that no whitespace should be present after "FreeBSD"|\.

    This patch instructs Mapleâ ¢ to recognize FreeBSD as a type of LinuxÂ®
    system. The bin/maple shell script calls the bin/maple.system.type shell
    script which in turn calls uname -a to find out the operating system name.
    Depending on the OS name it will find out which binaries to use.

 5. Start the license server.

    The following script, installed as /usr/local/rtc/rc.d/lmgrd is a
    convenient way to start up lmgrd:

    ----- snip ------------ #! /bin/sh PATH=/usr/local/sbin:/usr/local/bin:/
    sbin:/bin:/usr/sbin:/usr/bin PATH=${PATH}:/usr/local/maple/bin:/usr/local/
    maple/FLEXlm/UNIX/LINUX export PATH LICENSE_FILE=/usr/local/maple/license/
    license.dat LOG=/var/log/lmgrd.log case "$1" in start) lmgrd -c $
    {LICENSE_FILE} 2&gt;&gt; ${LOG} 1&gt;&2 echo -n " lmgrd" ;; stop) lmgrd -c $
    {LICENSE_FILE} -x lmdown 2&gt;&gt; ${LOG} 1&gt;&2 ;; *) echo "Usage: `basename $0`
    {start|stop}" 1&gt;&2 exit 64 ;; esac exit 0 ----- snip ------------
 6. Test that Mapleâ ¢ starts:

    % cd /usr/local/maple/bin % ./xmaple

    Once everything is working, consider writing Maplesoft to let them know you
    would like a native FreeBSD version!

11.4.1.Â Common Pitfalls

  * lmgrd is known to be picky about the license file and to dump core if there
    are any problems. A correct license file should look like this:

    # ======================================================= # License File
    for UNIX Installations ("Pointer File") # =================================
    ====================== SERVER chillig ANY #USE_SERVER VENDOR maplelmg
    FEATURE Maple maplelmg 2000.0831 permanent 1 XXXXXXXXXXXX \ PLATFORMS=i86_r
    ISSUER="Waterloo Maple Inc." \ ISSUED=11-may-2000 NOTICE=" Technische
    Universitat Wien" \ SN=XXXXXXXXX

    Note:

    In this example, the serial number and key were replaced with X. chillig is
    the hostname.

    Editing the license file works as long as the â  FEATUREâ   line is not
    edited. That line is protected by the license key.

11.5.Â Installing MATLABÂ®

Contributed by Dan Pelleg.

This document describes the process of installing the LinuxÂ® version of MATLAB
Â® version 6.5 onto a FreeBSD system. It works quite well, with the exception
of the Java Virtual Machineâ ¢ which is described further in SectionÂ 11.5.3, â
  Linking the Javaâ ¢ Runtime Environmentâ  .

The LinuxÂ® version of MATLABÂ® can be purchased and licensed from MathWorks.
Consider letting the company know that you would like a native FreeBSD version
of this software.

11.5.1.Â Installing MATLABÂ®

To install MATLABÂ®:

 1. Become root, as recommended by the installation script. Insert the
    installation CD and mount it. To start the installation script type:

    # /compat/linux/bin/sh /cdrom/install

    Tip:

    The installer is graphical. If it is not able to open a display, type
    setenv HOME ~USER, where USER is the user who ran su(1).

 2. When asked for the MATLABÂ® root directory, type: /compat/linux/usr/local/
    matlab.

    Tip:

    For easier typing on the rest of the installation process, type this at the
    shell prompt: set MATLAB=/compat/linux/usr/local/matlab.

 3. Edit the license file as instructed when obtaining the MATLABÂ® license.

    Tip:

    This file can be prepared in advance using an editor, and copied to $MATLAB
    /license.dat before the installer asks to edit it.

 4. Complete the installation process.

At this point the MATLABÂ® installation is complete. The following steps apply 
â  glueâ   to connect it to the FreeBSD system.

11.5.2.Â License Manager Startup

 1. Create symlinks for the license manager scripts:

    # ln -s $MATLAB/etc/lmboot /usr/local/etc/lmboot_TMW # ln -s $MATLAB/etc/
    lmdown /usr/local/etc/lmdown_TMW
 2. Create a startup file named /usr/local/etc/rc.d/flexlm. The example below
    is a modified version of the distributed $MATLAB/etc/rc.lm.glnx86. The
    changes are file locations and startup of the license manager under LinuxÂ®
    emulation.

    #!/bin/sh case "$1" in start) if [ -f /usr/local/etc/lmboot_TMW ]; then /
    compat/linux/bin/sh /usr/local/etc/lmboot_TMW -u username && echo
    'MATLAB_lmgrd' fi ;; stop) if [ -f /usr/local/etc/lmdown_TMW ]; then /
    compat/linux/bin/sh /usr/local/etc/lmdown_TMW &gt; /dev/null 2&gt;&1 fi ;; *)
    echo "Usage: $0 {start|stop}" exit 1 ;; esac exit 0

    Important:

    The file must be made executable:

    # chmod +x /usr/local/etc/rc.d/flexlm

    Replace username with the name of a valid user on the system which is not
    root.

 3. Start the license manager with the command:

    # service flexlm start

11.5.3.Â Linking the Javaâ ¢ Runtime Environment

Change the Javaâ ¢ Runtime Environment (JRE) link to one working under FreeBSD:

# cd $MATLAB/sys/java/jre/glnx86/ # unlink jre; ln -s ./jre1.1.8 ./jre

11.5.4.Â Creating a MATLABÂ® Startup Script

 1. Place the following startup script in /usr/local/bin/matlab:

    #!/bin/sh /compat/linux/bin/sh /compat/linux/usr/local/matlab/bin/matlab
    "$@"
 2. Then, type the command chmod +x /usr/local/bin/matlab.

Tip:

Depending on the version of emulators/linux_base, running this script may
result in errors. To avoid errors, edit /compat/linux/usr/local/matlab/bin/
matlab, and change the line that says:

if [ `expr "$lscmd" : '.*-&gt;.*'` -ne 0 ]; then

to this line:

if test -L $newbase; then

11.5.5.Â Creating a MATLABÂ® Shutdown Script

The following is needed to solve a problem with MATLABÂ® not exiting correctly.

 1. Create $MATLAB/toolbox/local/finish.m containing the single line:

    ! $MATLAB/bin/finish.sh

    Note:

    The $MATLAB is literal.

    Tip:

    The same directory contains finishsav.m and finishdlg.m, which allow the
    workspace to be saved before quitting. If either file is used, insert the
    line above immediately after the save command.

 2. Create $MATLAB/bin/finish.sh which contains the following:

    #!/compat/linux/bin/sh (sleep 5; killall -1 matlab_helper) & exit 0
 3. Make the file executable:

    # chmod +x $MATLAB/bin/finish.sh

11.5.6.Â Using MATLABÂ®

At this point, matlab is ready for use.

11.6.Â Installing OracleÂ®

Contributed by Marcel Moolenaar.

This document describes the process of installing OracleÂ® 8.0.5 and OracleÂ®
8.0.5.1 Enterprise Edition for LinuxÂ® onto a FreeBSD machine.

11.6.1.Â Installing the LinuxÂ® Environment

Make sure emulators/linux_base has been installed from the Ports Collection.

To run the intelligent agent, install the Red Hat Tcl package:
tcl-8.0.3-20.i386.rpm. The general command for installing RPMs with the
archivers/rpm port is:

# rpm -i --ignoreos --root /compat/linux --dbpath /var/lib/rpm package

This command should not generate any errors.

11.6.2.Â Creating the OracleÂ® Environment

Before installing OracleÂ®, set up a proper environment. This section only
describes how to install OracleÂ® for LinuxÂ® on FreeBSD, not what has been
described in the OracleÂ® installation guide.

11.6.2.1.Â Kernel Tuning

As described in the OracleÂ® installation guide, the maximum size of shared
memory needs to be set. Do not use SHMMAX under FreeBSD as it is calculated
from SHMMAXPGS and PGSIZE. Therefore, define SHMMAXPGS. All other options can
be used as described in the guide. For example:

options SHMMAXPGS=10000 options SHMMNI=100 options SHMSEG=10 options SEMMNS=200
options SEMMNI=70 options SEMMSL=61

Set these options to suit the intended use of OracleÂ®.

Also, make sure the following options are in the kernel configuration file:

options SYSVSHM #SysV shared memory options SYSVSEM #SysV semaphores options
SYSVMSG #SysV interprocess communication

11.6.2.2.Â OracleÂ® Account

Create a user account to be used as the oracle account. Add /compat/linux/bin/
bash to /etc/shells and set the shell for the oracle account to /compat/linux/
bin/bash.

11.6.2.3.Â Environment

Besides the normal OracleÂ® variables, such as ORACLE_HOME and ORACLE_SID set
the following environment variables:

   Variable                                  Value
LD_LIBRARY_PATH $ORACLE_HOME/lib
CLASSPATH       $ORACLE_HOME/jdbc/lib/classes111.zip
                /compat/linux/bin /compat/linux/sbin /compat/linux/usr/bin /
PATH            compat/linux/usr/sbin /bin /sbin /usr/bin /usr/sbin /usr/local/
                bin $ORACLE_HOME/bin

It is advised to set all the environment variables in ~/.profile as follows:

ORACLE_BASE=/oracle; export ORACLE_BASE ORACLE_HOME=/oracle; export ORACLE_HOME
LD_LIBRARY_PATH=$ORACLE_HOME/lib export LD_LIBRARY_PATH ORACLE_SID=ORCL; export
ORACLE_SID ORACLE_TERM=386x; export ORACLE_TERM CLASSPATH=$ORACLE_HOME/jdbc/lib
/classes111.zip export CLASSPATH PATH=/compat/linux/bin:/compat/linux/sbin:/
compat/linux/usr/bin PATH=$PATH:/compat/linux/usr/sbin:/bin:/sbin:/usr/bin:/usr
/sbin PATH=$PATH:/usr/local/bin:$ORACLE_HOME/bin export PATH

11.6.3.Â Installing OracleÂ®

Before starting the installer, create a directory named /var/tmp/.oracle which
is owned by the oracle user. The installation of OracleÂ® should work without
any problems. If errors are encountered, check the OracleÂ® distribution and
configuration. Once OracleÂ® is installed, apply the patches described in the
next two subsections.

A frequent error is that the TCP protocol adapter is not installed correctly.
As a consequence, no TCP listeners can be started. The following actions help
to solve this problem:

# cd $ORACLE_HOME/network/lib # make -f ins_network.mk ntcontab.o # cd
$ORACLE_HOME/lib # ar r libnetwork.a ntcontab.o # cd $ORACLE_HOME/network/lib #
make -f ins_network.mk install

Do not forget to run root.sh again.

11.6.3.1.Â Patching root.sh

When installing OracleÂ®, some actions, which need to be performed as root, are
recorded in a shell script called root.sh. This script is found in orainst.
Apply the following patch to root.sh so that it can find the FreeBSD location
of chown. Alternatively, run the script under a LinuxÂ® native shell.

*** orainst/root.sh.orig Tue Oct 6 21:57:33 1998 --- orainst/root.sh Mon Dec 28
15:58:53 1998 *************** *** 31,37 **** # This is the default value for
CHOWN # It will redefined later in this script for those ports # which have it
conditionally defined in ss_install.h ! CHOWN=/bin/chown # # Define variables
to be used in this script --- 31,37 ---- # This is the default value for CHOWN
# It will redefined later in this script for those ports # which have it
conditionally defined in ss_install.h ! CHOWN=/usr/sbin/chown # # Define
variables to be used in this script

If OracleÂ® is not installed from CD, patch the source for root.sh. It is
called rthd.sh and is located in orainst in the source tree.

11.6.3.2.Â Patching genclntsh

The script genclntsh is used to create a single shared client library when
building the demos. Apply the following patch to comment out the definition of
PATH:

*** bin/genclntsh.orig Wed Sep 30 07:37:19 1998 --- bin/genclntsh Tue Dec 22
15:36:49 1998 *************** *** 32,38 **** # # Explicit path to ensure that
we're using the correct commands #PATH=/usr/bin:/usr/ccs/bin export PATH ! PATH
=/usr/local/bin:/bin:/usr/bin export PATH # # each product MUST provide a
$PRODUCT/admin/shrept.lst --- 32,38 ---- # # Explicit path to ensure that we're
using the correct commands #PATH=/usr/bin:/usr/ccs/bin export PATH ! #PATH=/usr
/local/bin:/bin:/usr/bin: export PATH # # each product MUST provide a $PRODUCT/
admin/shrept.lst

11.6.4.Â Running OracleÂ®

After following these instructions, OracleÂ® should run as if it was running on
LinuxÂ®.

11.7.Â Advanced Topics

This section describes how LinuxÂ® binary compatibility works and is based on
an email written to FreeBSD chat mailing list by Terry Lambert &lt;
tlambert@primenet.com&gt; (Message ID:
&lt;199906020108.SAA07001@usr09.primenet.com&gt;).

FreeBSD has an abstraction called an â  execution class loaderâ  . This is a
wedge into the execve(2) system call.

Historically, the UNIXÂ® loader examined the magic number (generally the first
4 or 8 bytes of the file) to see if it was a binary known to the system, and if
so, invoked the binary loader.

If it was not the binary type for the system, the execve(2) call returned a
failure, and the shell attempted to start executing it as shell commands. The
assumption was a default of â  whatever the current shell isâ  .

Later, a hack was made for sh(1) to examine the first two characters, and if
they were :\n, it invoked the csh(1) shell instead.

FreeBSD has a list of loaders, instead of a single loader, with a fallback to
the #! loader for running shell interpreters or shell scripts.

For the LinuxÂ® ABI support, FreeBSD sees the magic number as an ELF binary.
The ELF loader looks for a specialized brand, which is a comment section in the
ELF image, and which is not present on SVR4/Solarisâ ¢ ELF binaries.

For LinuxÂ® binaries to function, they must be branded as type Linux using
brandelf(1):

# brandelf -t Linux file

When the ELF loader sees the Linux brand, the loader replaces a pointer in the
proc structure. All system calls are indexed through this pointer. In addition,
the process is flagged for special handling of the trap vector for the signal
trampoline code, and several other (minor) fix-ups that are handled by the 
LinuxÂ® kernel module.

The LinuxÂ® system call vector contains, among other things, a list of sysent[]
entries whose addresses reside in the kernel module.

When a system call is called by the LinuxÂ® binary, the trap code dereferences
the system call function pointer off the proc structure, and gets the LinuxÂ®,
not the FreeBSD, system call entry points.

LinuxÂ® mode dynamically reroots lookups. This is, in effect, equivalent to the
union option to file system mounts. First, an attempt is made to lookup the
file in /compat/linux/original-path. If that fails, the lookup is done in /
original-path. This makes sure that binaries that require other binaries can
run. For example, the LinuxÂ® toolchain can all run under LinuxÂ® ABI support.
It also means that the LinuxÂ® binaries can load and execute FreeBSD binaries,
if there are no corresponding LinuxÂ® binaries present, and that a uname(1)
command can be placed in the /compat/linux directory tree to ensure that the 
LinuxÂ® binaries can not tell they are not running on LinuxÂ®.

In effect, there is a LinuxÂ® kernel in the FreeBSD kernel. The various
underlying functions that implement all of the services provided by the kernel
are identical to both the FreeBSD system call table entries, and the LinuxÂ®
system call table entries: file system operations, virtual memory operations,
signal delivery, and System V IPC. The only difference is that FreeBSD binaries
get the FreeBSD glue functions, and LinuxÂ® binaries get the LinuxÂ® glue
functions. The FreeBSD glue functions are statically linked into the kernel,
and the LinuxÂ® glue functions can be statically linked, or they can be
accessed via a kernel module.

Technically, this is not really emulation, it is an ABI implementation. It is
sometimes called â  LinuxÂ® emulationâ   because the implementation was done at
a time when there was no other word to describe what was going on. Saying that
FreeBSD ran LinuxÂ® binaries was not true, since the code was not compiled in.

PartÂ III.Â System Administration

The remaining chapters of the FreeBSD Handbook cover all aspects of FreeBSD
system administration. Each chapter starts by describing what you will learn as
a result of reading the chapter, and also details what you are expected to know
before tackling the material.

These chapters are designed to be read when you need the information. You do
not have to read them in any particular order, nor do you need to read all of
them before you can begin using FreeBSD.

Table of Contents

12. Configuration and Tuning

    12.1. Synopsis
    12.2. Initial Configuration
    12.3. Core Configuration
    12.4. Application Configuration
    12.5. Starting Services
    12.6. Configuring the cron Utility
    12.7. Using rc(8) Under FreeBSD
    12.8. Setting Up Network Interface Cards
    12.9. Virtual Hosts
    12.10. Configuring the System Logger, syslogd
    12.11. Configuration Files
    12.12. Tuning with sysctl(8)
    12.13. Tuning Disks
    12.14. Tuning Kernel Limits
    12.15. Adding Swap Space
    12.16. Power and Resource Management
    12.17. Using and Debugging FreeBSD ACPI

13. The FreeBSD Booting Process

    13.1. Synopsis
    13.2. The Booting Problem
    13.3. The Boot Manager and Boot Stages
    13.4. Kernel Interaction During Boot
    13.5. Device Hints
    13.6. Init: Process Control Initialization
    13.7. Shutdown Sequence

14. Users and Basic Account Management

    14.1. Synopsis
    14.2. Introduction
    14.3. Modifying Accounts
    14.4. Limiting Users
    14.5. Groups

15. Security

    15.1. Synopsis
    15.2. Introduction
    15.3. Securing FreeBSD
    15.4. DES, Blowfish, MD5, SHA256, SHA512, and Crypt
    15.5. One-time Passwords
    15.6. TCP Wrappers
    15.7. Kerberos5
    15.8. OpenSSL
    15.9. VPN over IPsec
    15.10. OpenSSH
    15.11. File System Access Control Lists (ACLs)
    15.12. Monitoring Third Party Security Issues
    15.13. FreeBSD Security Advisories
    15.14. Process Accounting

16. Jails

    16.1. Synopsis
    16.2. Terms Related to Jails
    16.3. Introduction
    16.4. Creating and Controlling Jails
    16.5. Fine Tuning and Administration
    16.6. Application of Jails

17. Mandatory Access Control

    17.1. Synopsis
    17.2. Key Terms in This Chapter
    17.3. Explanation of MAC
    17.4. Understanding MAC Labels
    17.5. Planning the Security Configuration
    17.6. Module Configuration
    17.7. The mac_seeotheruids(4) Module
    17.8. The mac_bsdextended(4) Module
    17.9. The mac_ifoff(4) Module
    17.10. The mac_portacl(4) Module
    17.11. The mac_partition(4) Module
    17.12. The MAC Multi-Level Security Module
    17.13. The MAC Biba Module
    17.14. The MAC LOMAC Module
    17.15. Nagios in a MAC Jail
    17.16. User Lock Down
    17.17. Troubleshooting the MAC Framework

18. Security Event Auditing

    18.1. Synopsis
    18.2. Key Terms in This Chapter
    18.3. Installing Audit Support
    18.4. Audit Configuration
    18.5. Administering the Audit Subsystem

19. Storage

    19.1. Synopsis
    19.2. Device Names
    19.3. Adding Disks
    19.4. RAID
    19.5. USB Storage Devices
    19.6. Creating and Using CD Media
    19.7. Creating and Using DVD Media
    19.8. Creating and Using Floppy Disks
    19.9. Creating and Using Data Tapes
    19.10. Backups to Floppies
    19.11. Backup Strategies
    19.12. Backup Basics
    19.13. Network, Memory, and File-Backed File Systems
    19.14. File System Snapshots
    19.15. File System Quotas
    19.16. Encrypting Disk Partitions
    19.17. Encrypting Swap Space
    19.18. Highly Available Storage (HAST)

20. GEOM: Modular Disk Transformation Framework

    20.1. Synopsis
    20.2. GEOM Introduction
    20.3. RAID0 - Striping
    20.4. RAID1 - Mirroring
    20.5. RAID3 - Byte-level Striping with Dedicated Parity
    20.6. GEOM Gate Network Devices
    20.7. Labeling Disk Devices
    20.8. UFS Journaling Through GEOM

21. File Systems Support

    21.1. Synopsis
    21.2. The Z File System (ZFS)
    21.3. LinuxÂ® Filesystems

22. The vinum Volume Manager

    22.1. Synopsis
    22.2. Access Bottlenecks
    22.3. Data Integrity
    22.4. vinum Objects
    22.5. Some Examples
    22.6. Object Naming
    22.7. Configuring vinum
    22.8. Using vinum for the Root File System

23. Virtualization

    23.1. Synopsis
    23.2. FreeBSD as a Guest OS
    23.3. FreeBSD as a Host

24. Localization - i18n/L10n Usage and Setup

    24.1. Synopsis
    24.2. The Basics
    24.3. Using Localization
    24.4. Compiling i18n Programs
    24.5. Localizing FreeBSD to Specific Languages

25. Updating and Upgrading FreeBSD

    25.1. Synopsis
    25.2. FreeBSD Update
    25.3. Portsnap: a Ports Collection Update Tool
    25.4. Updating the Documentation Set
    25.5. Tracking a Development Branch
    25.6. Synchronizing Source
    25.7. Rebuilding â  worldâ  
    25.8. Tracking for Multiple Machines

26. DTrace

    26.1. Synopsis
    26.2. Implementation Differences
    26.3. Enabling DTrace Support
    26.4. Using DTrace
    26.5. The D Language

ChapterÂ 12.Â Configuration and Tuning

Written by Chern Lee.
Based on a tutorial written by Mike Smith.
Also based on tuning(7) written by Matt Dillon.
Table of Contents

12.1. Synopsis
12.2. Initial Configuration
12.3. Core Configuration
12.4. Application Configuration
12.5. Starting Services
12.6. Configuring the cron Utility
12.7. Using rc(8) Under FreeBSD
12.8. Setting Up Network Interface Cards
12.9. Virtual Hosts
12.10. Configuring the System Logger, syslogd
12.11. Configuration Files
12.12. Tuning with sysctl(8)
12.13. Tuning Disks
12.14. Tuning Kernel Limits
12.15. Adding Swap Space
12.16. Power and Resource Management
12.17. Using and Debugging FreeBSD ACPI

12.1.Â Synopsis

One of the important aspects of FreeBSD is proper system configuration. This
chapter explains much of the FreeBSD configuration process, including some of
the parameters which can be set to tune a FreeBSD system.

After reading this chapter, you will know:

  * How to efficiently work with file systems and swap partitions.

  * The basics of rc.conf configuration and /usr/local/etc/rc.d startup
    scripts.

  * How to configure and test a network card.

  * How to configure virtual hosts on network devices.

  * How to use the various configuration files in /etc.

  * How to tune FreeBSD using sysctl variables.

  * How to tune disk performance and modify kernel limitations.

Before reading this chapter, you should:

  * Understand UNIXÂ® and FreeBSD basics (ChapterÂ 4, UNIX Basics).

  * Be familiar with the basics of kernel configuration and compilation (
    ChapterÂ 9, Configuring the FreeBSD Kernel).

12.2.Â Initial Configuration

12.2.1.Â Partition Layout

12.2.1.1.Â Base Partitions

When laying out file systems with bsdlabel(8) or sysinstall(8), remember that
hard drives transfer data faster from the outer tracks to the inner. Thus
smaller and heavier-accessed file systems should be closer to the outside of
the drive, while larger partitions like /usr should be placed toward the inner
parts of the disk. It is a good idea to create partitions in an order similar
to: root, swap, /var, /usr.

The size of the /var partition reflects the intended machine's usage. This
partition /var is used to hold mailboxes, log files, and printer spools.
Mailboxes and log files can grow to unexpected sizes depending on how many
users exist and how long log files are kept. Most users rarely need more than
about a gigabyte of free disk space in /var.

Note:

There are a few times that a lot of disk space is required in /var/tmp. When
new software is installed with pkg_add(1) the packaging tools extract a
temporary copy of the packages under /var/tmp. Large software packages, like 
Firefox, OpenOffice or LibreOffice may be tricky to install if there is not
enough disk space under /var/tmp.

The /usr partition holds many of the files which support the system, including
the FreeBSD Ports Collection and system source code. At least 2 gigabytes is
recommended for this partition.

When selecting partition sizes, keep the space requirements in mind. Running
out of space in one partition while barely using another can be a hassle.

Note:

Some users have found that sysinstall(8)'s Auto-defaults partition sizer will
sometimes select smaller than adequate /var and / partitions. Partition wisely
and generously.

12.2.1.2.Â Swap Partition

As a rule of thumb, the swap partition should be about double the size of
physical memory (RAM) as the kernel's virtual memory (VM) paging algorithms are
tuned to perform best when the swap partition is at least two times the size of
main memory. Systems with minimal RAM may perform better with more swap.
Configuring too little swap can lead to inefficiencies in the VM page scanning
code and might create issues later if more memory is added.

On larger systems with multiple SCSI disks or multiple IDE disks operating on
different controllers, it is recommended that swap be configured on each drive
(up to four drives). The swap partitions should be approximately the same size.
The kernel can handle arbitrary sizes but internal data structures scale to 4
times the largest swap partition. Keeping the swap partitions near the same
size will allow the kernel to optimally stripe swap space across disks. Large
swap sizes are fine, even if swap is not used much. It might be easier to
recover from a runaway program before being forced to reboot.

12.2.1.3.Â Why Partition?

Several users think a single large partition will be fine, but there are
several reasons why this is a bad idea. First, each partition has different
operational characteristics and separating them allows the file system to tune
accordingly. For example, the root and /usr partitions are read-mostly, with
few writes, while a lot of reads and writes could occur in /var and /var/tmp.

By properly partitioning a system, fragmentation introduced in the smaller
write heavy partitions will not bleed over into the mostly-read partitions.
Keeping the write-loaded partitions closer to the disk's edge, will increase I/
O performance in the partitions where it occurs the most. Now while I/O
performance in the larger partitions may be needed, shifting them more toward
the edge of the disk will not lead to a significant performance improvement
over moving /var to the edge. Finally, there are safety concerns. A smaller,
neater root partition which is mostly read-only has a greater chance of
surviving a bad crash.

12.3.Â Core Configuration

The principal location for system configuration information is /etc/rc.conf.
This file contains a wide range of configuration information and it is read at
system startup to configure the system. It provides the configuration
information for the rc* files.

The entries in /etc/rc.conf override the default settings in /etc/defaults/
rc.conf. The file containing the default settings should not be edited.
Instead, all system-specific changes should be made to /etc/rc.conf.

A number of strategies may be applied in clustered applications to separate
site-wide configuration from system-specific configuration in order to keep
administration overhead down. The recommended approach is to place
system-specific configuration into /etc/rc.conf.local. For example:

  * /etc/rc.conf:

    sshd_enable="YES" keyrate="fast" defaultrouter="10.1.1.254"
  * /etc/rc.conf.local:

    hostname="node1.example.org" ifconfig_fxp0="inet 10.1.1.1/8"

rc.conf can then be distributed to every system using rsync or a similar
program, while rc.conf.local remains unique.

Upgrading the system using sysinstall(8) or make world will not overwrite
rc.conf, so system configuration information will not be lost.

Tip:

The /etc/rc.conf configuration file is parsed by sh(1). This allows system
operators to add a certain amount of logic to this file, which may help to
create very complex configuration scenarios. Refer to rc.conf(5) for further
information on this topic.

12.4.Â Application Configuration

Typically, installed applications have their own configuration files and
syntax. It is important that these files be kept separate from the base system,
so that they may be easily located and managed by the package management tools.

Typically, these files are installed in /usr/local/etc. In the case where an
application has a large number of configuration files, a subdirectory will be
created to hold them.

Normally, when a port or package is installed, sample configuration files are
also installed. These are usually identified with a .default suffix. If there
are no existing configuration files for the application, they will be created
by copying the .default files.

For example, consider the contents of the directory /usr/local/etc/apache:

-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf
-rw-r--r--  1 root  wheel   2184 May 20  1998 access.conf.default
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf
-rw-r--r--  1 root  wheel   9555 May 20  1998 httpd.conf.default
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic
-rw-r--r--  1 root  wheel  12205 May 20  1998 magic.default
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types
-rw-r--r--  1 root  wheel   2700 May 20  1998 mime.types.default
-rw-r--r--  1 root  wheel   7980 May 20  1998 srm.conf
-rw-r--r--  1 root  wheel   7933 May 20  1998 srm.conf.default

The file sizes show that only srm.conf has been changed. A later update of the 
Apache port would not overwrite this changed file.

12.5.Â Starting Services

Contributed by Tom Rhodes.

Many users install third party software on FreeBSD from the Ports Collection
and require the installed services to be started upon system initialization.
Services, such as mail/postfix or www/apache22 are just two of the many
software packages which may be started during system initialization. This
section explains the procedures available for starting third party software.

In FreeBSD, most included services, such as cron(8), are started through the
system start up scripts.

12.5.1.Â Extended Application Configuration

Now that FreeBSD includes rc.d, configuration of application startup is easier
and provides more features. Using the key words discussed in the rc.d section,
applications can be set to start after certain other services and extra flags
can be passed through /etc/rc.conf in place of hard coded flags in the start up
script. A basic script may look similar to the following:

#!/bin/sh # # PROVIDE: utility # REQUIRE: DAEMON # KEYWORD: shutdown . /etc/
rc.subr name=utility rcvar=utility_enable command="/usr/local/sbin/utility"
load_rc_config $name # # DO NOT CHANGE THESE DEFAULT VALUES HERE # SET THEM IN
THE /etc/rc.conf FILE # utility_enable=${utility_enable-"NO"} pidfile=$
{utility_pidfile-"/var/run/utility.pid"} run_rc_command "$1"

This script will ensure that the provided utility will be started after the
DAEMON pseudo-service. It also provides a method for setting and tracking the 
PID, or process ID file.

This application could then have the following line placed in /etc/rc.conf:

utility_enable="YES"

This method also allows for easier manipulation of the command line arguments,
inclusion of the default functions provided in /etc/rc.subr, compatibility with
the rcorder(8) utility and provides for easier configuration via rc.conf.

12.5.2.Â Using Services to Start Services

Other services, such as the POP3 server daemons or IMAP, could be started using
inetd(8). This involves installing the service utility from the Ports
Collection with a configuration line added to /etc/inetd.conf, or by
uncommenting one of the current configuration lines. Working with inetd and its
configuration is described in depth in the inetd section.

In some cases it may make more sense to use the cron(8) daemon to start system
services. This approach has a number of advantages because cron runs these
processes as the crontab's file owner. This allows regular users to start and
maintain some applications.

The cron utility provides a unique feature, @reboot, which may be used in place
of the time specification. This will cause the job to be run when cron(8) is
started, normally during system initialization.

12.6.Â Configuring the cron Utility

Contributed by Tom Rhodes.

One of the most useful utilities in FreeBSD is cron(8). This utility runs in
the background and regularly checks /etc/crontab for tasks to execute and
searches /var/cron/tabs for custom crontab files. These files store information
about specific functions which cron is supposed to perform at certain times.

The cron utility uses two different types of configuration files, the system
crontab and user crontabs. These formats only differ in the sixth field and
later. In the system crontab, cron will run the command as the user specified
in the sixth field. In a user crontab, all commands run as the user who created
the crontab, so the sixth field is the last field; this is an important
security feature. The final field is always the command to run.

Note:

User crontabs allow individual users to schedule tasks without the need for
root privileges. Commands in a user's crontab run with the permissions of the
user who owns the crontab.

The root user can have a user crontab just like any other user. The root user
crontab is separate from /etc/crontab (the system crontab). Because the system
crontab effectively invokes the specified commands as root there is usually no
need to create a user crontab for root.

Let us take a look at /etc/crontab, the system crontab:

# /etc/crontab - root's crontab for FreeBSD # # $FreeBSD: src/etc/crontab,v
1.32 2002/11/22 16:13:39 tom Exp $ # 1 # SHELL=/bin/sh PATH=/etc:/bin:/sbin:/
usr/bin:/usr/sbin 2 HOME=/var/log # # #minute hour mday month wday who command 
3 # # */5 * * * * root /usr/libexec/atrun 4

1    Like most FreeBSD configuration files, lines that begin with the #
     character are comments. A comment can be placed in the file as a reminder
     of what and why a desired action is performed. Comments cannot be on the
     same line as a command or else they will be interpreted as part of the
     command; they must be on a new line. Blank lines are ignored.

2    First, the environment must be defined. The equals (=) character is used
     to define any environment settings, as with this example where it is used
     for the SHELL, PATH, and HOME options. If the shell line is omitted, cron
     will use the default, which is sh. If the PATH variable is omitted, no
     default will be used and file locations will need to be absolute. If HOME
     is omitted, cron will use the invoking users home directory.

3    This line defines a total of seven fields. Listed here are the values
     minute, hour, mday, month, wday, who, and command. These are almost all
     self explanatory. minute is the time in minutes the command will be run.
     hour is similar to the minute option, just in hours. mday stands for day
     of the month. month is similar to hour and minute, as it designates the
     month. The wday option stands for day of the week. All these fields must
     be numeric values, and follow the twenty-four hour clock. The who field is
     special, and only exists in /etc/crontab. This field specifies which user
     the command should be run as. The last field is the command to be
     executed.

4    This last line will define the values discussed above. This example has a
     */5 listing,followed by several more * characters. These * characters mean
     â  first-lastâ  , and can be interpreted as every time. In this example,
     atrun is invoked by root every five minutes regardless of the day or
     month. For more information on atrun, refer to atrun(8).

     Commands can have any number of flags passed to them; however, commands
     which extend to multiple lines need to be broken with the backslash â  \â 
       continuation character.

This is the basic setup for every crontab, although there is one thing
different about this one. Field number six, which specifies the username, only
exists in the system crontab. This field should be omitted for individual user
crontab files.

12.6.1.Â Installing a Crontab

Important:

Do not use the procedure described here to edit and install the system crontab,
/etc/crontab. Instead, use an editor: cron will notice that the file has
changed and immediately begin using the updated version. See this FAQ entry for
more information.

To install a freshly written user crontab, first use an editor to create and
save a file in the proper format. Then, specify the file name with crontab:

% crontab crontab-file

In this example, crontab-file is the filename of a crontab that was previously
created.

To list installed crontab files, pass -l to crontab.

For users who wish to begin their own crontab file from scratch, without the
use of a template, the crontab -e option is available. This will invoke the
selected editor with an empty file. When the file is saved, it will be
automatically installed by crontab.

In order to remove a user crontab completely, use crontab -r.

12.7.Â Using rc(8) Under FreeBSD

Contributed by Tom Rhodes.

In 2002 FreeBSD integrated the NetBSD rc.d system for system initialization.
Users should notice the files listed in the /etc/rc.d directory. Many of these
files are for basic services which can be controlled with the start, stop, and
restart options. For instance, sshd(8) can be restarted with the following
command:

# service sshd restart

This procedure is similar for other services. Of course, services are usually
started automatically at boot time as specified in rc.conf(5). For example,
enabling the Network Address Translation daemon at startup is as simple as
adding the following line to /etc/rc.conf:

natd_enable="YES"

If a natd_enable="NO" line is already present, then simply change the NO to
YES. The rc scripts will automatically load any other dependent services during
the next reboot, as described below.

Since the rc.d system is primarily intended to start/stop services at system
startup/shutdown time, the standard start, stop and restart options will only
perform their action if the appropriate /etc/rc.conf variables are set. For
instance, sshd restart will only work if sshd_enable is set to YES in /etc/
rc.conf. To start, stop or restart a service regardless of the settings in /etc
/rc.conf, the commands should be prefixed with â  oneâ  . For instance, to
restart sshd regardless of the current /etc/rc.conf setting, execute the
following command:

# service sshd onerestart

It is easy to check if a service is enabled in /etc/rc.conf by running the
appropriate rc.d script with the option rcvar. Thus, an administrator can check
that sshd is in fact enabled in /etc/rc.conf by running:

# service sshd rcvar # sshd $sshd_enable=YES

Note:

The second line (# sshd) is the output from sshd, not a root console.

To determine whether or not a service is running, use status. For instance, to
verify that sshd is running:

# service sshd status sshd is running as pid 433.

In some cases it is also possible to reload a service. This will attempt to
send a signal to an individual service, forcing the service to reload its
configuration files. In most cases this means sending the service a SIGHUP
signal. Support for this feature is not included for every service.

The rc.d system is not only used for network services, it also contributes to
most of the system initialization. For instance, when the bgfsck script is
executed, it will print out the following message:

Starting background file system checks in 60 seconds.

Therefore this file is used for background file system checks, which are done
only during system initialization.

Many system services depend on other services to function properly. For
example, NIS and other RPC-based services may fail to start until after the
rpcbind (portmapper) service has started. To resolve this issue, information
about dependencies and other meta-data is included in the comments at the top
of each startup script. The rcorder(8) program is then used to parse these
comments during system initialization to determine the order in which system
services should be invoked to satisfy the dependencies.

The following words must be included in all startup scripts (they are required
by rc.subr(8) to â  enableâ   the startup script):

  * PROVIDE: Specifies the services this file provides.

The following words may be included at the top of each startup file. They are
not strictly necessary, but they are useful as hints to rcorder(8):

  * REQUIRE: Lists services which are required for this service. This file will
    run after the specified services.

  * BEFORE: Lists services which depend on this service. This file will run 
    before the specified services.

By carefully setting these keywords for each startup script, an administrator
has a very fine-grained level of control of the startup order of the scripts,
without the hassle of â  runlevelsâ   like some other UNIXÂ® operating systems.

Additional information about the rc.d system can be found in rc(8) and rc.subr
(8). Refer to this article for instructions on how to create custom rc.d
scripts.

12.8.Â Setting Up Network Interface Cards

Contributed by Marc Fonvieille.

Adding and configuring a network card is a common task for any FreeBSD
administrator.

12.8.1.Â Locating the Correct Driver

First, determine the model of the network interface card and the chip it uses.
FreeBSD supports a wide variety of network interface cards. Check the Hardware
Compatibility List for the FreeBSD release to see if the card is supported.

If the card is supported, determine the name of the FreeBSD driver for the
card. Refer to /usr/src/sys/conf/NOTES and /usr/src/sys/arch/conf/NOTES for the
list of network interface drivers with some information about the supported
chipsets. When in doubt, read the manual page of the driver as it will provide
more information about the supported hardware and any known limitations of the
driver.

The drivers for common network cards are already present in the GENERIC kernel,
meaning the card should show up during boot, as in this example:

dc0: &lt;82c169 PNIC 10/100BaseTX&gt; port 0xa000-0xa0ff mem 0xd3800000-0xd38 000ff
irq 15 at device 11.0 on pci0 miibus0: &lt;MII bus&gt; on dc0 bmtphy0: &lt;BCM5201 10/
100baseTX PHY&gt; PHY 1 on miibus0 bmtphy0: 10baseT, 10baseT-FDX, 100baseTX,
100baseTX-FDX, auto dc0: Ethernet address: 00:a0:cc:da:da:da dc0: [ITHREAD]
dc1: &lt;82c169 PNIC 10/100BaseTX&gt; port 0x9800-0x98ff mem 0xd3000000-0xd30 000ff
irq 11 at device 12.0 on pci0 miibus1: &lt;MII bus&gt; on dc1 bmtphy1: &lt;BCM5201 10/
100baseTX PHY&gt; PHY 1 on miibus1 bmtphy1: 10baseT, 10baseT-FDX, 100baseTX,
100baseTX-FDX, auto dc1: Ethernet address: 00:a0:cc:da:da:db dc1: [ITHREAD]

In this example, two cards using the dc(4) driver are present on the system.

If the driver for the interface is not present in GENERIC, but a driver is
available, the driver will need to be loaded before the interface can be
configured and used. This may be accomplished in one of two ways:

  * The easiest way is to load a kernel module for the network card with
    kldload(8). To also automatically load the driver at boot time, add the
    appropriate line to /boot/loader.conf. Not all NIC drivers are available as
    modules; notable examples of devices for which modules do not exist are ISA
    cards.

  * Alternatively, statically compile support for the card into a custom
    kernel. Refer to /usr/src/sys/conf/NOTES, /usr/src/sys/arch/conf/NOTES and
    the manual page of the driver to determine which line to add to the custom
    kernel configuration file. For more information about recompiling the
    kernel, refer to ChapterÂ 9, Configuring the FreeBSD Kernel. If the card
    was detected at boot, the kernel does not need to be recompiled.

12.8.1.1.Â Using WindowsÂ® NDIS Drivers

Unfortunately, there are still many vendors that do not provide schematics for
their drivers to the open source community because they regard such information
as trade secrets. Consequently, the developers of FreeBSD and other operating
systems are left two choices: develop the drivers by a long and pain-staking
process of reverse engineering or using the existing driver binaries available
for the MicrosoftÂ®Â WindowsÂ® platforms. Most developers, including those
involved with FreeBSD, have taken the latter approach.

Thanks to the contributions of Bill Paul (wpaul) there is â  nativeâ   support
for the Network Driver Interface Specification (NDIS). The FreeBSD NDISulator
(otherwise known as Project Evil) takes a WindowsÂ® driver binary and basically
tricks it into thinking it is running on WindowsÂ®. Because the ndis(4) driver
is using a WindowsÂ® binary, it only runs on i386â ¢ and amd64 systems. PCI,
CardBus, PCMCIA (PC-Card), and USB devices are supported.

To use the NDISulator, three things are needed:

 1. Kernel sources

 2. WindowsÂ®Â XP driver binary (.SYS extension)

 3. WindowsÂ®Â XP driver configuration file (.INF extension)

Locate the files for the specific card. Generally, they can be found on the
included CDs or at the vendor's website. The following examples use
W32DRIVER.SYS and W32DRIVER.INF.

The driver bit width must match the version of FreeBSD. For FreeBSD/i386, use a
WindowsÂ® 32-bit driver. For FreeBSD/amd64, a WindowsÂ® 64-bit driver is
needed.

The next step is to compile the driver binary into a loadable kernel module. As
root, use ndisgen(8):

# ndisgen /path/to/W32DRIVER.INF /path/to/W32DRIVER.SYS

ndisgen(8) is interactive and prompts for any extra information it requires. A
new kernel module is written in the current directory. Use kldload(8) to load
the new module:

# kldload ./W32DRIVER_SYS.ko

In addition to the generated kernel module, the ndis.ko and if_ndis.ko modules
must be loaded. This should happen automatically when any module that depends
on ndis(4) is loaded. If not, load them manually, using the following commands:

# kldload ndis # kldload if_ndis

The first command loads the NDIS miniport driver wrapper, the second loads the
actual network interface.

Now, check dmesg(8) to see if there were any errors loading. If all went well,
the output should be similar to the following:

ndis0: &lt;Wireless-G PCI Adapter&gt; mem 0xf4100000-0xf4101fff irq 3 at device 8.0
on pci1 ndis0: NDIS API version: 5.0 ndis0: Ethernet address: 0a:b1:2c:d3:4e:f5
ndis0: 11b rates: 1Mbps 2Mbps 5.5Mbps 11Mbps ndis0: 11g rates: 6Mbps 9Mbps
12Mbps 18Mbps 36Mbps 48Mbps 54Mbps

From here you can treat the ndis0 device like any other network interface
(e.g., dc0).

To configure the system to load the NDIS modules at boot time, copy the
generated module, W32DRIVER_SYS.ko, to the /boot/modules directory. Then, add
the following line to /boot/loader.conf:

W32DRIVER_SYS_load="YES"

12.8.2.Â Configuring the Network Card

Once the right driver is loaded for the network card, the card needs to be
configured. As with many other things, the network card may have been
configured at installation time by sysinstall.

To display the configuration for the network interfaces, enter the following
command:

% ifconfig dc0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu
1500 options=80008&lt;VLAN_MTU,LINKSTATE&gt; ether 00:a0:cc:da:da:da inet 192.168.1.3
netmask 0xffffff00 broadcast 192.168.1.255 media: Ethernet autoselect
(100baseTX &lt;full-duplex&gt;) status: active dc1: flags=8802
&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500 options=80008
&lt;VLAN_MTU,LINKSTATE&gt; ether 00:a0:cc:da:da:db inet 10.0.0.1 netmask 0xffffff00
broadcast 10.0.0.255 media: Ethernet 10baseT/UTP status: no carrier lo0: flags=
8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384 options=3&lt;RXCSUM,TXCSUM&gt;
inet6 fe80::1%lo0 prefixlen 64 scopeid 0x4 inet6 ::1 prefixlen 128 inet
127.0.0.1 netmask 0xff000000 nd6 options=3&lt;PERFORMNUD,ACCEPT_RTADV&gt;

In this example, the following devices were displayed:

  * dc0: The first Ethernet interface

  * dc1: The second Ethernet interface

  * lo0: The loopback device

FreeBSD uses the driver name followed by the order in which one the card is
detected at the kernel boot to name the network card. For example sis2 would be
the third network card on the system using the sis(4) driver.

In this example, the dc0 device is up and running. The key indicators are:

 1. UP means that the card is configured and ready.

 2. The card has an Internet (inet) address (in this case 192.168.1.3).

 3. It has a valid subnet mask (netmask; 0xffffff00 is the same as
    255.255.255.0).

 4. It has a valid broadcast address (in this case, 192.168.1.255).

 5. The MAC address of the card (ether) is 00:a0:cc:da:da:da

 6. The physical media selection is on autoselection mode (media: Ethernet
    autoselect (100baseTX &lt;full-duplex&gt;)). In this example, dc1 was configured
    to run with 10baseT/UTP media. For more information on available media
    types for a driver, refer to its manual page.

 7. The status of the link (status) is active, indicating that the carrier
    signal is detected. For dc1, the status: no carrier status is normal when
    an Ethernet cable is not plugged into the card.

If the ifconfig(8) output had shown something similar to:

dc0: flags=8843&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500 options=80008
&lt;VLAN_MTU,LINKSTATE&gt; ether 00:a0:cc:da:da:da media: Ethernet autoselect
(100baseTX &lt;full-duplex&gt;) status: active

it would indicate the card has not been configured.

To configure the card, you will need root privileges. The network card
configuration can be performed from the command line with ifconfig(8) but will
not persist after a reboot unless the network card's configuration is also
added to /etc/rc.conf using an editor. Add a line for each network card present
on the system, as seen in this example:

ifconfig_dc0="inet 192.168.1.3 netmask 255.255.255.0" ifconfig_dc1="inet
10.0.0.1 netmask 255.255.255.0 media 10baseT/UTP"

Replace dc0 and dc1 and the IP address information with the correct values for
the system. Refer to the man page for the driver, ifconfig(8) and rc.conf(5)
for more details about the allowed options and the syntax of /etc/rc.conf.

If the network was configured during installation, some lines about the network
card(s) may be already present. Double check /etc/rc.conf before adding any
lines.

If the network is not using DNS, edit /etc/hosts to add the names and the IP
addresses of various machines of the LAN, if they are not already there. For
more information, refer to hosts(5) and to /usr/share/examples/etc/hosts.

Note:

If there is no DHCP server and access to the Internet is needed, manually
configure the default gateway and the nameserver:

# echo 'defaultrouter="your_default_router"' &gt;&gt; /etc/rc.conf # echo 'nameserver
your_DNS_server' &gt;&gt; /etc/resolv.conf

12.8.3.Â Testing and Troubleshooting

Once the necessary changes in /etc/rc.conf are saved, a reboot can be used to
test the network configuration and to verify that the system restarts without
any configuration errors. Alternatively, apply the settings to the networking
system with this command:

# service netif restart

Note:

If a default gateway has been set in /etc/rc.conf, use also this command:

# service routing restart

Once the networking system has been relaunched, test the network interfaces.

12.8.3.1.Â Testing the Ethernet Card

To verify that an Ethernet card is configured correctly, ping the interface
itself, and then ping another machine on the LAN:

% ping -c5 192.168.1.3 PING 192.168.1.3 (192.168.1.3): 56 data bytes 64 bytes
from 192.168.1.3: icmp_seq=0 ttl=64 time=0.082 ms 64 bytes from 192.168.1.3:
icmp_seq=1 ttl=64 time=0.074 ms 64 bytes from 192.168.1.3: icmp_seq=2 ttl=64
time=0.076 ms 64 bytes from 192.168.1.3: icmp_seq=3 ttl=64 time=0.108 ms 64
bytes from 192.168.1.3: icmp_seq=4 ttl=64 time=0.076 ms --- 192.168.1.3 ping
statistics --- 5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.074/0.083/0.108/0.013 ms
% ping -c5 192.168.1.2 PING 192.168.1.2 (192.168.1.2): 56 data bytes 64 bytes
from 192.168.1.2: icmp_seq=0 ttl=64 time=0.726 ms 64 bytes from 192.168.1.2:
icmp_seq=1 ttl=64 time=0.766 ms 64 bytes from 192.168.1.2: icmp_seq=2 ttl=64
time=0.700 ms 64 bytes from 192.168.1.2: icmp_seq=3 ttl=64 time=0.747 ms 64
bytes from 192.168.1.2: icmp_seq=4 ttl=64 time=0.704 ms --- 192.168.1.2 ping
statistics --- 5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 0.700/0.729/0.766/0.025 ms

To test network resolution, use the machine name instead of 192.168.1.2. If
there is no DNS server on the network, /etc/hosts must first be configured.

12.8.3.2.Â Troubleshooting

Troubleshooting hardware and software configurations is always a pain, and a
pain which can be alleviated by checking the simple things first. Is the
network cable plugged in? Are the network services properly configured? Is the
firewall configured correctly? Is the network card supported by FreeBSD? Always
before sending a bug report, check the hardware notes, update the version of
FreeBSD to the latest STABLE version, check the mailing list archives, and
search the Internet.

If the card works, yet performance is poor, it would be worthwhile to read over
the tuning(7) manual page. Also, check the network configuration as incorrect
network settings can cause slow connections.

Some users experience one or two device timeout messages, which is normal for
some cards. If they continue, or are bothersome, determine if the device is
conflicting with another device. Double check the cable connections. Consider
trying another card.

At times, users see a few watchdog timeout errors. The first thing to do is to
check the network cable. Many cards require a PCI slot which supports Bus
Mastering. On some old motherboards, only one PCI slot allows it (usually slot
0). Check the network card and the motherboard documentation to determine if
that may be the problem.

No route to host messages occur if the system is unable to route a packet to
the destination host. This can happen if no default route is specified, or if a
cable is unplugged. Check the output of netstat -rn and make sure there is a
valid route to the host. If there is not, read on to ChapterÂ 32, Advanced
Networking.

ping: sendto: Permission denied error messages are often caused by a
misconfigured firewall. If ipfw is enabled in the kernel but no rules have been
defined, then the default policy is to deny all traffic, even ping requests!
Read on to ChapterÂ 31, Firewalls for more information.

Sometimes performance of the card is poor, or below average. In these cases it
is best to set the media selection mode from autoselect to the correct media
selection. While this usually works for most hardware, it may not resolve this
issue for everyone. Again, check all the network settings, and read over the
tuning(7) manual page.

12.9.Â Virtual Hosts

A very common use of FreeBSD is virtual site hosting, where one server appears
to the network as many servers. This is achieved by assigning multiple network
addresses to a single interface.

A given network interface has one â  realâ   address, and may have any number
of â  aliasâ   addresses. These aliases are normally added by placing alias
entries in /etc/rc.conf.

An alias entry for the interface fxp0 looks like:

ifconfig_fxp0_alias0="inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx"

Note that alias entries must start with alias0 and proceed upwards in order,
(for example, _alias1, _alias2, and so on). The configuration process will stop
at the first missing number.

The calculation of alias netmasks is important, but fortunately quite simple.
For a given interface, there must be one address which correctly represents the
network's netmask. Any other addresses which fall within this network must have
a netmask of all 1s (expressed as either 255.255.255.255 or 0xffffffff).

For example, consider the case where the fxp0 interface is connected to two
networks: the 10.1.1.0 network with a netmask of 255.255.255.0 and the
202.0.75.16 network with a netmask of 255.255.255.240. The system is to be
configured to appear in the range 10.1.1.1 through 10.1.1.5 and 202.0.75.17
through 202.0.75.20. Only the first address in a given network range should
have a real netmask. All the rest (10.1.1.2 through 10.1.1.5 and 202.0.75.18
through 202.0.75.20) must be configured with a netmask of 255.255.255.255.

The following /etc/rc.conf entries configure the adapter correctly for this
arrangement:

ifconfig_fxp0="inet 10.1.1.1 netmask 255.255.255.0" ifconfig_fxp0_alias0="inet
10.1.1.2 netmask 255.255.255.255" ifconfig_fxp0_alias1="inet 10.1.1.3 netmask
255.255.255.255" ifconfig_fxp0_alias2="inet 10.1.1.4 netmask 255.255.255.255"
ifconfig_fxp0_alias3="inet 10.1.1.5 netmask 255.255.255.255"
ifconfig_fxp0_alias4="inet 202.0.75.17 netmask 255.255.255.240"
ifconfig_fxp0_alias5="inet 202.0.75.18 netmask 255.255.255.255"
ifconfig_fxp0_alias6="inet 202.0.75.19 netmask 255.255.255.255"
ifconfig_fxp0_alias7="inet 202.0.75.20 netmask 255.255.255.255"

12.10.Â Configuring the System Logger, syslogd

Contributed by Niclas Zeising.

System logging is an important aspect of system administration. It is used both
to detect hardware and software issues and errors in the system. It also plays
a very important role in security auditing and incident response. System
daemons without a controlling terminal also usually log information to a system
logging facility or other log file.

This section describes how to configure and use the FreeBSD system logger,
syslogd(8), and how to perform log rotation and log management using newsyslog
(8). Focus will be on setting up and using syslogd on a local machine. For more
advanced setups using a separate loghost, see SectionÂ 30.11, â  Remote Host
Logging with syslogdâ  .

12.10.1.Â Using syslogd

In the default FreeBSD configuration syslogd(8) is started at boot. This is
controlled by the variable syslogd_enable in /etc/rc.conf. There are numerous
application arguments that affect the behavior of syslogd(8). To change them,
use syslogd_flags in /etc/rc.conf. Refer to syslogd(8) for more information on
the arguments, and rc.conf(5), SectionÂ 12.3, â  Core Configurationâ   and
SectionÂ 12.7, â  Using rc(8) Under FreeBSDâ   for more information about /etc/
rc.conf and the rc(8) subsystem.

12.10.2.Â Configuring syslogd

The configuration file, by default /etc/syslog.conf, controls what syslogd(8)
does with the log entries once they are received. There are several parameters
to control the handling of incoming events, of which the most basic are
facility and level. The facility describes which subsystem generated the
message, such as the kernel or a daemon, and the level describes the severity
of the event that occurred. This makes it possible to log the message to
different log files, or discard it, depending on the facility and level. It is
also possible to take action depending on the application that sent the
message, and in the case of remote logging, also the hostname of the machine
generating the logging event.

Configuring syslogd(8) is quite straight forward. The configuration file
contains one line per action, and the syntax for each line is a selector field
followed by an action field. The syntax of the selector field is facility.level
which will match log messages from facility at level level or higher. It is
also possible to add an optional comparison flag before the level to specify
more precisely what is logged. Multiple selector fields can be used for the
same action, and are separated with a semicolon (;). Using * will match
everything. The action field denotes where to send the log message, such as a
file or a remote log host. As an example, here is the default syslog.conf from
FreeBSD:

# $FreeBSD$ # # Spaces ARE valid field separators in this file. However, #
other *nix-like systems still insist on using tabs as field # separators. If
you are sharing this file between systems, you # may want to use only tabs as
field separators here. # Consult the syslog.conf(5) manpage. *.err;
kern.warning;auth.notice;mail.crit /dev/console 1 *.notice;authpriv.none;
kern.debug;lpr.info;mail.crit;news.err /var/log/messages security.* /var/log/
security auth.info;authpriv.info /var/log/auth.log mail.info /var/log/maillog 2
lpr.info /var/log/lpd-errs ftp.info /var/log/xferlog cron.* /var/log/cron *.=
debug /var/log/debug.log 3 *.emerg * # uncomment this to log all writes to /dev
/console to /var/log/console.log #console.info /var/log/console.log # uncomment
this to enable logging of all log messages to /var/log/all.log # touch /var/log
/all.log and chmod it to mode 600 before it will work #*.* /var/log/all.log #
uncomment this to enable logging to a remote loghost named loghost #*.*
@loghost # uncomment these if you're running inn # news.crit /var/log/news/
news.crit # news.err /var/log/news/news.err # news.notice /var/log/news/
news.notice !ppp 4 *.* /var/log/ppp.log !*

1    Match all messages with a level of err or higher, as well as kern.warning,
     auth.notice and mail.crit, and send these log messages to the console (/
     dev/console).

2    Match all messages from the mail facility at level info or above, and log
     the messages to /var/log/maillog.

3    This line uses a comparison flag, = to only match messages at level debug,
     and log them in /var/log/debug.log.

4    Here is an example usage of a program specification. This will make the
     rules following only be valid for the program in the program
     specification. In this case this line and the following makes all messages
     from ppp, but no other programs, end up in /var/log/ppp.log.

This example shows that there are plenty of levels and subsystems. The levels
are, in order from most to least critical: emerg, alert, crit, err, warning,
notice, info and debug.

The facilities are, in no particular order: auth, authpriv, console, cron,
daemon, ftp, kern, lpr, mail, mark, news, security, syslog, user, uucp and
local0 through local7. Be aware that other operating systems might have
different facilities.

With this knowledge it is easy to add a new line to /etc/syslog.conf to log
everything from the different daemons on level notice and higher to /var/log/
daemon.log. Just add the following:

daemon.notice /var/log/daemon.log

For more information about the different levels and facilities, refer to syslog
(3) and syslogd(8). For more information about syslog.conf, its syntax, and
more advanced usage examples, see syslog.conf(5) and SectionÂ 30.11, â  Remote
Host Logging with syslogdâ  .

12.10.3.Â Log Management and Rotation with newsyslog

Log files tend to grow quickly and accumulate steadily. This leads to the files
being full of less immediately useful information while filling up the hard
drive. Log management attempts to mitigate this. In FreeBSD, newsyslog(8) is
used to manage log files. This program periodically rotates and compresses log
files, and optionally creates missing log files and signals programs when log
files are moved. The log files are not necessarily generated by syslog as
newsyslog(8) works with any logs written from any program. Note that newsyslog
is normally run from cron(8) and is not a system daemon. In the default
configuration, it is run every hour.

12.10.3.1.Â Configuring newsyslog

To know what actions to take, newsyslog(8) reads its configuration file, by
default /etc/newsyslog.conf. This configuration file contains one line for each
file that newsyslog(8) manages. Each line states the file owner, permissions,
when to rotate that file, optional flags that affect log rotation, such as
compression, and programs to signal when the log is rotated. Here is the
default configuration in FreeBSD:

# configuration file for newsyslog # $FreeBSD$ # # Entries which do not specify
the '/pid_file' field will cause the # syslogd process to be signalled when
that log file is rotated. This # action is only appropriate for log files which
are written to by the # syslogd process (ie, files listed in /etc/syslog.conf).
If there # is no process which needs to be signalled when a given log file is #
rotated, then the entry for that file should include the 'N' flag. # # The
'flags' field is one or more of the letters: BCDGJNUXZ or a '-'. # # Note: some
sites will want to select more restrictive protections than the # defaults. In
particular, it may be desirable to switch many of the 644 # entries to 640 or
600. For example, some sites will consider the # contents of maillog, messages,
and lpd-errs to be confidential. In the # future, these defaults may change to
more conservative ones. # # logfilename [owner:group] mode count size when
flags [/pid_file] [sig_num] /var/log/all.log 600 7 * @T00 J /var/log/amd.log
644 7 100 * J /var/log/auth.log 600 7 100 @0101T JC /var/log/console.log 600 5
100 * J /var/log/cron 600 3 100 * JC /var/log/daily.log 640 7 * @T00 JN /var/
log/debug.log 600 7 100 * JC /var/log/init.log 644 3 100 * J /var/log/
kerberos.log 600 7 100 * J /var/log/lpd-errs 644 7 100 * JC /var/log/maillog
640 7 * @T00 JC /var/log/messages 644 5 100 @0101T JC /var/log/monthly.log 640
12 * $M1D0 JN /var/log/pflog 600 3 100 * JB /var/run/pflogd.pid /var/log/
ppp.log root:network 640 3 100 * JC /var/log/security 600 10 100 * JC /var/log/
sendmail.st 640 10 * 168 B /var/log/utx.log 644 3 * @01T05 B /var/log/
weekly.log 640 5 1 $W6D0 JN /var/log/xferlog 600 7 100 * JC

Each line starts with the name of the file to be rotated, optionally followed
by an owner and group for both rotated and newly created files. The next field,
mode is the mode of the files and count denotes how many rotated log files
should be kept. The size and when fields tell newsyslog when to rotate the
file. A log file is rotated when either its size is larger than the size field,
or when the time in the when filed has passed. * means that this field is
ignored. The flags field gives newsyslog(8) further instructions, such as how
to compress the rotated file, or to create the log file if it is missing. The
last two fields are optional, and specify the PID-file of a process and a
signal number to send to that process with when the file is rotated. For more
information on all fields, valid flags and how to specify the rotation time,
refer to newsyslog.conf(5). Remember that newsyslog is run from cron and can
not rotate files more often than it is run from cron(8).

12.11.Â Configuration Files

12.11.1.Â /etc Layout

There are a number of directories in which configuration information is kept.
These include:

/etc         Generic system configuration information; data here is
             system-specific.
/etc/        Default versions of system configuration files.
defaults
/etc/mail    Extra sendmail(8) configuration, other MTA configuration files.
/etc/ppp     Configuration for both user- and kernel-ppp programs.
/etc/namedb  Default location for named(8) data. Normally named.conf and zone
             files are stored here.
/usr/local/  Configuration files for installed applications. May contain
etc          per-application subdirectories.
/usr/local/  Start/stop scripts for installed applications.
etc/rc.d
/var/db      Automatically generated system-specific database files, such as
             the package database, the locate database, and so on

12.11.2.Â Hostnames

12.11.2.1.Â /etc/resolv.conf

/etc/resolv.conf dictates how FreeBSD's resolver accesses the Internet Domain
Name System (DNS).

The most common entries to resolv.conf are:

nameserver The IP address of a name server the resolver should query. The
           servers are queried in the order listed with a maximum of three.
search     Search list for hostname lookup. This is normally determined by the
           domain of the local hostname.
domain     The local domain name.

A typical resolv.conf:

search example.com nameserver 147.11.1.11 nameserver 147.11.100.30

Note:

Only one of the search and domain options should be used.

When using DHCP, dhclient(8) usually rewrites resolv.conf with information
received from the DHCP server.

12.11.2.2.Â /etc/hosts

/etc/hosts is a simple text database reminiscent of the old Internet. It works
in conjunction with DNS and NIS providing name to IP address mappings. Local
computers connected via a LAN can be placed in here for simplistic naming
purposes instead of setting up a named(8) server. Additionally, /etc/hosts can
be used to provide a local record of Internet names, reducing the need to query
externally for commonly accessed names.

# $FreeBSD$ # # # Host Database # # This file should contain the addresses and
aliases for local hosts that # share this file. Replace 'my.domain' below with
the domainname of your # machine. # # In the presence of the domain name
service or NIS, this file may # not be consulted at all; see /etc/nsswitch.conf
for the resolution order. # # ::1 localhost localhost.my.domain 127.0.0.1
localhost localhost.my.domain # # Imaginary network. #10.0.0.2 myname.my.domain
myname #10.0.0.3 myfriend.my.domain myfriend # # According to RFC 1918, you can
use the following IP networks for # private nets which will never be connected
to the Internet: # # 10.0.0.0 - 10.255.255.255 # 172.16.0.0 - 172.31.255.255 #
192.168.0.0 - 192.168.255.255 # # In case you want to be able to connect to the
Internet, you need # real official assigned numbers. Do not try to invent your
own network # numbers but instead get one from your network provider (if any)
or # from your regional registry (ARIN, APNIC, LACNIC, RIPE NCC, or AfriNIC.) #

/etc/hosts takes on the simple format of:

[Internet address] [official hostname] [alias1] [alias2] ...

For example:

10.0.0.1 myRealHostname.example.com myRealHostname foobar1 foobar2

Consult hosts(5) for more information.

12.11.3.Â sysctl.conf

sysctl.conf looks much like rc.conf. Values are set in a variable=value form.
The specified values are set after the system goes into multi-user mode. Not
all variables are settable in this mode.

To turn off logging of fatal signal exits and prevent users from seeing
processes started from other users, the following tunables can be set in
sysctl.conf:

# Do not log fatal signal exits (e.g., sig 11) kern.logsigexit=0 # Prevent
users from seeing information about processes that # are being run under
another UID. security.bsd.see_other_uids=0

12.12.Â Tuning with sysctl(8)

sysctl(8) is used to make changes to a running FreeBSD system. This includes
many advanced options of the TCP/IP stack and virtual memory system that can
dramatically improve performance for an experienced system administrator. Over
five hundred system variables can be read and set using sysctl(8).

At its core, sysctl(8) serves two functions: to read and to modify system
settings.

To view all readable variables:

% sysctl -a

To read a particular variable, for example, kern.maxproc:

% sysctl kern.maxproc kern.maxproc: 1044

To set a particular variable, use the intuitive variable=value syntax:

# sysctl kern.maxfiles=5000 kern.maxfiles: 2088 -&gt; 5000

Settings of sysctl variables are usually either strings, numbers, or booleans
(a boolean being 1 for yes or a 0 for no).

To automatically set some variables each time the machine boots, add them to /
etc/sysctl.conf. For more information refer to sysctl.conf(5) and
SectionÂ 12.11.3, â  sysctl.confâ  .

12.12.1.Â sysctl(8) Read-only

Contributed by Tom Rhodes.

In some cases it may be desirable to modify read-only sysctl(8) values. While
this is sometimes unavoidable, it can only be done on (re)boot.

For instance on some laptop models the cardbus(4) device will not probe memory
ranges, and fail with errors which look similar to:

cbb0: Could not map register memory device_probe_and_attach: cbb0 attach
returned 12

Cases like the one above usually require the modification of some default
sysctl(8) settings which are set read only. To overcome these situations a user
can put sysctl(8) â  OIDsâ   in their local /boot/loader.conf. Default settings
are located in /boot/defaults/loader.conf.

Fixing the problem mentioned above would require a user to set
hw.pci.allow_unsupported_io_range=1 in the aforementioned file. Now cardbus(4)
will work properly.

12.13.Â Tuning Disks

12.13.1.Â Sysctl Variables

12.13.1.1.Â vfs.vmiodirenable

The vfs.vmiodirenable sysctl variable may be set to either 0 (off) or 1 (on);
it is 1 by default. This variable controls how directories are cached by the
system. Most directories are small, using just a single fragment (typically
1Â K) in the file system and less (typically 512Â bytes) in the buffer cache.
With this variable turned off (to 0), the buffer cache will only cache a fixed
number of directories even if the system has a huge amount of memory. When
turned on (to 1), this sysctl allows the buffer cache to use the VM Page Cache
to cache the directories, making all the memory available for caching
directories. However, the minimum in-core memory used to cache a directory is
the physical page size (typically 4Â K) rather than 512Â  bytes. Keeping this
option enabled is recommended if the system is running any services which
manipulate large numbers of files. Such services can include web caches, large
mail systems, and news systems. Keeping this option on will generally not
reduce performance even with the wasted memory but you should experiment to
find out.

12.13.1.2.Â vfs.write_behind

The vfs.write_behind sysctl variable defaults to 1 (on). This tells the file
system to issue media writes as full clusters are collected, which typically
occurs when writing large sequential files. The idea is to avoid saturating the
buffer cache with dirty buffers when it would not benefit I/O performance.
However, this may stall processes and under certain circumstances should be
turned off.

12.13.1.3.Â vfs.hirunningspace

The vfs.hirunningspace sysctl variable determines how much outstanding write I/
O may be queued to disk controllers system-wide at any given instance. The
default is usually sufficient but on machines with lots of disks, try bumping
it up to four or five megabytes. Note that setting too high a value (exceeding
the buffer cache's write threshold) can lead to extremely bad clustering
performance. Do not set this value arbitrarily high! Higher write values may
add latency to reads occurring at the same time.

There are various other buffer-cache and VM page cache related sysctls.
Modifying these values is not recommended as the VM system does an extremely
good job of automatically tuning itself.

12.13.1.4.Â vm.swap_idle_enabled

The vm.swap_idle_enabled sysctl variable is useful in large multi-user systems
with lots of users entering and leaving the system and lots of idle processes.
Such systems tend to generate a great deal of continuous pressure on free
memory reserves. Turning this feature on and tweaking the swapout hysteresis
(in idle seconds) via vm.swap_idle_threshold1 and vm.swap_idle_threshold2
depresses the priority of memory pages associated with idle processes more
quickly then the normal pageout algorithm. This gives a helping hand to the
pageout daemon. Only turn this option on if needed, because the tradeoff is
essentially pre-page memory sooner rather than later which eats more swap and
disk bandwidth. In a small system this option will have a determinable effect,
but in a large system that is already doing moderate paging this option allows
the VM system to stage whole processes into and out of memory easily.

12.13.1.5.Â hw.ata.wc

FreeBSDÂ 4.3 flirted with turning off IDE write caching. This reduced write
bandwidth to IDE disks but was considered necessary due to serious data
consistency issues introduced by hard drive vendors. The problem is that IDE
drives lie about when a write completes. With IDE write caching turned on, IDE
hard drives not only write data to disk out of order, but will sometimes delay
writing some blocks indefinitely when under heavy disk loads. A crash or power
failure may cause serious file system corruption. FreeBSD's default was changed
to be safe. Unfortunately, the result was such a huge performance loss that we
changed write caching back to on by default after the release. Check the
default on the system by observing the hw.ata.wc sysctl variable. If IDE write
caching is turned off, setting this variable back to 1 will turn it back on.
This must be done from the boot loader at boot time as attempting to do it
after the kernel boots will have no effect.

For more information, refer to ata(4).

12.13.1.6.Â SCSI_DELAY (kern.cam.scsi_delay)

The SCSI_DELAY kernel config may be used to reduce system boot times. The
defaults are fairly high and can be responsible for 15 seconds of delay in the
boot process. Reducing it to 5 seconds usually works (especially with modern
drives). The kern.cam.scsi_delay boot time tunable should be used. The tunable,
and kernel config option accept values in terms of milliseconds and not seconds
.

12.13.2.Â Soft Updates

The tunefs(8) program can be used to fine-tune a file system. This program has
many different options, but for now we are only concerned with toggling Soft
Updates on and off, which is done by:

# tunefs -n enable /filesystem # tunefs -n disable /filesystem

A filesystem cannot be modified with tunefs(8) while it is mounted. A good time
to enable Soft Updates is before any partitions have been mounted, in
single-user mode.

Soft Updates drastically improves meta-data performance, mainly file creation
and deletion, through the use of a memory cache. We recommend to use Soft
Updates on all of your file systems. There are two downsides to Soft Updates
that you should be aware of: First, Soft Updates guarantees filesystem
consistency in the case of a crash but could very easily be several seconds
(even a minute!) behind updating the physical disk. If your system crashes you
may lose more work than otherwise. Secondly, Soft Updates delays the freeing of
filesystem blocks. If you have a filesystem (such as the root filesystem) which
is almost full, performing a major update, such as make installworld, can cause
the filesystem to run out of space and the update to fail.

12.13.2.1.Â More Details About Soft Updates

There are two traditional approaches to writing a file systems meta-data back
to disk. (Meta-data updates are updates to non-content data like inodes or
directories.)

Historically, the default behavior was to write out meta-data updates
synchronously. If a directory had been changed, the system waited until the
change was actually written to disk. The file data buffers (file contents) were
passed through the buffer cache and backed up to disk later on asynchronously.
The advantage of this implementation is that it operates safely. If there is a
failure during an update, the meta-data are always in a consistent state. A
file is either created completely or not at all. If the data blocks of a file
did not find their way out of the buffer cache onto the disk by the time of the
crash, fsck(8) is able to recognize this and repair the filesystem by setting
the file length to 0. Additionally, the implementation is clear and simple. The
disadvantage is that meta-data changes are slow. An rm -r, for instance,
touches all the files in a directory sequentially, but each directory change
(deletion of a file) will be written synchronously to the disk. This includes
updates to the directory itself, to the inode table, and possibly to indirect
blocks allocated by the file. Similar considerations apply for unrolling large
hierarchies (tar -x).

The second case is asynchronous meta-data updates. This is the default for
Linux/ext2fs and mount -o async for *BSD ufs. All meta-data updates are simply
being passed through the buffer cache too, that is, they will be intermixed
with the updates of the file content data. The advantage of this implementation
is there is no need to wait until each meta-data update has been written to
disk, so all operations which cause huge amounts of meta-data updates work much
faster than in the synchronous case. Also, the implementation is still clear
and simple, so there is a low risk for bugs creeping into the code. The
disadvantage is that there is no guarantee at all for a consistent state of the
filesystem. If there is a failure during an operation that updated large
amounts of meta-data (like a power failure, or someone pressing the reset
button), the filesystem will be left in an unpredictable state. There is no
opportunity to examine the state of the filesystem when the system comes up
again; the data blocks of a file could already have been written to the disk
while the updates of the inode table or the associated directory were not. It
is actually impossible to implement a fsck which is able to clean up the
resulting chaos (because the necessary information is not available on the
disk). If the filesystem has been damaged beyond repair, the only choice is to
use newfs(8) on it and restore it from backup.

The usual solution for this problem was to implement dirty region logging,
which is also referred to as journaling, although that term is not used
consistently and is occasionally applied to other forms of transaction logging
as well. Meta-data updates are still written synchronously, but only into a
small region of the disk. Later on they will be moved to their proper location.
Because the logging area is a small, contiguous region on the disk, there are
no long distances for the disk heads to move, even during heavy operations, so
these operations are quicker than synchronous updates. Additionally the
complexity of the implementation is fairly limited, so the risk of bugs being
present is low. A disadvantage is that all meta-data are written twice (once
into the logging region and once to the proper location) so for normal work, a
performance â  pessimizationâ   might result. On the other hand, in case of a
crash, all pending meta-data operations can be quickly either rolled-back or
completed from the logging area after the system comes up again, resulting in a
fast filesystem startup.

Kirk McKusick, the developer of Berkeley FFS, solved this problem with Soft
Updates: all pending meta-data updates are kept in memory and written out to
disk in a sorted sequence (â  ordered meta-data updatesâ  ). This has the
effect that, in case of heavy meta-data operations, later updates to an item â 
 catchâ   the earlier ones if the earlier ones are still in memory and have not
already been written to disk. So all operations on, say, a directory are
generally performed in memory before the update is written to disk (the data
blocks are sorted according to their position so that they will not be on the
disk ahead of their meta-data). If the system crashes, this causes an implicit 
â  log rewindâ  : all operations which did not find their way to the disk
appear as if they had never happened. A consistent filesystem state is
maintained that appears to be the one of 30 to 60 seconds earlier. The
algorithm used guarantees that all resources in use are marked as such in their
appropriate bitmaps: blocks and inodes. After a crash, the only resource
allocation error that occurs is that resources are marked as â  usedâ   which
are actually â  freeâ  . fsck(8) recognizes this situation, and frees the
resources that are no longer used. It is safe to ignore the dirty state of the
filesystem after a crash by forcibly mounting it with mount -f. In order to
free resources that may be unused, fsck(8) needs to be run at a later time.
This is the idea behind the background fsck: at system startup time, only a 
snapshot of the filesystem is recorded. The fsck can be run later on. All file
systems can then be mounted â  dirtyâ  , so the system startup proceeds in
multiuser mode. Then, background fscks will be scheduled for all file systems
where this is required, to free resources that may be unused. (File systems
that do not use Soft Updates still need the usual foreground fsck though.)

The advantage is that meta-data operations are nearly as fast as asynchronous
updates which are, faster than logging, which has to write the meta-data twice.
The disadvantages are the complexity of the code (implying a higher risk for
bugs in an area that is highly sensitive regarding loss of user data), and a
higher memory consumption. Additionally there are some idiosyncrasies one has
to get used to. After a crash, the state of the filesystem appears to be
somewhat â  olderâ  . In situations where the standard synchronous approach
would have caused some zero-length files to remain after the fsck, these files
do not exist at all with a Soft Updates filesystem because neither the
meta-data nor the file contents have ever been written to disk. Disk space is
not released until the updates have been written to disk, which may take place
some time after running rm. This may cause problems when installing large
amounts of data on a filesystem that does not have enough free space to hold
all the files twice.

12.14.Â Tuning Kernel Limits

12.14.1.Â File/Process Limits

12.14.1.1.Â kern.maxfiles

kern.maxfiles can be raised or lowered based upon system requirements. This
variable indicates the maximum number of file descriptors on the system. When
the file descriptor table is full, file: table is full will show up repeatedly
in the system message buffer, which can be viewed using dmesg.

Each open file, socket, or fifo uses one file descriptor. A large-scale
production server may easily require many thousands of file descriptors,
depending on the kind and number of services running concurrently.

In older FreeBSD releases, the default value of kern.maxfiles is derived from
maxusers in the kernel configuration file. kern.maxfiles grows proportionally
to the value of maxusers. When compiling a custom kernel, consider setting this
kernel configuration option according to the use of the system. From this
number, the kernel is given most of its pre-defined limits. Even though a
production machine may not have 256 concurrent users, the resources needed may
be similar to a high-scale web server.

The variable kern.maxusers is automatically sized at boot based on the amount
of memory available in the system, and may be determined at run-time by
inspecting the value of the read-only kern.maxusers sysctl. Some sites will
require larger or smaller values of kern.maxusers and may set it as a loader
tunable; values of 64, 128, and 256 are not uncommon. Going above 256 is not
recommended unless a huge number of file descriptors are needed. Many of the
tunable values set to their defaults by kern.maxusers may be individually
overridden at boot-time or run-time in /boot/loader.conf. Refer to loader.conf
(5) and /boot/defaults/loader.conf for more details and some hints.

In older releases, the system will auto-tune maxusers if it is set to 0 ^[3].
When setting this option, set maxusers to at least 4, especially if the system
runs Xorg or is used to compile software. The most important table set by
maxusers is the maximum number of processes, which is set to 20 + 16 *
maxusers. If maxusers is set to 1, there can only be 36 simultaneous processes,
including the 18 or so that the system starts up at boot time and the 15 or so
used by Xorg. Even a simple task like reading a manual page will start up nine
processes to filter, decompress, and view it. Setting maxusers to 64 allows up
to 1044 simultaneous processes, which should be enough for nearly all uses. If,
however, you see the dreaded proc table full error when trying to start another
program, or are running a server with a large number of simultaneous users
(like ftp.FreeBSD.org), increase the number and rebuild.

Note:

maxusers does not limit the number of users which can log into your machine. It
simply sets various table sizes to reasonable values considering the maximum
number of users on the system and how many processes each user will be running.

12.14.1.2.Â kern.ipc.somaxconn

The kern.ipc.somaxconn sysctl variable limits the size of the listen queue for
accepting new TCP connections. The default value of 128 is typically too low
for robust handling of new connections in a heavily loaded web server
environment. For such environments, it is recommended to increase this value to
1024 or higher. The service daemon may itself limit the listen queue size
(e.g., sendmail(8), or Apache) but will often have a directive in its
configuration file to adjust the queue size. Large listen queues also do a
better job of avoiding Denial of Service (DoS) attacks.

12.14.2.Â Network Limits

The NMBCLUSTERS kernel configuration option dictates the amount of network
Mbufs available to the system. A heavily-trafficked server with a low number of
Mbufs will hinder FreeBSD's ability. Each cluster represents approximately 2Â K
of memory, so a value of 1024 represents 2 megabytes of kernel memory reserved
for network buffers. A simple calculation can be done to figure out how many
are needed. A web server which maxes out at 1000 simultaneous connections where
each connection uses a 6Â K receive and 16Â K send buffer, requires
approximately 32Â MB worth of network buffers to cover the web server. A good
rule of thumb is to multiply by 2, so 2x32Â MBÂ /Â 2Â KBÂ = 64Â MBÂ /Â 2Â kBÂ =
32768. Values between 4096 and 32768 are recommended for machines with greater
amounts of memory. Under no circumstances should you specify an arbitrarily
high value for this parameter as it could lead to a boot time crash. To observe
network cluster usage, use -m with netstat(1).

The kern.ipc.nmbclusters loader tunable should be used to tune this at boot
time. Only older versions of FreeBSD will require the use of the NMBCLUSTERS
kernel config(8) option.

For busy servers that make extensive use of the sendfile(2) system call, it may
be necessary to increase the number of sendfile(2) buffers via the NSFBUFS
kernel configuration option or by setting its value in /boot/loader.conf (see
loader(8) for details). A common indicator that this parameter needs to be
adjusted is when processes are seen in the sfbufa state. The sysctl variable
kern.ipc.nsfbufs is a read-only glimpse at the kernel configured variable. This
parameter nominally scales with kern.maxusers, however it may be necessary to
tune accordingly.

Important:

Even though a socket has been marked as non-blocking, calling sendfile(2) on
the non-blocking socket may result in the sendfile(2) call blocking until
enough struct sf_buf's are made available.

12.14.2.1.Â net.inet.ip.portrange.*

The net.inet.ip.portrange.* sysctl variables control the port number ranges
automatically bound to TCP and UDP sockets. There are three ranges: a low
range, a default range, and a high range. Most network programs use the default
range which is controlled by the net.inet.ip.portrange.first and
net.inet.ip.portrange.last, which default to 1024 and 5000, respectively. Bound
port ranges are used for outgoing connections, and it is possible to run the
system out of ports under certain circumstances. This most commonly occurs when
running a heavily loaded web proxy. The port range is not an issue when running
servers which handle mainly incoming connections, such as a normal web server,
or has a limited number of outgoing connections, such as a mail relay. For
situations where there is a shortage of ports, it is recommended to increase
net.inet.ip.portrange.last modestly. A value of 10000, 20000 or 30000 may be
reasonable. Consider firewall effects when changing the port range. Some
firewalls may block large ranges of ports (usually low-numbered ports) and
expect systems to use higher ranges of ports for outgoing connections â   for
this reason it is not recommended that net.inet.ip.portrange.first be lowered.

12.14.2.2.Â TCP Bandwidth Delay Product

The TCP Bandwidth Delay Product Limiting is similar to TCP/Vegas in NetBSD. It
can be enabled by setting net.inet.tcp.inflight.enable sysctl variable to 1.
The system will attempt to calculate the bandwidth delay product for each
connection and limit the amount of data queued to the network to just the
amount required to maintain optimum throughput.

This feature is useful when serving data over modems, Gigabit Ethernet, or even
high speed WAN links (or any other link with a high bandwidth delay product),
especially when also using window scaling or when a large send window has been
configured. When enabling this option, also be sure to set
net.inet.tcp.inflight.debug to 0 (disable debugging), and for production use
setting net.inet.tcp.inflight.min to at least 6144 may be beneficial. However,
note that setting high minimums may effectively disable bandwidth limiting
depending on the link. The limiting feature reduces the amount of data built up
in intermediate route and switch packet queues and reduces the amount of data
built up in the local host's interface queue. With fewer queued packets,
interactive connections, especially over slow modems, will operate with lower 
Round Trip Times. This feature only effects server side data transmission such
as uploading. It has no effect on data reception or downloading.

Adjusting net.inet.tcp.inflight.stab is not recommended. This parameter
defaults to 20, representing 2 maximal packets added to the bandwidth delay
product window calculation. The additional window is required to stabilize the
algorithm and improve responsiveness to changing conditions, but it can also
result in higher ping times over slow links, though still much lower than
without the inflight algorithm. In such cases, try reducing this parameter to
15, 10, or 5; and reducing net.inet.tcp.inflight.min (for example, to 3500) to
get the desired effect. Reducing these parameters should be done as a last
resort only.

12.14.3.Â Virtual Memory

12.14.3.1.Â kern.maxvnodes

A vnode is the internal representation of a file or directory. So increasing
the number of vnodes available to the operating system cuts down on disk I/O.
Normally this is handled by the operating system and does not need to be
changed. In some cases where disk I/O is a bottleneck and the system is running
out of vnodes, this setting will need to be increased. The amount of inactive
and free RAM will need to be taken into account.

To see the current number of vnodes in use:

# sysctl vfs.numvnodes vfs.numvnodes: 91349

To see the maximum vnodes:

# sysctl kern.maxvnodes kern.maxvnodes: 100000

If the current vnode usage is near the maximum, increasing kern.maxvnodes by a
value of 1,000 is probably a good idea. Keep an eye on the number of
vfs.numvnodes. If it climbs up to the maximum again, kern.maxvnodes will need
to be increased further. A shift in your memory usage as reported by top(1)
should be visible. More memory should be active.

12.15.Â Adding Swap Space

Despite careful planning, sometimes a system does not run as expected. If more
swap space is needed, it is simple enough to add. There are three ways to
increase swap space: add a new hard drive, enable swap over NFS, or create a
swap file on an existing partition.

For information on how to encrypt swap space, what options for this task exist
and why it should be done, refer to SectionÂ 19.17, â  Encrypting Swap Spaceâ  
of the Handbook.

12.15.1.Â Swap on a New or Existing Hard Drive

Adding a new hard drive for swap gives better performance than adding a
partition on an existing drive. Setting up partitions and hard drives is
explained in SectionÂ 19.3, â  Adding Disksâ  . SectionÂ 12.2, â  Initial
Configurationâ   discusses partition layouts and swap partition size
considerations.

Use swapon(8) to add a swap partition to the system. For example:

# swapon /dev/ada1s1b

Warning:

It is possible to use any partition not currently mounted, even if it already
contains data. Using swapon(8) on a partition that contains data will overwrite
and destroy that data. Make sure that the partition to be added as swap is
really the intended partition before running swapon(8).

To automatically add this swap partition on boot, add an entry to /etc/fstab
for the partition:

/dev/ada1s1b none swap sw 0 0

See fstab(5) for an explanation of the entries in /etc/fstab.

12.15.2.Â Swapping over NFS

Swapping over NFS is only recommended if you do not have a local hard disk to
swap to; NFS swapping will be limited by the available network bandwidth and
puts an additional burden on the NFS server.

12.15.3.Â Swapfiles

You can create a file of a specified size to use as a swap file. The following
example will create a 64MB file named /usr/swap0.

ExampleÂ 12.1.Â Creating a Swapfile on FreeBSD

 1. The GENERIC kernel already includes the memory disk driver (md(4)) required
    for this operation. When building a custom kernel, make sure to include the
    following line in the custom configuration file:

    device md

    For information on building a custom kernel, refer to ChapterÂ 9, 
    Configuring the FreeBSD Kernel.

 2. Create a swapfile (/usr/swap0):

    # dd if=/dev/zero of=/usr/swap0 bs=1024k count=64
 3. Set proper permissions on (/usr/swap0):

    # chmod 0600 /usr/swap0
 4. Enable the swap file in /etc/rc.conf:

    swapfile="/usr/swap0" # Set to name of swapfile if aux swapfile desired.
 5. Reboot the machine or to enable the swap file immediately, type:

    # mdconfig -a -t vnode -f /usr/swap0 -u 0 && swapon /dev/md0


12.16.Â Power and Resource Management

Written by Hiten Pandya and Tom Rhodes.

It is important to utilize hardware resources in an efficient manner. Before
the Advanced Configuration and Power Interface (ACPI) was introduced, it was
difficult and inflexible for operating systems to manage the power usage and
thermal properties of a system. The hardware was managed by the BIOS and the
user had less control and visibility into the power management settings. Some
limited configurability was available via Advanced Power Management (APM).
Power and resource management is one of the key components of a modern
operating system. It allows the operating system to monitor system limits and
to possibly provide an alert if the system temperature increases unexpectedly.

This section provides comprehensive information about ACPI. References will be
provided for further reading.

12.16.1.Â What Is ACPI?

ACPI is a standard written by an alliance of vendors to provide a standard
interface for hardware resources and power management. It is a key element in 
Operating System-directed configuration and Power Management as it provides
more control and flexibility to the operating system. Modern systems â  
stretchedâ   the limits of the current Plug and Play interfaces prior to the
introduction of ACPI. ACPI is the direct successor to APM.

12.16.2.Â Shortcomings of Advanced Power Management (APM)

The APM facility controls the power usage of a system based on its activity.
The APM BIOS is supplied by the (system) vendor and is specific to the hardware
platform. An APM driver in the operating system mediates access to the APM
Software Interface, which allows management of power levels. APM should still
be used for systems manufactured at or before the year 2000.

There are four major problems in APM. Firstly, power management is done by the
(vendor-specific) BIOS, and the OS does not have any knowledge of it. One
example of this, is when the user sets idle-time values for a hard drive in the
APM BIOS, that when exceeded, it (BIOS) would spin down the hard drive, without
the consent of the OS. Secondly, the APM logic is embedded in the BIOS, and it
operates outside the scope of the OS. This means users can only fix problems in
their APM BIOS by flashing a new one into the ROM; which is a very dangerous
procedure with the potential to leave the system in an unrecoverable state if
it fails. Thirdly, APM is a vendor-specific technology, which means that there
is a lot of parity (duplication of efforts) and bugs found in one vendor's
BIOS, may not be solved in others. Last but not the least, the APM BIOS did not
have enough room to implement a sophisticated power policy, or one that can
adapt very well to the purpose of the machine.

Plug and Play BIOS (PNPBIOS) was unreliable in many situations. PNPBIOS is
16-bit technology, so the OS has to use 16-bit emulation in order to â  
interfaceâ   with PNPBIOS methods.

The FreeBSD APM driver is documented in the apm(4) manual page.

12.16.3.Â Configuring ACPI

The acpi.ko driver is loaded by default at start up by the loader(8) and should
not be compiled into the kernel. The reasoning behind this is that modules are
easier to work with, say if switching to another acpi.ko without doing a kernel
rebuild. This has the advantage of making testing easier. Another reason is
that starting ACPI after a system has been brought up often does not work well.
If you are experiencing problems, ACPI can be disabled altogether. This driver
should not and can not be unloaded because the system bus uses it for various
hardware interactions. ACPI can be disabled by setting hint.acpi.0.disabled="1"
in /boot/loader.conf or at the loader(8) prompt.

Note:

ACPI and APM cannot coexist and should be used separately. The last one to load
will terminate if the driver notices the other running.

ACPI can be used to put the system into a sleep mode with acpiconf(8), the -s
flag, and a 1-5 option. Most users will only need 1 or 3 (suspend to RAM).
Option 5 will do a soft-off which is the same action as:

# halt -p

Other options are available via sysctl(8). Check out the acpi(4) and acpiconf
(8) manual pages for more information.

12.17.Â Using and Debugging FreeBSD ACPI

Written by Nate Lawson.
With contributions from Peter Schultz and Tom Rhodes.

ACPI is a fundamentally new way of discovering devices, managing power usage,
and providing standardized access to various hardware previously managed by the
BIOS. Progress is being made toward ACPI working on all systems, but bugs in
some motherboards' ACPI Machine Language (AML) bytecode, incompleteness in
FreeBSD's kernel subsystems, and bugs in the IntelÂ® ACPI-CA interpreter
continue to appear.

This section is intended to help users assist the FreeBSD ACPI maintainers in
identifying the root cause of problems you observe and debugging and developing
a solution.

12.17.1.Â Submitting Debugging Information

Note:

Before submitting a problem, be sure you are running the latest BIOS version
and, if available, embedded controller firmware version.

When submitting a problem, send the following information to
freebsd-acpi@FreeBSD.org:

  * Description of the buggy behavior, including system type and model and
    anything that causes the bug to appear. Note as accurately as possible when
    the bug began occurring if it is new.

  * The dmesg(8) output after boot -v, including any error messages generated
    by the bug.

  * The dmesg(8) output from boot -v with ACPI disabled, if disabling it helps
    fix the problem.

  * Output from sysctl hw.acpi. This is also a good way of figuring out what
    features the system offers.

  * URL where the ACPI Source Language (ASL) can be found. Do not send the ASL
    directly to the list as it can be very large. Generate a copy of the ASL by
    running this command:

    # acpidump -dt &gt; name-system.asl

    (Substitute your login name for name and manufacturer/model for system.
    Example: njl-FooCo6000.asl)

Most FreeBSD developers watch FreeBSD-CURRENT mailing list, but one should
submit problems to freebsd-acpi to be sure it is seen. Be patient when waiting
for a response. If the bug is not immediately apparent, you may be asked to
submit a PR using send-pr(1). When entering a PR, include the same information
as requested above. This helps developers to track the problem and resolve it.
Do not send a PR without emailing freebsd-acpi first as it is likely that the
problem has been reported before.

12.17.2.Â Background

ACPI is present in all modern computers that conform to the ia32 (x86), ia64
(Itanium), and amd64 (AMD) architectures. The full standard has many features
including CPU performance management, power planes control, thermal zones,
various battery systems, embedded controllers, and bus enumeration. Most
systems implement less than the full standard. For instance, a desktop system
usually only implements the bus enumeration parts while a laptop might have
cooling and battery management support as well. Laptops also have suspend and
resume, with their own associated complexity.

An ACPI-compliant system has various components. The BIOS and chipset vendors
provide various fixed tables (e.g., FADT) in memory that specify things like
the APIC map (used for SMP), config registers, and simple configuration values.
Additionally, a table of bytecode (the Differentiated System Description Table 
DSDT) is provided that specifies a tree-like name space of devices and methods.

The ACPI driver must parse the fixed tables, implement an interpreter for the
bytecode, and modify device drivers and the kernel to accept information from
the ACPI subsystem. For FreeBSD, IntelÂ® has provided an interpreter (ACPI-CA)
that is shared with Linux and NetBSD. The path to the ACPI-CA source code is
src/sys/contrib/dev/acpica. The glue code that allows ACPI-CA to work on
FreeBSD is in src/sys/dev/acpica/Osd. Finally, drivers that implement various 
ACPI devices are found in src/sys/dev/acpica.

12.17.3.Â Common Problems

For ACPI to work correctly, all the parts have to work correctly. Here are some
common problems, in order of frequency of appearance, and some possible
workarounds or fixes.

12.17.3.1.Â Mouse Issues

In some cases, resuming from a suspend operation will cause the mouse to fail.
A known work around is to add hint.psm.0.flags="0x3000" to /boot/loader.conf.
If this does not work, consider sending a bug report using send-pr(1).

12.17.3.2.Â Suspend/Resume

ACPI has three suspend to RAM (STR) states, S1-S3, and one suspend to disk
state (STD), called S4. S5 is â  soft offâ   and is the normal state the system
is in when plugged in but not powered up. S4 can actually be implemented two
separate ways. S4BIOS is a BIOS-assisted suspend to disk. S4OS is implemented
entirely by the operating system.

Start by checking sysctl hw.acpi for the suspend-related items. Here are the
results for a Thinkpad:

hw.acpi.supported_sleep_state: S3 S4 S5 hw.acpi.s4bios: 0

Use acpiconf -s to test S3, S4OS, and S5. An s4bios of one (1), indicates S4
BIOS support instead of S4 OS.

When testing suspend/resume, start with S1, if supported. This state is most
likely to work since it does not require much driver support. No one has
implemented S2 which is similar to S1. The next thing to try is S3. This is the
deepest STR state and requires a lot of driver support to properly reinitialize
the hardware. If you have problems resuming, feel free to email freebsd-acpi,
but do not expect the problem to be resolved since there are a lot of drivers
and hardware that need more testing and work.

A common problem with suspend/resume is that many device drivers do not save,
restore, or reinitialize their firmware, registers, or device memory properly.
As a first attempt at debugging the problem, try:

# sysctl debug.bootverbose=1 # sysctl debug.acpi.suspend_bounce=1 # acpiconf -s
3

This test emulates suspend/resume cycle of all device drivers without actually
going into S3 state. In some cases, problems such as losing firmware state,
device watchdog time out, and retrying forever, can be captured with this
method. Note that the system will not really enter S3 state, which means
devices may not lose power, and many will work fine even if suspend/resume
methods are totally missing, unlike real S3 state.

Harder cases require additional hardware, such as a serial port/cable for
serial console or a Firewire port/cable for dcons(4), and kernel debugging
skills.

To help isolate the problem, remove as many drivers from the kernel as
possible. If it works, narrow down which driver is the problem by loading
drivers until it fails again. Typically binary drivers like nvidia.ko, display
drivers, and USB will have the most problems while Ethernet interfaces usually
work fine. If you can properly load/unload the drivers, automate this by
putting the appropriate commands in /etc/rc.suspend and /etc/rc.resume. There
is a commented-out example for unloading and loading a driver. Try setting
hw.acpi.reset_video to zero (0) if the display is messed up after resume. Try
setting longer or shorter values for hw.acpi.sleep_delay to see if that helps.

Another thing to try is load a recent Linux distribution with ACPI support and
test their suspend/resume support on the same hardware. If it works on Linux,
it is likely a FreeBSD driver problem and narrowing down which driver causes
the problems will help us fix the problem. Note that the ACPI maintainers do
not usually maintain other drivers, such as sound or ATA, so any work done on
tracking down a driver problem should probably eventually be posted to the
freebsd-current list and mailed to the driver maintainer. Advanced users can
start by putting some debugging printf(3)s in a problematic driver to track
down where in its resume function it hangs.

Finally, try disabling ACPI and enabling APM instead. If suspend/resume works
with APM, you may be better off sticking with APM, especially on older hardware
(pre-2000). It took vendors a while to get ACPI support correct and older
hardware is more likely to have BIOS problems with ACPI.

12.17.3.3.Â System Hangs (Temporary or Permanent)

Most system hangs are a result of lost interrupts or an interrupt storm.
Chipsets have a lot of problems based on how the BIOS configures interrupts
before boot, correctness of the APIC (MADT) table, and routing of the System
Control Interrupt (SCI).

Interrupt storms can be distinguished from lost interrupts by checking the
output of vmstat -i and looking at the line that has acpi0. If the counter is
increasing at more than a couple per second, there is an interrupt storm. If
the system appears hung, try breaking to DDB (CTRL+ALT+ESC on console) and type
show interrupts.

When dealing with interrupt problems try disabling APIC support with
hint.apic.0.disabled="1" in loader.conf.

12.17.3.4.Â Panics

Panics are relatively rare for ACPI and are the top priority to be fixed. The
first step is to isolate the steps to reproduce the panic (if possible) and get
a backtrace. Follow the advice for enabling options DDB and setting up a serial
console (see SectionÂ 27.6.5.3, â  Entering the DDB Debugger from the Serial
Lineâ  ) or setting up a dump(8) partition. To get a backtrace in DDB, use tr.
When handwriting the backtrace, get at least the lowest five (5) and top five
(5) lines in the trace.

Then, try to isolate the problem by booting with ACPI disabled. If that works,
isolate the ACPI subsystem by using various values of debug.acpi.disable. See
acpi(4) for some examples.

12.17.3.5.Â System Powers Up After Suspend or Shutdown

First, try setting hw.acpi.disable_on_poweroff="0" in loader.conf(5). This
keeps ACPI from disabling various events during the shutdown process. Some
systems need this value set to 1 (the default) for the same reason. This
usually fixes the problem of a system powering up spontaneously after a suspend
or poweroff.

12.17.3.6.Â Other Problems

For other problems with ACPI such as it not working with a docking station or
devices not being detected, email a description to the mailing list. Some
issues may be related to unfinished parts of the ACPI subsystem which might
take a while to be implemented. Be patient and prepared to test patches.

12.17.4.Â ASL, acpidump, and IASL

The most common problem is the BIOS vendors providing incorrect (or outright
buggy!) bytecode. This is usually manifested by kernel console messages like
this:

ACPI-1287: *** Error: Method execution failed [\\_SB_.PCI0.LPC0.FIGD._STA] \\
(Node 0xc3f6d160), AE_NOT_FOUND

Often, these problems may be resolved by updating the BIOS to the latest
revision. Most console messages are harmless but if when there are other
problems like the battery status is not working, these messages are a good
place to start looking for problems in the AML. The bytecode, known as AML, is
compiled from a source language called ASL. The AML is found in the table known
as the DSDT. To get a copy of the system's ASL, use acpidump(8). Include both
-t, to show the contents of the fixed tables, and -d, to disassemble the AML.
Refer to Submitting Debugging Information for an example syntax.

The simplest first check is to recompile the ASL to check for errors. Warnings
can usually be ignored, but errors are bugs that will usually prevent ACPI from
working correctly. To recompile the ASL, issue the following command:

# iasl your.asl

12.17.5.Â Fixing Your ASL

In the long run, the goal of FreeBSD is for almost everyone to have working 
ACPI without any user intervention. At this point, workarounds are still being
developed for common mistakes made by the BIOS vendors. The MicrosoftÂ®
interpreter (acpi.sys and acpiec.sys) does not strictly check for adherence to
the standard, and thus many BIOS vendors who only test ACPI under WindowsÂ®
never fix their ASL. FreeBSD developers continue to identify and document
exactly what non-standard behavior is allowed by MicrosoftÂ®'s interpreter and
replicate it so FreeBSD can work without forcing users to fix the ASL. As a
workaround, and to help identify behavior, fix the ASL manually. If this works,
send a diff(1) of the old and new ASL so developers can possibly work around
the buggy behavior in ACPI-CA and thus make the unnecessary fix.

Here is a list of common error messages, their cause, and how to fix them:

12.17.5.1.Â _OS Dependencies

Some AML assumes the world consists of various WindowsÂ® versions. You can tell
FreeBSD to claim it is any OS to see if this fixes problems you may have. An
easy way to override this is to set hw.acpi.osname="Windows 2001" in /boot/
loader.conf or other similar strings you find in the ASL.

12.17.5.2.Â Missing Return Statements

Some methods do not explicitly return a value as the standard requires. While 
ACPI-CA does not handle this, FreeBSD has a workaround that allows it to return
the value implicitly. Explicit Return statements can be added where required if
you know what value should be returned. To force iasl to compile the ASL, use
the -f flag.

12.17.5.3.Â Overriding the Default AML

After customizing your.asl, compile it with this command:

# iasl your.asl

Adding the -f flag will force creation of the AML, even if there are errors
during compilation. Some errors, such as missing Return statements, are
automatically worked around by the interpreter.

DSDT.aml is the default output filename for iasl. Load this file instead of the
BIOS's buggy copy, which is still present in flash memory, by editing /boot/
loader.conf as follows:

acpi_dsdt_load="YES" acpi_dsdt_name="/boot/DSDT.aml"

Be sure to copy DSDT.aml to /boot.

12.17.6.Â Getting Debugging Output from ACPI

The ACPI driver has a very flexible debugging facility. A set of subsystems and
the level of verbosity can be specified. The subsystems to debug are specified
as â  layersâ   and are broken down into ACPI-CA components
(ACPI_ALL_COMPONENTS) and ACPI hardware support (ACPI_ALL_DRIVERS). The
verbosity of debugging output is specified as the â  levelâ   and ranges from
ACPI_LV_ERROR (just report errors) to ACPI_LV_VERBOSE (everything). The â  
levelâ   is a bitmask so multiple options can be set at once, separated by
spaces. In practice, a serial console should be used to log the output if it is
so long it flushes the console message buffer. A full list of the individual
layers and levels is found in acpi(4).

Debugging output is not enabled by default. To enable it, add options
ACPI_DEBUG to the kernel configuration file if ACPI is compiled into the
kernel. Add ACPI_DEBUG=1 to /etc/make.conf to enable it globally. If it is a
module, recompile just the acpi.ko module as follows:

# cd /sys/modules/acpi/acpi && make clean && make ACPI_DEBUG=1

Install acpi.ko in /boot/kernel and add the desired level and layer to
loader.conf. This example enables debug messages for all ACPI-CA components and
all ACPI hardware drivers such as (CPU and LID. It only outputs error messages
at the least verbose level.

debug.acpi.layer="ACPI_ALL_COMPONENTS ACPI_ALL_DRIVERS" debug.acpi.level=
"ACPI_LV_ERROR"

If the required information is triggered by a specific event, such as a suspend
and then resume, leave out changes to loader.conf and instead use sysctl to
specify the layer and level after booting and preparing the system for the
specific event. The sysctls are named the same as the tunables in loader.conf.

12.17.7.Â References

More information about ACPI may be found in the following locations:

  * The FreeBSD ACPI mailing list

  * The ACPI Mailing List Archives http://lists.freebsd.org/pipermail/
    freebsd-acpi/

  * The old ACPI Mailing List Archives http://home.jp.FreeBSD.org/mail-list/
    acpi-jp/

  * The ACPI 2.0 Specification http://acpi.info/spec.htm

  * FreeBSD Manual pages: acpi(4), acpi_thermal(4), acpidump(8), iasl(8),
    acpidb(8)

  * DSDT debugging resource. (Uses Compaq as an example but generally useful.)


------------

^[3] The auto-tuning algorithm sets maxusers equal to the amount of memory in
the system, with a minimum of 32, and a maximum of 384.

ChapterÂ 13.Â The FreeBSD Booting Process

Table of Contents

13.1. Synopsis
13.2. The Booting Problem
13.3. The Boot Manager and Boot Stages
13.4. Kernel Interaction During Boot
13.5. Device Hints
13.6. Init: Process Control Initialization
13.7. Shutdown Sequence

13.1.Â Synopsis

The process of starting a computer and loading the operating system is referred
to as â  the bootstrap processâ  , or simply â  bootingâ  . FreeBSD's boot
process provides a great deal of flexibility in customizing what happens when
the system starts, including the ability to select from different operating
systems installed on the same computer, different versions of the same
operating system, or a different installed kernel.

This chapter details the configuration options that can be set. It demonstrates
how to customize the FreeBSD boot process, including everything that happens
until the FreeBSD kernel has started, probed for devices, and started init(8).
This occurs when the text color of the boot messages changes from bright white
to grey.

After reading this chapter, you will recognize:

  * The components of the FreeBSD bootstrap system and how they interact.

  * The options that can be passed to the components in the FreeBSD bootstrap
    in order to control the boot process.

  * The basics of device.hints(5).

Note:

This chapter only describes the boot process for FreeBSD running on Intel x86
systems.

13.2.Â The Booting Problem

Turning on a computer and starting the operating system poses an interesting
dilemma. By definition, the computer does not know how to do anything until the
operating system is started. This includes running programs from the disk. If
the computer can not run a program from the disk without the operating system,
and the operating system programs are on the disk, how is the operating system
started?

This problem parallels one in the book The Adventures of Baron Munchausen. A
character had fallen part way down a manhole, and pulled himself out by
grabbing his bootstraps, and lifting. In the early days of computing the term
bootstrap was applied to the mechanism used to load the operating system, which
has become shortened to â  bootingâ  .

On x86 hardware the Basic Input/Output System (BIOS) is responsible for loading
the operating system. To do this, the BIOS looks on the hard disk for the
Master Boot Record (MBR), which must be located on a specific place on the
disk. The BIOS has enough knowledge to load and run the MBR, and assumes that
the MBR can then carry out the rest of the tasks involved in loading the
operating system, possibly with the help of the BIOS.

The code within the MBR is usually referred to as a boot manager, especially
when it interacts with the user. In this case the boot manager usually has more
code in the first track of the disk or within some OS's file system. (A boot
manager is sometimes also called a boot loader, but FreeBSD uses that term for
a later stage of booting.) Popular boot managers include boot0 (aka Boot Easy,
the standard FreeBSD boot manager), Grub, GAG, and LILO. (Only boot0 fits
within the MBR.)

If only one operating system is installed, a standard PC MBR will suffice. This
MBR searches for the first bootable (active) slice on the disk, and then runs
the code on that slice to load the remainder of the operating system. By
default, the MBR installed by fdisk(8) is such an MBR and is based on /boot/
mbr.

If multiple operating systems are present, a different boot manager can be
installed which displays the list of operating systems so that the user can
choose which one to boot from. Two boot managers are discussed in the next
subsection.

The remainder of the FreeBSD bootstrap system is divided into three stages. The
first stage is run by the MBR, which knows just enough to get the computer into
a specific state and run the second stage. The second stage can do a little bit
more, before running the third stage. The third stage finishes the task of
loading the operating system. The work is split into three stages because PC
standards put limits on the size of the programs that can be run at stages one
and two. Chaining the tasks together allows FreeBSD to provide a more flexible
loader.

The kernel is then started and it begins to probe for devices and initialize
them for use. Once the kernel boot process is finished, the kernel passes
control to the user process init(8), which then makes sure the disks are in a
usable state. init(8) then starts the user-level resource configuration which
mounts file systems, sets up network cards to communicate on the network, and
starts the processes which have been configured to run on a FreeBSD system at
startup.

13.3.Â The Boot Manager and Boot Stages

13.3.1.Â The Boot Manager

The code in the MBR or boot manager is sometimes referred to as stage zero of
the boot process. This section discusses two boot managers: boot0 and LILO.

The boot0 Boot Manager:Â The MBR installed by FreeBSD's installer or boot0cfg
(8) is based on /boot/boot0. The size and capability of boot0 is restricted to
446 bytes due to the slice table and 0x55AA identifier at the end of the MBR.
If boot0 and multiple operating systems are installed, a message similar to
this example will be displayed at boot time:

ExampleÂ 13.1.Â boot0 Screenshot
F1 Win F2 FreeBSD Default: F2


Other operating systems, in particular WindowsÂ®, will overwrite an existing
MBR if they are installed after FreeBSD. If this happens, or you want to
replace the existing MBR with the FreeBSD MBR, use the following command:

# fdisk -B -b /boot/boot0 device

where device is the boot disk, such as ad0 for the first IDE disk, ad2 for the
first IDE disk on a second IDE controller, or da0 for the first SCSI disk. To
create a custom configuration of the MBR, refer to boot0cfg(8).

The LILO Boot Manager:Â To install this boot manager so it will also boot
FreeBSD, boot into Linux and add the following to the existing /etc/lilo.conf
configuration:

other=/dev/hdXY table=/dev/hdX loader=/boot/chain.b label=FreeBSD

Specify FreeBSD's primary partition and drive using Linux specifiers, replacing
X with the Linux drive letter and Y with the Linux primary partition number.
For a SCSI drive, change /dev/hd to /dev/sd. The loader=/boot/chain.b line can
be omitted if both operating systems are installed on the same drive. Next, run
/sbin/liloÂ -v to commit the new changes. Verify these are correct by checking
the screen messages.

13.3.2.Â Stage One, /boot/boot1, and Stage Two, /boot/boot2

Conceptually, the first and second stages are part of the same program, on the
same area of the disk. Because of space constraints, they have been split into
two, but are always installed together. They are copied from the combined /boot
/boot by the installer or bsdlabel.

They are located outside file systems, in the first track of the boot slice,
starting with the first sector. This is where boot0, or any other boot manager,
expects to find a program to run which will continue the boot process. The
number of sectors used is easily determined from the size of /boot/boot.

boot1 is very simple, since it can only be 512 bytes in size, and knows just
enough about the FreeBSD bsdlabel, which stores information about the slice, to
find and execute boot2.

boot2 is slightly more sophisticated, and understands the FreeBSD file system
enough to find files, and can provide a simple interface to choose the kernel
or loader to run.

loader is much more sophisticated and provides a boot configuration which is
run by boot2.

ExampleÂ 13.2.Â boot2 Screenshot
&gt;&gt; FreeBSD/i386 BOOT Default: 0:ad(0,a)/boot/loader boot:


bsdlabel(8) can be used to replace the installed boot1 and boot2:

# bsdlabel -B diskslice

where diskslice is the disk and slice to boot from, such as ad0s1 for the first
slice on the first IDE disk.

Dangerously Dedicated Mode:

If just the disk name is used, such as ad0, bsdlabel(8) will create a â  
dangerously dedicatedâ   disk, without slices. This is probably not the desired
action, so double check the diskslice passed to bsdlabel(8) before pressing 
Return.

13.3.3.Â Stage Three, /boot/loader

The loader is the final stage of the three-stage bootstrap, and is located on
the file system, usually as /boot/loader.

The loader is intended as an interactive method for configuration, using a
built-in command set, backed up by a more powerful interpreter which has a more
complex command set.

13.3.3.1.Â Loader Program Flow

During initialization, the loader will probe for a console and for disks, and
figure out which disk it is booting from. It will set variables accordingly,
and an interpreter is started where user commands can be passed from a script
or interactively.

The loader will then read /boot/loader.rc, which by default reads in /boot/
defaults/loader.conf which sets reasonable defaults for variables and reads /
boot/loader.conf for local changes to those variables. loader.rc then acts on
these variables, loading whichever modules and kernel are selected.

Finally, by default, the loader issues a 10 second wait for key presses, and
boots the kernel if it is not interrupted. If interrupted, the user is
presented with a prompt which understands the command set, where the user may
adjust variables, unload all modules, load modules, and then finally boot or
reboot.

13.3.3.2.Â Loader Built-In Commands

These are the most commonly used loader commands. For a complete discussion of
all available commands, refer to loader(8).

autoboot seconds

    Proceeds to boot the kernel if not interrupted within the time span given,
    in seconds. It displays a countdown, and the default time span is 10
    seconds.

boot [-options] [kernelname]

    Immediately proceeds to boot the kernel, with any specified options or
    kernel name. Providing a kernel name on the command-line is only applicable
    after an unload command has been issued; otherwise the previously-loaded
    kernel will be used.

boot-conf

    Goes through the same automatic configuration of modules based on specified
    variables, most commonly kernel. This only makes sense if unload is used
    first, before changing some variables.

help [topic]

    Shows help messages read from /boot/loader.help. If the topic given is
    index, the list of available topics is displayed.

include filename â Š

    Processes the file with the given filename. The file is read in and
    interpreted line by line. An error immediately stops the include command.

load [-t type] filename

    Loads the kernel, kernel module, or file of the type given, with the
    specified filename. Any arguments after filename are passed to the file.

ls [-l] [path]

    Displays a listing of files in the given path, or the root directory, if
    the path is not specified. If -l is specified, file sizes will also be
    shown.

lsdev [-v]

    Lists all of the devices from which it may be possible to load modules. If
    -v is specified, more details are printed.

lsmod [-v]

    Displays loaded modules. If -v is specified, more details are shown.

more filename

    Displays the files specified, with a pause at each LINES displayed.

reboot

    Immediately reboots the system.

set variable, set variable=value

    Sets the loader's environment variables.

unload

    Removes all loaded modules.

13.3.3.3.Â Loader Examples

Here are some practical examples of loader usage:

  * To boot the usual kernel in single-user mode:

    boot -s
  * To unload the usual kernel and modules, and then load the previous or
    another kernel:

    unload load kernel.old

    Use kernel.GENERIC to refer to the default kernel that comes with an
    installation, or kernel.old to refer to the previously installed kernel
    before a system upgrade or before configuring a custom kernel.

    Note:

    Use the following to load the usual modules with another kernel:

    unload set kernel="kernel.old" boot-conf
  * To load an automated kernel configuration script:

    load -t userconfig_script /boot/kernel.conf

13.3.3.4.Â Boot Time Splash Screens

Contributed by Joseph J. Barbish.

The splash screen creates an alternate boot screen. The splash screen hides all
the boot probe messages and service startup messages before displaying either a
command line or graphical login prompt.

There are two basic environments available in FreeBSD. The first is the default
legacy virtual console command line environment. After the system finishes
booting, a console login prompt is presented. The second environment is the
graphical environment provided by Xorg. Refer to that chapter for more
information on how to install and configure a graphical display manager and a
graphical login manager.

13.3.3.4.1.Â Splash Screen Function

The splash screen function supports 256-colors in the bitmap (.bmp), ZSoft PCX
(.pcx), or TheDraw (.bin) formats. The splash image files must have a
resolution of 320 by 200 pixels or less in order to work on standard VGA
adapters.

To use larger images, up to the maximum resolution of 1024 by 768 pixels, load
the VESA module during system boot. For a custom kernel, include the VESA
kernel configuration option. Loading VESA support provides the ability to
display a splash screen image that fills the whole display screen.

While the splash screen is being displayed during the booting process, it can
be turned off any time by hitting any key on the keyboard.

The splash screen also defaults to being a screen saver outside. After a time
period of non-use, the splash screen will be displayed and will cycle through
steps of changing intensity of the image, from bright to very dark and over
again. The configuration of the splash screen saver can be overridden by adding
a saver= line to /etc/rc.conf. Several built-in screen savers are available and
described in splash(4). The saver= option only applies to virtual consoles and
has no effect on graphical display managers.

A few boot loader messages, including the boot options menu and a timed wait
count down prompt, are displayed at boot time, even when the splash screen is
enabled.

Sample splash screen files can be downloaded from the gallery at http://
artwork.freebsdgr.org. By installing the sysutils/bsd-splash-changer port,
splash images can be chosen from a collection randomly at each boot.

13.3.3.4.2.Â Enabling the Splash Screen Function

The splash screen .bmp, .pcx, or .bin image has to be placed on the root
partition, for example in /boot.

For the default boot display resolution of 256-colors and 320 by 200 pixels or
less, edit /boot/loader.conf so it contains the following:

splash_bmp_load="YES" bitmap_load="YES" bitmap_name="/boot/splash.bmp"

For larger video resolutions up to the maximum of 1024 by 768 pixels, edit /
boot/loader.conf, so it contains the following:

vesa_load="YES" splash_bmp_load="YES" bitmap_load="YES" bitmap_name="/boot/
splash.bmp"

This example assumes that /boot/splash.bmp is used for the splash screen. To
use a PCX file, use the following statements, plus the vesa_load="YES" line,
depending on the resolution:

splash_pcx_load="YES" bitmap_load="YES" bitmap_name="/boot/splash.pcx"

Beginning with FreeBSDÂ 8.3, another option is to use ASCII art in TheDraw
format.

splash_txt="YES" bitmap_load="YES" bitmap_name="/boot/splash.bin"

The file name is not restricted to â  splashâ   as shown in the above example.
It can be anything as long as it is one of the supported types such as,
splash_640x400.bmp or bluewave.pcx.

Other interesting loader.conf options include:

beastie_disable="YES"

    This will stop the boot options menu from being displayed, but the timed
    wait count down prompt will still be present. Even with the display of the
    boot options menu disabled, entering an option selection at the timed wait
    count down prompt will enact the corresponding boot option.

loader_logo="beastie"

    This will replace the default words â  FreeBSDâ  , which are displayed to
    the right of the boot options menu with the colored beastie logo.

For more information, refer to splash(4), loader.conf(5), and vga(4).

13.4.Â Kernel Interaction During Boot

Once the kernel is loaded by either the default loader or by boot2 which
bypasses the loader, it examines its boot flags, if any, and adjusts its
behavior as necessary.

13.4.1.Â Kernel Boot Flags

Here are the more common boot flags:

-a

    During kernel initialization, ask for the device to mount as the root file
    system.

-C

    Boot from CDROM.

-c

    Run UserConfig, the boot-time kernel configurator.

-s

    Boot into single-user mode.

-v

    Be more verbose during kernel startup.

Note:

Refer to boot(8) for more information on the other boot flags.

13.5.Â Device Hints

Contributed by Tom Rhodes.

During initial system startup, the boot loader(8) reads device.hints(5). This
file stores kernel boot information known as variables, sometimes referred to
as â  device hintsâ  . These â  device hintsâ   are used by device drivers for
device configuration.

Device hints may also be specified at the Stage 3 boot loader prompt. Variables
can be added using set, removed with unset, and viewed show. Variables set in /
boot/device.hints can also be overridden. Device hints entered at the boot
loader are not permanent and will not be applied on the next reboot.

Once the system is booted, kenv(1) can be used to dump all of the variables.

The syntax for /boot/device.hints is one variable per line, using the hash â  #
â   as comment markers. Lines are constructed as follows:

hint.driver.unit.keyword="value"

The syntax for the Stage 3 boot loader is:

set hint.driver.unit.keyword=value

where driver is the device driver name, unit is the device driver unit number,
and keyword is the hint keyword. The keyword may consist of the following
options:

  * at: specifies the bus which the device is attached to.

  * port: specifies the start address of the I/O to be used.

  * irq: specifies the interrupt request number to be used.

  * drq: specifies the DMA channel number.

  * maddr: specifies the physical memory address occupied by the device.

  * flags: sets various flag bits for the device.

  * disabled: if set to 1 the device is disabled.

Since device drivers may accept or require more hints not listed here, viewing
a driver's manual page is recommended. For more information, refer to
device.hints(5), kenv(1), loader.conf(5), and loader(8).

13.6.Â Init: Process Control Initialization

Once the kernel has finished booting, it passes control to the user process
init(8), which is located at /sbin/init, or the program path specified in the
init_path variable in loader.

13.6.1.Â Automatic Reboot Sequence

The automatic reboot sequence makes sure that the file systems available on the
system are consistent. If they are not, and fsck(8) cannot fix the
inconsistencies of a UFS file system, init(8) drops the system into single-user
mode so that the system administrator can resolve the problem directly.

13.6.2.Â Single-User Mode

This mode can be reached through the automatic reboot sequence, the user
booting with -s, or by setting the boot_single variable in loader.

It can also be reached by calling shutdown(8) from multi-user mode without
including -r or -h.

If the system console is set to insecure in /etc/ttys, the system will prompt
for the root password before initiating single-user mode.

ExampleÂ 13.3.Â An Insecure Console in /etc/ttys
# name getty type status comments # # If console is marked "insecure", then
init will ask for the root password # when going to single-user mode. console
none unknown off insecure


Note:

An insecure console means that physical security to the console is considered
to be insecure, so only someone who knows the root password may use single-user
mode. Thus, to add this measure of security, choose insecure, instead of the
default of secure.

13.6.3.Â Multi-User Mode

If init(8) finds the file systems to be in order, or once the user has finished
their commands in single-user mode, the system enters multi-user mode, in which
it starts the resource configuration of the system.

13.6.3.1.Â Resource Configuration (rc)

The resource configuration system reads in configuration defaults from /etc/
defaults/rc.conf, and system-specific details from /etc/rc.conf, and then
proceeds to mount the system file systems listed in /etc/fstab. It starts up
networking services, miscellaneous system daemons, then the startup scripts of
locally installed packages.

To learn more about the resource configuration system, refer to rc(8) and
examine the scripts themselves.

13.7.Â Shutdown Sequence

Upon controlled shutdown using shutdown(8), init(8) will attempt to run the
script /etc/rc.shutdown, and then proceed to send all processes the TERM
signal, and subsequently the KILL signal to any that do not terminate in a
timely manner.

To power down a FreeBSD machine on architectures and systems that support power
management, use shutdown -p now to turn the power off immediately. To reboot a
FreeBSD system, use shutdown -r now. One must be root or a member of the
operator group in order to run shutdown(8). One can also use halt(8) and reboot
(8). Refer to their manual pages and to shutdown(8) for more information.

Note:

Power management requires acpi(4) to be loaded as a module or staticly compiled
into a custom kernel.

ChapterÂ 14.Â Users and Basic Account Management

Contributed by Neil Blakey-Milner.
Table of Contents

14.1. Synopsis
14.2. Introduction
14.3. Modifying Accounts
14.4. Limiting Users
14.5. Groups

14.1.Â Synopsis

FreeBSD allows multiple users to use the computer at the same time. While only
one user can sit in front of the screen and use the keyboard at any one time,
any number of users can log in to the system through the network. To use the
system, every user must have a user account.

After reading this chapter, you will know:

  * The differences between the various user accounts on a FreeBSD system.

  * How to add and remove user accounts.

  * How to change account details, such as the user's full name or preferred
    shell.

  * How to set limits on a per-account basis to control the resources, such as
    memory and CPU time, that accounts and groups of accounts are allowed to
    access.

  * How to use groups to make account management easier.

Before reading this chapter, you should:

  * Understand the basics of UNIXÂ® and FreeBSD.

14.2.Â Introduction

Since all access to the FreeBSD system is achieved via accounts and all
processes are run by users, user and account management is important.

Every account on a FreeBSD system has certain information associated with it to
identify the account.

User name

    The user name is typed at the login: prompt. User names must be unique on
    the system as no two users can have the same user name. There are a number
    of rules for creating valid user names, documented in passwd(5). Typically
    user names consist of eight or fewer all lower case characters in order to
    maintain backwards compatibility with applications.

Password

    Each account has an associated password. While the password can be blank,
    this is highly discouraged and every account should have a password.

User ID (UID)

    The User ID (UID) is a number, traditionally from 0 to 65535^[4], used to
    uniquely identify the user to the system. Internally, FreeBSD uses the UID
    to identify users. Commands that allow a user name to be specified will
    first convert it to the UID. Though unlikely, it is possible for several
    accounts with different user names to share the same UID. As far as FreeBSD
    is concerned, these accounts are one user.

Group ID (GID)

    The Group ID (GID) is a number, traditionally from 0 to 65535^[4], used to
    uniquely identify the primary group that the user belongs to. Groups are a
    mechanism for controlling access to resources based on a user's GID rather
    than their UID. This can significantly reduce the size of some
    configuration files. A user may also be a member of more than one group.

Login class

    Login classes are an extension to the group mechanism that provide
    additional flexibility when tailoring the system to different users.

Password change time

    By default FreeBSD does not force users to change their passwords
    periodically. Password expiration can be enforced on a per-user basis,
    forcing some or all users to change their passwords after a certain amount
    of time has elapsed.

Account expiry time

    By default FreeBSD does not expire accounts. When creating accounts that
    need a limited lifespan, such as student accounts in a school, specify the
    account expiry date. After the expiry time has elapsed, the account cannot
    be used to log in to the system, although the account's directories and
    files will remain.

User's full name

    The user name uniquely identifies the account to FreeBSD, but does not
    necessarily reflect the user's real name. This information can be
    associated with the account.

Home directory

    The home directory is the full path to a directory on the system. This is
    the user's starting directory when the user logs in. A common convention is
    to put all user home directories under /home/username or /usr/home/username
    . Each user stores their personal files and subdirectories in their own
    home directory.

User shell

    The shell provides the default environment users use to interact with the
    system. There are many different kinds of shells, and experienced users
    will have their own preferences, which can be reflected in their account
    settings.

There are three main types of accounts: the superuser, system accounts, and
user accounts. The superuser account, usually called root, is used to manage
the system with no limitations on privileges. System accounts are used to run
services. User accounts are assigned to real people and are used to log in and
use the system.

14.2.1.Â The Superuser Account

The superuser account, usually called root, is used to perform system
administration tasks and should not be used for day-to-day tasks like sending
and receiving mail, general exploration of the system, or programming.

This is because the superuser, unlike normal user accounts, can operate without
limits, and misuse of the superuser account may result in spectacular
disasters. User accounts are unable to destroy the system by mistake, so it is
generally best to use normal user accounts whenever possible, unless extra
privilege is required.

Always double and triple-check any commands issued as the superuser, since an
extra space or missing character can mean irreparable data loss.

Always create a user account for the system administrator and use this account
to log in to the system for general usage. This applies equally to multi-user
or single-user systems. Later sections will discuss how to create additional
accounts and how to change between the normal user and superuser.

14.2.2.Â System Accounts

System accounts are used to run services such as DNS, mail, and web servers.
The reason for this is security; if all services ran as the superuser, they
could act without restriction.

Examples of system accounts are daemon, operator, bind, news, and www.

nobody is the generic unprivileged system account. However, the more services
that use nobody, the more files and processes that user will become associated
with, and hence the more privileged that user becomes.

14.2.3.Â User Accounts

User accounts are the primary means of access for real people to the system.
User accounts insulate the user and the environment, preventing users from
damaging the system or other users, and allowing users to customize their
environment without affecting others.

Every person accessing the system should have a unique user account. This
allows the administrator to find out who is doing what, prevents users from
clobbering each others' settings or reading each others' mail, and so forth.

Each user can set up their own environment to accommodate their use of the
system, by using alternate shells, editors, key bindings, and language.

14.3.Â Modifying Accounts

FreeBSD provides a variety of different commands to manage user accounts. The
most common commands are summarized below, followed by more detailed examples
of their usage.

 Command                                 Summary
adduser(8) The recommended command-line application for adding new users.
rmuser(8)  The recommended command-line application for removing users.
chpass(1)  A flexible tool for changing user database information.
passwd(1)  The simple command-line tool to change user passwords.
pw(8)      A powerful and flexible tool for modifying all aspects of user
           accounts.

14.3.1.Â adduser

adduser(8) is a simple program for adding new users When a new user is added,
this program automatically updates /etc/passwd and /etc/group. It also creates
a home directory for the new user, copies in the default configuration files
from /usr/share/skel, and can optionally mail the new user a welcome message.

ExampleÂ 14.1.Â Adding a User on FreeBSD
# adduser Username: jru Full name: J. Random User Uid (Leave empty for
default): Login group [jru]: Login group is jru. Invite jru into other groups?
[]: wheel Login class [default]: Shell (sh csh tcsh zsh nologin) [sh]: zsh Home
directory [/home/jru]: Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]: Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]: Enter password: Enter password again:
Lock out the account after creation? [no]: Username : jru Password : **** Full
Name : J. Random User Uid : 1001 Class : Groups : jru wheel Home : /home/jru
Shell : /usr/local/bin/zsh Locked : no OK? (yes/no): yes adduser: INFO:
Successfully added (jru) to the user database. Add another user? (yes/no): no
Goodbye! #


Note:

Since the password is not echoed when typed, be careful to not mistype the
password when creating the user account.

14.3.2.Â rmuser

To completely remove a user from the system use rmuser(8). This command
performs the following steps:

 1. Removes the user's crontab(1) entry if one exists.

 2. Removes any at(1) jobs belonging to the user.

 3. Kills all processes owned by the user.

 4. Removes the user from the system's local password file.

 5. Removes the user's home directory, if it is owned by the user.

 6. Removes the incoming mail files belonging to the user from /var/mail.

 7. Removes all files owned by the user from temporary file storage areas such
    as /tmp.

 8. Finally, removes the username from all groups to which it belongs in /etc/
    group.

    Note:

    If a group becomes empty and the group name is the same as the username,
    the group is removed. This complements the per-user unique groups created
    by adduser(8).

rmuser(8) cannot be used to remove superuser accounts since that is almost
always an indication of massive destruction.

By default, an interactive mode is used, as shown in the following example.

ExampleÂ 14.2.Â rmuser Interactive Account Removal
# rmuser jru Matching password entry: jru:*:1001:1001::0:0:J. Random User:/home
/jru:/usr/local/bin/zsh Is this the entry you wish to remove? y Remove user's
home directory (/home/jru)? y Updating password file, updating databases, done.
Updating group file: trusted (removing group jru -- personal group is empty)
done. Removing user's incoming mail file /var/mail/jru: done. Removing files
belonging to jru from /tmp: done. Removing files belonging to jru from /var/
tmp: done. Removing files belonging to jru from /var/tmp/vi.recover: done. #


14.3.3.Â chpass

chpass(1) can be used to change user database information such as passwords,
shells, and personal information.

Only the superuser can change other users' information and passwords with
chpass(1).

When passed no options, aside from an optional username, chpass(1) displays an
editor containing user information. When the user exists from the editor, the
user database is updated with the new information.

Note:

You will be asked for your password after exiting the editor if you are not the
superuser.

ExampleÂ 14.3.Â Interactive chpass by Superuser
#Changing user database information for jru. Login: jru Password: * Uid [#]:
1001 Gid [# or name]: 1001 Change [month day year]: Expire [month day year]:
Class: Home directory: /home/jru Shell: /usr/local/bin/zsh Full Name: J. Random
User Office Location: Office Phone: Home Phone: Other information:


A user can change only a small subset of this information, and only for their
own user account.

ExampleÂ 14.4.Â Interactive chpass by Normal User
#Changing user database information for jru. Shell: /usr/local/bin/zsh Full
Name: J. Random User Office Location: Office Phone: Home Phone: Other
information:


Note:

chfn(1) and chsh(1) are links to chpass(1), as are ypchpass(1), ypchfn(1), and
ypchsh(1). NIS support is automatic, so specifying the yp before the command is
not necessary. How to configure NIS is covered in ChapterÂ 30, Network Servers.

14.3.4.Â passwd

passwd(1) is the usual way to change your own password as a user, or another
user's password as the superuser.

Note:

To prevent accidental or unauthorized changes, the user must enter their
original password before a new password can be set. This is not the case when
the superuser changes a user's password.

ExampleÂ 14.5.Â Changing Your Password
% passwd Changing local password for jru. Old password: New password: Retype
new password: passwd: updating the database... passwd: done

ExampleÂ 14.6.Â Changing Another User's Password as the Superuser
# passwd jru Changing local password for jru. New password: Retype new
password: passwd: updating the database... passwd: done


Note:

As with chpass(1), yppasswd(1) is a link to passwd(1), so NIS works with either
command.

14.3.5.Â pw

pw(8) is a command line utility to create, remove, modify, and display users
and groups. It functions as a front end to the system user and group files. pw
(8) has a very powerful set of command line options that make it suitable for
use in shell scripts, but new users may find it more complicated than the other
commands presented in this section.

14.4.Â Limiting Users

FreeBSD provides several methods for an administrator to limit the amount of
system resources an individual may use. These limits are discussed in two
sections: disk quotas and other resource limits.

Disk quotas limit the amount of disk space available to users and provide a way
to quickly check that usage without calculating it every time. Quotas are
discussed in SectionÂ 19.15, â  File System Quotasâ  .

The other resource limits include ways to limit the amount of CPU, memory, and
other resources a user may consume. These are defined using login classes and
are discussed here.

Login classes are defined in /etc/login.conf and are described in detail in
login.conf(5). Each user account is assigned to a login class, default by
default, and each login class has a set of login capabilities associated with
it. A login capability is a name=value pair, where name is a well-known
identifier and value is an arbitrary string which is processed accordingly
depending on the name. Setting up login classes and capabilities is rather
straightforward and is also described in login.conf(5).

Note:

FreeBSD does not normally read the configuration in /etc/login.conf directly,
but instead reads the /etc/login.conf.db database which provides faster
lookups. Whenever /etc/login.conf is edited, the /etc/login.conf.db must be
updated by executing the following command:

# cap_mkdb /etc/login.conf

Resource limits differ from the default login capabilities in two ways. First,
for every limit, there is a soft (current) and hard limit. A soft limit may be
adjusted by the user or application, but may not be set higher than the hard
limit. The hard limit may be lowered by the user, but can only be raised by the
superuser. Second, most resource limits apply per process to a specific user,
not to the user as a whole. These differences are mandated by the specific
handling of the limits, not by the implementation of the login capability
framework.

Below are the most commonly used resource limits. The rest of the limits, along
with all the other login capabilities, can be found in login.conf(5).

coredumpsize
   
    The limit on the size of a core file generated by a program is subordinate
    to other limits on disk usage, such as filesize, or disk quotas. This limit
    is often used as a less-severe method of controlling disk space
    consumption. Since users do not generate core files themselves, and often
    do not delete them, setting this may save them from running out of disk
    space should a large program crash.

cputime
   
    The maximum amount of CPU time a user's process may consume. Offending
    processes will be killed by the kernel.

    Note:

    This is a limit on CPU time consumed, not percentage of the CPU as
    displayed in some fields by top(1) and ps(1).

filesize
   
    The maximum size of a file the user may own. Unlike disk quotas, this limit
    is enforced on individual files, not the set of all files a user owns.

maxproc
   
    The maximum number of processes a user can run. This includes foreground
    and background processes. This limit may not be larger than the system
    limit specified by the kern.maxproc sysctl(8). Setting this limit too small
    may hinder a user's productivity as it is often useful to be logged in
    multiple times or to execute pipelines. Some tasks, such as compiling a
    large program, spawn multiple processes and other intermediate
    preprocessors.

memorylocked
   
    The maximum amount of memory a process may request to be locked into main
    memory using mlock(2). Some system-critical programs, such as amd(8), lock
    into main memory so that if the system begins to swap, they do not
    contribute to disk thrashing.

memoryuse
   
    The maximum amount of memory a process may consume at any given time. It
    includes both core memory and swap usage. This is not a catch-all limit for
    restricting memory consumption, but is a good start.

openfiles
   
    The maximum number of files a process may have open. In FreeBSD, files are
    used to represent sockets and IPC channels, so be careful not to set this
    too low. The system-wide limit for this is defined by the kern.maxfiles
    sysctl(8).

sbsize
   
    The limit on the amount of network memory, and thus mbufs, a user may
    consume in order to limit network communications.

stacksize
   
    The maximum size of a process stack. This alone is not sufficient to limit
    the amount of memory a program may use so it should be used in conjunction
    with other limits.

There are a few other things to remember when setting resource limits.
Following are some general tips, suggestions, and miscellaneous comments.

  * Processes started at system startup by /etc/rc are assigned to the daemon
    login class.

  * Although the /etc/login.conf that comes with the system is a good source of
    reasonable values for most limits, they may not be appropriate for every
    system. Setting a limit too high may open the system up to abuse, while
    setting it too low may put a strain on productivity.

  * Users of Xorg should probably be granted more resources than other users. 
    Xorg by itself takes a lot of resources, but it also encourages users to
    run more programs simultaneously.

  * Many limits apply to individual processes, not the user as a whole. For
    example, setting openfiles to 50 means that each process the user runs may
    open up to 50 files. The total amount of files a user may open is the value
    of openfiles multiplied by the value of maxproc. This also applies to
    memory consumption.

For further information on resource limits and login classes and capabilities
in general, refer to cap_mkdb(1), getrlimit(2), and login.conf(5).

14.5.Â Groups

A group is a list of users. A group is identified by its group name and GID. In
FreeBSD, the kernel uses the UID of a process, and the list of groups it
belongs to, to determine what the process is allowed to do. Most of the time,
the GID of a user or process usually means the first group in the list.

The group name to GID mapping is listed in /etc/group. This is a plain text
file with four colon-delimited fields. The first field is the group name, the
second is the encrypted password, the third the GID, and the fourth the
comma-delimited list of members. For a more complete description of the syntax,
refer to group(5).

The superuser can modify /etc/group using a text editor. Alternatively, pw(8)
can be used to add and edit groups. For example, to add a group called teamtwo
and then confirm that it exists:

ExampleÂ 14.7.Â Adding a Group Using pw(8)
# pw groupadd teamtwo # pw groupshow teamtwo teamtwo:*:1100:


In this example, 1100 is the GID of teamtwo. Right now, teamtwo has no members.
This command will add jru as a member of teamtwo.

ExampleÂ 14.8.Â Adding User Accounts to a New Group Using pw(8)
# pw groupmod teamtwo -M jru # pw groupshow teamtwo teamtwo:*:1100:jru


The argument to -M is a comma-delimited list of users to be added to a new
(empty) group or to replace the members of an existing group. To the user, this
group membership is different from (and in addition to) the user's primary
group listed in the password file. This means that the user will not show up as
a member when using groupshow with pw(8), but will show up when the information
is queried via id(1) or a similar tool. When pw(8) is used to add a user to a
group, it only manipulates /etc/group and does not attempt to read additional
data from /etc/passwd.

ExampleÂ 14.9.Â Adding a New Member to a Group Using pw(8)
# pw groupmod teamtwo -m db # pw groupshow teamtwo teamtwo:*:1100:jru,db


In this example, the argument to -m is a comma-delimited list of users who are
to be added to the group. Unlike the previous example, these users are appended
to the group list and do not replace the list of existing users in the group.

ExampleÂ 14.10.Â Using id(1) to Determine Group Membership
% id jru uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)


In this example, jru is a member of the groups jru and teamtwo.

For more information about this command and the format of /etc/group, refer to
pw(8) and group(5).


------------

^[4] It is possible to use UIDs/GIDs as large as 4294967295, but such IDs can
cause serious problems with software that makes assumptions about the values of
IDs.

ChapterÂ 15.Â Security

Much of this chapter has been taken from the security(7) manual page by Matthew
Dillon.
Table of Contents

15.1. Synopsis
15.2. Introduction
15.3. Securing FreeBSD
15.4. DES, Blowfish, MD5, SHA256, SHA512, and Crypt
15.5. One-time Passwords
15.6. TCP Wrappers
15.7. Kerberos5
15.8. OpenSSL
15.9. VPN over IPsec
15.10. OpenSSH
15.11. File System Access Control Lists (ACLs)
15.12. Monitoring Third Party Security Issues
15.13. FreeBSD Security Advisories
15.14. Process Accounting

15.1.Â Synopsis

This chapter will provide a basic introduction to system security concepts,
some general good rules of thumb, and some advanced topics under FreeBSD. A lot
of the topics covered here can be applied to system and Internet security in
general as well. The Internet is no longer a â  friendlyâ   place in which
everyone wants to be your kind neighbor. Securing your system is imperative to
protect your data, intellectual property, time, and much more from the hands of
hackers and the like.

FreeBSD provides an array of utilities and mechanisms to ensure the integrity
and security of your system and network.

After reading this chapter, you will know:

  * Basic system security concepts, in respect to FreeBSD.

  * About the various crypt mechanisms available in FreeBSD, such as DES and 
    MD5.

  * How to set up one-time password authentication.

  * How to configure TCP Wrappers for use with inetd.

  * How to set up Kerberos5 on FreeBSD.

  * How to configure IPsec and create a VPN between FreeBSD/WindowsÂ® machines.

  * How to configure and use OpenSSH, FreeBSD's SSH implementation.

  * What file system ACLs are and how to use them.

  * How to use the Portaudit utility to audit third party software packages
    installed from the Ports Collection.

  * How to utilize the FreeBSD security advisories publications.

  * Have an idea of what Process Accounting is and how to enable it on FreeBSD.

Before reading this chapter, you should:

  * Understand basic FreeBSD and Internet concepts.

Additional security topics are covered throughout this book. For example,
Mandatory Access Control is discussed in ChapterÂ 17, Mandatory Access Control
and Internet Firewalls are discussed in ChapterÂ 31, Firewalls.

15.2.Â Introduction

Security is a function that begins and ends with the system administrator.
While all BSD UNIXÂ® multi-user systems have some inherent security, the job of
building and maintaining additional security mechanisms to keep those users â  
honestâ   is probably one of the single largest undertakings of the sysadmin.
Machines are only as secure as you make them, and security concerns are ever
competing with the human necessity for convenience. UNIXÂ® systems, in general,
are capable of running a huge number of simultaneous processes and many of
these processes operate as servers â   meaning that external entities can
connect and talk to them. As yesterday's mini-computers and mainframes become
today's desktops, and as computers become networked and inter-networked,
security becomes an even bigger issue.

System security also pertains to dealing with various forms of attack,
including attacks that attempt to crash, or otherwise make a system unusable,
but do not attempt to compromise the root account (â  break rootâ  ). Security
concerns can be split up into several categories:

 1. Denial of service attacks.

 2. User account compromises.

 3. Root compromise through accessible servers.

 4. Root compromise via user accounts.

 5. Backdoor creation.

A denial of service attack is an action that deprives the machine of needed
resources. Typically, DoS attacks are brute-force mechanisms that attempt to
crash or otherwise make a machine unusable by overwhelming its servers or
network stack. Some DoS attacks try to take advantage of bugs in the networking
stack to crash a machine with a single packet. The latter can only be fixed by
applying a bug fix to the kernel. Attacks on servers can often be fixed by
properly specifying options to limit the load the servers incur on the system
under adverse conditions. Brute-force network attacks are harder to deal with.
A spoofed-packet attack, for example, is nearly impossible to stop, short of
cutting your system off from the Internet. It may not be able to take your
machine down, but it can saturate your Internet connection.

A user account compromise is even more common than a DoS attack. Many sysadmins
still run standard telnetd, rlogind, rshd, and ftpd servers on their machines.
These servers, by default, do not operate over encrypted connections. The
result is that if you have any moderate-sized user base, one or more of your
users logging into your system from a remote location (which is the most common
and convenient way to login to a system) will have his or her password sniffed.
The attentive system admin will analyze his remote access logs looking for
suspicious source addresses even for successful logins.

One must always assume that once an attacker has access to a user account, the
attacker can break root. However, the reality is that in a well secured and
maintained system, access to a user account does not necessarily give the
attacker access to root. The distinction is important because without access to
root the attacker cannot generally hide his tracks and may, at best, be able to
do nothing more than mess with the user's files, or crash the machine. User
account compromises are very common because users tend not to take the
precautions that sysadmins take.

System administrators must keep in mind that there are potentially many ways to
break root on a machine. The attacker may know the root password, the attacker
may find a bug in a root-run server and be able to break root over a network
connection to that server, or the attacker may know of a bug in a suid-root
program that allows the attacker to break root once he has broken into a user's
account. If an attacker has found a way to break root on a machine, the
attacker may not have a need to install a backdoor. Many of the root holes
found and closed to date involve a considerable amount of work by the attacker
to cleanup after himself, so most attackers install backdoors. A backdoor
provides the attacker with a way to easily regain root access to the system,
but it also gives the smart system administrator a convenient way to detect the
intrusion. Making it impossible for an attacker to install a backdoor may
actually be detrimental to your security, because it will not close off the
hole the attacker found to break in the first place.

Security remedies should always be implemented with a multi-layered â  onion
peelâ   approach and can be categorized as follows:

 1. Securing root and staff accounts.

 2. Securing rootâ  run servers and suid/sgid binaries.

 3. Securing user accounts.

 4. Securing the password file.

 5. Securing the kernel core, raw devices, and file systems.

 6. Quick detection of inappropriate changes made to the system.

 7. Paranoia.

The next section of this chapter will cover the above bullet items in greater
depth.

15.3.Â Securing FreeBSD

Command Versus Protocol:

Throughout this document, we will use bold text to refer to an application, and
a monospaced font to refer to specific commands. Protocols will use a normal
font. This typographical distinction is useful for instances such as ssh, since
it is a protocol as well as command.

The sections that follow will cover the methods of securing your FreeBSD system
that were mentioned in the last section of this chapter.

15.3.1.Â Securing the root Account and Staff Accounts

First off, do not bother securing staff accounts if you have not secured the
root account. Most systems have a password assigned to the root account. The
first thing you do is assume that the password is always compromised. This does
not mean that you should remove the password. The password is almost always
necessary for console access to the machine. What it does mean is that you
should not make it possible to use the password outside of the console or
possibly even with the su(1) command. For example, make sure that your ptys are
specified as being insecure in the /etc/ttys file so that direct root logins
via telnet or rlogin are disallowed. If using other login services such as sshd
, make sure that direct root logins are disabled there as well. You can do this
by editing your /etc/ssh/sshd_config file, and making sure that PermitRootLogin
is set to no. Consider every access method â   services such as FTP often fall
through the cracks. Direct root logins should only be allowed via the system
console.

Of course, as a sysadmin you have to be able to get to root, so we open up a
few holes. But we make sure these holes require additional password
verification to operate. One way to make root accessible is to add appropriate
staff accounts to the wheel group (in /etc/group). The staff members placed in
the wheel group are allowed to su to root. You should never give staff members
native wheel access by putting them in the wheel group in their password entry.
Staff accounts should be placed in a staff group, and then added to the wheel
group via the /etc/group file. Only those staff members who actually need to
have root access should be placed in the wheel group. It is also possible, when
using an authentication method such as Kerberos, to use Kerberos' .k5login file
in the root account to allow a ksu(1) to root without having to place anyone at
all in the wheel group. This may be the better solution since the wheel
mechanism still allows an intruder to break root if the intruder has gotten
hold of your password file and can break into a staff account. While having the
wheel mechanism is better than having nothing at all, it is not necessarily the
safest option.

To lock an account completely, the pw(8) command should be used:

# pw lock staff

This will prevent the user from logging in using any mechanism, including ssh
(1).

Another method of blocking access to accounts would be to replace the encrypted
password with a single â  *â   character. This character would never match the
encrypted password and thus block user access. For example, the following staff
account:

foobar:R9DT/Fa1/LV9U:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh

Should be changed to this:

foobar:*:1000:1000::0:0:Foo Bar:/home/foobar:/usr/local/bin/tcsh

This will prevent the foobar user from logging in using conventional methods.
This method for access restriction is flawed on sites using Kerberos or in
situations where the user has set up keys with ssh(1).

These security mechanisms also assume that you are logging in from a more
restrictive server to a less restrictive server. For example, if your main box
is running all sorts of servers, your workstation should not be running any. In
order for your workstation to be reasonably secure you should run as few
servers as possible, up to and including no servers at all, and you should run
a password-protected screen blanker. Of course, given physical access to a
workstation an attacker can break any sort of security you put on it. This is
definitely a problem that you should consider, but you should also consider the
fact that the vast majority of break-ins occur remotely, over a network, from
people who do not have physical access to your workstation or servers.

Using something like Kerberos also gives you the ability to disable or change
the password for a staff account in one place, and have it immediately affect
all the machines on which the staff member may have an account. If a staff
member's account gets compromised, the ability to instantly change his password
on all machines should not be underrated. With discrete passwords, changing a
password on N machines can be a mess. You can also impose re-passwording
restrictions with Kerberos: not only can a Kerberos ticket be made to timeout
after a while, but the Kerberos system can require that the user choose a new
password after a certain period of time (say, once a month).

15.3.2.Â Securing Root-run Servers and SUID/SGID Binaries

The prudent sysadmin only runs the servers he needs to, no more, no less. Be
aware that third party servers are often the most bug-prone. For example,
running an old version of imapd or popper is like giving a universal root
ticket out to the entire world. Never run a server that you have not checked
out carefully. Many servers do not need to be run as root. For example, the 
ntalk, comsat, and finger daemons can be run in special user sandboxes. A
sandbox is not perfect, unless you go through a large amount of trouble, but
the onion approach to security still stands: If someone is able to break in
through a server running in a sandbox, they still have to break out of the
sandbox. The more layers the attacker must break through, the lower the
likelihood of his success. Root holes have historically been found in virtually
every server ever run as root, including basic system servers. If you are
running a machine through which people only login via sshd and never login via 
telnetd or rshd or rlogind, then turn off those services!

FreeBSD now defaults to running ntalkd, comsat, and finger in a sandbox.
Another program which may be a candidate for running in a sandbox is named(8).
/etc/defaults/rc.conf includes the arguments necessary to run named in a
sandbox in a commented-out form. Depending on whether you are installing a new
system or upgrading an existing system, the special user accounts used by these
sandboxes may not be installed. The prudent sysadmin would research and
implement sandboxes for servers whenever possible.

There are a number of other servers that typically do not run in sandboxes: 
sendmail, popper, imapd, ftpd, and others. There are alternatives to some of
these, but installing them may require more work than you are willing to
perform (the convenience factor strikes again). You may have to run these
servers as root and rely on other mechanisms to detect break-ins that might
occur through them.

The other big potential root holes in a system are the suid-root and sgid
binaries installed on the system. Most of these binaries, such as rlogin,
reside in /bin, /sbin, /usr/bin, or /usr/sbin. While nothing is 100% safe, the
system-default suid and sgid binaries can be considered reasonably safe. Still,
root holes are occasionally found in these binaries. A root hole was found in
Xlib in 1998 that made xterm (which is typically suid) vulnerable. It is better
to be safe than sorry and the prudent sysadmin will restrict suid binaries,
that only staff should run, to a special group that only staff can access, and
get rid of (chmod 000) any suid binaries that nobody uses. A server with no
display generally does not need an xterm binary. Sgid binaries can be almost as
dangerous. If an intruder can break an sgid-kmem binary, the intruder might be
able to read /dev/kmem and thus read the encrypted password file, potentially
compromising any passworded account. Alternatively an intruder who breaks group
kmem can monitor keystrokes sent through ptys, including ptys used by users who
login through secure methods. An intruder that breaks the tty group can write
to almost any user's tty. If a user is running a terminal program or emulator
with a keyboard-simulation feature, the intruder can potentially generate a
data stream that causes the user's terminal to echo a command, which is then
run as that user.

15.3.3.Â Securing User Accounts

User accounts are usually the most difficult to secure. While you can impose
draconian access restrictions on your staff and â  starâ   out their passwords,
you may not be able to do so with any general user accounts you might have. If
you do have sufficient control, then you may win out and be able to secure the
user accounts properly. If not, you simply have to be more vigilant in your
monitoring of those accounts. Use of ssh and Kerberos for user accounts is more
problematic, due to the extra administration and technical support required,
but still a very good solution compared to a encrypted password file.

15.3.4.Â Securing the Password File

The only sure fire way is to star out as many passwords as you can and use ssh
or Kerberos for access to those accounts. Even though the encrypted password
file (/etc/spwd.db) can only be read by root, it may be possible for an
intruder to obtain read access to that file even if the attacker cannot obtain
root-write access.

Your security scripts should always check for and report changes to the
password file (see the Checking file integrity section below).

15.3.5.Â Securing the Kernel Core, Raw Devices, and File Systems

If an attacker breaks root he can do just about anything, but there are certain
conveniences. For example, most modern kernels have a packet sniffing device
driver built in. Under FreeBSD it is called the bpf device. An intruder will
commonly attempt to run a packet sniffer on a compromised machine. You do not
need to give the intruder the capability and most systems do not have the need
for the bpf device compiled in.

But even if you turn off the bpf device, you still have /dev/mem and /dev/kmem
to worry about. For that matter, the intruder can still write to raw disk
devices. Also, there is another kernel feature called the module loader,
kldload(8). An enterprising intruder can use a KLD module to install his own
bpf device, or other sniffing device, on a running kernel. To avoid these
problems you have to run the kernel at a higher secure level, at least
securelevel 1.

The secure level of the kernel can be set in a variety of ways. The simplest
way of raising the secure level of a running kernel is through a sysctl on the
kern.securelevel kernel variable:

# sysctl kern.securelevel=1

By default, the FreeBSD kernel boots with a secure level of -1. The secure
level will remain at -1 unless it is altered, either by the administrator or by
init(8) because of a setting in the start up scripts. The secure level may be
raised during system startup by setting the kern_securelevel_enable variable to
YES in the /etc/rc.conf file, and the value of the kern_securelevel variable to
the desired secure level.

The default secure level of a FreeBSD system right after the startup scripts
are done is -1. This is called â  insecure modeâ   because immutable file flags
may be turned off, all devices may be read from or written to, and so on.

Once the secure level is set to 1 or a higher value, the append-only and
immutable files are honored, they cannot be turned off, and access to raw
devices will be denied. Higher levels restrict even more operations. For a full
description of the effect of various secure levels, please read the security(7)
manual page.

Note:

Bumping the secure level to 1 or higher may cause a few problems to X11 (access
to /dev/io will be blocked), or to the installation of FreeBSD built from
source (the installworld part of the process needs to temporarily reset the
append-only and immutable flags of some files), and in a few other cases.
Sometimes, as in the case of X11, it may be possible to work around this by
starting xdm(1) pretty early in the boot process, when the securelevel is still
low enough. Workarounds like this may not be possible for all secure levels or
for all the potential restrictions they enforce. A bit of forward planning is a
good idea. Understanding the restrictions imposed by each secure level is
important as they severely diminish the ease of system use. It will also make
choosing a default setting much simpler and prevent any surprises.

If the kernel's secure level is raised to 1 or a higher value, it may be useful
to set the schg flag on critical startup binaries, directories, and script
files (i.e., everything that gets run up to the point where the securelevel is
set). This might be overdoing it, and upgrading the system is much more
difficult when it operates at a high secure level. A less strict compromise is
to run the system at a higher secure level but skip setting the schg flag for
every system file and directory under the sun. Another possibility is to simply
mount / and /usr read-only. It should be noted that being too draconian about
what is permitted may prevent the all-important detection of an intrusion.

15.3.6.Â Checking File Integrity: Binaries, Configuration Files, Etc.

When it comes right down to it, you can only protect your core system
configuration and control files so much before the convenience factor rears its
ugly head. For example, using chflags to set the schg bit on most of the files
in / and /usr is probably counterproductive, because while it may protect the
files, it also closes a detection window. The last layer of your security onion
is perhaps the most important â   detection. The rest of your security is
pretty much useless (or, worse, presents you with a false sense of security) if
you cannot detect potential intrusions. Half the job of the onion is to slow
down the attacker, rather than stop him, in order to be able to catch him in
the act.

The best way to detect an intrusion is to look for modified, missing, or
unexpected files. The best way to look for modified files is from another
(often centralized) limited-access system. Writing your security scripts on the
extra-secure limited-access system makes them mostly invisible to potential
attackers, and this is important. In order to take maximum advantage you
generally have to give the limited-access box significant access to the other
machines in the business, usually either by doing a read-only NFS export of the
other machines to the limited-access box, or by setting up ssh key-pairs to
allow the limited-access box to ssh to the other machines. Except for its
network traffic, NFS is the least visible method â   allowing you to monitor
the file systems on each client box virtually undetected. If your
limited-access server is connected to the client boxes through a switch, the
NFS method is often the better choice. If your limited-access server is
connected to the client boxes through a hub, or through several layers of
routing, the NFS method may be too insecure (network-wise) and using ssh may be
the better choice even with the audit-trail tracks that ssh lays.

Once you have given a limited-access box at least read access to the client
systems it is supposed to monitor, you must write scripts to do the actual
monitoring. Given an NFS mount, you can write scripts out of simple system
utilities such as find(1) and md5(1). It is best to physically md5 the
client-box files at least once a day, and to test control files such as those
found in /etc and /usr/local/etc even more often. When mismatches are found,
relative to the base md5 information the limited-access machine knows is valid,
it should scream at a sysadmin to go check it out. A good security script will
also check for inappropriate suid binaries and for new or deleted files on
system partitions such as / and /usr.

When using ssh rather than NFS, writing the security script is much more
difficult. You essentially have to scp the scripts to the client box in order
to run them, making them visible, and for safety you also need to scp the
binaries (such as find) that those scripts use. The ssh client on the client
box may already be compromised. All in all, using ssh may be necessary when
running over insecure links, but it is also a lot harder to deal with.

A good security script will also check for changes to user and staff members
access configuration files: .rhosts, .shosts, .ssh/authorized_keys and so
forth, files that might fall outside the purview of the MD5 check.

If you have a huge amount of user disk space, it may take too long to run
through every file on those partitions. In this case, setting mount flags to
disallow suid binaries is a good idea. The nosuid option (see mount(8)) is what
you want to look into. You should probably scan them anyway, at least once a
week, since the object of this layer is to detect a break-in attempt, whether
or not the attempt succeeds.

Process accounting (see accton(8)) is a relatively low-overhead feature of the
operating system which might help as a post-break-in evaluation mechanism. It
is especially useful in tracking down how an intruder has actually broken into
a system, assuming the file is still intact after the break-in has occurred.

Finally, security scripts should process the log files, and the logs themselves
should be generated in as secure a manner as possible â   remote syslog can be
very useful. An intruder will try to cover his tracks, and log files are
critical to the sysadmin trying to track down the time and method of the
initial break-in. One way to keep a permanent record of the log files is to run
the system console to a serial port and collect the information to a secure
machine monitoring the consoles.

15.3.7.Â Paranoia

A little paranoia never hurts. As a rule, a sysadmin can add any number of
security features, as long as they do not affect convenience, and can add
security features that do affect convenience with some added thought. Even more
importantly, a security administrator should mix it up a bit â   if you use
recommendations such as those given by this document verbatim, you give away
your methodologies to the prospective attacker who also has access to this
document.

15.3.8.Â Denial of Service Attacks

This section covers Denial of Service attacks. A DoS attack is typically a
packet attack. While there is not much you can do about modern spoofed packet
attacks that saturate your network, you can generally limit the damage by
ensuring that the attacks cannot take down your servers by:

 1. Limiting server forks.

 2. Limiting springboard attacks (ICMP response attacks, ping broadcast, etc.).

 3. Overloading the Kernel Route Cache.

A common DoS attack scenario is attacking a forking server and making it spawn
so many child processes that the host system eventually runs out of memory,
file descriptors, etc. and then grinds to a halt. inetd (see inetd(8)) has
several options to limit this sort of attack. It should be noted that while it
is possible to prevent a machine from going down, it is not generally possible
to prevent a service from being disrupted by the attack. Read the inetd manual
page carefully and pay specific attention to the -c, -C, and -R options. Note
that spoofed-IP attacks will circumvent the -C option to inetd, so typically a
combination of options must be used. Some standalone servers have
self-fork-limitation parameters.

Sendmail has its -OMaxDaemonChildren option, which tends to work much better
than trying to use Sendmail's load limiting options due to the load lag. You
should specify a MaxDaemonChildren parameter, when you start sendmail; high
enough to handle your expected load, but not so high that the computer cannot
handle that number of Sendmail instances without falling on its face. It is
also prudent to run Sendmail in queued mode (-ODeliveryMode=queued) and to run
the daemon (sendmail -bd) separate from the queue-runs (sendmail -q15m). If you
still want real-time delivery you can run the queue at a much lower interval,
such as -q1m, but be sure to specify a reasonable MaxDaemonChildren option for 
that Sendmail to prevent cascade failures.

Syslogd can be attacked directly and it is strongly recommended that you use
the -s option whenever possible, and the -a option otherwise.

You should also be fairly careful with connect-back services such as TCP
Wrapper's reverse-identd, which can be attacked directly. You generally do not
want to use the reverse-ident feature of TCP Wrapper for this reason.

It is a very good idea to protect internal services from external access by
firewalling them off at your border routers. The idea here is to prevent
saturation attacks from outside your LAN, not so much to protect internal
services from network-based root compromise. Always configure an exclusive
firewall, i.e., â  firewall everything except ports A, B, C, D, and M-Zâ  .
This way you can firewall off all of your low ports except for certain specific
services such as named (if you are primary for a zone), ntalkd, sendmail, and
other Internet-accessible services. If you try to configure the firewall the
other way â   as an inclusive or permissive firewall, there is a good chance
that you will forget to â  closeâ   a couple of services, or that you will add
a new internal service and forget to update the firewall. You can still open up
the high-numbered port range on the firewall, to allow permissive-like
operation, without compromising your low ports. Also take note that FreeBSD
allows you to control the range of port numbers used for dynamic binding, via
the various net.inet.ip.portrange sysctl's (sysctl -a | fgrep portrange), which
can also ease the complexity of your firewall's configuration. For example, you
might use a normal first/last range of 4000 to 5000, and a hiport range of
49152 to 65535, then block off everything under 4000 in your firewall (except
for certain specific Internet-accessible ports, of course).

Another common DoS attack is called a springboard attack â   to attack a server
in a manner that causes the server to generate responses which overloads the
server, the local network, or some other machine. The most common attack of
this nature is the ICMP ping broadcast attack. The attacker spoofs ping packets
sent to your LAN's broadcast address with the source IP address set to the
actual machine they wish to attack. If your border routers are not configured
to stomp on ping packets to broadcast addresses, your LAN winds up generating
sufficient responses to the spoofed source address to saturate the victim,
especially when the attacker uses the same trick on several dozen broadcast
addresses over several dozen different networks at once. Broadcast attacks of
over a hundred and twenty megabits have been measured. A second common
springboard attack is against the ICMP error reporting system. By constructing
packets that generate ICMP error responses, an attacker can saturate a server's
incoming network and cause the server to saturate its outgoing network with
ICMP responses. This type of attack can also crash the server by running it out
of memory, especially if the server cannot drain the ICMP responses it
generates fast enough. Use the sysctl variable net.inet.icmp.icmplim to limit
these attacks. The last major class of springboard attacks is related to
certain internal inetd services such as the udp echo service. An attacker
simply spoofs a UDP packet with the source address being server A's echo port,
and the destination address being server B's echo port, where server A and B
are both on your LAN. The two servers then bounce this one packet back and
forth between each other. The attacker can overload both servers and their LANs
simply by injecting a few packets in this manner. Similar problems exist with
the internal chargen port. A competent sysadmin will turn off all of these
inetd-internal test services.

Spoofed packet attacks may also be used to overload the kernel route cache.
Refer to the net.inet.ip.rtexpire, rtminexpire, and rtmaxcache sysctl
parameters. A spoofed packet attack that uses a random source IP will cause the
kernel to generate a temporary cached route in the route table, viewable with
netstat -rna | fgrep W3. These routes typically timeout in 1600 seconds or so.
If the kernel detects that the cached route table has gotten too big it will
dynamically reduce the rtexpire but will never decrease it to less than
rtminexpire. There are two problems:

 1. The kernel does not react quickly enough when a lightly loaded server is
    suddenly attacked.

 2. The rtminexpire is not low enough for the kernel to survive a sustained
    attack.

If your servers are connected to the Internet via a T3 or better, it may be
prudent to manually override both rtexpire and rtminexpire via sysctl(8). Never
set either parameter to zero (unless you want to crash the machine). Setting
both parameters to 2 seconds should be sufficient to protect the route table
from attack.

15.3.9.Â Access Issues with Kerberos and SSH

There are a few issues with both Kerberos and ssh that need to be addressed if
you intend to use them. Kerberos 5 is an excellent authentication protocol, but
there are bugs in the kerberized telnet and rlogin applications that make them
unsuitable for dealing with binary streams. Also, by default Kerberos does not
encrypt a session unless you use the -x option. ssh encrypts everything by
default.

Ssh works quite well in every respect except that it forwards encryption keys
by default. What this means is that if you have a secure workstation holding
keys that give you access to the rest of the system, and you ssh to an insecure
machine, your keys are usable. The actual keys themselves are not exposed, but
ssh installs a forwarding port for the duration of your login, and if an
attacker has broken root on the insecure machine he can utilize that port to
use your keys to gain access to any other machine that your keys unlock.

We recommend that you use ssh in combination with Kerberos whenever possible
for staff logins. Ssh can be compiled with Kerberos support. This reduces your
reliance on potentially exposed ssh keys while at the same time protecting
passwords via Kerberos. Ssh keys should only be used for automated tasks from
secure machines (something that Kerberos is unsuited to do). We also recommend
that you either turn off key-forwarding in the ssh configuration, or that you
make use of the from=IP/DOMAIN option that ssh allows in its authorized_keys
file to make the key only usable to entities logging in from specific machines.

15.4.Â DES, Blowfish, MD5, SHA256, SHA512, and Crypt

Parts rewritten and updated by Bill Swingle.

Every user on a UNIXÂ® system has a password associated with their account. It
seems obvious that these passwords need to be known only to the user and the
actual operating system. In order to keep these passwords secret, they are
encrypted with what is known as a â  one-way hashâ  , that is, they can only be
easily encrypted but not decrypted. In other words, what we told you a moment
ago was obvious is not even true: the operating system itself does not really
know the password. It only knows the encrypted form of the password. The only
way to get the â  plain-textâ   password is by a brute force search of the
space of possible passwords.

Unfortunately the only secure way to encrypt passwords when UNIXÂ® came into
being was based on DES, the Data Encryption Standard. This was not such a
problem for users resident in the US, but since the source code for DES could
not be exported outside the US, FreeBSD had to find a way to both comply with
US law and retain compatibility with all the other UNIXÂ® variants that still
used DES.

The solution was to divide up the encryption libraries so that US users could
install the DES libraries and use DES but international users still had an
encryption method that could be exported abroad. This is how FreeBSD came to
use MD5 as its default encryption method. MD5 is believed to be more secure
than DES, so installing DES is offered primarily for compatibility reasons.

15.4.1.Â Recognizing Your Crypt Mechanism

Currently the library supports DES, MD5, Blowfish, SHA256, and SHA512 hash
functions. By default FreeBSDÂ 9.1 and later uses SHA512 to encrypt passwords.
Older versions use MD5 by default.

It is pretty easy to identify which encryption method FreeBSD is set up to use.
Examining the encrypted passwords in the /etc/master.passwd file is one way.
Passwords encrypted with the MD5 hash are longer than those encrypted with the
DES hash and also begin with the characters $1$. Passwords starting with $2a$
are encrypted with the Blowfish hash function. DES password strings do not have
any particular identifying characteristics, but they are shorter than MD5
passwords, and are coded in a 64-character alphabet which does not include the
$ character, so a relatively short string which does not begin with a dollar
sign is very likely a DES password. Both SHA256 and SHA512 begin with the
characters $6$.

The password format used for new passwords is controlled by the passwd_format
login capability in /etc/login.conf, which takes values of des, md5, blf,
sha256 or sha512. See the login.conf(5) manual page for more information about
login capabilities.

15.5.Â One-time Passwords

By default, FreeBSD includes support for OPIE (One-time Passwords In
Everything), which uses the MD5 hash by default.

There are three different sorts of passwords which we will discuss below. The
first is your usual UNIXÂ® style or Kerberos password; we will call this a â  
UNIXÂ® passwordâ  . The second sort is the one-time password which is generated
by the OPIE opiekey(1) program and accepted by the opiepasswd(1) program and
the login prompt; we will call this a â  one-time passwordâ  . The final sort
of password is the secret password which you give to the opiekey program (and
sometimes the opiepasswd programs) which it uses to generate one-time
passwords; we will call it a â  secret passwordâ   or just unqualified â  
passwordâ  .

The secret password does not have anything to do with your UNIXÂ® password;
they can be the same but this is not recommended. OPIE secret passwords are not
limited to 8 characters like old UNIXÂ® passwords^[5], they can be as long as
you like. Passwords of six or seven word long phrases are fairly common. For
the most part, the OPIE system operates completely independently of the UNIXÂ®
password system.

Besides the password, there are two other pieces of data that are important to
OPIE. One is what is known as the â  seedâ   or â  keyâ  , consisting of two
letters and five digits. The other is what is called the â  iteration countâ  ,
a number between 1 and 100. OPIE creates the one-time password by concatenating
the seed and the secret password, then applying the MD5 hash as many times as
specified by the iteration count and turning the result into six short English
words. These six English words are your one-time password. The authentication
system (primarily PAM) keeps track of the last one-time password used, and the
user is authenticated if the hash of the user-provided password is equal to the
previous password. Because a one-way hash is used it is impossible to generate
future one-time passwords if a successfully used password is captured; the
iteration count is decremented after each successful login to keep the user and
the login program in sync. When the iteration count gets down to 1, OPIE must
be reinitialized.

There are a few programs involved in each system which we will discuss below.
The opiekey program accepts an iteration count, a seed, and a secret password,
and generates a one-time password or a consecutive list of one-time passwords.
The opiepasswd program is used to initialize OPIE, and to change passwords,
iteration counts, or seeds; it takes either a secret passphrase, or an
iteration count, seed, and a one-time password. The opieinfo program will
examine the relevant credentials files (/etc/opiekeys) and print out the
invoking user's current iteration count and seed.

There are four different sorts of operations we will cover. The first is using
opiepasswd over a secure connection to set up one-time-passwords for the first
time, or to change your password or seed. The second operation is using
opiepasswd over an insecure connection, in conjunction with opiekey over a
secure connection, to do the same. The third is using opiekey to log in over an
insecure connection. The fourth is using opiekey to generate a number of keys
which can be written down or printed out to carry with you when going to some
location without secure connections to anywhere.

15.5.1.Â Secure Connection Initialization

To initialize OPIE for the first time, execute the opiepasswd command:

% opiepasswd -c [grimreaper] ~ $ opiepasswd -f -c Adding unfurl: Only use this
method from the console; NEVER from remote. If you are using telnet, xterm, or
a dial-in, type ^C now or exit with no password. Then run opiepasswd without
the -c parameter. Using MD5 to compute responses. Enter new secret pass phrase:
Again new secret pass phrase: ID unfurl OTP key is 499 to4268 MOS MALL GOAT ARM
AVID COED

At the Enter new secret pass phrase: or Enter secret password: prompts, you
should enter a password or phrase. Remember, this is not the password that you
will use to login with, this is used to generate your one-time login keys. The 
â  IDâ   line gives the parameters of your particular instance: your login
name, the iteration count, and seed. When logging in the system will remember
these parameters and present them back to you so you do not have to remember
them. The last line gives the particular one-time password which corresponds to
those parameters and your secret password; if you were to re-login immediately,
this one-time password is the one you would use.

15.5.2.Â Insecure Connection Initialization

To initialize or change your secret password over an insecure connection, you
will need to already have a secure connection to some place where you can run
opiekey; this might be in the form of a shell prompt on a machine you trust.
You will also need to make up an iteration count (100 is probably a good
value), and you may make up your own seed or use a randomly-generated one. Over
on the insecure connection (to the machine you are initializing), use
opiepasswd:

% opiepasswd Updating unfurl: You need the response from an OTP generator. Old
secret pass phrase: otp-md5 498 to4268 ext Response: GAME GAG WELT OUT DOWN
CHAT New secret pass phrase: otp-md5 499 to4269 Response: LINE PAP MILK NELL
BUOY TROY ID mark OTP key is 499 gr4269 LINE PAP MILK NELL BUOY TROY

To accept the default seed press Return. Then before entering an access
password, move over to your secure connection and give it the same parameters:

% opiekey 498 to4268 Using the MD5 algorithm to compute response. Reminder:
Don't use opiekey from telnet or dial-in sessions. Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT

Now switch back over to the insecure connection, and copy the one-time password
generated over to the relevant program.

15.5.3.Â Generating a Single One-time Password

Once you have initialized OPIE and login, you will be presented with a prompt
like this:

% telnet example.com Trying 10.0.0.1... Connected to example.com Escape
character is '^]'. FreeBSD/i386 (example.com) (ttypa) login: &lt;username&gt; otp-md5
498 gr4269 ext Password:

As a side note, the OPIE prompts have a useful feature (not shown here): if you
press Return at the password prompt, the prompter will turn echo on, so you can
see what you are typing. This can be extremely useful if you are attempting to
type in a password by hand, such as from a printout.

At this point you need to generate your one-time password to answer this login
prompt. This must be done on a trusted system that you can run opiekey on.
(There are versions of these for DOS, WindowsÂ® and MacÂ OSÂ® as well.) They
need the iteration count and the seed as command line options. You can
cut-and-paste these right from the login prompt on the machine that you are
logging in to.

On the trusted system:

% opiekey 498 to4268 Using the MD5 algorithm to compute response. Reminder:
Don't use opiekey from telnet or dial-in sessions. Enter secret pass phrase:
GAME GAG WELT OUT DOWN CHAT

Now that you have your one-time password you can continue logging in.

15.5.4.Â Generating Multiple One-time Passwords

Sometimes you have to go places where you do not have access to a trusted
machine or secure connection. In this case, it is possible to use the opiekey
command to generate a number of one-time passwords beforehand to be printed out
and taken with you. For example:

% opiekey -n 5 30 zz99999 Using the MD5 algorithm to compute response.
Reminder: Don't use opiekey from telnet or dial-in sessions. Enter secret pass
phrase: &lt;secret password&gt; 26: JOAN BORE FOSS DES NAY QUIT 27: LATE BIAS SLAY
FOLK MUCH TRIG 28: SALT TIN ANTI LOON NEAL USE 29: RIO ODIN GO BYE FURY TIC 30:
GREW JIVE SAN GIRD BOIL PHI

The -n 5 requests five keys in sequence, the 30 specifies what the last
iteration number should be. Note that these are printed out in reverse order of
eventual use. If you are really paranoid, you might want to write the results
down by hand; otherwise you can cut-and-paste into lpr. Note that each line
shows both the iteration count and the one-time password; you may still find it
handy to scratch off passwords as you use them.

15.5.5.Â Restricting Use of UNIXÂ® Passwords

OPIE can restrict the use of UNIXÂ® passwords based on the IP address of a
login session. The relevant file is /etc/opieaccess, which is present by
default. Please check opieaccess(5) for more information on this file and which
security considerations you should be aware of when using it.

Here is a sample opieaccess file:

permit 192.168.0.0 255.255.0.0

This line allows users whose IP source address (which is vulnerable to
spoofing) matches the specified value and mask, to use UNIXÂ® passwords at any
time.

If no rules in opieaccess are matched, the default is to deny non-OPIE logins.

15.6.Â TCP Wrappers

Written by Tom Rhodes.

Anyone familiar with inetd(8) has probably heard of TCP Wrappers at some point.
But few individuals seem to fully comprehend its usefulness in a network
environment. It seems that everyone wants to install a firewall to handle
network connections. While a firewall has a wide variety of uses, there are
some things that a firewall will not handle, such as sending text back to the
connection originator. The TCP Wrappers software does this and much more. In
the next few sections many of the TCP Wrappers features will be discussed, and,
when applicable, example configuration lines will be provided.

The TCP Wrappers software extends the abilities of inetd to provide support for
every server daemon under its control. Using this method it is possible to
provide logging support, return messages to connections, permit a daemon to
only accept internal connections, etc. While some of these features can be
provided by implementing a firewall, this will add not only an extra layer of
protection but go beyond the amount of control a firewall can provide.

The added functionality of TCP Wrappers should not be considered a replacement
for a good firewall. TCP Wrappers can be used in conjunction with a firewall or
other security enhancements though and it can serve nicely as an extra layer of
protection for the system.

Since this is an extension to the configuration of inetd, the reader is
expected have read the inetd configuration section.

Note:

While programs run by inetd(8) are not exactly â  daemonsâ  , they have
traditionally been called daemons. This is the term we will use in this section
too.

15.6.1.Â Initial Configuration

The only requirement of using TCP Wrappers in FreeBSD is to ensure the inetd
server is started from rc.conf with the -Ww option; this is the default
setting. Of course, proper configuration of /etc/hosts.allow is also expected,
but syslogd(8) will throw messages in the system logs in these cases.

Note:

Unlike other implementations of TCP Wrappers, the use of hosts.deny has been
deprecated. All configuration options should be placed in /etc/hosts.allow.

In the simplest configuration, daemon connection policies are set to either be
permitted or blocked depending on the options in /etc/hosts.allow. The default
configuration in FreeBSD is to allow a connection to every daemon started with 
inetd. Changing this will be discussed only after the basic configuration is
covered.

Basic configuration usually takes the form of daemon : address : action. Where
daemon is the daemon name which inetd started. The address can be a valid
hostname, an IP address or an IPv6 address enclosed in brackets ([Â ]). The
action field can be either allow or deny to grant or deny access appropriately.
Keep in mind that configuration works off a first rule match semantic, meaning
that the configuration file is scanned in ascending order for a matching rule.
When a match is found the rule is applied and the search process will halt.

Several other options exist but they will be explained in a later section. A
simple configuration line may easily be constructed from that information
alone. For example, to allow POP3 connections via the mail/qpopper daemon, the
following lines should be appended to hosts.allow:

# This line is required for POP3 connections: qpopper : ALL : allow

After adding this line, inetd will need to be restarted by using service(8):

# service inetd restart

15.6.2.Â Advanced Configuration

TCP Wrappers has advanced options too; they will allow for more control over
the way connections are handled. In some cases it may be a good idea to return
a comment to certain hosts or daemon connections. In other cases, perhaps a log
file should be recorded or an email sent to the administrator. Other situations
may require the use of a service for local connections only. This is all
possible through the use of configuration options known as wildcards, expansion
characters and external command execution. The next two sections are written to
cover these situations.

15.6.2.1.Â External Commands

Suppose that a situation occurs where a connection should be denied yet a
reason should be sent to the individual who attempted to establish that
connection. How could it be done? That action can be made possible by using the
twist option. When a connection attempt is made, twist will be called to
execute a shell command or script. An example already exists in the hosts.allow
file:

# The rest of the daemons are protected. ALL : ALL \ : severity auth.info \ :
twist /bin/echo "You are not welcome to use %d from %h."

This example shows that the message, â  You are not allowed to use daemon from
hostname.â   will be returned for any daemon not previously configured in the
access file. This is extremely useful for sending a reply back to the
connection initiator right after the established connection is dropped. Note
that any message returned must be wrapped in quote " characters; there are no
exceptions to this rule.

Warning:

It may be possible to launch a denial of service attack on the server if an
attacker, or group of attackers, could flood these daemons with connection
requests.

Another possibility is to use the spawn option in these cases. Like twist, the
spawn option implicitly denies the connection and may be used to run external
shell commands or scripts. Unlike twist, spawn will not send a reply back to
the individual who established the connection. For an example, consider the
following configuration line:

# We do not allow connections from example.com: ALL : .example.com \ : spawn (/
bin/echo %a from %h attempted to access %d &gt;&gt; \ /var/log/connections.log) \ :
deny

This will deny all connection attempts from the *.example.com domain;
simultaneously logging the hostname, IP address and the daemon which they
attempted to access in the /var/log/connections.log file.

Aside from the already explained substitution characters above, e.g., %a, a few
others exist. See the hosts_access(5) manual page for the complete list.

15.6.2.2.Â Wildcard Options

Thus far the ALL option has been used continuously throughout the examples.
Other options exist which could extend the functionality a bit further. For
instance, ALL may be used to match every instance of either a daemon, domain or
an IP address. Another wildcard available is PARANOID which may be used to
match any host which provides an IP address that may be forged. In other words,
PARANOID may be used to define an action to be taken whenever a connection is
made from an IP address that differs from its hostname. The following example
may shed some more light on this discussion:

# Block possibly spoofed requests to sendmail: sendmail : PARANOID : deny

In that example all connection requests to sendmail which have an IP address
that varies from its hostname will be denied.

Caution:

Using the PARANOID wildcard may severely cripple servers if the client or
server has a broken DNS setup. Administrator discretion is advised.

To learn more about wildcards and their associated functionality, see the
hosts_access(5) manual page.

Before any of the specific configuration lines above will work, the first
configuration line should be commented out in hosts.allow. This was noted at
the beginning of this section.

15.7.Â Kerberos5

Contributed by Tillman Hodgson.
Based on a contribution by Mark Murray.

Kerberos is a network add-on system/protocol that allows users to authenticate
themselves through the services of a secure server. Services such as remote
login, remote copy, secure inter-system file copying and other high-risk tasks
are made considerably safer and more controllable.

Kerberos can be described as an identity-verifying proxy system. It can also be
described as a trusted third-party authentication system. Kerberos provides
only one function â   the secure authentication of users on the network. It
does not provide authorization functions (what users are allowed to do) or
auditing functions (what those users did). After a client and server have used 
Kerberos to prove their identity, they can also encrypt all of their
communications to assure privacy and data integrity as they go about their
business.

Therefore it is highly recommended that Kerberos be used with other security
methods which provide authorization and audit services.

The following instructions can be used as a guide on how to set up Kerberos as
distributed for FreeBSD. However, you should refer to the relevant manual pages
for a complete description.

For purposes of demonstrating a Kerberos installation, the various name spaces
will be handled as follows:

  * The DNS domain (â  zoneâ  ) will be example.org.

  * The Kerberos realm will be EXAMPLE.ORG.

Note:

Please use real domain names when setting up Kerberos even if you intend to run
it internally. This avoids DNS problems and assures inter-operation with other 
Kerberos realms.

15.7.1.Â History

Kerberos was created by MIT as a solution to network security problems. The 
Kerberos protocol uses strong cryptography so that a client can prove its
identity to a server (and vice versa) across an insecure network connection.

Kerberos is both the name of a network authentication protocol and an adjective
to describe programs that implement the program (Kerberos telnet, for example).
The current version of the protocol is version 5, described in RFCÂ 1510.

Several free implementations of this protocol are available, covering a wide
range of operating systems. The Massachusetts Institute of Technology (MIT),
where Kerberos was originally developed, continues to develop their Kerberos
package. It is commonly used in the US as a cryptography product, as such it
has historically been affected by US export regulations. The MIT Kerberos is
available as a port (security/krb5). Heimdal Kerberos is another version 5
implementation, and was explicitly developed outside of the US to avoid export
regulations (and is thus often included in non-commercial UNIXÂ® variants). The
Heimdal Kerberos distribution is available as a port (security/heimdal), and a
minimal installation of it is included in the base FreeBSD install.

In order to reach the widest audience, these instructions assume the use of the
Heimdal distribution included in FreeBSD.

15.7.2.Â Setting up a Heimdal KDC

The Key Distribution Center (KDC) is the centralized authentication service
that Kerberos provides â   it is the computer that issues Kerberos tickets. The
KDC is considered â  trustedâ   by all other computers in the Kerberos realm,
and thus has heightened security concerns.

Note that while running the Kerberos server requires very few computing
resources, a dedicated machine acting only as a KDC is recommended for security
reasons.

To begin setting up a KDC, ensure that your /etc/rc.conf file contains the
correct settings to act as a KDC (you may need to adjust paths to reflect your
own system):

kerberos5_server_enable="YES" kadmind5_server_enable="YES"

Next we will set up your Kerberos config file, /etc/krb5.conf:

[libdefaults] default_realm = EXAMPLE.ORG [realms] EXAMPLE.ORG = { kdc =
kerberos.example.org admin_server = kerberos.example.org } [domain_realm]
.example.org = EXAMPLE.ORG

Note that this /etc/krb5.conf file implies that your KDC will have the
fully-qualified hostname of kerberos.example.org. You will need to add a CNAME
(alias) entry to your zone file to accomplish this if your KDC has a different
hostname.

Note:

For large networks with a properly configured BIND DNS server, the above
example could be trimmed to:

[libdefaults] default_realm = EXAMPLE.ORG

With the following lines being appended to the example.org zonefile:

_kerberos._udp IN SRV 01 00 88 kerberos.example.org. _kerberos._tcp IN SRV 01
00 88 kerberos.example.org. _kpasswd._udp IN SRV 01 00 464
kerberos.example.org. _kerberos-adm._tcp IN SRV 01 00 749 kerberos.example.org.
_kerberos IN TXT EXAMPLE.ORG

Note:

For clients to be able to find the Kerberos services, you must have either a
fully configured /etc/krb5.conf or a minimally configured /etc/krb5.conf and a
properly configured DNS server.

Next we will create the Kerberos database. This database contains the keys of
all principals encrypted with a master password. You are not required to
remember this password, it will be stored in a file (/var/heimdal/m-key). To
create the master key, run kstash and enter a password.

Once the master key has been created, you can initialize the database using the
kadmin program with the -l option (standing for â  localâ  ). This option
instructs kadmin to modify the database files directly rather than going
through the kadmind network service. This handles the chicken-and-egg problem
of trying to connect to the database before it is created. Once you have the
kadmin prompt, use the init command to create your realms initial database.

Lastly, while still in kadmin, create your first principal using the add
command. Stick to the defaults options for the principal for now, you can
always change them later with the modify command. Note that you can use the ?
command at any prompt to see the available options.

A sample database creation session is shown below:

# kstash Master key: xxxxxxxx Verifying password - Master key: xxxxxxxx #
kadmin -l kadmin&gt; init EXAMPLE.ORG Realm max ticket life [unlimited]: kadmin&gt;
add tillman Max ticket life [unlimited]: Max renewable life [unlimited]:
Attributes []: Password: xxxxxxxx Verifying password - Password: xxxxxxxx

Now it is time to start up the KDC services. Run service kerberos start and
service kadmind start to bring up the services. Note that you will not have any
kerberized daemons running at this point but you should be able to confirm that
the KDC is functioning by obtaining and listing a ticket for the principal
(user) that you just created from the command-line of the KDC itself:

% kinit tillman tillman@EXAMPLE.ORG's Password: % klist Credentials cache:
FILE:/tmp/krb5cc_500 Principal: tillman@EXAMPLE.ORG Issued Expires Principal
Aug 27 15:37:58 Aug 28 01:37:58 krbtgt/EXAMPLE.ORG@EXAMPLE.ORG

The ticket can then be revoked when you have finished:

% kdestroy

15.7.3.Â Kerberos Enabling a Server with Heimdal Services

First, we need a copy of the Kerberos configuration file, /etc/krb5.conf. To do
so, simply copy it over to the client computer from the KDC in a secure fashion
(using network utilities, such as scp(1), or physically via a floppy disk).

Next you need a /etc/krb5.keytab file. This is the major difference between a
server providing Kerberos enabled daemons and a workstation â   the server must
have a keytab file. This file contains the server's host key, which allows it
and the KDC to verify each others identity. It must be transmitted to the
server in a secure fashion, as the security of the server can be broken if the
key is made public. This explicitly means that transferring it via a clear text
channel, such as FTP, is a very bad idea.

Typically, you transfer the keytab to the server using the kadmin program. This
is handy because you also need to create the host principal (the KDC end of the
krb5.keytab) using kadmin.

Note that you must have already obtained a ticket and that this ticket must be
allowed to use the kadmin interface in the kadmind.acl. See the section titled 
â  Remote administrationâ   in the Heimdal info pages (info heimdal) for
details on designing access control lists. If you do not want to enable remote
kadmin access, you can simply securely connect to the KDC (via local console,
ssh(1) or Kerberos telnet(1)) and perform administration locally using kadmin
-l.

After installing the /etc/krb5.conf file, you can use kadmin from the Kerberos
server. The add --random-key command will let you add the server's host
principal, and the ext command will allow you to extract the server's host
principal to its own keytab. For example:

# kadmin kadmin&gt; add --random-key host/myserver.example.org Max ticket life
[unlimited]: Max renewable life [unlimited]: Attributes []: kadmin&gt; ext host/
myserver.example.org kadmin&gt; exit

Note that the ext command (short for â  extractâ  ) stores the extracted key in
/etc/krb5.keytab by default.

If you do not have kadmind running on the KDC (possibly for security reasons)
and thus do not have access to kadmin remotely, you can add the host principal
(host/myserver.EXAMPLE.ORG) directly on the KDC and then extract it to a
temporary file (to avoid over-writing the /etc/krb5.keytab on the KDC) using
something like this:

# kadmin kadmin&gt; ext --keytab=/tmp/example.keytab host/myserver.example.org
kadmin&gt; exit

You can then securely copy the keytab to the server computer (using scp or a
floppy, for example). Be sure to specify a non-default keytab name to avoid
over-writing the keytab on the KDC.

At this point your server can communicate with the KDC (due to its krb5.conf
file) and it can prove its own identity (due to the krb5.keytab file). It is
now ready for you to enable some Kerberos services. For this example we will
enable the telnet service by putting a line like this into your /etc/inetd.conf
and then restarting the inetd(8) service with service inetd restart:

telnet stream tcp nowait root /usr/libexec/telnetd telnetd -a user

The critical bit is that the -a (for authentication) type is set to user.
Consult the telnetd(8) manual page for more details.

15.7.4.Â Kerberos Enabling a Client with Heimdal

Setting up a client computer is almost trivially easy. As far as Kerberos
configuration goes, you only need the Kerberos configuration file, located at /
etc/krb5.conf. Simply securely copy it over to the client computer from the KDC
.

Test your client computer by attempting to use kinit, klist, and kdestroy from
the client to obtain, show, and then delete a ticket for the principal you
created above. You should also be able to use Kerberos applications to connect
to Kerberos enabled servers, though if that does not work and obtaining a
ticket does the problem is likely with the server and not with the client or
the KDC.

When testing an application like telnet, try using a packet sniffer (such as
tcpdump(1)) to confirm that your password is not sent in the clear. Try using
telnet with the -x option, which encrypts the entire data stream (similar to
ssh).

Various non-core Kerberos client applications are also installed by default.
This is where the â  minimalâ   nature of the base Heimdal installation is
felt: telnet is the only Kerberos enabled service.

The Heimdal port adds some of the missing client applications: Kerberos enabled
versions of ftp, rsh, rcp, rlogin, and a few other less common programs. The 
MIT port also contains a full suite of Kerberos client applications.

15.7.5.Â User Configuration Files: .k5login and .k5users

Users within a realm typically have their Kerberos principal (such as
tillman@EXAMPLE.ORG) mapped to a local user account (such as a local account
named tillman). Client applications such as telnet usually do not require a
user name or a principal.

Occasionally, however, you want to grant access to a local user account to
someone who does not have a matching Kerberos principal. For example,
tillman@EXAMPLE.ORG may need access to the local user account webdevelopers.
Other principals may also need access to that local account.

The .k5login and .k5users files, placed in a users home directory, can be used
similar to a powerful combination of .hosts and .rhosts, solving this problem.
For example, if a .k5login with the following contents:

tillman@example.org jdoe@example.org

Were to be placed into the home directory of the local user webdevelopers then
both principals listed would have access to that account without requiring a
shared password.

Reading the manual pages for these commands is recommended. Note that the ksu
manual page covers .k5users.

15.7.6.Â Kerberos Tips, Tricks, and Troubleshooting

  * When using either the Heimdal or MIT Kerberos ports ensure that your PATH
    environment variable lists the Kerberos versions of the client applications
    before the system versions.

  * Do all the computers in your realm have synchronized time settings? If not,
    authentication may fail. SectionÂ 30.10, â  Clock Synchronization with NTPâ
       describes how to synchronize clocks using NTP.

  * MIT and Heimdal inter-operate nicely. Except for kadmin, the protocol for
    which is not standardized.

  * If you change your hostname, you also need to change your host/ principal
    and update your keytab. This also applies to special keytab entries like
    the www/ principal used for Apache's www/mod_auth_kerb.

  * All hosts in your realm must be resolvable (both forwards and reverse) in 
    DNS (or /etc/hosts as a minimum). CNAMEs will work, but the A and PTR
    records must be correct and in place. The error message is not very
    intuitive: Kerberos5 refuses authentication because Read req failed: Key
    table entry not found.

  * Some operating systems that may being acting as clients to your KDC do not
    set the permissions for ksu to be setuid root. This means that ksu does not
    work, which is a good security idea but annoying. This is not a KDC error.

  * With MIT Kerberos, if you want to allow a principal to have a ticket life
    longer than the default ten hours, you must use modify_principal in kadmin
    to change the maxlife of both the principal in question and the krbtgt
    principal. Then the principal can use the -l option with kinit to request a
    ticket with a longer lifetime.

  * Note:

    If you run a packet sniffer on your KDC to add in troubleshooting and then
    run kinit from a workstation, you will notice that your TGT is sent
    immediately upon running kinit â   even before you type your password! The
    explanation is that the Kerberos server freely transmits a TGT (Ticket
    Granting Ticket) to any unauthorized request; however, every TGT is
    encrypted in a key derived from the user's password. Therefore, when a user
    types their password it is not being sent to the KDC, it is being used to
    decrypt the TGT that kinit already obtained. If the decryption process
    results in a valid ticket with a valid time stamp, the user has valid 
    Kerberos credentials. These credentials include a session key for
    establishing secure communications with the Kerberos server in the future,
    as well as the actual ticket-granting ticket, which is actually encrypted
    with the Kerberos server's own key. This second layer of encryption is
    unknown to the user, but it is what allows the Kerberos server to verify
    the authenticity of each TGT.

  * If you want to use long ticket lifetimes (a week, for example) and you are
    using OpenSSH to connect to the machine where your ticket is stored, make
    sure that Kerberos TicketCleanup is set to no in your sshd_config or else
    your tickets will be deleted when you log out.

  * Remember that host principals can have a longer ticket lifetime as well. If
    your user principal has a lifetime of a week but the host you are
    connecting to has a lifetime of nine hours, you will have an expired host
    principal in your cache and the ticket cache will not work as expected.

  * When setting up a krb5.dict file to prevent specific bad passwords from
    being used (the manual page for kadmind covers this briefly), remember that
    it only applies to principals that have a password policy assigned to them.
    The krb5.dict files format is simple: one string per line. Creating a
    symbolic link to /usr/share/dict/words might be useful.

15.7.7.Â Differences with the MIT Port

The major difference between the MIT and Heimdal installs relates to the kadmin
program which has a different (but equivalent) set of commands and uses a
different protocol. This has a large implications if your KDC is MIT as you
will not be able to use the Heimdal kadmin program to administer your KDC
remotely (or vice versa, for that matter).

The client applications may also take slightly different command line options
to accomplish the same tasks. Following the instructions on the MIT Kerberos
web site (http://web.mit.edu/Kerberos/www/) is recommended. Be careful of path
issues: the MIT port installs into /usr/local/ by default, and the â  normalâ  
system applications may be run instead of MIT if your PATH environment variable
lists the system directories first.

Note:

With the MIT security/krb5 port that is provided by FreeBSD, be sure to read
the /usr/local/share/doc/krb5/README.FreeBSD file installed by the port if you
want to understand why logins via telnetd and klogind behave somewhat oddly.
Most importantly, correcting the â  incorrect permissions on cache fileâ  
behavior requires that the login.krb5 binary be used for authentication so that
it can properly change ownership for the forwarded credentials.

The rc.conf must also be modified to contain the following configuration:

kerberos5_server="/usr/local/sbin/krb5kdc" kadmind5_server="/usr/local/sbin/
kadmind" kerberos5_server_enable="YES" kadmind5_server_enable="YES"

This is done because the applications for MIT kerberos installs binaries in the
/usr/local hierarchy.

15.7.8.Â Mitigating Limitations Found in Kerberos

15.7.8.1.Â Kerberos is an all-or-nothing approach

Every service enabled on the network must be modified to work with Kerberos (or
be otherwise secured against network attacks) or else the users credentials
could be stolen and re-used. An example of this would be Kerberos enabling all
remote shells (via rsh and telnet, for example) but not converting the POP3
mail server which sends passwords in plain text.

15.7.8.2.Â Kerberos is Intended for Single-User Workstations

In a multi-user environment, Kerberos is less secure. This is because it stores
the tickets in the /tmp directory, which is readable by all users. If a user is
sharing a computer with several other people simultaneously (i.e. multi-user),
it is possible that the user's tickets can be stolen (copied) by another user.

This can be overcome with the -c filename command-line option or (preferably)
the KRB5CCNAME environment variable, but this is rarely done. In principal,
storing the ticket in the users home directory and using simple file
permissions can mitigate this problem.

15.7.8.3.Â The KDC is a Single Point of Failure

By design, the KDC must be as secure as the master password database is
contained on it. The KDC should have absolutely no other services running on it
and should be physically secured. The danger is high because Kerberos stores
all passwords encrypted with the same key (the â  masterâ   key), which in turn
is stored as a file on the KDC.

As a side note, a compromised master key is not quite as bad as one might
normally fear. The master key is only used to encrypt the Kerberos database and
as a seed for the random number generator. As long as access to your KDC is
secure, an attacker cannot do much with the master key.

Additionally, if the KDC is unavailable (perhaps due to a denial of service
attack or network problems) the network services are unusable as authentication
can not be performed, a recipe for a denial-of-service attack. This can
alleviated with multiple KDCs (a single master and one or more slaves) and with
careful implementation of secondary or fall-back authentication (PAM is
excellent for this).

15.7.8.4.Â Kerberos Shortcomings

Kerberos allows users, hosts and services to authenticate between themselves.
It does not have a mechanism to authenticate the KDC to the users, hosts or
services. This means that a trojanned kinit (for example) could record all user
names and passwords. Something like security/tripwire or other file system
integrity checking tools can alleviate this.

15.7.9.Â Resources and further information

  * The Kerberos FAQ

  * Designing an Authentication System: a Dialog in Four Scenes

  * RFC 1510, The Kerberos Network Authentication Service (V5)

  * MIT Kerberos home page

  * Heimdal Kerberos home page

15.8.Â OpenSSL

Written by Tom Rhodes.

One feature that many users overlook is the OpenSSL toolkit included in
FreeBSD. OpenSSL provides an encryption transport layer on top of the normal
communications layer; thus allowing it to be intertwined with many network
applications and services.

Some uses of OpenSSL may include encrypted authentication of mail clients, web
based transactions such as credit card payments and more. Many ports such as
www/apache22, and mail/claws-mail will offer compilation support for building
with OpenSSL.

Note:

In most cases the Ports Collection will attempt to build the security/openssl
port unless the WITH_OPENSSL_BASE make variable is explicitly set to â  yesâ  .

The version of OpenSSL included in FreeBSD supports Secure Sockets Layer v2/v3
(SSLv2/SSLv3), Transport Layer Security v1 (TLSv1) network security protocols
and can be used as a general cryptographic library.

Note:

While OpenSSL supports the IDEA algorithm, it is disabled by default due to
United States patents. To use it, the license should be reviewed and, if the
restrictions are acceptable, the MAKE_IDEA variable must be set in make.conf.

One of the most common uses of OpenSSL is to provide certificates for use with
software applications. These certificates ensure that the credentials of the
company or individual are valid and not fraudulent. If the certificate in
question has not been verified by one of the several â  Certificate Authorities
â  , or CAs, a warning is usually produced. A Certificate Authority is a
company, such as VeriSign, which will sign certificates in order to validate
credentials of individuals or companies. This process has a cost associated
with it and is definitely not a requirement for using certificates; however, it
can put some of the more paranoid users at ease.

15.8.1.Â Generating Certificates

To generate a certificate, the following command is available:

# openssl req -new -nodes -out req.pem -keyout cert.pem Generating a 1024 bit
RSA private key ................++++++
.......................................++++++ writing new private key to
'cert.pem' ----- You are about to be asked to enter information that will be
incorporated into your certificate request. What you are about to enter is what
is called a Distinguished Name or a DN. There are quite a few fields but you
can leave some blank For some fields there will be a default value, If you
enter '.', the field will be left blank. ----- Country Name (2 letter code)
[AU]:US State or Province Name (full name) [Some-State]:PA Locality Name (eg,
city) []:Pittsburgh Organization Name (eg, company) [Internet Widgits Pty Ltd]:
My Company Organizational Unit Name (eg, section) []:Systems Administrator
Common Name (eg, YOUR name) []:localhost.example.org Email Address []:
trhodes@FreeBSD.org Please enter the following 'extra' attributes to be sent
with your certificate request A challenge password []:SOME PASSWORD An optional
company name []:Another Name

Notice the response directly after the â  Common Nameâ   prompt shows a domain
name. This prompt requires a server name to be entered for verification
purposes; placing anything but a domain name would yield a useless certificate.
Other options, for instance expire time, alternate encryption algorithms, etc.
are available. A complete list may be obtained by viewing the openssl(1) manual
page.

Two files should now exist in the directory in which the aforementioned command
was issued. The certificate request, req.pem, may be sent to a certificate
authority who will validate the credentials that you entered, sign the request
and return the certificate to you. The second file created will be named
cert.pem and is the private key for the certificate and should be protected at
all costs; if this falls in the hands of others it can be used to impersonate
you (or your server).

In cases where a signature from a CA is not required, a self signed certificate
can be created. First, generate the RSA key:

# openssl dsaparam -rand -genkey -out myRSA.key 1024

Next, generate the CA key:

# openssl gendsa -des3 -out myca.key myRSA.key

Use this key to create the certificate:

# openssl req -new -x509 -days 365 -key myca.key -out new.crt

Two new files should appear in the directory: a certificate authority signature
file, myca.key and the certificate itself, new.crt. These should be placed in a
directory, preferably under /etc, which is readable only by root. Permissions
of 0700 should be fine for this and they can be set with the chmod utility.

15.8.2.Â Using Certificates, an Example

So what can these files do? A good use would be to encrypt connections to the 
Sendmail MTA. This would dissolve the use of clear text authentication for
users who send mail via the local MTA.

Note:

This is not the best use in the world as some MUAs will present the user with
an error if they have not installed the certificate locally. Refer to the
documentation included with the software for more information on certificate
installation.

The following lines should be placed inside the local .mc file:

dnl SSL Options define(`confCACERT_PATH',`/etc/certs')dnl define(`confCACERT',
`/etc/certs/new.crt')dnl define(`confSERVER_CERT',`/etc/certs/new.crt')dnl
define(`confSERVER_KEY',`/etc/certs/myca.key')dnl define(`confTLS_SRV_OPTIONS',
`V')dnl

Where /etc/certs/ is the directory to be used for storing the certificate and
key files locally. The last few requirements are a rebuild of the local .cf
file. This is easily achieved by typing make install within the /etc/mail
directory. Follow that up with make restart which should start the Sendmail
daemon.

If all went well there will be no error messages in the /var/log/maillog file
and Sendmail will show up in the process list.

For a simple test, simply connect to the mail server using the telnet(1)
utility:

# telnet example.com 25 Trying 192.0.34.166... Connected to example.com. Escape
character is '^]'. 220 example.com ESMTP Sendmail 8.12.10/8.12.10; Tue, 31 Aug
2004 03:41:22 -0400 (EDT) ehlo example.com 250-example.com Hello example.com
[192.0.34.166], pleased to meet you 250-ENHANCEDSTATUSCODES 250-PIPELINING
250-8BITMIME 250-SIZE 250-DSN 250-ETRN 250-AUTH LOGIN PLAIN 250-STARTTLS
250-DELIVERBY 250 HELP quit 221 2.0.0 example.com closing connection Connection
closed by foreign host.

If the â  STARTTLSâ   line appears in the output then everything is working
correctly.

15.9.Â VPN over IPsec

Written by Nik Clayton.

Creating a VPN between two networks, separated by the Internet, using FreeBSD
gateways.

15.9.1.Â Understanding IPsec

Written by Hiten M. Pandya.

This section will guide you through the process of setting up IPsec. In order
to set up IPsec, it is necessary that you are familiar with the concepts of
building a custom kernel (see ChapterÂ 9, Configuring the FreeBSD Kernel).

IPsec is a protocol which sits on top of the Internet Protocol (IP) layer. It
allows two or more hosts to communicate in a secure manner (hence the name).
The FreeBSD IPsec â  network stackâ   is based on the KAME implementation,
which has support for both protocol families, IPv4 and IPv6.

IPsec consists of two sub-protocols:

  * Encapsulated Security Payload ESP), protects the IP packet data from third
    party interference, by encrypting the contents using symmetric cryptography
    algorithms (like Blowfish, 3DES).

  * Authentication Header (AH), protects the IP packet header from third party
    interference and spoofing, by computing a cryptographic checksum and
    hashing the IP packet header fields with a secure hashing function. This is
    then followed by an additional header that contains the hash, to allow the
    information in the packet to be authenticated.

ESP and AH can either be used together or separately, depending on the
environment.

IPsec can either be used to directly encrypt the traffic between two hosts
(known as Transport Mode); or to build â  virtual tunnelsâ   between two
subnets, which could be used for secure communication between two corporate
networks (known as Tunnel Mode). The latter is more commonly known as a Virtual
Private Network (VPN). The ipsec(4) manual page should be consulted for
detailed information on the IPsec subsystem in FreeBSD.

To add IPsec support to your kernel, add the following options to your kernel
configuration file:

options IPSEC #IP security device crypto

If IPsec debugging support is desired, the following kernel option should also
be added:

options IPSEC_DEBUG #debug for IP security

15.9.2.Â The Problem

There is no standard for what constitutes a VPN. VPNs can be implemented using
a number of different technologies, each of which have their own strengths and
weaknesses. This section presents a scenario, and the strategies used for
implementing a VPN for this scenario.

15.9.3.Â The Scenario: Two networks, one home based and one corporate based.
Both are connected to the Internet, and expected, via this VPN to behave as
one.

The premise is as follows:

  * You have at least two sites

  * Both sites are using IP internally

  * Both sites are connected to the Internet, through a gateway that is running
    FreeBSD.

  * The gateway on each network has at least one public IP address.

  * The internal addresses of the two networks can be public or private IP
    addresses, it does not matter. They just may not collide; e.g.: may not
    both use 192.168.1.x.

15.9.4.Â Configuring IPsec on FreeBSD

Written by Tom Rhodes.

To begin, the security/ipsec-tools must be installed from the Ports Collection.
This third party software package provides a number of applications which will
help support the configuration.

The next requirement is to create two gif(4) pseudo-devices which will be used
to tunnel packets and allow both networks to communicate properly. As root, run
the following commands, replacing the internal and external items with the real
internal and external gateways:

# ifconfig gif0 create
# ifconfig gif0 internal1 internal2
# ifconfig gif0 tunnel external1 external2

For example, the corporate LAN's public IP is 172.16.5.4 having a private IP of
10.246.38.1. The home LAN's public IP is 192.168.1.12 with an internal private 
IP of 10.0.0.5.

This may seem confusing, so review the following example output from the
ifconfig(8) command:

Gateway 1: gif0: flags=8051 mtu 1280 tunnel inet 172.16.5.4 --&gt; 192.168.1.12
inet6 fe80::2e0:81ff:fe02:5881%gif0 prefixlen 64 scopeid 0x6 inet 10.246.38.1
--&gt; 10.0.0.5 netmask 0xffffff00 Gateway 2: gif0: flags=8051 mtu 1280 tunnel
inet 192.168.1.12 --&gt; 172.16.5.4 inet 10.0.0.5 --&gt; 10.246.38.1 netmask
0xffffff00 inet6 fe80::250:bfff:fe3a:c1f%gif0 prefixlen 64 scopeid 0x4

Once complete, both private IPs should be reachable using the ping(8) command
like the following output suggests:

priv-net# ping 10.0.0.5 PING 10.0.0.5 (10.0.0.5): 56 data bytes 64 bytes from
10.0.0.5: icmp_seq=0 ttl=64 time=42.786 ms 64 bytes from 10.0.0.5: icmp_seq=1
ttl=64 time=19.255 ms 64 bytes from 10.0.0.5: icmp_seq=2 ttl=64 time=20.440 ms
64 bytes from 10.0.0.5: icmp_seq=3 ttl=64 time=21.036 ms --- 10.0.0.5 ping
statistics --- 4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev = 19.255/25.879/42.786/9.782 ms corp-net# ping
10.246.38.1 PING 10.246.38.1 (10.246.38.1): 56 data bytes 64 bytes from
10.246.38.1: icmp_seq=0 ttl=64 time=28.106 ms 64 bytes from 10.246.38.1:
icmp_seq=1 ttl=64 time=42.917 ms 64 bytes from 10.246.38.1: icmp_seq=2 ttl=64
time=127.525 ms 64 bytes from 10.246.38.1: icmp_seq=3 ttl=64 time=119.896 ms 64
bytes from 10.246.38.1: icmp_seq=4 ttl=64 time=154.524 ms --- 10.246.38.1 ping
statistics --- 5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 28.106/94.594/154.524/49.814 ms

As expected, both sides have the ability to send and receive ICMP packets from
the privately configured addresses. Next, both gateways must be told how to
route packets in order to correctly send traffic from either network. The
following command will achieve this goal:

# corp-net# route add 10.0.0.0 10.0.0.5 255.255.255.0
# corp-net# route add net 10.0.0.0: gateway 10.0.0.5
# priv-net# route add 10.246.38.0 10.246.38.1 255.255.255.0
# priv-net# route add host 10.246.38.0: gateway 10.246.38.1

At this point, internal machines should be reachable from each gateway as well
as from machines behind the gateways. This is easily determined from the
following example:

corp-net# ping 10.0.0.8 PING 10.0.0.8 (10.0.0.8): 56 data bytes 64 bytes from
10.0.0.8: icmp_seq=0 ttl=63 time=92.391 ms 64 bytes from 10.0.0.8: icmp_seq=1
ttl=63 time=21.870 ms 64 bytes from 10.0.0.8: icmp_seq=2 ttl=63 time=198.022 ms
64 bytes from 10.0.0.8: icmp_seq=3 ttl=63 time=22.241 ms 64 bytes from
10.0.0.8: icmp_seq=4 ttl=63 time=174.705 ms --- 10.0.0.8 ping statistics --- 5
packets transmitted, 5 packets received, 0% packet loss round-trip min/avg/max/
stddev = 21.870/101.846/198.022/74.001 ms priv-net# ping 10.246.38.107 PING
10.246.38.1 (10.246.38.107): 56 data bytes 64 bytes from 10.246.38.107:
icmp_seq=0 ttl=64 time=53.491 ms 64 bytes from 10.246.38.107: icmp_seq=1 ttl=64
time=23.395 ms 64 bytes from 10.246.38.107: icmp_seq=2 ttl=64 time=23.865 ms 64
bytes from 10.246.38.107: icmp_seq=3 ttl=64 time=21.145 ms 64 bytes from
10.246.38.107: icmp_seq=4 ttl=64 time=36.708 ms --- 10.246.38.107 ping
statistics --- 5 packets transmitted, 5 packets received, 0% packet loss
round-trip min/avg/max/stddev = 21.145/31.721/53.491/12.179 ms

Setting up the tunnels is the easy part. Configuring a secure link is a much
more in depth process. The following configuration uses pre-shared (PSK) RSA
keys. Aside from the IP addresses, both /usr/local/etc/racoon/racoon.conf files
will be identical and look similar to

path pre_shared_key "/usr/local/etc/racoon/psk.txt"; #location of pre-shared
key file log debug; #log verbosity setting: set to 'notify' when testing and
debugging is complete padding # options are not to be changed { maximum_length
20; randomize off; strict_check off; exclusive_tail off; } timer # timing
options. change as needed { counter 5; interval 20 sec; persend 1; #
natt_keepalive 15 sec; phase1 30 sec; phase2 15 sec; } listen # address [port]
that racoon will listening on { isakmp 172.16.5.4 [500]; isakmp_natt 172.16.5.4
[4500]; } remote 192.168.1.12 [500] { exchange_mode main,aggressive; doi
ipsec_doi; situation identity_only; my_identifier address 172.16.5.4;
peers_identifier address 192.168.1.12; lifetime time 8 hour; passive off;
proposal_check obey; # nat_traversal off; generate_policy off; proposal {
encryption_algorithm blowfish; hash_algorithm md5; authentication_method
pre_shared_key; lifetime time 30 sec; dh_group 1; } } sainfo (address
10.246.38.0/24 any address 10.0.0.0/24 any) # address $network/$netmask $type
address $network/$netmask $type ( $type being any or esp) { # $network must be
the two internal networks you are joining. pfs_group 1; lifetime time 36000
sec; encryption_algorithm blowfish,3des,des; authentication_algorithm
hmac_md5,hmac_sha1; compression_algorithm deflate; }

Explaining every available option, along with those listed in these examples is
beyond the scope of this document. There is plenty of relevant information in
the racoon configuration manual page.

The SPD policies need to be configured so FreeBSD and racoon is able to encrypt
and decrypt network traffic between hosts.

This task may be undertaken with a simple shell script similar to the following
which is on the corporate gateway. This file will be used during system
initialization and should be saved as /usr/local/etc/racoon/setkey.conf.

flush; spdflush; # To the home network spdadd 10.246.38.0/24 10.0.0.0/24 any -P
out ipsec esp/tunnel/172.16.5.4-192.168.1.12/use; spdadd 10.0.0.0/24
10.246.38.0/24 any -P in ipsec esp/tunnel/192.168.1.12-172.16.5.4/use;

Once in place, racoon may be started on both gateways using the following
command:

# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf -l /var/log/
racoon.log

The output should be similar to the following:

corp-net# /usr/local/sbin/racoon -F -f /usr/local/etc/racoon/racoon.conf
Foreground mode. 2006-01-30 01:35:47: INFO: begin Identity Protection mode.
2006-01-30 01:35:48: INFO: received Vendor ID: KAME/racoon 2006-01-30 01:35:55:
INFO: received Vendor ID: KAME/racoon 2006-01-30 01:36:04: INFO: ISAKMP-SA
established 172.16.5.4[500]-192.168.1.12[500]
spi:623b9b3bd2492452:7deab82d54ff704a 2006-01-30 01:36:05: INFO: initiate new
phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0] 2006-01-30 01:36:09: INFO:
IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0] spi=28496098
(0x1b2d0e2) 2006-01-30 01:36:09: INFO: IPsec-SA established: ESP/Tunnel
172.16.5.4[0]-&gt;192.168.1.12[0] spi=47784998(0x2d92426) 2006-01-30 01:36:13:
INFO: respond new phase 2 negotiation: 172.16.5.4[0]192.168.1.12[0] 2006-01-30
01:36:18: INFO: IPsec-SA established: ESP/Tunnel 192.168.1.12[0]-&gt;172.16.5.4[0]
spi=124397467(0x76a279b) 2006-01-30 01:36:18: INFO: IPsec-SA established: ESP/
Tunnel 172.16.5.4[0]-&gt;192.168.1.12[0] spi=175852902(0xa7b4d66)

To ensure the tunnel is working properly, switch to another console and use
tcpdump(1) to view network traffic using the following command. Replace em0
with the network interface card as required.

# tcpdump -i em0 host 172.16.5.4 and dst 192.168.1.12

Data similar to the following should appear on the console. If not, there is an
issue, and debugging the returned data will be required.

01:47:32.021683 IP corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP
(spi=0x02acbf9f,seq=0xa) 01:47:33.022442 IP corporatenetwork.com &gt;
192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=0xb) 01:47:34.024218 IP
corporatenetwork.com &gt; 192.168.1.12.privatenetwork.com: ESP(spi=0x02acbf9f,seq=
0xc)

At this point, both networks should be available and seem to be part of the
same network. Most likely both networks are protected by a firewall, as they
should be. To allow traffic to flow between them, rules need to be added to
pass packets back and forth. For the ipfw(8) firewall, add the following lines
to the firewall configuration file:

ipfw add 00201 allow log esp from any to any ipfw add 00202 allow log ah from
any to any ipfw add 00203 allow log ipencap from any to any ipfw add 00204
allow log udp from any 500 to any

Note:

The rule numbers may need to be altered depending on the current host
configuration.

For users of pf(4) or ipf(8), the following rules should do the trick:

pass in quick proto esp from any to any pass in quick proto ah from any to any
pass in quick proto ipencap from any to any pass in quick proto udp from any
port = 500 to any port = 500 pass in quick on gif0 from any to any pass out
quick proto esp from any to any pass out quick proto ah from any to any pass
out quick proto ipencap from any to any pass out quick proto udp from any port
= 500 to any port = 500 pass out quick on gif0 from any to any

Finally, to allow the machine to start support for the VPN during system
initialization, add the following lines to /etc/rc.conf:

ipsec_enable="YES" ipsec_program="/usr/local/sbin/setkey" ipsec_file="/usr/
local/etc/racoon/setkey.conf" # allows setting up spd policies on boot
racoon_enable="yes"

15.10.Â OpenSSH

Contributed by Chern Lee.

OpenSSH is a set of network connectivity tools used to access remote machines
securely. It can be used as a direct replacement for rlogin, rsh, rcp, and
telnet. Additionally, TCP/IP connections can be tunneled/forwarded securely
through SSH. OpenSSH encrypts all traffic to effectively eliminate
eavesdropping, connection hijacking, and other network-level attacks.

OpenSSH is maintained by the OpenBSD project, and is based upon SSH v1.2.12
with all the recent bug fixes and updates. It is compatible with both SSH
protocols 1 and 2.

15.10.1.Â Advantages of Using OpenSSH

Normally, when using telnet(1) or rlogin(1), data is sent over the network in a
clear, un-encrypted form. Network sniffers anywhere in between the client and
server can steal your user/password information or data transferred in your
session. OpenSSH offers a variety of authentication and encryption methods to
prevent this from happening.

15.10.2.Â Enabling sshd

The sshd is an option presented during a Standard install of FreeBSD. To see if
sshd is enabled, check the rc.conf file for:

sshd_enable="YES"

This will load sshd(8), the daemon program for OpenSSH, the next time your
system initializes. Alternatively, it is possible to use service(8) to start 
OpenSSH:

# service sshd start

15.10.3.Â SSH Client

The ssh(1) utility works similarly to rlogin(1).

# ssh user@example.com Host key not found from the list of known hosts. Are you
sure you want to continue connecting (yes/no)? yes Host 'example.com' added to
the list of known hosts. user@example.com's password: *******

The login will continue just as it would have if a session was created using
rlogin or telnet. SSH utilizes a key fingerprint system for verifying the
authenticity of the server when the client connects. The user is prompted to
enter yes only when connecting for the first time. Future attempts to login are
all verified against the saved fingerprint key. The SSH client will alert you
if the saved fingerprint differs from the received fingerprint on future login
attempts. The fingerprints are saved in ~/.ssh/known_hosts, or ~/.ssh/
known_hosts2 for SSH v2 fingerprints.

By default, recent versions of the OpenSSH servers only accept SSH v2
connections. The client will use version 2 if possible and will fall back to
version 1. The client can also be forced to use one or the other by passing it
the -1 or -2 for version 1 or version 2, respectively. The version 1
compatibility is maintained in the client for backwards compatibility with
older versions.

15.10.4.Â Secure Copy

The scp(1) command works similarly to rcp(1); it copies a file to or from a
remote machine, except in a secure fashion.

# scp user@example.com:/COPYRIGHT COPYRIGHT user@example.com's password:
******* COPYRIGHT 100% |*****************************| 4735 00:00 #

Since the fingerprint was already saved for this host in the previous example,
it is verified when using scp(1) here.

The arguments passed to scp(1) are similar to cp(1), with the file or files in
the first argument, and the destination in the second. Since the file is
fetched over the network, through SSH, one or more of the file arguments takes
on the form user@host:&lt;path_to_remote_file&gt;.

15.10.5.Â Configuration

The system-wide configuration files for both the OpenSSH daemon and client
reside within the /etc/ssh directory.

ssh_config configures the client settings, while sshd_config configures the
daemon.

Additionally, the sshd_program (/usr/sbin/sshd by default), and sshd_flags
rc.conf options can provide more levels of configuration.

15.10.6.Â ssh-keygen

Instead of using passwords, ssh-keygen(1) can be used to generate DSA or RSA
keys to authenticate a user:

% ssh-keygen -t dsa Generating public/private dsa key pair. Enter file in which
to save the key (/home/user/.ssh/id_dsa): Created directory '/home/user/.ssh'.
Enter passphrase (empty for no passphrase): Enter same passphrase again: Your
identification has been saved in /home/user/.ssh/id_dsa. Your public key has
been saved in /home/user/.ssh/id_dsa.pub. The key fingerprint is:
bb:48:db:f2:93:57:80:b6:aa:bc:f5:d5:ba:8f:79:17 user@host.example.com

ssh-keygen(1) will create a public and private key pair for use in
authentication. The private key is stored in ~/.ssh/id_dsa or ~/.ssh/id_rsa,
whereas the public key is stored in ~/.ssh/id_dsa.pub or ~/.ssh/id_rsa.pub,
respectively for DSA and RSA key types. The public key must be placed in the ~
/.ssh/authorized_keys file of the remote machine for both RSA or DSA keys in
order for the setup to work.

This will allow connection to the remote machine based upon SSH keys instead of
passwords.

If a passphrase is used in ssh-keygen(1), the user will be prompted for a
password each time in order to use the private key. ssh-agent(1) can alleviate
the strain of repeatedly entering long passphrases, and is explored in the
SectionÂ 15.10.7, â  ssh-agent and ssh-addâ   section below.

Warning:

The various options and files can be different according to the OpenSSH version
you have on your system; to avoid problems you should consult the ssh-keygen(1)
manual page.

15.10.7.Â ssh-agent and ssh-add

The ssh-agent(1) and ssh-add(1) utilities provide methods for SSH keys to be
loaded into memory for use, without needing to type the passphrase each time.

The ssh-agent(1) utility will handle the authentication using the private key
(s) that are loaded into it. ssh-agent(1) should be used to launch another
application. At the most basic level, it could spawn a shell or at a more
advanced level, a window manager.

To use ssh-agent(1) in a shell, first it will need to be spawned with a shell
as an argument. Secondly, the identity needs to be added by running ssh-add(1)
and providing it the passphrase for the private key. Once these steps have been
completed the user will be able to ssh(1) to any host that has the
corresponding public key installed. For example:

% ssh-agent csh % ssh-add Enter passphrase for /home/user/.ssh/id_dsa: Identity
added: /home/user/.ssh/id_dsa (/home/user/.ssh/id_dsa) %

To use ssh-agent(1) in X11, a call to ssh-agent(1) will need to be placed in ~
/.xinitrc. This will provide the ssh-agent(1) services to all programs launched
in X11. An example ~/.xinitrc file might look like this:

exec ssh-agent startxfce4

This would launch ssh-agent(1), which would in turn launch XFCE, every time X11
starts. Then once that is done and X11 has been restarted so that the changes
can take effect, simply run ssh-add(1) to load all of your SSH keys.

15.10.8.Â SSH Tunneling

OpenSSH has the ability to create a tunnel to encapsulate another protocol in
an encrypted session.

The following command tells ssh(1) to create a tunnel for telnet:

% ssh -2 -N -f -L 5023:localhost:23 user@foo.example.com %

The ssh command is used with the following options:

-2

    Forces ssh to use version 2 of the protocol. (Do not use if you are working
    with older SSH servers)

-N

    Indicates no command, or tunnel only. If omitted, ssh would initiate a
    normal session.

-f

    Forces ssh to run in the background.

-L

    Indicates a local tunnel in localport:remotehost:remoteport fashion.

user@foo.example.com

    The remote SSH server.

An SSH tunnel works by creating a listen socket on localhost on the specified
port. It then forwards any connection received on the local host/port via the
SSH connection to the specified remote host and port.

In the example, port 5023 on localhost is being forwarded to port 23 on
localhost of the remote machine. Since 23 is telnet, this would create a secure
telnet session through an SSH tunnel.

This can be used to wrap any number of insecure TCP protocols such as SMTP,
POP3, FTP, etc.

ExampleÂ 15.1.Â Using SSH to Create a Secure Tunnel for SMTP
% ssh -2 -N -f -L 5025:localhost:25 user@mailserver.example.com
user@mailserver.example.com's password: ***** % telnet localhost 5025 Trying
127.0.0.1... Connected to localhost. Escape character is '^]'. 220
mailserver.example.com ESMTP

This can be used in conjunction with an ssh-keygen(1) and additional user
accounts to create a more seamless/hassle-free SSH tunneling environment. Keys
can be used in place of typing a password, and the tunnels can be run as a
separate user.


15.10.8.1.Â Practical SSH Tunneling Examples

15.10.8.1.1.Â Secure Access of a POP3 Server

At work, there is an SSH server that accepts connections from the outside. On
the same office network resides a mail server running a POP3 server. The
network, or network path between your home and office may or may not be
completely trustable. Because of this, you need to check your e-mail in a
secure manner. The solution is to create an SSH connection to your office's SSH
server, and tunnel through to the mail server.

% ssh -2 -N -f -L 2110:mail.example.com:110 user@ssh-server.example.com
user@ssh-server.example.com's password: ******

When the tunnel is up and running, you can point your mail client to send POP3
requests to localhost port 2110. A connection here will be forwarded securely
across the tunnel to mail.example.com.

15.10.8.1.2.Â Bypassing a Draconian Firewall

Some network administrators impose extremely draconian firewall rules,
filtering not only incoming connections, but outgoing connections. You may be
only given access to contact remote machines on ports 22 and 80 for SSH and web
surfing.

You may wish to access another (perhaps non-work related) service, such as an
Ogg Vorbis server to stream music. If this Ogg Vorbis server is streaming on
some other port than 22 or 80, you will not be able to access it.

The solution is to create an SSH connection to a machine outside of your
network's firewall, and use it to tunnel to the Ogg Vorbis server.

% ssh -2 -N -f -L 8888:music.example.com:8000
user@unfirewalled-system.example.org user@unfirewalled-system.example.org's
password: *******

Your streaming client can now be pointed to localhost port 8888, which will be
forwarded over to music.example.com port 8000, successfully evading the
firewall.

15.10.9.Â The AllowUsers Option

It is often a good idea to limit which users can log in and from where. The
AllowUsers option is a good way to accomplish this. For example, to only allow
the root user to log in from 192.168.1.32, something like this would be
appropriate in the /etc/ssh/sshd_config file:

AllowUsers root@192.168.1.32

To allow the user admin to log in from anywhere, just list the username by
itself:

AllowUsers admin

Multiple users should be listed on the same line, like so:

AllowUsers root@192.168.1.32 admin

Note:

It is important that you list each user that needs to log in to this machine;
otherwise they will be locked out.

After making changes to /etc/ssh/sshd_config you must tell sshd(8) to reload
its config files, by running:

# service sshd reload

15.10.10.Â Further Reading

OpenSSH

ssh(1) scp(1) ssh-keygen(1) ssh-agent(1) ssh-add(1) ssh_config(5)

sshd(8) sftp-server(8) sshd_config(5)

15.11.Â File System Access Control Lists (ACLs)

Contributed by Tom Rhodes.

In conjunction with file system enhancements like snapshots, FreeBSD offers the
security of File System Access Control Lists (ACLs).

Access Control Lists extend the standard UNIXÂ® permission model in a highly
compatible (POSIXÂ®.1e) way. This feature permits an administrator to make use
of and take advantage of a more sophisticated security model.

To enable ACL support for UFS file systems, the following:

options UFS_ACL

must be compiled into the kernel. If this option has not been compiled in, a
warning message will be displayed when attempting to mount a file system
supporting ACLs. This option is included in the GENERIC kernel. ACLs rely on
extended attributes being enabled on the file system. Extended attributes are
natively supported in the next generation UNIXÂ® file system, UFS2.

Note:

A higher level of administrative overhead is required to configure extended
attributes on UFS1 than on UFS2. The performance of extended attributes on UFS2
is also substantially higher. As a result, UFS2 is generally recommended in
preference to UFS1 for use with access control lists.

ACLs are enabled by the mount-time administrative flag, acls, which may be
added to /etc/fstab. The mount-time flag can also be automatically set in a
persistent manner using tunefs(8) to modify a superblock ACLs flag in the file
system header. In general, it is preferred to use the superblock flag for
several reasons:

  * The mount-time ACLs flag cannot be changed by a remount (mount(8) -u), only
    by means of a complete umount(8) and fresh mount(8). This means that ACLs
    cannot be enabled on the root file system after boot. It also means that
    you cannot change the disposition of a file system once it is in use.

  * Setting the superblock flag will cause the file system to always be mounted
    with ACLs enabled even if there is not an fstab entry or if the devices
    re-order. This prevents accidental mounting of the file system without ACLs
    enabled, which can result in ACLs being improperly enforced, and hence
    security problems.

Note:

We may change the ACLs behavior to allow the flag to be enabled without a
complete fresh mount(8), but we consider it desirable to discourage accidental
mounting without ACLs enabled, because you can shoot your feet quite nastily if
you enable ACLs, then disable them, then re-enable them without flushing the
extended attributes. In general, once you have enabled ACLs on a file system,
they should not be disabled, as the resulting file protections may not be
compatible with those intended by the users of the system, and re-enabling ACLs
may re-attach the previous ACLs to files that have since had their permissions
changed, resulting in other unpredictable behavior.

File systems with ACLs enabled will show a + (plus) sign in their permission
settings when viewed. For example:

drwx------ 2 robert robert 512 Dec 27 11:54 private drwxrwx---+ 2 robert robert
512 Dec 23 10:57 directory1 drwxrwx---+ 2 robert robert 512 Dec 22 10:20
directory2 drwxrwx---+ 2 robert robert 512 Dec 27 11:57 directory3 drwxr-xr-x 2
robert robert 512 Nov 10 11:54 public_html

Here we see that the directory1, directory2, and directory3 directories are all
taking advantage of ACLs. The public_html directory is not.

15.11.1.Â Making Use of ACLs

The file system ACLs can be viewed by the getfacl(1) utility. For instance, to
view the ACL settings on the test file, one would use the command:

% getfacl test #file:test #owner:1001 #group:1001 user::rw- group::r--
other::r--

To change the ACL settings on this file, invoke the setfacl(1) utility.
Observe:

% setfacl -k test

The -k flag will remove all of the currently defined ACLs from a file or file
system. The more preferable method would be to use -b as it leaves the basic
fields required for ACLs to work.

% setfacl -m u:trhodes:rwx,group:web:r--,o::--- test

In the aforementioned command, the -m option was used to modify the default ACL
entries. Since there were no pre-defined entries, as they were removed by the
previous command, this will restore the default options and assign the options
listed. Take care to notice that if you add a user or group which does not
exist on the system, an Invalid argument error will be printed to stdout.

15.12.Â Monitoring Third Party Security Issues

Contributed by Tom Rhodes.

In recent years, the security world has made many improvements to how
vulnerability assessment is handled. The threat of system intrusion increases
as third party utilities are installed and configured for virtually any
operating system available today.

Vulnerability assessment is a key factor in security, and while FreeBSD
releases advisories for the base system, doing so for every third party utility
is beyond the FreeBSD Project's capability. There is a way to mitigate third
party vulnerabilities and warn administrators of known security issues. A
FreeBSD add on utility known as Portaudit exists solely for this purpose.

The ports-mgmt/portaudit port polls a database, updated and maintained by the
FreeBSD Security Team and ports developers, for known security issues.

To begin using Portaudit, one must install it from the Ports Collection:

# cd /usr/ports/ports-mgmt/portaudit && make install clean

During the install process, the configuration files for periodic(8) will be
updated, permitting Portaudit output in the daily security runs. Ensure the
daily security run emails, which are sent to root's email account, are being
read. No more configuration will be required here.

After installation, an administrator can update the database and view known
vulnerabilities in installed packages by invoking the following command:

# portaudit -Fda

Note:

The database will automatically be updated during the periodic(8) run; thus,
the previous command is completely optional. It is only required for the
following examples.

To audit the third party utilities installed as part of the Ports Collection at
anytime, an administrator need only run the following command:

# portaudit -a

Portaudit will produce something like this for vulnerable packages:

Affected package: cups-base-1.1.22.0_1 Type of problem: cups-base -- HPGL
buffer overflow vulnerability. Reference: &lt;http://www.FreeBSD.org/ports/
portaudit/40a3bca2-6809-11d9-a9e7-0001020eed82.html&gt; 1 problem(s) in your
installed packages found. You are advised to update or deinstall the affected
package(s) immediately.

By pointing a web browser to the URL shown, an administrator may obtain more
information about the vulnerability in question. This will include versions
affected, by FreeBSD Port version, along with other web sites which may contain
security advisories.

In short, Portaudit is a powerful utility and extremely useful when coupled
with the Portupgrade port.

15.13.Â FreeBSD Security Advisories

Contributed by Tom Rhodes.

Like many production quality operating systems, FreeBSD publishes â  Security
Advisoriesâ  . These advisories are usually mailed to the security lists and
noted in the Errata only after the appropriate releases have been patched. This
section will work to explain what an advisory is, how to understand it, and
what measures to take in order to patch a system.

15.13.1.Â What Does an Advisory Look Like?

The FreeBSD security advisories look similar to the one below, taken from the
freebsd-security-notifications mailing list.

=============================================================================
FreeBSD-SA-XX:XX.UTIL Security Advisory The FreeBSD Project Topic: denial of
service due to some problem 1 Category: core 2 Module: sys 3 Announced:
2003-09-23 4 Credits: Person 5 Affects: All releases of FreeBSD 6 FreeBSD
4-STABLE prior to the correction date Corrected: 2003-09-23 16:42:59 UTC
(RELENG_4, 4.9-PRERELEASE) 2003-09-23 20:08:42 UTC (RELENG_5_1, 5.1-RELEASE-p6)
2003-09-23 20:07:06 UTC (RELENG_5_0, 5.0-RELEASE-p15) 2003-09-23 16:44:58 UTC
(RELENG_4_8, 4.8-RELEASE-p8) 2003-09-23 16:47:34 UTC (RELENG_4_7,
4.7-RELEASE-p18) 2003-09-23 16:49:46 UTC (RELENG_4_6, 4.6-RELEASE-p21)
2003-09-23 16:51:24 UTC (RELENG_4_5, 4.5-RELEASE-p33) 2003-09-23 16:52:45 UTC
(RELENG_4_4, 4.4-RELEASE-p43) 2003-09-23 16:54:39 UTC (RELENG_4_3,
4.3-RELEASE-p39) 7 CVE Name: CVE-XXXX-XXXX 8 For general information regarding
FreeBSD Security Advisories, including descriptions of the fields above,
security branches, and the following sections, please visit http://
www.FreeBSD.org/security/. I. Background 9 II. Problem Description 10 III.
Impact 11 IV. Workaround 12 V. Solution 13 VI. Correction details 14 VII.
References 15

1    The Topic field indicates exactly what the problem is. It is basically an
     introduction to the current security advisory and notes the utility with
     the vulnerability.

2    The Category refers to the affected part of the system which may be one of
     core, contrib, or ports. The core category means that the vulnerability
     affects a core component of the FreeBSD operating system. The contrib
     category means that the vulnerability affects software contributed to the
     FreeBSD Project, such as sendmail. Finally the ports category indicates
     that the vulnerability affects add on software available as part of the
     Ports Collection.

3    The Module field refers to the component location, for instance sys. In
     this example, we see that the module, sys, is affected; therefore, this
     vulnerability affects a component used within the kernel.

4    The Announced field reflects the date said security advisory was
     published, or announced to the world. This means that the security team
     has verified that the problem does exist and that a patch has been
     committed to the FreeBSD source code repository.

5    The Credits field gives credit to the individual or organization who
     noticed the vulnerability and reported it.

6    The Affects field explains which releases of FreeBSD are affected by this
     vulnerability. For the kernel, a quick look over the output from ident on
     the affected files will help in determining the revision. For ports, the
     version number is listed after the port name in /var/db/pkg. If the system
     does not sync with the FreeBSD Subversion repository and rebuilt daily,
     chances are that it is affected.

7    The Corrected field indicates the date, time, time offset, and release
     that was corrected.

8    Reserved for the identification information used to look up
     vulnerabilities in the Common Vulnerabilities Database system.

9    The Background field gives information on exactly what the affected
     utility is. Most of the time this is why the utility exists in FreeBSD,
     what it is used for, and a bit of information on how the utility came to
     be.

10   The Problem Description field explains the security hole in depth. This
     can include information on flawed code, or even how the utility could be
     maliciously used to open a security hole.

11   The Impact field describes what type of impact the problem could have on a
     system. For example, this could be anything from a denial of service
     attack, to extra privileges available to users, or even giving the
     attacker superuser access.

12   The Workaround field offers a feasible workaround to system administrators
     who may be incapable of upgrading the system. This may be due to time
     constraints, network availability, or a slew of other reasons. Regardless,
     security should not be taken lightly, and an affected system should either
     be patched or the security hole workaround should be implemented.

13   The Solution field offers instructions on patching the affected system.
     This is a step by step tested and verified method for getting a system
     patched and working securely.

14   The Correction Details field displays the Subversion branch or release
     name with the periods changed to underscore characters. It also shows the
     revision number of the affected files within each branch.

15   The References field usually offers sources of other information. This can
     include web URLs, books, mailing lists, and newsgroups.

15.14.Â Process Accounting

Contributed by Tom Rhodes.

Process accounting is a security method in which an administrator may keep
track of system resources used, their allocation among users, provide for
system monitoring, and minimally track a user's commands.

This indeed has its own positive and negative points. One of the positives is
that an intrusion may be narrowed down to the point of entry. A negative is the
amount of logs generated by process accounting, and the disk space they may
require. This section will walk an administrator through the basics of process
accounting.

15.14.1.Â Enabling and Utilizing Process Accounting

Before making use of process accounting, it must be enabled. To do this,
execute the following commands:

# touch /var/account/acct # accton /var/account/acct # echo 'accounting_enable=
"YES"' &gt;&gt; /etc/rc.conf

Once enabled, accounting will begin to track CPU stats, commands, etc. All
accounting logs are in a non-human readable format and may be viewed using the
sa(8) utility. If issued without any options, sa will print information
relating to the number of per user calls, the total elapsed time in minutes,
total CPU and user time in minutes, average number of I/O operations, etc.

To view information about commands being issued, one would use the lastcomm(1)
utility. The lastcomm command may be used to print out commands issued by users
on specific ttys(5), for example:

# lastcomm ls trhodes ttyp1

Would print out all known usage of the ls by trhodes on the ttyp1 terminal.

Many other useful options exist and are explained in the lastcomm(1), acct(5)
and sa(8) manual pages.


------------

^[5] Under FreeBSD the standard login password may be up to 128 characters in
length.

ChapterÂ 16.Â Jails

Contributed by Matteo Riondato.
Table of Contents

16.1. Synopsis
16.2. Terms Related to Jails
16.3. Introduction
16.4. Creating and Controlling Jails
16.5. Fine Tuning and Administration
16.6. Application of Jails

16.1.Â Synopsis

This chapter will provide an explanation of what FreeBSD jails are and how to
use them. Jails, sometimes referred to as an enhanced replacement of chroot
environments, are a very powerful tool for system administrators, but their
basic usage can also be useful for advanced users.

Important:

Jails are a powerful tool, but they are not a security panacea. It is
particularly important to note that while it is not possible for a jailed
process to break out on its own, there are several ways in which an
unprivileged user outside the jail can cooperate with a privileged user inside
the jail and thereby obtain elevated privileges in the host environment.

Most of these attacks can be mitigated by ensuring that the jail root is not
accessible to unprivileged users in the host environment. Regardless, as a
general rule, untrusted users with privileged access to a jail should not be
given access to the host environment.

After reading this chapter, you will know:

  * What a jail is, and what purpose it may serve in FreeBSD installations.

  * How to build, start, and stop a jail.

  * The basics of jail administration, both from inside and outside the jail.

Other sources of useful information about jails are:

  * The jail(8) manual page. This is the full reference of the jail utility â  
    the administrative tool which can be used in FreeBSD to start, stop, and
    control FreeBSD jails.

  * The mailing lists and their archives. The archives of the FreeBSD general
    questions mailing list and other mailing lists hosted by the FreeBSD list
    server already contain a wealth of material for jails. It should always be
    engaging to search the archives, or post a new question to the
    freebsd-questions mailing list.

16.2.Â Terms Related to Jails

To facilitate better understanding of parts of the FreeBSD system related to
jails, their internals and the way they interact with the rest of FreeBSD, the
following terms are used further in this chapter:

chroot(8) (command)

    Utility, which uses chroot(2) FreeBSD system call to change the root
    directory of a process and all its descendants.

chroot(2) (environment)

    The environment of processes running in a â  chrootâ  . This includes
    resources such as the part of the file system which is visible, user and
    group IDs which are available, network interfaces and other IPC mechanisms,
    etc.

jail(8) (command)

    The system administration utility which allows launching of processes
    within a jail environment.

host (system, process, user, etc.)

    The controlling system of a jail environment. The host system has access to
    all the hardware resources available, and can control processes both
    outside of and inside a jail environment. One of the important differences
    of the host system from a jail is that the limitations which apply to
    superuser processes inside a jail are not enforced for processes of the
    host system.

hosted (system, process, user, etc.)

    A process, user or other entity, whose access to resources is restricted by
    a FreeBSD jail.

16.3.Â Introduction

Since system administration is a difficult and perplexing task, many powerful
tools were developed to make life easier for the administrator. These tools
mostly provide enhancements of some sort to the way systems are installed,
configured and maintained. Part of the tasks which an administrator is expected
to do is to properly configure the security of a system, so that it can
continue serving its real purpose, without allowing security violations.

One of the tools which can be used to enhance the security of a FreeBSD system
are jails. Jails were introduced in FreeBSDÂ 4.X by Poul-Henning Kamp &lt;
phk@FreeBSD.org&gt;, but were greatly improved in FreeBSDÂ 5.X to make them a
powerful and flexible subsystem. Their development still goes on, enhancing
their usefulness, performance, reliability, and security.

16.3.1.Â What is a Jail

BSD-like operating systems have had chroot(2) since the time of 4.2BSD. The
chroot(8) utility can be used to change the root directory of a set of
processes, creating a safe environment, separate from the rest of the system.
Processes created in the chrooted environment can not access files or resources
outside of it. For that reason, compromising a service running in a chrooted
environment should not allow the attacker to compromise the entire system. The
chroot(8) utility is good for easy tasks, which do not require a lot of
flexibility or complex and advanced features. Since the inception of the chroot
concept, however, many ways have been found to escape from a chrooted
environment and, although they have been fixed in modern versions of the
FreeBSD kernel, it was clear that chroot(2) was not the ideal solution for
securing services. A new subsystem had to be implemented.

This is one of the main reasons why jails were developed.

Jails improve on the concept of the traditional chroot(2) environment, in
several ways. In a traditional chroot(2) environment, processes are only
limited in the part of the file system they can access. The rest of the system
resources (like the set of system users, the running processes, or the
networking subsystem) are shared by the chrooted processes and the processes of
the host system. Jails expand this model by virtualizing not only access to the
file system, but also the set of users, the networking subsystem of the FreeBSD
kernel and a few other things. A more complete set of fine-grained controls
available for tuning the access of a jailed environment is described in
SectionÂ 16.5, â  Fine Tuning and Administrationâ  .

A jail is characterized by four elements:

  * A directory subtree â   the starting point from which a jail is entered.
    Once inside the jail, a process is not permitted to escape outside of this
    subtree. Traditional security issues which plagued the original chroot(2)
    design will not affect FreeBSD jails.

  * A hostname â   the hostname which will be used within the jail. Jails are
    mainly used for hosting network services, therefore having a descriptive
    hostname for each jail can really help the system administrator.

  * An IP address â   this will be assigned to the jail and cannot be changed
    in any way during the jail's life span. The IP address of a jail is usually
    an alias address for an existing network interface, but this is not
    strictly necessary.

  * A command â   the path name of an executable to run inside the jail. This
    is relative to the root directory of the jail environment, and may vary a
    lot, depending on the type of the specific jail environment.

Apart from these, jails can have their own set of users and their own root
user. Naturally, the powers of the root user are limited within the jail
environment and, from the point of view of the host system, the jail root user
is not an omnipotent user. In addition, the root user of a jail is not allowed
to perform critical operations to the system outside of the associated jail(8)
environment. More information about capabilities and restrictions of the root
user will be discussed in SectionÂ 16.5, â  Fine Tuning and Administrationâ  
below.

16.4.Â Creating and Controlling Jails

Some administrators divide jails into the following two types: â  completeâ  
jails, which resemble a real FreeBSD system, and â  serviceâ   jails, dedicated
to one application or service, possibly running with privileges. This is only a
conceptual division and the process of building a jail is not affected by it.
The jail(8) manual page is quite clear about the procedure for building a jail:

# setenv D /here/is/the/jail # mkdir -p $D 1 # cd /usr/src # make buildworld 2
# make installworld DESTDIR=$D 3 # make distribution DESTDIR=$D 4 # mount -t
devfs devfs $D/dev 5

1    Selecting a location for a jail is the best starting point. This is where
     the jail will physically reside within the file system of the jail's host.
     A good choice can be /usr/jail/jailname, where jailname is the hostname
     identifying the jail. The /usr/ file system usually has enough space for
     the jail file system, which for â  completeâ   jails is, essentially, a
     replication of every file present in a default installation of the FreeBSD
     base system.

2    If you have already rebuilt your userland using make world or make
     buildworld, you can skip this step and install your existing userland into
     the new jail.

3    This command will populate the directory subtree chosen as jail's physical
     location on the file system with the necessary binaries, libraries, manual
     pages and so on.

4    The distribution target for make installs every needed configuration file.
     In simple words, it installs every installable file of /usr/src/etc/ to
     the /etc directory of the jail environment: $D/etc/.

5    Mounting the devfs(8) file system inside a jail is not required. On the
     other hand, any, or almost any application requires access to at least one
     device, depending on the purpose of the given application. It is very
     important to control access to devices from inside a jail, as improper
     settings could permit an attacker to do nasty things in the jail. Control
     over devfs(8) is managed through rulesets which are described in the devfs
     (8) and devfs.conf(5) manual pages.

Once a jail is installed, it can be started by using the jail(8) utility. The
jail(8) utility takes four mandatory arguments which are described in the
SectionÂ 16.3.1, â  What is a Jailâ  . Other arguments may be specified too,
e.g., to run the jailed process with the credentials of a specific user. The
command argument depends on the type of the jail; for a virtual system, /etc/rc
is a good choice, since it will replicate the startup sequence of a real
FreeBSD system. For a service jail, it depends on the service or application
that will run within the jail.

Jails are often started at boot time and the FreeBSD rc mechanism provides an
easy way to do this.

 1. A list of the jails which are enabled to start at boot time should be added
    to the rc.conf(5) file:

    jail_enable="YES" # Set to NO to disable starting of any jails jail_list="
    www" # Space separated list of names of jails

    Note:

    Jail names in jail_list should contain alphanumeric characters only.

 2. For each jail listed in jail_list, a group of rc.conf(5) settings, which
    describe the particular jail, should be added:

    jail_www_rootdir="/usr/jail/www" # jail's root directory jail_www_hostname=
    "www.example.org" # jail's hostname jail_www_ip="192.168.0.10" # jail's IP
    address jail_www_devfs_enable="YES" # mount devfs in the jail jail_www
    _devfs_ruleset="www_ruleset" # devfs ruleset to apply to jail

    The default startup of jails configured in rc.conf(5), will run the /etc/rc
    script of the jail, which assumes the jail is a complete virtual system.
    For service jails, the default startup command of the jail should be
    changed, by setting the jail_jailname_exec_start option appropriately.

    Note:

    For a full list of available options, please see the rc.conf(5) manual
    page.

service(8) can be used to start or stop a jail by hand, if an entry for it
exists in rc.conf:

# service jail start www # service jail stop www

A clean way to shut down a jail(8) is not available at the moment. This is
because commands normally used to accomplish a clean system shutdown cannot be
used inside a jail. The best way to shut down a jail is to run the following
command from within the jail itself or using the jexec(8) utility from outside
the jail:

# sh /etc/rc.shutdown

More information about this can be found in the jail(8) manual page.

16.5.Â Fine Tuning and Administration

There are several options which can be set for any jail, and various ways of
combining a host FreeBSD system with jails, to produce higher level
applications. This section presents:

  * Some of the options available for tuning the behavior and security
    restrictions implemented by a jail installation.

  * Some of the high-level applications for jail management, which are
    available through the FreeBSD Ports Collection, and can be used to
    implement overall jail-based solutions.

16.5.1.Â System Tools for Jail Tuning in FreeBSD

Fine tuning of a jail's configuration is mostly done by setting sysctl(8)
variables. A special subtree of sysctl exists as a basis for organizing all the
relevant options: the security.jail.* hierarchy of FreeBSD kernel options. Here
is a list of the main jail-related sysctls, complete with their default value.
Names should be self-explanatory, but for more information about them, please
refer to the jail(8) and sysctl(8) manual pages.

  * security.jail.set_hostname_allowed: 1

  * security.jail.socket_unixiproute_only: 1

  * security.jail.sysvipc_allowed: 0

  * security.jail.enforce_statfs: 2

  * security.jail.allow_raw_sockets: 0

  * security.jail.chflags_allowed: 0

  * security.jail.jailed: 0

These variables can be used by the system administrator of the host system to
add or remove some of the limitations imposed by default on the root user. Note
that there are some limitations which cannot be removed. The root user is not
allowed to mount or unmount file systems from within a jail(8). The root inside
a jail may not load or unload devfs(8) rulesets, set firewall rules, or do many
other administrative tasks which require modifications of in-kernel data, such
as setting the securelevel of the kernel.

The base system of FreeBSD contains a basic set of tools for viewing
information about the active jails, and attaching to a jail to run
administrative commands. The jls(8) and jexec(8) commands are part of the base
FreeBSD system, and can be used to perform the following simple tasks:

  * Print a list of active jails and their corresponding jail identifier (JID),
    IP address, hostname and path.

  * Attach to a running jail, from its host system, and run a command inside
    the jail or perform administrative tasks inside the jail itself. This is
    especially useful when the root user wants to cleanly shut down a jail. The
    jexec(8) utility can also be used to start a shell in a jail to do
    administration in it; for example:

    # jexec 1 tcsh

16.5.2.Â High-Level Administrative Tools in the FreeBSD Ports Collection

Among the many third-party utilities for jail administration, one of the most
complete and useful is sysutils/jailutils. It is a set of small applications
that contribute to jail(8) management. Please refer to its web page for more
information.

16.6.Â Application of Jails

16.6.1.Â Service Jails

Contributed by Daniel Gerzo.

This section is based upon an idea originally presented by Simon L. Nielsen &lt;
simon@FreeBSD.org&gt; at http://simon.nitro.dk/service-jails.html, and an updated
article written by Ken Tom &lt;locals@gmail.com&gt;. This section illustrates how to
set up a FreeBSD system that adds an additional layer of security, using the
jail(8) feature. It is also assumed that the given system is at least running
RELENG_6_0 and the information provided earlier in this chapter has been well
understood.

16.6.1.1.Â Design

One of the major problems with jails is the management of their upgrade
process. This tends to be a problem because every jail has to be rebuilt from
scratch whenever it is updated. This is usually not a problem for a single
jail, since the update process is fairly simple, but can be quite time
consuming and tedious if a lot of jails are created.

Warning:

This setup requires advanced experience with FreeBSD and usage of its features.
If the presented steps below look too complicated, it is advised to take a look
at a simpler system such as sysutils/ezjail, which provides an easier method of
administering FreeBSD jails and is not as sophisticated as this setup.

This idea has been presented to resolve such issues by sharing as much as is
possible between jails, in a safe way â   using read-only mount_nullfs(8)
mounts, so that updating will be simpler, and putting single services into
individual jails will become more attractive. Additionally, it provides a
simple way to add or remove jails as well as a way to upgrade them.

Note:

Examples of services in this context are: an HTTP server, a DNS server, a SMTP
server, and so forth.

The goals of the setup described in this section are:

  * Create a simple and easy to understand jail structure. This implies not
    having to run a full installworld on each and every jail.

  * Make it easy to add new jails or remove existing ones.

  * Make it easy to update or upgrade existing jails.

  * Make it possible to run a customized FreeBSD branch.

  * Be paranoid about security, reducing as much as possible the possibility of
    compromise.

  * Save space and inodes, as much as possible.

As it has been already mentioned, this design relies heavily on having a single
master template which is read-only (known as nullfs) mounted into each jail and
one read-write device per jail. A device can be a separate physical disc, a
partition, or a vnode backed md(4) device. In this example, we will use
read-write nullfs mounts.

The file system layout is described in the following list:

  * Each jail will be mounted under the /home/j directory.

  * /home/j/mroot is the template for each jail and the read-only partition for
    all of the jails.

  * A blank directory will be created for each jail under the /home/j
    directory.

  * Each jail will have a /s directory, that will be linked to the read-write
    portion of the system.

  * Each jail shall have its own read-write system that is based upon /home/j/
    skel.

  * Each jailspace (read-write portion of each jail) shall be created in /home/
    js.

Note:

This assumes that the jails are based under the /home partition. This can, of
course, be changed to anything else, but this change will have to be reflected
in each of the examples below.

16.6.1.2.Â Creating the Template

This section will describe the steps needed to create the master template that
will be the read-only portion for the jails to use.

It is always a good idea to update the FreeBSD system to the latest -RELEASE
branch. Check the corresponding Handbook Chapter to accomplish this task. In
the case the update is not feasible, the buildworld will be required in order
to be able to proceed. Additionally, the sysutils/cpdup package will be
required. We will use the portsnap(8) utility to download the FreeBSD Ports
Collection. The Handbook Portsnap Chapter is always good reading for newcomers.

 1. First, create a directory structure for the read-only file system which
    will contain the FreeBSD binaries for our jails, then change directory to
    the FreeBSD source tree and install the read-only file system to the jail
    template:

    # mkdir /home/j /home/j/mroot # cd /usr/src # make installworld DESTDIR=/
    home/j/mroot
 2. Next, prepare a FreeBSD Ports Collection for the jails as well as a FreeBSD
    source tree, which is required for mergemaster:

    # cd /home/j/mroot # mkdir usr/ports # portsnap -p /home/j/mroot/usr/ports
    fetch extract # cpdup /usr/src /home/j/mroot/usr/src
 3. Create a skeleton for the read-write portion of the system:

    # mkdir /home/j/skel /home/j/skel/home /home/j/skel/usr-X11R6 /home/j/skel/
    distfiles # mv etc /home/j/skel # mv usr/local /home/j/skel/usr-local # mv
    tmp /home/j/skel # mv var /home/j/skel # mv root /home/j/skel
 4. Use mergemaster to install missing configuration files. Then get rid of the
    extra directories that mergemaster creates:

    # mergemaster -t /home/j/skel/var/tmp/temproot -D /home/j/skel -i # cd /
    home/j/skel # rm -R bin boot lib libexec mnt proc rescue sbin sys usr dev
 5. Now, symlink the read-write file system to the read-only file system.
    Please make sure that the symlinks are created in the correct s/ locations.
    Real directories or the creation of directories in the wrong locations will
    cause the installation to fail.

    # cd /home/j/mroot # mkdir s # ln -s s/etc etc # ln -s s/home home # ln -s
    s/root root # ln -s ../s/usr-local usr/local # ln -s ../s/usr-X11R6 usr/
    X11R6 # ln -s ../../s/distfiles usr/ports/distfiles # ln -s s/tmp tmp # ln
    -s s/var var
 6. As a last step, create a generic /home/j/skel/etc/make.conf with its
    contents as shown below:

    WRKDIRPREFIX?= /s/portbuild

    Having WRKDIRPREFIX set up this way will make it possible to compile
    FreeBSD ports inside each jail. Remember that the ports directory is part
    of the read-only system. The custom path for WRKDIRPREFIX allows builds to
    be done in the read-write portion of every jail.

16.6.1.3.Â Creating Jails

Now that we have a complete FreeBSD jail template, we can setup and configure
the jails in /etc/rc.conf. This example demonstrates the creation of 3 jails: â
  NSâ  , â  MAILâ   and â  WWWâ  .

 1. Put the following lines into the /etc/fstab file, so that the read-only
    template for the jails and the read-write space will be available in the
    respective jails:

    /home/j/mroot /home/j/ns nullfs ro 0 0 /home/j/mroot /home/j/mail nullfs ro
    0 0 /home/j/mroot /home/j/www nullfs ro 0 0 /home/js/ns /home/j/ns/s nullfs
    rw 0 0 /home/js/mail /home/j/mail/s nullfs rw 0 0 /home/js/www /home/j/www/
    s nullfs rw 0 0

    Note:

    Partitions marked with a 0 pass number are not checked by fsck(8) during
    boot, and partitions marked with a 0 dump number are not backed up by dump
    (8). We do not want fsck to check nullfs mounts or dump to back up the
    read-only nullfs mounts of the jails. This is why they are marked with â  
    0Â 0â   in the last two columns of each fstab entry above.

 2. Configure the jails in /etc/rc.conf:

    jail_enable="YES" jail_set_hostname_allow="NO" jail_list="ns mail www"
    jail_ns_hostname="ns.example.org" jail_ns_ip="192.168.3.17" jail_ns_rootdir
    ="/usr/home/j/ns" jail_ns_devfs_enable="YES" jail_mail_hostname=
    "mail.example.org" jail_mail_ip="192.168.3.18" jail_mail_rootdir="/usr/home
    /j/mail" jail_mail_devfs_enable="YES" jail_www_hostname="www.example.org"
    jail_www_ip="62.123.43.14" jail_www_rootdir="/usr/home/j/www"
    jail_www_devfs_enable="YES"

    Warning:

    The reason why the jail_name_rootdir variable is set to /usr/home instead
    of /home is that the physical path of the /home directory on a default
    FreeBSD installation is /usr/home. The jail_name_rootdir variable must not
    be set to a path which includes a symbolic link, otherwise the jails will
    refuse to start. Use the realpath(1) utility to determine a value which
    should be set to this variable. Please see the FreeBSD-SA-07:01.jail
    Security Advisory for more information.

 3. Create the required mount points for the read-only file system of each
    jail:

    # mkdir /home/j/ns /home/j/mail /home/j/www
 4. Install the read-write template into each jail. Note the use of sysutils/
    cpdup, which helps to ensure that a correct copy is done of each directory:

    # mkdir /home/js # cpdup /home/j/skel /home/js/ns # cpdup /home/j/skel /
    home/js/mail # cpdup /home/j/skel /home/js/www
 5. In this phase, the jails are built and prepared to run. First, mount the
    required file systems for each jail, and then start them using the jail rc
    script.

    # mount -a # service jail start

The jails should be running now. To check if they have started correctly, use
the jls(8) command. Its output should be similar to the following:

# jls JID IP Address Hostname Path 3 192.168.3.17 ns.example.org /home/j/ns 2
192.168.3.18 mail.example.org /home/j/mail 1 62.123.43.14 www.example.org /home
/j/www

At this point, it should be possible to log onto each jail, add new users or
configure daemons. The JID column indicates the jail identification number of
each running jail. Use the following command in order to perform administrative
tasks in the jail whose JID is 3:

# jexec 3 tcsh

16.6.1.4.Â Upgrading

In time, there will be a need to upgrade the system to a newer version of
FreeBSD, either because of a security issue, or because new features have been
implemented which are useful for the existing jails. The design of this setup
provides an easy way to upgrade existing jails. Additionally, it minimizes
their downtime, as the jails will be brought down only in the very last minute.
Also, it provides a way to roll back to the older versions should any problems
occur.

 1. The first step is to upgrade the host system in the usual manner. Then
    create a new temporary read-only template in /home/j/mroot2.

    # mkdir /home/j/mroot2 # cd /usr/src # make installworld DESTDIR=/home/j/
    mroot2 # cd /home/j/mroot2 # cpdup /usr/src usr/src # mkdir s

    The installworld run creates a few unnecessary directories, which should be
    removed:

    # chflags -R 0 var # rm -R etc var root usr/local tmp
 2. Recreate the read-write symlinks for the master file system:

    # ln -s s/etc etc # ln -s s/root root # ln -s s/home home # ln -s ../s/
    usr-local usr/local # ln -s ../s/usr-X11R6 usr/X11R6 # ln -s s/tmp tmp # ln
    -s s/var var
 3. The right time to stop the jails is now:

    # service jail stop
 4. Unmount the original file systems:

    # umount /home/j/ns/s # umount /home/j/ns # umount /home/j/mail/s # umount
    /home/j/mail # umount /home/j/www/s # umount /home/j/www

    Note:

    The read-write systems are attached to the read-only system (/s) and must
    be unmounted first.

 5. Move the old read-only file system and replace it with the new one. This
    will serve as a backup and archive of the old read-only file system should
    something go wrong. The naming convention used here corresponds to when a
    new read-only file system has been created. Move the original FreeBSD Ports
    Collection over to the new file system to save some space and inodes:

    # cd /home/j # mv mroot mroot.20060601 # mv mroot2 mroot # mv
    mroot.20060601/usr/ports mroot/usr
 6. At this point the new read-only template is ready, so the only remaining
    task is to remount the file systems and start the jails:

    # mount -a # service jail start

Use jls(8) to check if the jails started correctly. Do not forget to run
mergemaster in each jail. The configuration files will need to be updated as
well as the rc.d scripts.

ChapterÂ 17.Â Mandatory Access Control

Written by Tom Rhodes.
Table of Contents

17.1. Synopsis
17.2. Key Terms in This Chapter
17.3. Explanation of MAC
17.4. Understanding MAC Labels
17.5. Planning the Security Configuration
17.6. Module Configuration
17.7. The mac_seeotheruids(4) Module
17.8. The mac_bsdextended(4) Module
17.9. The mac_ifoff(4) Module
17.10. The mac_portacl(4) Module
17.11. The mac_partition(4) Module
17.12. The MAC Multi-Level Security Module
17.13. The MAC Biba Module
17.14. The MAC LOMAC Module
17.15. Nagios in a MAC Jail
17.16. User Lock Down
17.17. Troubleshooting the MAC Framework

17.1.Â Synopsis

FreeBSDÂ 5.X introduced new security extensions from the TrustedBSD Project
based on the POSIXÂ®.1e draft. Two of the most significant new security
mechanisms are file system Access Control Lists (ACLs) and Mandatory Access
Control (MAC) facilities. MAC allows new access control modules to be loaded,
implementing new security policies. Some modules provide protections for a
narrow subset of the system, hardening a particular service. Others provide
comprehensive labeled security across all subjects and objects. The mandatory
part of the definition indicates that enforcement of controls is performed by
administrators and the operating system. This is in contrast to the default
security mechanism of Discretionary Access Control (DAC where enforcement is
left to the discretion of users.

This chapter focuses on the MAC framework and the set of pluggable security
policy modules FreeBSD provides for enabling various security mechanisms.

After reading this chapter, you will know:

  * Which MAC security policy modules are included in FreeBSD and their
    associated mechanisms.

  * The capabilities of MAC security policy modules as well as the difference
    between a labeled and non-labeled policy.

  * How to efficiently configure a system to use the MAC framework.

  * How to configure the different security policy modules included with the 
    MAC framework.

  * How to implement a more secure environment using the MAC framework.

  * How to test the MAC configuration to ensure the framework has been properly
    implemented.

Before reading this chapter, you should:

  * Understand UNIXÂ® and FreeBSD basics (ChapterÂ 4, UNIX Basics).

  * Have some familiarity with security and how it pertains to FreeBSD (
    ChapterÂ 15, Security).

Warning:

Improper MAC configuration may cause loss of system access, aggravation of
users, or inability to access the features provided by Xorg. More importantly, 
MAC should not be relied upon to completely secure a system. The MAC framework
only augments an existing security policy. Without sound security practices and
regular security checks, the system will never be completely secure.

The examples contained within this chapter are for demonstration purposes and
the example settings should not be implemented on a production system.
Implementing any security policy takes a good deal of understanding, proper
design, and thorough testing.

17.1.1.Â What Will Not Be Covered

This chapter covers a broad range of security issues relating to the MAC
framework. The development of new MAC security policy modules will not be
covered. A number of security policy modules included with the MAC framework
have specific characteristics which are provided for both testing and new
module development. These include mac_test(4), mac_stub(4) and mac_none(4). For
more information on these security policy modules and the various mechanisms
they provide, refer to their manual pages.

17.2.Â Key Terms in This Chapter

Before reading this chapter, a few key terms must be explained:

  * compartment: a set of programs and data to be partitioned or separated,
    where users are given explicit access to specific component of a system. A
    compartment represents a grouping, such as a work group, department,
    project, or topic. Compartments make it possible to implement a
    need-to-know-basis security policy.

  * high-watermark: this type of policy permits the raising of security levels
    for the purpose of accessing higher level information. In most cases, the
    original level is restored after the process is complete. Currently, the
    FreeBSD MAC framework does not include this type of policy.

  * integrity: the level of trust which can be placed on data. As the integrity
    of the data is elevated, so does the ability to trust that data.

  * label: a security attribute which can be applied to files, directories, or
    other items in the system. It could be considered a confidentiality stamp.
    When a label is placed on a file, it describes the security properties of
    that file and will only permit access by files, users, and resources with a
    similar security setting. The meaning and interpretation of label values
    depends on the policy configuration. Some policies treat a label as
    representing the integrity or secrecy of an object while other policies
    might use labels to hold rules for access.

  * level: the increased or decreased setting of a security attribute. As the
    level increases, its security is considered to elevate as well.

  * low-watermark: this type of policy permits lowering security levels for the
    purpose of accessing information which is less secure. In most cases, the
    original security level of the user is restored after the process is
    complete. The only security policy module in FreeBSD to use this is
    mac_lomac(4).

  * multilabel: this property is a file system option which can be set in
    single user mode using tunefs(8), during boot using fstab(5), or during the
    creation of a new file system. This option permits an administrator to
    apply different MAC labels on different objects. This option only applies
    to security policy modules which support labeling.

  * object: an entity through which information flows under the direction of a 
    subject. This includes directories, files, fields, screens, keyboards,
    memory, magnetic storage, printers or any other data storage or moving
    device. An object is a data container or a system resource. Access to an 
    object effectively means access to its data.

  * policy: a collection of rules which defines how objectives are to be
    achieved. A policy usually documents how certain items are to be handled.
    This chapter considers the term policy to be a security policy, or a
    collection of rules which controls the flow of data and information and
    defines who has access to that data and information.

  * sensitivity: usually used when discussing Multilevel Security MLS. A
    sensitivity level describes how important or secret the data should be. As
    the sensitivity level increases, so does the importance of the secrecy, or
    confidentiality, of the data.

  * single label: a policy where the entire file system uses one label to
    enforce access control over the flow of data. Whenever multilabel is not
    set, all files will conform to the same label setting.

  * subject: any active entity that causes information to flow between objects
    such as a user, user process, or system process. On FreeBSD, this is almost
    always a thread acting in a process on behalf of a user.

17.3.Â Explanation of MAC

With all of these new terms in mind, consider how the MAC framework augments
the security of the system as a whole. The various security policy modules
provided by the MAC framework could be used to protect the network and file
systems or to block users from accessing certain ports and sockets. Perhaps the
best use of the policy modules is to load several security policy modules at a
time in order to provide a MLS environment. This approach differs from a
hardening policy, which typically hardens elements of a system which are used
only for specific purposes. The downside to MLS is increased administrative
overhead.

The overhead is minimal when compared to the lasting effect of a framework
which provides the ability to pick and choose which policies are required for a
specific configuration and which keeps performance overhead down. The reduction
of support for unneeded policies can increase the overall performance of the
system as well as offer flexibility of choice. A good implementation would
consider the overall security requirements and effectively implement the
various security policy modules offered by the framework.

A system utilizing MAC guarantees that a user will not be permitted to change
security attributes at will. All user utilities, programs, and scripts must
work within the constraints of the access rules provided by the selected
security policy modules and total control of the MAC access rules are in the
hands of the system administrator.

It is the duty of the system administrator to carefully select the correct
security policy modules. For an environment that needs to limit access control
over the network, the mac_portacl(4), mac_ifoff(4), and mac_biba(4) policy
modules make good starting points. For an environment where strict
confidentiality of file system objects is required, consider the
mac_bsdextended(4) and mac_mls(4) policy modules.

Policy decisions could be made based on network configuration. If only certain
users should be permitted access to ssh(1), the mac_portacl(4) policy module is
a good choice. In the case of file systems, access to objects might be
considered confidential to some users, but not to others. As an example, a
large development team might be broken off into smaller projects where
developers in project A might not be permitted to access objects written by
developers in project B. Yet both projects might need to access objects created
by developers in project C. Using the different security policy modules
provided by the MAC framework, users could be divided into these groups and
then given access to the appropriate objects.

Each security policy module has a unique way of dealing with the overall
security of a system. Module selection should be based on a well thought out
security policy which may require revision and reimplementation. Understanding
the different security policy modules offered by the MAC framework will help
administrators choose the best policies for their situations.

Caution:

Implementing MAC is much like implementing a firewall, care must be taken to
prevent being completely locked out of the system. The ability to revert back
to a previous configuration should be considered and the implementation of MAC
remotely should be done with extreme caution.

17.4.Â Understanding MAC Labels

A MAC label is a security attribute which may be applied to subjects and
objects throughout the system.

When setting a label, the administrator must be able to comprehend what exactly
is being done and understand any implications in order to prevent unexpected or
undesired behavior of the system. The attributes available on an object depend
on the loaded policy module as policy modules interpret their attributes in
different ways.

The security label on an object is used as a part of a security access control
decision by a policy. With some policies, the label contains all of the
information necessary to make a decision. In other policies, the labels may be
processed as part of a larger rule set. For instance, setting the label of biba
/low on a file will represent a label maintained by the Biba security policy
module, with a value of â  lowâ  .

A few policy modules which support the labeling feature in FreeBSD offer three
specific predefined labels: low, high, and equal. Such policy modules enforce
access control in a different manner with each policy module, where the low
label is the lowest setting, the equal label sets the subject or object to be
disabled or unaffected, and the high label enforces the highest setting
available in the Biba and MLS policy modules.

Within single label file system environments, only one label may be used on
objects. This label enforces one set of access permissions across the entire
system and in many environments may be all that is required. There are a few
cases where multiple labels may be set on objects or subjects in the file
system by passing multilabel to tunefs(8).

In the case of Biba and MLS, a numeric label may be set to indicate the precise
level of hierarchical control. This numeric level is used to partition or sort
information into different groups of classification only permitting access to
that group or a higher group level.

In most cases, the administrator will set up a single label to use throughout
the file system. This is similar to DAC to some extent as root is the one in
control and who configures the policies so that users are placed in the
appropriate categories/access levels. Alas, many policy modules can restrict
the root user as well. Basic control over objects will then be released to the
group, but root may revoke or modify the settings at any time. This is the
hierarchical/clearance model covered by policies such as Biba and MLS.

17.4.1.Â Label Configuration

Virtually all aspects of label policy module configuration will be performed
using the base system utilities. These commands provide a simple interface for
object or subject configuration or the manipulation and verification of the
configuration.

All configuration may be done using setfmac(8) and setpmac(8). setfmac is used
to set MAC labels on system objects while setpmac is used to set the labels on
system subjects. Observe:

# setfmac biba/high test

If the configuration is successful, the prompt will be returned without error.
A common error is Permission denied which usually occurs when the label is
being set or modified on an object which is restricted.^[6] The system
administrator may use the following commands to overcome this:

# setfmac biba/high test Permission denied # setpmac biba/low setfmac biba/high
test # getfmac test test: biba/high

setpmac can be used to override the policy module's settings by assigning a
different label to the invoked process. getpmac is usually used with currently
running processes, such as sendmail. It takes a process ID in place of a
command. If users attempt to manipulate a file not in their access, subject to
the rules of the loaded policy modules, the Operation not permitted error will
be displayed by the mac_set_link function.

17.4.1.1.Â Common Label Types

For the mac_biba(4), mac_mls(4) and mac_lomac(4) policy modules, the ability to
assign simple labels is provided. These take the form of high, equal, and low,
where:

  * The low label is considered the lowest label setting an object or subject
    may have. Setting this on objects or subjects blocks their access to
    objects or subjects marked high.

  * The equal label should only be placed on objects considered to be exempt
    from the policy.

  * The high label grants an object or subject the highest possible setting.

With respect to each policy module, each of those settings will establish a
different information flow directive. Refer to the manual pages of the module
to determine the traits of these generic label configurations.

17.4.1.1.1.Â Advanced Label Configuration

Numeric grade labels are used for comparison:compartment+compartment. For
example:

biba/10:2+3+6(5:2+3-20:2+3+4+5+6)

may be interpreted as â  Biba Policy Labelâ  /â  Grade 10â  :â  Compartments 2,
3 and 6â  : (â  grade 5 ...â  )

In this example, the first grade would be considered the â  effective gradeâ  
with â  effective compartmentsâ  , the second grade is the low grade, and the
last one is the high grade. In most configurations, these settings will not be
used as they are advanced configurations.

System objects only have a current grade/compartment. System subjects reflect
the range of available rights in the system, and network interfaces, where they
are used for access control.

The grade and compartments in a subject and object pair are used to construct a
relationship known as â  dominanceâ  , in which a subject dominates an object,
the object dominates the subject, neither dominates the other, or both dominate
each other. The â  both dominateâ   case occurs when the two labels are equal.
Due to the information flow nature of Biba, a user has rights to a set of
compartments that might correspond to projects, but objects also have a set of
compartments. Users may have to subset their rights using su or setpmac in
order to access objects in a compartment from which they are not restricted.

17.4.1.2.Â Users and Label Settings

Users are required to have labels so that their files and processes properly
interact with the security policy defined on the system. This is configured in
login.conf using login classes. Every policy module that uses labels will
implement the user class setting.

An example entry containing every policy module setting is displayed below:

default:\ :copyright=/etc/COPYRIGHT:\ :welcome=/etc/motd:\ :setenv=MAIL=/var/
mail/$,BLOCKSIZE=K:\ :path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:
/usr/local/bin:\ :manpath=/usr/share/man /usr/local/man:\ :nologin=/usr/sbin/
nologin:\ :cputime=1h30m:\ :datasize=8M:\ :vmemoryuse=100M:\ :stacksize=2M:\
:memorylocked=4M:\ :memoryuse=8M:\ :filesize=8M:\ :coredumpsize=8M:\ :openfiles
=24:\ :maxproc=32:\ :priority=0:\ :requirehome:\ :passwordtime=91d:\ :umask=
022:\ :ignoretime@:\ :label=partition/13,mls/5,biba/10(5-15),lomac/10[2]:

To set the user class default label which will be enforced by MAC, use label.
Users are never permitted to modify this value. In a real configuration,
however, the administrator would never enable every policy module. It is
recommended that the rest of this chapter be reviewed before any configuration
is implemented.

Note:

Users may change their label after they login, subject to the constraints of
the policy. The example above tells the Biba policy that a process's minimum
integrity is 5, its maximum is 15, and the default effective label is 10. The
process will run at 10 until it chooses to change label, perhaps due to the
user using setpmac(8), which will be constrained by Biba to the configured
range.

After any change to login.conf, the login class capability database must be
rebuilt using cap_mkdb.

Many sites have a large number of users requiring several different user
classes. In depth planning is required as this may get extremely difficult to
manage.

17.4.1.3.Â Network Interfaces and Label Settings

Labels may be set on network interfaces to help control the flow of data across
the network. Policies using network interface labels function in the same way
that policies function with respect to objects. Users at high settings in biba,
for example, will not be permitted to access network interfaces with a label of
low.

maclabel may be passed to ifconfig when setting the MAC label on network
interfaces. For example:

# ifconfig bge0 maclabel biba/equal

will set the MAC label of biba/equal on the bge(4) interface. When using a
setting similar to biba/high(low-high), the entire label should be quoted to
prevent an error from being returned.

Each policy module which supports labeling has a tunable which may be used to
disable the MAC label on network interfaces. Setting the label to equal will
have a similar effect. Review the output of sysctl, the policy manual pages,
and the information in this chapter for more information on those tunables.

17.4.2.Â Singlelabel or Multilabel?

By default, the system will use singlelabel. For the administrator, there are
several differences which offer pros and cons to the flexibility in the
system's security model.

A security policy which uses singlelabel only permits one label, such as biba/
high, to be used for each subject or object. This provides lower administration
overhead, but decreases the flexibility of policies which support labeling.

multilabel permits each subject or object to have its own independent MAC
label. The decision to use multilabel or singlelabel is only required for the
policies which implement the labeling feature, including the Biba, Lomac, and 
MLS policies.

In many cases, multilabel may not be needed. Consider the following situation
and security model:

  * FreeBSD web-server using the MAC framework and a mix of the various
    policies.

  * This machine only requires one label, biba/high, for everything in the
    system. This file system would not require multilabel as a single label
    will always be in effect.

  * But, this machine will be a web server and should have the web server run
    at biba/low to prevent write up capabilities. The server could use a
    separate partition set at biba/low for most if not all of its runtime
    state.

If any of the non-labeling policies are to be used, multilabel would not be
required. These include the seeotheruids, portacl and partition policies.

Using multilabel with a partition and establishing a security model based on
multilabel functionality could increase administrative overhead as everything
in the file system has a label. This includes directories, files, and even
device nodes.

The following command will set multilabel on the file systems to have multiple
labels. This may only be done in single user mode and is not a requirement for
the swap file system:

# tunefs -l enable /

Note:

Some users have experienced problems with setting the multilabel flag on the
root partition. If this is the case, please review the SectionÂ 17.17, â  
Troubleshooting the MAC Frameworkâ   of this chapter.

17.5.Â Planning the Security Configuration

Whenever a new technology is implemented, a planning phase is recommended.
During the planning stages, an administrator should consider the implementation
requirements and the implementation goals.

For MAC installations, these include:

  * How to classify information and resources available on the target systems.

  * Which information or resources to restrict access to along with the type of
    restrictions that should be applied.

  * Which MAC module or modules will be required to achieve this goal.

Good planning helps to ensure a trouble-free and efficient trusted system
implementation. A trial run of the trusted system and its configuration should
occur before a MAC implementation is used on production systems. The idea of
just letting loose on a system with MAC is like setting up for failure.

Different environments have different needs and requirements. Establishing an
in depth and complete security profile will decrease the need of changes once
the system goes live. The rest of this chapter covers the available modules,
describes their use and configuration, and in some cases, provides insight on
applicable situations. For instance, a web server might use the mac_biba(4) and
mac_bsdextended(4) policies. In the case of a machine with few local users,
mac_partition(4) might be a good choice.

17.6.Â Module Configuration

Beginning with FreeBSDÂ 8.0, the default FreeBSD kernel includes options MAC.
This means that every module included with the MAC framework may be loaded as a
run-time kernel module. The recommended method is to add the module name to /
boot/loader.conf so that it will load during boot. Each module also provides a
kernel option for those administrators who choose to compile their own custom
kernel.

Some modules support the use of labeling, which is controlling access by
enforcing a label such as â  this is allowed and this is notâ  . A label
configuration file may control how files may be accessed, network communication
can be exchanged, and more. The previous section showed how the multilabel flag
could be set on file systems to enable per-file or per-partition access
control.

A single label configuration enforces only one label across the system, that is
why the tunefs option is called multilabel.

17.7.Â The mac_seeotheruids(4) Module

Module name: mac_seeotheruids.ko

Kernel configuration line: options MAC_SEEOTHERUIDS

Boot option: mac_seeotheruids_load="YES"

The mac_seeotheruids(4) module mimics and extends the
security.bsd.see_other_uids and security.bsd.see_other_gids sysctl tunables.
This option does not require any labels to be set before configuration and can
operate transparently with the other modules.

After loading the module, the following sysctl tunables may be used to control
the features:

  * security.mac.seeotheruids.enabled enables the module and uses the default
    settings which deny users the ability to view processes and sockets owned
    by other users.

  * security.mac.seeotheruids.specificgid_enabled allows certain groups to be
    exempt from this policy. To exempt specific groups from this policy, use
    the security.mac.seeotheruids.specificgid=XXX sysctl tunable. Replace XXX
    with the numeric group ID to be exempted.

  * security.mac.seeotheruids.primarygroup_enabled is used to exempt specific
    primary groups from this policy. When using this tunable,
    security.mac.seeotheruids.specificgid_enabled may not be set.

17.8.Â The mac_bsdextended(4) Module

Module name: mac_bsdextended.ko

Kernel configuration line: options MAC_BSDEXTENDED

Boot option: mac_bsdextended_load="YES"

The mac_bsdextended(4) module enforces the file system firewall. This module's
policy provides an extension to the standard file system permissions model,
permitting an administrator to create a firewall-like ruleset to protect files,
utilities, and directories in the file system hierarchy. When access to a file
system object is attempted, the list of rules is iterated until either a
matching rule is located or the end is reached. This behavior may be changed by
the use of a sysctl(8) parameter, security.mac.bsdextended.firstmatch_enabled.
Similar to other firewall modules in FreeBSD, a file containing the access
control rules can be created and read by the system at boot time using an
rc.conf(5) variable.

The rule list may be entered using ugidfw(8) which has a syntax similar to ipfw
(8). More tools can be written by using the functions in the libugidfw(3)
library.

Extreme caution should be taken when working with this module as incorrect use
could block access to certain parts of the file system.

17.8.1.Â Examples

After the mac_bsdextended(4) module has been loaded, the following command may
be used to list the current rule configuration:

# ugidfw list 0 slots, 0 rules

By default, no rules are defined and everything is completely accessible. To
create a rule which will block all access by users but leave root unaffected,
run the following command:

# ugidfw add subject not uid root new object not uid root mode n

This is a very bad idea as it will block all users from issuing even the most
simple commands, such as ls. The next example will block user1 any and all
access, including directory listings, to user2's home directory:

# ugidfw set 2 subject uid user1 object uid user2 mode n # ugidfw set 3 subject
uid user1 object gid user2 mode n

Instead of user1, not uid user2 could be used. This enforces the same access
restrictions for all users instead of just one user.

Note:

The root user is unaffected by these changes.

For more information, refer to mac_bsdextended(4) and ugidfw(8)

17.9.Â The mac_ifoff(4) Module

Module name: mac_ifoff.ko

Kernel configuration line: options MAC_IFOFF

Boot option: mac_ifoff_load="YES"

The mac_ifoff(4) module exists solely to disable network interfaces on the fly
and keep network interfaces from being brought up during system boot. It does
not require any labels to be set up on the system, nor does it depend on other 
MAC modules.

Most of this module's control is performed through the sysctl tunables listed
below.

  * security.mac.ifoff.lo_enabled enables or disables all traffic on the
    loopback (lo(4)) interface.

  * security.mac.ifoff.bpfrecv_enabled enables or disables all traffic on the
    Berkeley Packet Filter interface (bpf(4))

  * security.mac.ifoff.other_enabled enables or disables traffic on all other
    interfaces.

One of the most common uses of mac_ifoff(4) is network monitoring in an
environment where network traffic should not be permitted during the boot
sequence. Another suggested use would be to write a script which uses security/
aide to automatically block network traffic if it finds new or altered files in
protected directories.

17.10.Â The mac_portacl(4) Module

Module name: mac_portacl.ko

Kernel configuration line: MAC_PORTACL

Boot option: mac_portacl_load="YES"

The mac_portacl(4) module is used to limit binding to local TCP and UDP ports
using a variety of sysctl variables. mac_portacl(4) makes it possible to allow
non-root users to bind to specified privileged ports below 1024.

Once loaded, this module enables the MAC policy on all sockets. The following
tunables are available:

  * security.mac.portacl.enabled enables or disables the policy completely.

  * security.mac.portacl.port_high sets the highest port number that
    mac_portacl(4) protects.

  * security.mac.portacl.suser_exempt, when set to a non-zero value, exempts
    the root user from this policy.

  * security.mac.portacl.rules specifies the mac_portacl policy, which is a
    text string of the form: rule[,rule,...] with as many rules as needed. Each
    rule is of the form: idtype:id:protocol:port. The idtype parameter can be
    uid or gid and is used to interpret the id parameter as either a user id or
    group id, respectively. The protocol parameter is used to determine if the
    rule should apply to TCP or UDP by setting the parameter to tcp or udp. The
    final port parameter is the port number to allow the specified user or
    group to bind to.

Note:

Since the ruleset is interpreted directly by the kernel, only numeric values
can be used for the user ID, group ID, and port parameters. Names cannot be
used for users, groups, or services.

By default, ports below 1024 can only be used by or bound to privileged
processes, which run as root. For mac_portacl(4) to allow non-privileged
processes to bind to ports below 1024, this restriction has to be disabled by
setting the sysctl(8) variables net.inet.ip.portrange.reservedlow and
net.inet.ip.portrange.reservedhigh to zero:

# sysctl security.mac.portacl.port_high=1023 # sysctl
net.inet.ip.portrange.reservedlow=0 net.inet.ip.portrange.reservedhigh=0

See the examples below or refer to mac_portacl(4) for further information.

17.10.1.Â Examples

Since the root user should not be crippled by this policy, this example starts
by setting the security.mac.portacl.suser_exempt to a non-zero value.

# sysctl security.mac.portacl.suser_exempt=1

Next, allow the user with UID 80 to bind to port 80. This allows the www user
to run a web server without ever having root privilege.

# sysctl security.mac.portacl.rules=uid:80:tcp:80

The next example permits the user with the UID of 1001 to bind to the TCP ports
110 (â  pop3â  ) and 995 (â  pop3sâ  ). This permits this user to start a
server that accepts connections on ports 110 and 995.

# sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995

17.11.Â The mac_partition(4) Module

Module name: mac_partition.ko

Kernel configuration line: options MAC_PARTITION

Boot option: mac_partition_load="YES"

The mac_partition(4) policy will drop processes into specific â  partitionsâ  
based on their MAC label. This module should be added to loader.conf(5) so that
it loads and enables the policy at system boot.

Most configuration for this policy is done using setpmac(8). One sysctl tunable
is available for this policy:

  * security.mac.partition.enabled enables the enforcement of MAC process
    partitions.

When this policy is enabled, users will only be permitted to see their
processes, and any others within their partition, but will not be permitted to
work with utilities outside the scope of this partition. For instance, a user
in the insecure class will not be permitted to access top as well as many other
commands that must spawn a process.

To set or drop utilities into a partition label, use the setpmac utility:

# setpmac partition/13 top

This example adds top to the label set on users in the insecure class. All
processes spawned by users in the insecure class will stay in the partition/13
label.

17.11.1.Â Examples

The following command will display the partition label and the process list:

# ps Zax

This command will display another user's process partition label and that
user's currently running processes:

# ps -ZU trhodes

Note:

Users can see processes in root's label unless the mac_seeotheruids(4) policy
is loaded.

A really crafty implementation could have all of the services disabled in /etc/
rc.conf and started by a script that starts them with the proper labeling set.

Note:

The following policies support integer settings in place of the three default
labels offered. These options, including their limitations, are further
explained in the module manual pages.

17.12.Â The MAC Multi-Level Security Module

Module name: mac_mls.ko

Kernel configuration line: options MAC_MLS

Boot option: mac_mls_load="YES"

The mac_mls(4) policy controls access between subjects and objects in the
system by enforcing a strict information flow policy.

In MLS environments, a â  clearanceâ   level is set in the label of each
subject or object, along with compartments. Since these clearance or
sensibility levels can reach numbers greater than several thousand; it would be
a daunting task for any system administrator to thoroughly configure each
subject or object. Thankfully, three â  instantâ   labels are included in this
policy.

These labels are mls/low, mls/equal and mls/high. Since these labels are
described in depth in the manual page, they will only get a brief description
here:

  * The mls/low label contains a low configuration which permits it to be
    dominated by all other objects. Anything labeled with mls/low will have a
    low clearance level and not be permitted to access information of a higher
    level. This label also prevents objects of a higher clearance level from
    writing or passing information on to them.

  * The mls/equal label should be placed on objects considered to be exempt
    from the policy.

  * The mls/high label is the highest level of clearance possible. Objects
    assigned this label will hold dominance over all other objects in the
    system; however, they will not permit the leaking of information to objects
    of a lower class.

MLS provides:

  * A hierarchical security level with a set of non hierarchical categories.

  * Fixed rules of no read up, no write down. This means that a subject can
    have read access to objects on its own level or below, but not above.
    Similarly, a subject can have write access to objects on its own level or
    above but not beneath.

  * Secrecy, or the prevention of inappropriate disclosure of data.

  * A basis for the design of systems that concurrently handle data at multiple
    sensitivity levels without leaking information between secret and
    confidential.

The following sysctl tunables are available for the configuration of special
services and interfaces:

  * security.mac.mls.enabled is used to enable or disable the MLS policy.

  * security.mac.mls.ptys_equal labels all pty(4) devices as mls/equal during
    creation.

  * security.mac.mls.revocation_enabled revokes access to objects after their
    label changes to a label of a lower grade.

  * security.mac.mls.max_compartments sets the maximum number of compartment
    levels allowed on a system.

To manipulate the MLS labels, use setfmac(8). To assign a label to an object,
issue the following command:

# setfmac mls/5 test

To get the MLS label for the file test, issue the following command:

# getfmac test

Another approach is to create a master policy file in /etc/ which specifies the
MLS policy information and to feed that file to setfmac. This method will be
explained after all policies are covered.

17.12.1.Â Planning Mandatory Sensitivity

When using the MLS policy module, an administrator plans to control the flow of
sensitive information. The default block read up block write down sets
everything to a low state. Everything is accessible and an administrator slowly
augments the confidentiality of the information during the configuration
stage;.

Beyond the three basic label options, an administrator may group users and
groups as required to block the information flow between them. It might be
easier to look at the information in clearance levels using descriptive words,
such as classifications of Confidential, Secret, and Top Secret. Some
administrators instead create different groups based on project levels.
Regardless of the classification method, a well thought out plan must exist
before implementing such a restrictive policy.

Some example situations for the MLS policy module include an e-commerce web
server, a file server holding critical company information, and financial
institution environments.

17.13.Â The MAC Biba Module

Module name: mac_biba.ko

Kernel configuration line: options MAC_BIBA

Boot option: mac_biba_load="YES"

The mac_biba(4) module loads the MAC Biba policy. This policy is similar to the
MLS policy with the exception that the rules for information flow are slightly
reversed. This is to prevent the downward flow of sensitive information whereas
the MLS policy prevents the upward flow of sensitive information. Much of this
section can apply to both policies.

In Biba environments, an â  integrityâ   label is set on each subject or
object. These labels are made up of hierarchical grades and non-hierarchical
components. As an grade ascends, so does its integrity.

Supported labels are biba/low, biba/equal, and biba/high; as explained below:

  * The biba/low label is considered the lowest integrity an object or subject
    may have. Setting this on objects or subjects will block their write access
    to objects or subjects marked high. They still have read access though.

  * The biba/equal label should only be placed on objects considered to be
    exempt from the policy.

  * The biba/high label will permit writing to objects set at a lower label,
    but not permit reading that object. It is recommended that this label be
    placed on objects that affect the integrity of the entire system.

Biba provides:

  * Hierarchical integrity level with a set of non hierarchical integrity
    categories.

  * Fixed rules are no write up, no read down, the opposite of MLS. A subject
    can have write access to objects on its own level or below, but not above.
    Similarly, a subject can have read access to objects on its own level or
    above, but not below.

  * Integrity by preventing inappropriate modification of data.

  * Integrity levels instead of MLS sensitivity levels.

The following sysctl tunables can be used to manipulate the Biba policy:

  * security.mac.biba.enabled is used to enable or disable enforcement of the
    Biba policy on the target machine.

  * security.mac.biba.ptys_equal is used to disable the Biba policy on pty(4)
    devices.

  * security.mac.biba.revocation_enabled forces the revocation of access to
    objects if the label is changed to dominate the subject.

To access the Biba policy setting on system objects, use setfmac and getfmac:

# setfmac biba/low test # getfmac test test: biba/low

17.13.1.Â Planning Mandatory Integrity

Integrity, which is different from sensitivity, guarantees that the information
will never be manipulated by untrusted parties. This includes information
passed between subjects, objects, and both. It ensures that users will only be
able to modify or access information they explicitly need to.

The mac_biba(4) security policy module permits an administrator to address
which files and programs a user may see and invoke while assuring that the
programs and files are free from threats and trusted by the system for that
user.

During the initial planning phase, an administrator must be prepared to
partition users into grades, levels, and areas. Users will be blocked access
not only to data but to programs and utilities both before and after they
start. The system will default to a high label once this policy module is
enabled, and it is up to the administrator to configure the different grades
and levels for users. Instead of using clearance levels, a good planning method
could include topics. For instance, only allow developers modification access
to the source code repository, source code compiler, and other development
utilities. Other users would be grouped into other categories such as testers,
designers, or end users and would only be permitted read access.

A lower integrity subject is unable to write to a higher integrity subject and
a higher integrity subject cannot observe or read a lower integrity object.
Setting a label at the lowest possible grade could make it inaccessible to
subjects. Some prospective environments for this security policy module would
include a constrained web server, a development and test machine, and a source
code repository. A less useful implementation would be a personal workstation,
a machine used as a router, or a network firewall.

17.14.Â The MAC LOMAC Module

Module name: mac_lomac.ko

Kernel configuration line: options MAC_LOMAC

Boot option: mac_lomac_load="YES"

Unlike the MAC Biba policy, the mac_lomac(4) policy permits access to lower
integrity objects only after decreasing the integrity level to not disrupt any
integrity rules.

The MAC version of the Low-watermark integrity policy works almost identically
to Biba, but with the exception of using floating labels to support subject
demotion via an auxiliary grade compartment. This secondary compartment takes
the form [auxgrade]. When assigning a LOMAC policy with an auxiliary grade, use
the syntax lomac/10[2] where the number two (2) is the auxiliary grade.

The MAC LOMAC policy relies on the ubiquitous labeling of all system objects
with integrity labels, permitting subjects to read from low integrity objects
and then downgrading the label on the subject to prevent future writes to high
integrity objects using [auxgrade]. The policy may provide for greater
compatibility and require less initial configuration than Biba.

17.14.1.Â Examples

Like the Biba and MLS policies, setfmac and setpmac are used to place labels on
system objects:

# setfmac /usr/home/trhodes lomac/high[low] # getfmac /usr/home/trhodes lomac/
high[low]

The auxiliary grade low is a feature provided only by the MAC LOMAC policy.

17.15.Â Nagios in a MAC Jail

The following demonstration implements a secure environment using various MAC
modules with properly configured policies. This is only a test as implementing
a policy and ignoring it could be disastrous in a production environment.

Before beginning this process, multilabel must be set on each file system as
not doing so will result in errors. This example assumes that net-mngt/
nagios-plugins, net-mngt/nagios, and www/apache22 are all installed,
configured, and working correctly.

17.15.1.Â Create an Insecure User Class

Begin the procedure by adding the following user class to /etc/login.conf:

insecure:\ :copyright=/etc/COPYRIGHT:\ :welcome=/etc/motd:\ :setenv=MAIL=/var/
mail/$,BLOCKSIZE=K:\ :path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:
/usr/local/bin :manpath=/usr/share/man /usr/local/man:\ :nologin=/usr/sbin/
nologin:\ :cputime=1h30m:\ :datasize=8M:\ :vmemoryuse=100M:\ :stacksize=2M:\
:memorylocked=4M:\ :memoryuse=8M:\ :filesize=8M:\ :coredumpsize=8M:\ :openfiles
=24:\ :maxproc=32:\ :priority=0:\ :requirehome:\ :passwordtime=91d:\ :umask=
022:\ :ignoretime@:\ :label=biba/10(10-10):

Add the following line to the default user class:

:label=biba/high:

Next, issue the following command to rebuild the database:

# cap_mkdb /etc/login.conf

17.15.2.Â Boot Configuration

Add the following lines to /boot/loader.conf:

mac_biba_load="YES" mac_seeotheruids_load="YES"

17.15.3.Â Configure Users

Set the root user to the default class using:

# pw usermod root -L default

All user accounts that are not root or system users will now require a login
class. The login class is required otherwise users will be refused access to
common commands such as vi(1). The following sh script should do the trick:

# for x in `awk -F: '($3 &gt;= 1001) && ($3 != 65534) { print $1 }' \ /etc/passwd
`; do pw usermod $x -L default; done;

Drop the nagios and www users into the insecure class:

# pw usermod nagios -L insecure
# pw usermod www -L insecure

17.15.4.Â Create the Contexts File

A contexts file should now be created as /etc/policy.contexts.

# This is the default BIBA policy for this system. # System: /var/run biba/
equal /var/run/* biba/equal /dev biba/equal /dev/* biba/equal /var biba/equal /
var/spool biba/equal /var/spool/* biba/equal /var/log biba/equal /var/log/*
biba/equal /tmp biba/equal /tmp/* biba/equal /var/tmp biba/equal /var/tmp/*
biba/equal /var/spool/mqueue biba/equal /var/spool/clientmqueue biba/equal #
For Nagios: /usr/local/etc/nagios /usr/local/etc/nagios/* biba/10 /var/spool/
nagios biba/10 /var/spool/nagios/* biba/10 # For apache /usr/local/etc/apache
biba/10 /usr/local/etc/apache/* biba/10

This policy enforces security by setting restrictions on the flow of
information. In this specific configuration, users, including root, should
never be allowed to access Nagios. Configuration files and processes that are a
part of Nagios will be completely self contained or jailed.

This file will be read by the system by issuing the following command:

# setfsmac -ef /etc/policy.contexts / # setfsmac -ef /etc/policy.contexts /

Note:

The above file system layout will differ depending upon the environment and
must be run on every file system.

/etc/mac.conf requires the following modifications in the main section:

default_labels file ?biba default_labels ifnet ?biba default_labels process ?
biba default_labels socket ?biba

17.15.5.Â Enable Networking

Add the following line to /boot/loader.conf:

security.mac.biba.trust_all_interfaces=1

And the following to the network card configuration stored in rc.conf. If the
primary Internet configuration is done via DHCP, this may need to be configured
manually after every system boot:

maclabel biba/equal

17.15.6.Â Testing the Configuration

Ensure that the web server and Nagios will not be started on system
initialization and reboot. Ensure the root user cannot access any of the files
in the Nagios configuration directory. If root can issue an ls(1) command on /
var/spool/nagios, something is wrong. Otherwise a â  permission deniedâ   error
should be returned.

If all seems well, Nagios, Apache, and Sendmail can now be started:

# cd /etc/mail && make stop && \ setpmac biba/equal make start && setpmac biba/
10\(10-10\) apachectl start && \ setpmac biba/10\(10-10\) /usr/local/etc/rc.d/
nagios.sh forcestart

Double check to ensure that everything is working properly. If not, check the
log files for error messages. Use sysctl(8) to disable the mac_biba(4) security
policy module enforcement and try starting everything again as usual.

Note:

The root user can still change the security enforcement and edit its
configuration files. The following command will permit the degradation of the
security policy to a lower grade for a newly spawned shell:

# setpmac biba/10 csh

To block this from happening, force the user into a range using login.conf(5).
If setpmac(8) attempts to run a command outside of the compartment's range, an
error will be returned and the command will not be executed. In this case, set
root to biba/high(high-high).

17.16.Â User Lock Down

This example considers a relatively small storage system with fewer than fifty
users. Users will have login capabilities, and be permitted to store data and
access resources.

For this scenario, the mac_bsdextended(4) and mac_seeotheruids(4) policy
modules could co-exist and block access to system objects while hiding user
processes.

Begin by adding the following line to /boot/loader.conf:

mac_seeotheruids_load="YES"

The mac_bsdextended(4) security policy module may be activated by adding this
line to /etc/rc.conf:

ugidfw_enable="YES"

Default rules stored in /etc/rc.bsdextended will be loaded at system
initialization. However, the default entries may need modification. Since this
machine is expected only to service users, everything may be left commented out
except the last two lines in order to force the loading of user owned system
objects by default.

Add the required users to this machine and reboot. For testing purposes, try
logging in as a different user across two consoles. Run ps aux to see if
processes of other users are visible. Verify that running ls(1) on another
user's home directory fails.

Do not try to test with the root user unless the specific sysctls have been
modified to block super user access.

Note:

When a new user is added, their mac_bsdextended(4) rule will not be in the
ruleset list. To update the ruleset quickly, unload the security policy module
and reload it again using kldunload(8) and kldload(8).

17.17.Â Troubleshooting the MAC Framework

This section discusses common configuration issues.

17.17.1.Â multilabel cannot be enabled on /

Themultilabel flag does not stay enabled on my root (/) partition!

The following steps may resolve this transient error:

 1. Edit /etc/fstab and set the root partition to ro for read-only.

 2. Reboot into single user mode.

 3. Run tunefs -l enable on /.

 4. Reboot the system.

 5. Run mount -urw / and change the ro back to rw in /etc/fstab and reboot the
    system again.

 6. Double-check the output from mount to ensure that multilabel has been
    properly set on the root file system.

17.17.2.Â Xorg Server Will Not Start After MAC

After establishing a secure environment with MAC, I am no longer able to start
Xorg!

This could be caused by the MAC partition policy or by a mislabeling in one of
the MAC labeling policies. To debug, try the following:

 1. Check the error message; if the user is in the insecure class, the
    partition policy may be the culprit. Try setting the user's class back to
    the default class and rebuild the database with cap_mkdb. If this does not
    alleviate the problem, go to step two.

 2. Double-check the label policies. Ensure that the policies are set correctly
    for the user, the Xorg application, and the /dev entries.

 3. If neither of these resolve the problem, send the error message and a
    description of the environment to the FreeBSD general questions mailing
    list mailing list.

17.17.3.Â Error: _secure_path(3) cannot stat .login_conf

When a user attempts to switch from the root user to another user in the
system, the error message _secure_path: unable to state .login_conf appears.

This message is usually shown when the user has a higher label setting than
that of the user they are attempting to become. For instance, joe has a default
label of biba/low. The root user, who has a label of biba/high, cannot view
joe's home directory. This will happen whether or not root has used su to
become joe as the Biba integrity model will not permit root to view objects set
at a lower integrity level.

17.17.4.Â The root username is broken!

In normal or even single user mode, the root is not recognized, whoami returns
0 (zero), and su returns who are you?.

This can happen if a labeling policy has been disabled, either by a sysctl(8)
or the policy module was unloaded. If the policy is disabled, the login
capabilities database needs to be reconfigured with label removed. Double check
login.conf to ensure that all label options have been removed and rebuild the
database with cap_mkdb.

This may also happen if a policy restricts access to master.passwd. This is
usually caused by an administrator altering the file under a label which
conflicts with the general policy being used by the system. In these cases, the
user information would be read by the system and access would be blocked as the
file has inherited the new label. Disable the policy using sysctl(8) and
everything should return to normal.


------------

^[6] Other conditions may produce different failures. For instance, the file
may not be owned by the user attempting to relabel the object, the object may
not exist, or the object may be read only. A mandatory policy will not allow
the process to relabel the file, maybe because of a property of the file, a
property of the process, or a property of the proposed new label value. For
example, a user running at low integrity tries to change the label of a high
integrity file. Or perhaps a user running at low integrity tries to change the
label of a low integrity file to a high integrity label.

ChapterÂ 18.Â Security Event Auditing

Written by Tom Rhodes and Robert Watson.
Table of Contents

18.1. Synopsis
18.2. Key Terms in This Chapter
18.3. Installing Audit Support
18.4. Audit Configuration
18.5. Administering the Audit Subsystem

18.1.Â Synopsis

The FreeBSD operating system includes support for fine-grained security event
auditing. Event auditing allows the reliable, fine-grained, and configurable
logging of a variety of security-relevant system events, including logins,
configuration changes, and file and network access. These log records can be
invaluable for live system monitoring, intrusion detection, and postmortem
analysis. FreeBSD implements Sunâ ¢'s published BSM API and file format, and is
interoperable with both Sunâ ¢'s Solarisâ ¢ and AppleÂ®'s MacÂ OSÂ® X audit
implementations.

This chapter focuses on the installation and configuration of Event Auditing.
It explains audit policies, and provides an example audit configuration.

After reading this chapter, you will know:

  * What Event Auditing is and how it works.

  * How to configure Event Auditing on FreeBSD for users and processes.

  * How to review the audit trail using the audit reduction and review tools.

Before reading this chapter, you should:

  * Understand UNIXÂ® and FreeBSD basics (ChapterÂ 4, UNIX Basics).

  * Be familiar with the basics of kernel configuration/compilation (
    ChapterÂ 9, Configuring the FreeBSD Kernel).

  * Have some familiarity with security and how it pertains to FreeBSD (
    ChapterÂ 15, Security).

Warning:

The audit facility has some known limitations which include that not all
security-relevant system events are currently auditable, and that some login
mechanisms, such as X11-based display managers and third party daemons, do not
properly configure auditing for user login sessions.

The security event auditing facility is able to generate very detailed logs of
system activity: on a busy system, trail file data can be very large when
configured for high detail, exceeding gigabytes a week in some configurations.
Administrators should take into account disk space requirements associated with
high volume audit configurations. For example, it may be desirable to dedicate
a file system to the /var/audit tree so that other file systems are not
affected if the audit file system becomes full.

18.2.Â Key Terms in This Chapter

Before reading this chapter, a few key audit-related terms must be explained:

  * event: An auditable event is any event that can be logged using the audit
    subsystem. Examples of security-relevant events include the creation of a
    file, the building of a network connection, or a user logging in. Events
    are either â  attributableâ  , meaning that they can be traced to an
    authenticated user, or â  non-attributableâ   if they cannot be. Examples
    of non-attributable events are any events that occur before authentication
    in the login process, such as bad password attempts.

  * class: Event classes are named sets of related events, and are used in
    selection expressions. Commonly used classes of events include â  file
    creationâ   (fc), â  execâ   (ex) and â  login_logoutâ   (lo).

  * record: A record is an audit log entry describing a security event. Records
    contain a record event type, information on the subject (user) performing
    the action, date and time information, information on any objects or
    arguments, and a success or failure condition.

  * trail: An audit trail, or log file, consists of a series of audit records
    describing security events. Typically, trails are in roughly chronological
    order with respect to the time events completed. Only authorized processes
    are allowed to commit records to the audit trail.

  * selection expression: A selection expression is a string containing a list
    of prefixes and audit event class names used to match events.

  * preselection: The process by which the system identifies which events are
    of interest to the administrator in order to avoid generating audit records
    describing events that are not of interest. The preselection configuration
    uses a series of selection expressions to identify which classes of events
    to audit for which users, as well as global settings that apply to both
    authenticated and unauthenticated processes.

  * reduction: The process by which records from existing audit trails are
    selected for preservation, printing, or analysis. Likewise, the process by
    which undesired audit records are removed from the audit trail. Using
    reduction, administrators can implement policies for the preservation of
    audit data. For example, detailed audit trails might be kept for one month,
    but after that, trails might be reduced in order to preserve only login
    information for archival purposes.

18.3.Â Installing Audit Support

User space support for Event Auditing is installed as part of the base FreeBSD
operating system. Kernel support for Event Auditing is compiled in by default,
but support for this feature must be explicitly compiled into the custom kernel
by adding the following line to the kernel configuration file:

options AUDIT

Rebuild and reinstall the kernel via the normal process explained in
ChapterÂ 9, Configuring the FreeBSD Kernel.

Once an audit-enabled kernel is built, installed, and the system has been
rebooted, enable the audit daemon by adding the following line to rc.conf(5):

auditd_enable="YES"

Audit support must then be started by a reboot, or by manually starting the
audit daemon:

service auditd start

18.4.Â Audit Configuration

All configuration files for security audit are found in /etc/security. The
following files must be present before the audit daemon is started:

  * audit_class - Contains the definitions of the audit classes.

  * audit_control - Controls aspects of the audit subsystem, such as default
    audit classes, minimum disk space to leave on the audit log volume, maximum
    audit trail size, etc.

  * audit_event - Textual names and descriptions of system audit events, as
    well as a list of which classes each event is in.

  * audit_user - User-specific audit requirements, which are combined with the
    global defaults at login.

  * audit_warn - A customizable shell script used by auditd to generate warning
    messages in exceptional situations, such as when space for audit records is
    running low or when the audit trail file has been rotated.

Warning:

Audit configuration files should be edited and maintained carefully, as errors
in configuration may result in improper logging of events.

18.4.1.Â Event Selection Expressions

Selection expressions are used in a number of places in the audit configuration
to determine which events should be audited. Expressions contain a list of
event classes to match, each with a prefix indicating whether matching records
should be accepted or ignored, and optionally to indicate if the entry is
intended to match successful or failed operations. Selection expressions are
evaluated from left to right, and two expressions are combined by appending one
onto the other.

The following list contains the default audit event classes present in
audit_class:

  * all - all - Match all event classes.

  * ad - administrative - Administrative actions performed on the system as a
    whole.

  * ap - application - Application defined action.

  * cl - file close - Audit calls to the close system call.

  * ex - exec - Audit program execution. Auditing of command line arguments and
    environmental variables is controlled via audit_control(5) using the argv
    and envv parameters to the policy setting.

  * fa - file attribute access - Audit the access of object attributes such as
    stat(1), pathconf(2) and similar events.

  * fc - file create - Audit events where a file is created as a result.

  * fd - file delete - Audit events where file deletion occurs.

  * fm - file attribute modify - Audit events where file attribute modification
    occurs, such as chown(8), chflags(1), flock(2), etc.

  * fr - file read - Audit events in which data is read, files are opened for
    reading, etc.

  * fw - file write - Audit events in which data is written, files are written
    or modified, etc.

  * io - ioctl - Audit use of the ioctl(2) system call.

  * ip - ipc - Audit various forms of Inter-Process Communication, including
    POSIX pipes and System V IPC operations.

  * lo - login_logout - Audit login(1) and logout(1) events occurring on the
    system.

  * na - non attributable - Audit non-attributable events.

  * no - invalid class - Match no audit events.

  * nt - network - Audit events related to network actions, such as connect(2)
    and accept(2).

  * ot - other - Audit miscellaneous events.

  * pc - process - Audit process operations, such as exec(3) and exit(3).

These audit event classes may be customized by modifying the audit_class and
audit_event configuration files.

Each audit class in the list is combined with a prefix indicating whether
successful/failed operations are matched, and whether the entry is adding or
removing matching for the class and type.

  * (none) Audit both successful and failed instances of the event.

  * + Audit successful events in this class.

  * - Audit failed events in this class.

  * ^ Audit neither successful nor failed events in this class.

  * ^+ Do not audit successful events in this class.

  * ^- Do not audit failed events in this class.

The following example selection string selects both successful and failed login
/logout events, but only successful execution events:

lo,+ex

18.4.2.Â Configuration Files

In most cases, administrators will need to modify only two files when
configuring the audit system: audit_control and audit_user. The first controls
system-wide audit properties and policies; the second may be used to fine-tune
auditing by user.

18.4.2.1.Â The audit_control File

The audit_control file specifies a number of defaults for the audit subsystem.
Viewing the contents of this file, we see the following:

dir:/var/audit flags:lo minfree:20 naflags:lo policy:cnt filesz:0

The dir option is used to set one or more directories where audit logs will be
stored. If more than one directory entry appears, they will be used in order as
they fill. It is common to configure audit so that audit logs are stored on a
dedicated file system, in order to prevent interference between the audit
subsystem and other subsystems if the file system fills.

The flags field sets the system-wide default preselection mask for attributable
events. In the example above, successful and failed login and logout events are
audited for all users.

The minfree option defines the minimum percentage of free space for the file
system where the audit trail is stored. When this threshold is exceeded, a
warning will be generated. The above example sets the minimum free space to
twenty percent.

The naflags option specifies audit classes to be audited for non-attributed
events, such as the login process and system daemons.

The policy option specifies a comma-separated list of policy flags controlling
various aspects of audit behavior. The default cnt flag indicates that the
system should continue running despite an auditing failure (this flag is highly
recommended). Another commonly used flag is argv, which causes command line
arguments to the execve(2) system call to be audited as part of command
execution.

The filesz option specifies the maximum size in bytes to allow an audit trail
file to grow to before automatically terminating and rotating the trail file.
The default, 0, disables automatic log rotation. If the requested file size is
non-zero and below the minimum 512k, it will be ignored and a log message will
be generated.

18.4.2.2.Â The audit_user File

The audit_user file permits the administrator to specify further audit
requirements for specific users. Each line configures auditing for a user via
two fields: the first is the alwaysaudit field, which specifies a set of events
that should always be audited for the user, and the second is the neveraudit
field, which specifies a set of events that should never be audited for the
user.

The following example audit_user file audits login/logout events and successful
command execution for the root user, and audits file creation and successful
command execution for the www user. If used with the example audit_control file
above, the lo entry for root is redundant, and login/logout events will also be
audited for the www user.

root:lo,+ex:no www:fc,+ex:no

18.5.Â Administering the Audit Subsystem

18.5.1.Â Viewing Audit Trails

Audit trails are stored in the BSM binary format, so tools must be used to
modify or convert to text. The praudit(1) command converts trail files to a
simple text format; the auditreduce(1) command may be used to reduce the audit
trail file for analysis, archiving, or printing purposes. auditreduce supports
a variety of selection parameters, including event type, event class, user,
date or time of the event, and the file path or object acted on.

For example, the praudit utility will dump the entire contents of a specified
audit log in plain text:

# praudit /var/audit/AUDITFILE

Where AUDITFILE is the audit log to dump.

Audit trails consist of a series of audit records made up of tokens, which
praudit prints sequentially one per line. Each token is of a specific type,
such as header holding an audit record header, or path holding a file path from
a name lookup. The following is an example of an execve event:

header,133,10,execve(2),0,Mon Sep 25 15:58:03 2006, + 384 msec exec
arg,finger,doug path,/usr/bin/finger attribute,555,root,wheel,90,24918,104944
subject,robert,root,wheel,root,wheel,38439,38032,42086,128.232.9.100
return,success,0 trailer,133

This audit represents a successful execve call, in which the command finger
doug has been run. The arguments token contains both the processed command line
presented by the shell to the kernel. The path token holds the path to the
executable as looked up by the kernel. The attribute token describes the
binary, and in particular, includes the file mode which can be used to
determine if the application was setuid. The subject token describes the
subject process, and stores in sequence the audit user ID, effective user ID
and group ID, real user ID and group ID, process ID, session ID, port ID, and
login address. Notice that the audit user ID and real user ID differ: the user
robert has switched to the root account before running this command, but it is
audited using the original authenticated user. Finally, the return token
indicates the successful execution, and the trailer concludes the record.

praudit also supports an XML output format, which can be selected using the -x
argument.

18.5.2.Â Reducing Audit Trails

Since audit logs may be very large, an administrator will likely want to select
a subset of records for using, such as records associated with a specific user:

# auditreduce -u trhodes /var/audit/AUDITFILE | praudit

This will select all audit records produced for the user trhodes stored in the
AUDITFILE file.

18.5.3.Â Delegating Audit Review Rights

Members of the audit group are given permission to read audit trails in /var/
audit; by default, this group is empty, so only the root user may read audit
trails. Users may be added to the audit group in order to delegate audit review
rights to the user. As the ability to track audit log contents provides
significant insight into the behavior of users and processes, it is recommended
that the delegation of audit review rights be performed with caution.

18.5.4.Â Live Monitoring Using Audit Pipes

Audit pipes are cloning pseudo-devices in the device file system which allow
applications to tap the live audit record stream. This is primarily of interest
to authors of intrusion detection and system monitoring applications. However,
for the administrator the audit pipe device is a convenient way to allow live
monitoring without running into problems with audit trail file ownership or log
rotation interrupting the event stream. To track the live audit event stream,
use the following command line:

# praudit /dev/auditpipe

By default, audit pipe device nodes are accessible only to the root user. To
make them accessible to the members of the audit group, add a devfs rule to
devfs.rules:

add path 'auditpipe*' mode 0440 group audit

See devfs.rules(5) for more information on configuring the devfs file system.

Warning:

It is easy to produce audit event feedback cycles, in which the viewing of each
audit event results in the generation of more audit events. For example, if all
network I/O is audited, and praudit(1) is run from an SSH session, then a
continuous stream of audit events will be generated at a high rate, as each
event being printed will generate another event. It is advisable to run praudit
on an audit pipe device from sessions without fine-grained I/O auditing in
order to avoid this happening.

18.5.5.Â Rotating Audit Trail Files

Audit trails are written to only by the kernel, and managed only by the audit
daemon, auditd. Administrators should not attempt to use newsyslog.conf(5) or
other tools to directly rotate audit logs. Instead, the audit management tool
may be used to shut down auditing, reconfigure the audit system, and perform
log rotation. The following command causes the audit daemon to create a new
audit log and signal the kernel to switch to using the new log. The old log
will be terminated and renamed, at which point it may then be manipulated by
the administrator.

# audit -n

Warning:

If the auditd daemon is not currently running, this command will fail and an
error message will be produced.

Adding the following line to /etc/crontab will force the rotation every twelve
hours from cron(8):

0 */12 * * * root /usr/sbin/audit -n

The change will take effect once you have saved the new /etc/crontab.

Automatic rotation of the audit trail file based on file size is possible via
the filesz option in audit_control(5), and is described in the configuration
files section of this chapter.

18.5.6.Â Compressing Audit Trails

As audit trail files can become very large, it is often desirable to compress
or otherwise archive trails once they have been closed by the audit daemon. The
audit_warn script can be used to perform customized operations for a variety of
audit-related events, including the clean termination of audit trails when they
are rotated. For example, the following may be added to the audit_warn script
to compress audit trails on close:

# # Compress audit trail files on close. # if [ "$1" = closefile ]; then gzip
-9 $2 fi

Other archiving activities might include copying trail files to a centralized
server, deleting old trail files, or reducing the audit trail to remove
unneeded records. The script will be run only when audit trail files are
cleanly terminated, so will not be run on trails left unterminated following an
improper shutdown.

ChapterÂ 19.Â Storage

Table of Contents

19.1. Synopsis
19.2. Device Names
19.3. Adding Disks
19.4. RAID
19.5. USB Storage Devices
19.6. Creating and Using CD Media
19.7. Creating and Using DVD Media
19.8. Creating and Using Floppy Disks
19.9. Creating and Using Data Tapes
19.10. Backups to Floppies
19.11. Backup Strategies
19.12. Backup Basics
19.13. Network, Memory, and File-Backed File Systems
19.14. File System Snapshots
19.15. File System Quotas
19.16. Encrypting Disk Partitions
19.17. Encrypting Swap Space
19.18. Highly Available Storage (HAST)

19.1.Â Synopsis

This chapter covers the use of disks in FreeBSD. This includes memory-backed
disks, network-attached disks, standard SCSI/IDE storage devices, and devices
using the USB interface.

After reading this chapter, you will know:

  * The terminology FreeBSD uses to describe the organization of data on a
    physical disk.

  * How to add additional hard disks to a FreeBSD system.

  * How to configure FreeBSD to use USB storage devices.

  * How to set up virtual file systems, such as memory disks.

  * How to use quotas to limit disk space usage.

  * How to encrypt disks to secure them against attackers.

  * How to create and burn CDs and DVDs on FreeBSD.

  * The various storage media options for backups.

  * How to use the backup programs available under FreeBSD.

  * How to backup to floppy disks.

  * What file system snapshots are and how to use them efficiently.

Before reading this chapter, you should:

  * Know how to configure and install a new FreeBSD kernel.

19.2.Â Device Names

The following is a list of physical storage devices supported in FreeBSD, and
their associated device names.

TableÂ 19.1.Â Physical Disk Naming Conventions

     Drive type                           Drive device name
IDE hard drives       ad
IDE CDROM drives      acd
SCSI hard drives and
USB Mass storage      da
devices
SCSI CDROM drives     cd
Assorted non-standard mcd for Mitsumi CD-ROM and scd for Sony CD-ROM devices
CDROM drives
Floppy drives         fd
SCSI tape drives      sa
IDE tape drives       ast
Flash drives          fla for DiskOnChipÂ® Flash device
                      aacd for AdaptecÂ® AdvancedRAID, mlxd and mlyd for MylexÂ
RAID drives           ®, amrd for AMI MegaRAIDÂ®, idad for Compaq Smart RAID,
                      twed for 3wareÂ® RAID.


19.3.Â Adding Disks

Originally contributed by David O'Brien.

This section describes how to add a new SATA disk to a machine that currently
only has a single drive. First, turn off the computer and install the drive in
the computer following the instructions of the computer, controller, and drive
manufacturers. Reboot the system and become root.

Inspect /var/run/dmesg.boot to ensure the new disk was found. In this example,
the newly added SATA drive will appear as ada1.

For this example, a single large partition will be created on the new disk. The
GPT partitioning scheme will be used in preference to the older and less
versatile MBR scheme.

Note:

If the disk to be added is not blank, old partition information can be removed
with gpart delete. See gpart(8) for details.

The partition scheme is created, and then a single partition is added:

# gpart create -s GPT ada1 # gpart add -t freebsd-ufs ada1

Depending on use, several smaller partitions may be desired. See gpart(8) for
options to create partitions smaller than a whole disk.

A file system is created on the new blank disk:

# newfs -U /dev/ada1p1

An empty directory is created as a mountpoint, a location for mounting the new
disk in the original disk's file system:

# mkdir /newdisk

Finally, an entry is added to /etc/fstab so the new disk will be mounted
automatically at startup:

/dev/ada1p1 /newdisk ufs rw 2 2

The new disk can be mounted manually, without restarting the system:

# mount /newdisk

19.4.Â RAID

19.4.1.Â Software RAID

19.4.1.1.Â Concatenated Disk Driver (CCD) Configuration

Original work by Christopher Shumway.
Revised by Jim Brown.

When choosing a mass storage solution, the most important factors to consider
are speed, reliability, and cost. It is rare to have all three in balance.
Normally a fast, reliable mass storage device is expensive, and to cut back on
cost either speed or reliability must be sacrificed.

In designing the system described below, cost was chosen as the most important
factor, followed by speed, then reliability. Data transfer speed for this
system is ultimately constrained by the network. While reliability is very
important, the CCD drive described below serves online data that is already
fully backed up and which can easily be replaced.

Defining the requirements is the first step in choosing a mass storage
solution. If the requirements prefer speed or reliability over cost, the
solution will differ from the system described in this section.

19.4.1.1.1.Â Installing the Hardware

In addition to the IDE system disk, three Western Digital 30GB, 5400 RPM IDE
disks form the core of the CCD disk described below, providing approximately
90GB of online storage. Ideally, each IDE disk would have its own IDE
controller and cable, but to minimize cost, additional IDE controllers were not
used. Instead, the disks were configured with jumpers so that each IDE
controller has one master, and one slave.

Upon reboot, the system BIOS was configured to automatically detect the disks
attached. More importantly, FreeBSD detected them on reboot:

ad0: 19574MB &lt;WDC WD205BA&gt; [39770/16/63] at ata0-master UDMA33 ad1: 29333MB
&lt;WDC WD307AA&gt; [59598/16/63] at ata0-slave UDMA33 ad2: 29333MB &lt;WDC WD307AA&gt;
[59598/16/63] at ata1-master UDMA33 ad3: 29333MB &lt;WDC WD307AA&gt; [59598/16/63] at
ata1-slave UDMA33

Note:

If FreeBSD does not detect all the disks, consult the drive documentation for
proper setup and verify that the controller is supported by FreeBSD.

19.4.1.1.2.Â Setting Up the CCD

The ccd(4) driver takes several identical disks and concatenates them into one
logical file system. In order to use ccd(4), its kernel module must be loaded
using ccd(4). When using a custom kernel, ensure that this line is compiled in:

device ccd

Before configuring ccd(4), use bsdlabel(8) to label the disks:

bsdlabel -w ad1 auto bsdlabel -w ad2 auto bsdlabel -w ad3 auto

This example creates a bsdlabel for ad1c, ad2c and ad3c that spans the entire
disk.

The next step is to change the disk label type. Use bsdlabel(8) to edit the
disks:

bsdlabel -e ad1 bsdlabel -e ad2 bsdlabel -e ad3

This opens up the current disk label on each disk with the editor specified by
the EDITOR environment variable, typically vi(1).

An unmodified disk label will look something like this:

8 partitions: # size offset fstype [fsize bsize bps/cpg] c: 60074784 0 unused 0
0 0 # (Cyl. 0 - 59597)

Add a new e partition for ccd(4) to use. This can usually be copied from the c
partition, but the fstype must be 4.2BSD. The disk label should now look
something like this:

8 partitions: # size offset fstype [fsize bsize bps/cpg] c: 60074784 0 unused 0
0 0 # (Cyl. 0 - 59597) e: 60074784 0 4.2BSD 0 0 0 # (Cyl. 0 - 59597)

19.4.1.1.3.Â Building the File System

Now that all the disks are labeled, build the ccd(4) using ccdconfig(8), with
options similar to the following:

ccdconfig ccd01 322 03 /dev/ad1e4 /dev/ad2e /dev/ad3e

The use and meaning of each option is described below:

1    The first argument is the device to configure, in this case, /dev/ccd0c.
     The /dev/ portion is optional.

2    The interleave for the file system, which defines the size of a stripe in
     disk blocks, each normally 512 bytes. So, an interleave of 32 would be
     16,384 bytes.

3    Flags for ccdconfig(8). For example, to enable drive mirroring, specify a
     flag. This configuration does not provide mirroring for ccd(4), so it is
     set at 0 (zero).

4    The final arguments to ccdconfig(8) are the devices to place into the
     array. Use the complete path name for each device.

After running ccdconfig(8) the ccd(4) is configured and a file system can be
installed. Refer to newfs(8) for options, or run:

newfs /dev/ccd0c

19.4.1.1.4.Â Making it All Automatic

Generally, ccd(4) should be configured to automount upon each reboot. To do
this, write out the current configuration to /etc/ccd.conf using the following
command:

ccdconfig -g &gt; /etc/ccd.conf

During reboot, the script /etc/rc runs ccdconfig -C if /etc/ccd.conf exists.
This automatically configures the ccd(4) so it can be mounted.

Note:

When booting into single user mode, the following command must be issued to
configure the array before the ccd(4) can be mounted:

ccdconfig -C

To automatically mount the ccd(4), place an entry for the ccd(4) in /etc/fstab
so it will be mounted at boot time:

/dev/ccd0c /media ufs rw 2 2

19.4.1.2.Â The Vinum Volume Manager

The Vinum Volume Manager is a block device driver which implements virtual disk
drives. It isolates disk hardware from the block device interface and maps data
in ways which result in an increase in flexibility, performance and reliability
compared to the traditional slice view of disk storage. vinum(4) implements the
RAID-0, RAID-1 and RAID-5 models, both individually and in combination.

Refer to ChapterÂ 22, The vinum Volume Manager for more information about vinum
(4).

19.4.2.Â Hardware RAID

FreeBSD also supports a variety of hardware RAID controllers. These devices
control a RAID subsystem without the need for FreeBSD specific software to
manage the array.

Using an on-card BIOS, the card controls most of the disk operations. The
following is a brief setup description using a Promise IDE RAID controller.
When this card is installed and the system is started up, it displays a prompt
requesting information. Follow the instructions to enter the card's setup
screen and to combine all the attached drives. After doing so, the disks will
look like a single drive to FreeBSD. Other RAID levels can be set up
accordingly.

19.4.3.Â Rebuilding ATA RAID1 Arrays

FreeBSD supports the ability to hot-replace a failed disk in an array.

An error indicating a failed disk will appear in /var/log/messages or in the
dmesg(8) output:

ad6 on monster1 suffered a hard error. ad6: READ command timeout tag=0 serv=0 -
resetting ad6: trying fallback to PIO mode ata3: resetting devices .. done ad6:
hard error reading fsbn 1116119 of 0-7 (ad6 bn 1116119; cn 1107 tn 4 sn 11)\\
status=59 error=40 ar0: WARNING - mirror lost

Use atacontrol(8) to check for further information:

# atacontrol list ATA channel 0: Master: no device present Slave: acd0
&lt;HL-DT-ST CD-ROM GCR-8520B/1.00&gt; ATA/ATAPI rev 0 ATA channel 1: Master: no
device present Slave: no device present ATA channel 2: Master: ad4 &lt;MAXTOR
6L080J4/A93.0500&gt; ATA/ATAPI rev 5 Slave: no device present ATA channel 3:
Master: ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI rev 5 Slave: no device present
# atacontrol status ar0 ar0: ATA RAID1 subdisks: ad4 ad6 status: DEGRADED

 1. First, detach the ata channel with the failed disk so that it can be safely
    removed:

    # atacontrol detach ata3
 2. Replace the disk.

 3. Reattach the ata channel:

    # atacontrol attach ata3 Master: ad6 &lt;MAXTOR 6L080J4/A93.0500&gt; ATA/ATAPI
    rev 5 Slave: no device present
 4. Add the new disk to the array as a spare:

    # atacontrol addspare ar0 ad6
 5. Rebuild the array:

    # atacontrol rebuild ar0
 6. It is possible to check on the progress by issuing the following command:

    # dmesg | tail -10 [output removed] ad6: removed from configuration ad6:
    deleted from ar0 disk1 ad6: inserted into ar0 disk1 as spare # atacontrol
    status ar0 ar0: ATA RAID1 subdisks: ad4 ad6 status: REBUILDING 0% completed
 7. Wait until this operation completes.

19.5.Â USB Storage Devices

Contributed by Marc Fonvieille.

Many external storage solutions, such as hard drives, USB thumbdrives, and CD/
DVD burners, use the Universal Serial Bus (USB). FreeBSD provides support for
these devices.

19.5.1.Â Configuration

The USB mass storage devices driver, umass(4), is built into the GENERIC kernel
and provides support for USB storage devices. For a custom kernel, be sure that
the following lines are present in the kernel configuration file:

device scbus device da device pass device uhci device ohci device ehci device
usb device umass

Since the umass(4) driver uses the SCSI subsystem to access the USB storage
devices, any USB device will be seen as a SCSI device by the system. Depending
on the USB chipset on the motherboard, device uhci or device ohci is used to
provide USB 1.X support. Support for USB 2.0 controllers is provided by device
ehci.

Note:

If the USB device is a CD or DVD burner, cd(4), must be added to the kernel via
the line:

device cd

Since the burner is seen as a SCSI drive, the driver atapicam(4) should not be
used in the kernel configuration.

19.5.2.Â Testing the Configuration

To test the USB configuration, plug in the USB device. In the system message
buffer, dmesg(8), the drive should appear as something like:

umass0: USB Solid state disk, rev 1.10/1.00, addr 2 GEOM: create disk da0 dp=
0xc2d74850 da0 at umass-sim0 bus 0 target 0 lun 0 da0: &lt;Generic Traveling Disk
1.11&gt; Removable Direct Access SCSI-2 device da0: 1.000MB/s transfers da0: 126MB
(258048 512 byte sectors: 64H 32S/T 126C)

The brand, device node (da0), and other details will differ according to the
device.

Since the USB device is seen as a SCSI one, camcontrol can be used to list the
USB storage devices attached to the system:

# camcontrol devlist &lt;Generic Traveling Disk 1.11&gt; at scbus0 target 0 lun 0
(da0,pass0)

If the drive comes with a file system, it can be mounted. Refer to
SectionÂ 19.3, â  Adding Disksâ   for instructions on how to format and create
partitions on the USB drive.

Warning:

Allowing untrusted users to mount arbitrary media, by enabling vfs.usermount as
described below, should not be considered safe from a security point of view.
Most file systems in FreeBSD were not built to safeguard against malicious
devices.

To make the device mountable as a normal user, one solution is to make all
users of the device a member of the operator group using pw(8). Next, ensure
that the operator group is able to read and write the device by adding these
lines to /etc/devfs.rules:

[localrules=5] add path 'da*' mode 0660 group operator

Note:

If SCSI disks are installed in the system, change the second line as follows:

add path 'da[3-9]*' mode 0660 group operator

This will exclude the first three SCSI disks (da0 to da2)from belonging to the
operator group.

Next, enable the devfs.rules(5) ruleset in /etc/rc.conf:

devfs_system_ruleset="localrules"

Next, instruct the running kernel to allow regular users to mount file systems.
The easiest way is to add the following line to /etc/sysctl.conf:

vfs.usermount=1

Since this only takes effect after the next reboot use sysctl(8) to set this
variable now.

The final step is to create a directory where the file system is to be mounted.
This directory needs to be owned by the user that is to mount the file system.
One way to do that is for root to create a subdirectory owned by that user as /
mnt/username. In the following example, replace username with the login name of
the user and usergroup with the user's primary group:

# mkdir /mnt/username # chown username:usergroup /mnt/username

Suppose a USB thumbdrive is plugged in, and a device /dev/da0s1 appears. If the
device is preformatted with a FAT file system, it can be mounted using:

% mount -t msdosfs -o -m=644,-M=755 /dev/da0s1 /mnt/username

Before the device can be unplugged, it must be unmounted first. After device
removal, the system message buffer will show messages similar to the following:

umass0: at uhub0 port 1 (addr 2) disconnected (da0:umass-sim0:0:0:0): lost
device (da0:umass-sim0:0:0:0): removing device entry GEOM: destroy disk da0 dp=
0xc2d74850 umass0: detached

19.5.3.Â Further Reading

Beside the Adding Disks and Mounting and Unmounting File Systems sections,
reading various manual pages may be also useful: umass(4), camcontrol(8), and
usbconfig(8) under FreeBSDÂ  8.X or usbdevs(8) under earlier versions of
FreeBSD.

19.6.Â Creating and Using CD Media

Contributed by Mike Meyer.

19.6.1.Â Introduction

CD media provide a number of features that differentiate them from conventional
disks. Initially, they were not writable by the user. They are designed so that
they can be read continuously without delays to move the head between tracks.
They are also much easier to transport between systems.

CD media do have tracks, but this refers to a section of data to be read
continuously and not a physical property of the disk. For example, to produce a
CD on FreeBSD, prepare the data files that are going to make up the tracks on
the CD, then write the tracks to the CD.

The ISO 9660 file system was designed to deal with these differences. To
overcome the original file system limits, it provides an extension mechanism
that allows properly written CDs to exceed those limits while still working
with systems that do not support those extensions.

The sysutils/cdrtools port includes mkisofs(8), a program that can be used to
produce a data file containing an ISO 9660 file system. It has options that
support various extensions, and is described below.

Which tool to use to burn the CD depends on whether the CD burner is ATAPI or
something else. ATAPI CD burners use burncd which is part of the base system.
SCSI and USB CD burners should use cdrecord from the sysutils/cdrtools port. It
is also possible to use cdrecord and other tools for SCSI drives on ATAPI
hardware with the ATAPI/CAM module.

For CD burning software with a graphical user interface, consider X-CD-Roast or
K3b. These tools are available as packages or from the sysutils/xcdroast and
sysutils/k3b ports. X-CD-Roast and K3b require the ATAPI/CAM module with ATAPI
hardware.

19.6.2.Â mkisofs

The sysutils/cdrtools port also installs mkisofs(8), which produces an ISO 9660
file system that is an image of a directory tree in the UNIXÂ® file system name
space. The simplest usage is:

# mkisofs -o imagefile.iso /path/to/tree

This command creates an imagefile.iso containing an ISO 9660 file system that
is a copy of the tree at /path/to/tree. In the process, it maps the file names
to names that fit the limitations of the standard ISO 9660 file system, and
will exclude files that have names uncharacteristic of ISO file systems.

A number of options are available to overcome these restrictions. In
particular, -R enables the Rock Ridge extensions common to UNIXÂ® systems, -J
enables Joliet extensions used by Microsoft systems, and -hfs can be used to
create HFS file systems used by MacÂ OSÂ®.

For CDs that are going to be used only on FreeBSD systems, -U can be used to
disable all filename restrictions. When used with -R, it produces a file system
image that is identical to the specified FreeBSD tree, though it may violate
the ISO 9660 standard in a number of ways.

The last option of general use is -b. This is used to specify the location of
the boot image for use in producing an â  El Toritoâ   bootable CD. This option
takes an argument which is the path to a boot image from the top of the tree
being written to the CD. By default, mkisofs(8) creates an ISO image in â  
floppy disk emulationâ   mode, and thus expects the boot image to be exactly
1200, 1440 or 2880Â KB in size. Some boot loaders, like the one used by the
FreeBSD distribution disks, do not use emulation mode. In this case,
-no-emul-boot should be used. So, if /tmp/myboot holds a bootable FreeBSD
system with the boot image in /tmp/myboot/boot/cdboot, this command would
produce the image of an ISO 9660 file system as /tmp/bootable.iso:

# mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot

If md is configured in the kernel, the file system can be mounted as a memory
disk with:

# mdconfig -a -t vnode -f /tmp/bootable.iso -u 0 # mount -t cd9660 /dev/md0 /
mnt

One can then verify that /mnt and /tmp/myboot are identical.

There are many other options available for mkisofs(8) to fine-tune its
behavior. Refer to mkisofs(8) for details.

19.6.3.Â burncd

For an ATAPI CD burner, burncd can be used to burn an ISO image onto a CD.
burncd is part of the base system, installed as /usr/sbin/burncd. Usage is very
simple, as it has few options:

# burncd -f cddevice data imagefile.iso fixate

This command will burn a copy of imagefile.iso on cddevice. The default device
is /dev/acd0. See burncd(8) for options to set the write speed, eject the CD
after burning, and write audio data.

19.6.4.Â cdrecord

For systems without an ATAPI CD burner, cdrecord can be used to burn CDs.
cdrecord is not part of the base system and must be installed from either the
sysutils/cdrtools package or port. Changes to the base system can cause binary
versions of this program to fail, possibly resulting in a â  coasterâ  . It is
recommended to either upgrade the port when the system is upgraded, or for
users tracking -STABLE, to upgrade the port when a new version becomes
available.

While cdrecord has many options, basic usage is simple. Burning an ISO 9660
image is done with:

# cdrecord dev=device imagefile.iso

The tricky part of using cdrecord is finding the dev to use. To find the proper
setting, use -scanbus which might produce results like this:

# cdrecord -scanbus Cdrecord-Clone 2.01 (i386-unknown-freebsd7.0) Copyright (C)
1995-2004 JÃ¶rg Schilling Using libscg version 'schily-0.1' scsibus0: 0,0,0 0)
'SEAGATE ' 'ST39236LW ' '0004' Disk 0,1,0 1) 'SEAGATE ' 'ST39173W ' '5958' Disk
0,2,0 2) * 0,3,0 3) 'iomega ' 'jaz 1GB ' 'J.86' Removable Disk 0,4,0 4) 'NEC '
'CD-ROM DRIVE:466' '1.26' Removable CD-ROM 0,5,0 5) * 0,6,0 6) * 0,7,0 7) *
scsibus1: 1,0,0 100) * 1,1,0 101) * 1,2,0 102) * 1,3,0 103) * 1,4,0 104) *
1,5,0 105) 'YAMAHA ' 'CRW4260 ' '1.0q' Removable CD-ROM 1,6,0 106) 'ARTEC '
'AM12S ' '1.06' Scanner 1,7,0 107) *

This lists the appropriate dev value for the devices on the list. Locate the CD
burner, and use the three numbers separated by commas as the value for dev. In
this case, the CRW device is 1,5,0, so the appropriate input is dev=1,5,0.
Refer to cdrecord(1) for easier ways to specify this value and for information
on writing audio tracks and controlling the write speed.

19.6.5.Â Duplicating Audio CDs

To duplicate an audio CD, extract the audio data from the CD to a series of
files, then write these files to a blank CD. The process is slightly different
for ATAPI and SCSI drives.

ProcedureÂ 19.1.Â SCSI Drives

 1. Use cdda2wav to extract the audio:

    % cdda2wav -vall -D2,0 -B -Owav
 2. Use cdrecord to write the .wav files:

    % cdrecord -v dev=2,0 -dao -useinfo *.wav

    Make sure that 2,0 is set appropriately, as described in SectionÂ 19.6.4, â
      cdrecordâ  .

ProcedureÂ 19.2.Â ATAPI Drives

Note:

With the help of the ATAPI/CAM module, cdda2wav can also be used on ATAPI
drives. This tool is usually a better choice for most of users, as it supports
jitter correction and endianness, than the method proposed below.

 1. The ATAPI CD driver makes each track available as /dev/acddtnn, where d is
    the drive number, and nn is the track number written with two decimal
    digits, prefixed with zero as needed. So the first track on the first disk
    is /dev/acd0t01, the second is /dev/acd0t02, the third is /dev/acd0t03, and
    so on.

    Make sure the appropriate files exist in /dev. If the entries are missing,
    force the system to retaste the media:

    # dd if=/dev/acd0 of=/dev/null count=1
 2. Extract each track using dd(1), making sure to specify a block size when
    extracting the files:

    # dd if=/dev/acd0t01 of=track1.cdr bs=2352 # dd if=/dev/acd0t02 of=
    track2.cdr bs=2352 ...
 3. Burn the extracted files to disk using burncd. Specify that these are audio
    files, and that burncd should fixate the disk when finished:

    # burncd -f /dev/acd0 audio track1.cdr track2.cdr ... fixate

19.6.6.Â Duplicating Data CDs

It is possible to copy a data CD to an image file that is functionally
equivalent to the image file created with mkisofs(8), and then use it to
duplicate any data CD. The example given here assumes that the CDROM device is
acd0. Substitute the correct CDROM device.

# dd if=/dev/acd0 of=file.iso bs=2048

Now that there is an image, it can be burned to CD as described above.

19.6.7.Â Using Data CDs

It is possible to mount and read the data on a standard data CD. By default,
mount(8) assumes that a file system is of type ufs. Running this command:

# mount /dev/cd0 /mnt

will generate an error about Incorrect super block, and will fail to mount the
CD. The CD does not use the UFS file system, so attempts to mount it as such
will fail. Instead, tell mount(8) that the file system is of type ISO9660 by
specifying -t cd9660 to mount(8). For example, to mount the CDROM device, /dev/
cd0, under /mnt, use:

# mount -t cd9660 /dev/cd0 /mnt

Replace /dev/cd0 with the device name for the CD device. Also, -t cd9660
executes mount_cd9660(8), meaning the above command is equivalent to:

# mount_cd9660 /dev/cd0 /mnt

While data CDROMs from any vendor can be mounted this way, disks with certain
ISO 9660 extensions might behave oddly. For example, Joliet disks store all
filenames in two-byte Unicode characters. The FreeBSD kernel does not speak
Unicode, but the FreeBSD CD9660 driver is able to convert Unicode characters on
the fly. If some non-English characters show up as question marks, specify the
local charset with -C. For more information, refer to mount_cd9660(8).

Note:

In order to do this character conversion with the help of -C, the kernel
requires the cd9660_iconv.ko module to be loaded. This can be done either by
adding this line to loader.conf:

cd9660_iconv_load="YES"

and then rebooting the machine, or by directly loading the module with kldload
(8).

Occasionally, Device not configured will be displayed when trying to mount a
CDROM. This usually means that the CDROM drive thinks that there is no disk in
the tray, or that the drive is not visible on the bus. It can take a couple of
seconds for a CDROM drive to realize that a media is present, so be patient.

Sometimes, a SCSI CDROM may be missed because it did not have enough time to
answer the bus reset. To resolve this,add the following option to the kernel
configuration and rebuild the kernel.

options SCSI_DELAY=15000

This tells the SCSI bus to pause 15 seconds during boot, to give the CDROM
drive every possible chance to answer the bus reset.

19.6.8.Â Burning Raw Data CDs

It is possible to burn a file directly to CD, without creating an ISO 9660 file
system. Some people do this for backup purposes. This command runs more quickly
than burning a standard CD:

# burncd -f /dev/acd1 -s 12 data archive.tar.gz fixate

In order to retrieve the data burned to such a CD, the data must be read from
the raw device node:

# tar xzvf /dev/acd1

This type of disk can not be mounted as a normal CDROM and the data cannot be
read under any operating system except FreeBSD. In order to mount the CD, or to
share the data with another operating system, mkisofs(8) must be used as
described above.

19.6.9.Â Using the ATAPI/CAM Driver

Contributed by Marc Fonvieille.

This driver allows ATAPI devices, such as CD/DVD drives, to be accessed through
the SCSI subsystem, and so allows the use of applications like sysutils/cdrdao
or cdrecord(1).

To use this driver, add the following line to /boot/loader.conf:

atapicam_load="YES"

then, reboot the system.

Note:

Users who prefer to statically compile atapicam(4) support into the kernel,
should add this line to the kernel configuration file:

device atapicam

Ensure the following lines are still in the kernel configuration file:

device ata device scbus device cd device pass

Then rebuild, install the new kernel, and reboot the machine.

During the boot process, the burner should show up, like so:

acd0: CD-RW &lt;MATSHITA CD-RW/DVD-ROM UJDA740&gt; at ata1-master PIO4 cd0 at ata1
bus 0 target 0 lun 0 cd0: &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; Removable CD-ROM
SCSI-0 device cd0: 16.000MB/s transfers cd0: Attempt to query device size
failed: NOT READY, Medium not present - tray closed

The drive can now be accessed via the /dev/cd0 device name. For example, to
mount a CD-ROM on /mnt, type the following:

# mount -t cd9660 /dev/cd0 /mnt

As root, run the following command to get the SCSI address of the burner:

# camcontrol devlist &lt;MATSHITA CDRW/DVD UJDA740 1.00&gt; at scbus1 target 0 lun 0
(pass0,cd0)

In this example, 1,0,0 is the SCSI address to use with cdrecord(1) and other
SCSI applications.

For more information about ATAPI/CAM and SCSI system, refer to atapicam(4) and
cam(4).

19.7.Â Creating and Using DVD Media

Contributed by Marc Fonvieille.
With inputs from Andy Polyakov.

19.7.1.Â Introduction

Compared to the CD, the DVD is the next generation of optical media storage
technology. The DVD can hold more data than any CD and is the standard for
video publishing.

Five physical recordable formats can be defined for a recordable DVD:

  * DVD-R: This was the first DVD recordable format available. The DVD-R
    standard is defined by the DVD Forum. This format is write once.

  * DVD-RW: This is the rewritable version of the DVD-R standard. A DVD-RW can
    be rewritten about 1000 times.

  * DVD-RAM: This is a rewritable format which can be seen as a removable hard
    drive. However, this media is not compatible with most DVD-ROM drives and
    DVD-Video players as only a few DVD writers support the DVD-RAM format.
    Refer to SectionÂ 19.7.9, â  Using a DVD-RAMâ   for more information on
    DVD-RAM use.

  * DVD+RW: This is a rewritable format defined by the DVD+RW Alliance. A
    DVD+RW can be rewritten about 1000 times.

  * DVD+R: This format is the write once variation of the DVD+RW format.

A single layer recordable DVD can hold up to 4,700,000,000Â bytes which is
actually 4.38Â GB or 4485Â MB as 1 kilobyte is 1024 bytes.

Note:

A distinction must be made between the physical media and the application. For
example, a DVD-Video is a specific file layout that can be written on any
recordable DVD physical media such as DVD-R, DVD+R, or DVD-RW. Before choosing
the type of media, ensure that both the burner and the DVD-Video player are
compatible with the media under consideration.

19.7.2.Â Configuration

To perform DVD recording, use growisofs(1). This command is part of the
sysutils/dvd+rw-tools utilities which support all DVD media types.

These tools use the SCSI subsystem to access the devices, therefore ATAPI/CAM
support must be loaded or statically compiled into the kernel. This support is
not needed if the burner uses the USB interface. Refer to SectionÂ 19.5, â  USB
Storage Devicesâ   for more details on USB device configuration.

DMA access must also be enabled for ATAPI devices, by adding the following line
to /boot/loader.conf:

hw.ata.atapi_dma="1"

Before attempting to use dvd+rw-tools, consult the Hardware Compatibility Notes
.

Note:

For a graphical user interface, consider using sysutils/k3b which provides a
user friendly interface to growisofs(1) and many other burning tools.

19.7.3.Â Burning Data DVDs

Since growisofs(1) is a front-end to mkisofs, it will invoke mkisofs(8) to
create the file system layout and perform the write on the DVD. This means that
an image of the data does not need to be created before the burning process.

To burn to a DVD+R or a DVD-R the data in /path/to/data, use the following
command:

# growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data

In this example, -J -R is passed to mkisofs(8) to create an ISO 9660 file
system with Joliet and Rock Ridge extensions. Refer to mkisofs(8) for more
details.

For the initial session recording, -Z is used for both single and multiple
sessions. Replace /dev/cd0, with the name of the DVD device. Using -dvd-compat
indicates that the disk will be closed and that the recording will be
unappendable. This should also provide better media compatibility with DVD-ROM
drives.

To burn a pre-mastered image, such as imagefile.iso, use:

# growisofs -dvd-compat -Z /dev/cd0=imagefile.iso

The write speed should be detected and automatically set according to the media
and the drive being used. To force the write speed, use -speed=. Refer to
growisofs(1) for example usage.

Note:

In order to support working files larger than 4.38GB, an UDF/ISO-9660 hybrid
filesystem must be created by passing -udf -iso-level 3 to mkisofs(8) and all
related programs, such as growisofs(1). This is required only when creating an
ISO image file or when writing files directly to a disk. Since a disk created
this way must be mounted as an UDF filesystem with mount_udf(8), it will be
usable only on an UDF aware operating system. Otherwise it will look as if it
contains corrupted files.

To create this type of ISO file:

% mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data

To burn files directly to a disk:

# growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data

When an ISO image already contains large files, no additional options are
required for growisofs(1) to burn that image on a disk.

Be sure to use an up-to-date version of sysutils/cdrtools, which contains
mkisofs(8), as an older version may not contain large files support. If the
latest version does not work, install sysutils/cdrtools-devel and read its
mkisofs(8).

19.7.4.Â Burning a DVD-Video

A DVD-Video is a specific file layout based on the ISO 9660 and micro-UDF
(M-UDF) specifications. Since DVD-Video presents a specific data structure
hierarchy, a particular program such as multimedia/dvdauthor is needed to
author the DVD.

If an image of the DVD-Video file system already exists, it can be burned in
the same way as any other image. If dvdauthor was used to make the DVD and the
result is in /path/to/video, the following command should be used to burn the
DVD-Video:

# growisofs -Z /dev/cd0 -dvd-video /path/to/video

-dvd-video is passed to mkisofs(8) to instruct it to create a DVD-Video file
system layout. This option implies the -dvd-compat growisofs(1) option.

19.7.5.Â Using a DVD+RW

Unlike CD-RW, a virgin DVD+RW needs to be formatted before first use. It is 
recommended to let growisofs(1) take care of this automatically whenever
appropriate. However, it is possible to use dvd+rw-format to format the DVD+RW:

# dvd+rw-format /dev/cd0

Only perform this operation once and keep in mind that only virgin DVD+RW
medias need to be formatted. Once formatted, the DVD+RW can be burned as usual.

To burn a totally new file system and not just append some data onto a DVD+RW,
the media does not need to be blanked first. Instead, write over the previous
recording like this:

# growisofs -Z /dev/cd0 -J -R /path/to/newdata

The DVD+RW format supports appending data to a previous recording. This
operation consists of merging a new session to the existing one as it is not
considered to be multi-session writing. growisofs(1) will grow the ISO 9660
file system present on the media.

For example, to append data to a DVD+RW, use the following:

# growisofs -M /dev/cd0 -J -R /path/to/nextdata

The same mkisofs(8) options used to burn the initial session should be used
during next writes.

Note:

Use -dvd-compat for better media compatibility with DVD-ROM drives. When using
DVD+RW, this option will not prevent the addition of data.

To blank the media, use:

# growisofs -Z /dev/cd0=/dev/zero

19.7.6.Â Using a DVD-RW

A DVD-RW accepts two disc formats: incremental sequential and restricted
overwrite. By default, DVD-RW discs are in sequential format.

A virgin DVD-RW can be directly written without being formatted. However, a
non-virgin DVD-RW in sequential format needs to be blanked before writing a new
initial session.

To blank a DVD-RW in sequential mode:

# dvd+rw-format -blank=full /dev/cd0

Note:

A full blanking using -blank=full will take about one hour on a 1x media. A
fast blanking can be performed using -blank, if the DVD-RW will be recorded in
Disk-At-Once (DAO) mode. To burn the DVD-RW in DAO mode, use the command:

# growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso

Since growisofs(1) automatically attempts to detect fast blanked media and
engage DAO write, -use-the-force-luke=dao should not be required.

One should instead use restricted overwrite mode with any DVD-RW as this format
is more flexible than the default of incremental sequential.

To write data on a sequential DVD-RW, use the same instructions as for the
other DVD formats:

# growisofs -Z /dev/cd0 -J -R /path/to/data

To append some data to a previous recording, use -M with growisofs(1). However,
if data is appended on a DVD-RW in incremental sequential mode, a new session
will be created on the disc and the result will be a multi-session disc.

A DVD-RW in restricted overwrite format does not need to be blanked before a
new initial session. Instead, overwrite the disc with -Z. It is also possible
to grow an existing ISO 9660 file system written on the disc with -M. The
result will be a one-session DVD.

To put a DVD-RW in restricted overwrite format, the following command must be
used:

# dvd+rw-format /dev/cd0

To change back to sequential format, use:

# dvd+rw-format -blank=full /dev/cd0

19.7.7.Â Multi-Session

Few DVD-ROM drives support multi-session DVDs and most of the time only read
the first session. DVD+R, DVD-R and DVD-RW in sequential format can accept
multiple sessions. The notion of multiple sessions does not exist for the
DVD+RW and the DVD-RW restricted overwrite formats.

Using the following command after an initial non-closed session on a DVD+R,
DVD-R, or DVD-RW in sequential format, will add a new session to the disc:

# growisofs -M /dev/cd0 -J -R /path/to/nextdata

Using this command with a DVD+RW or a DVD-RW in restricted overwrite mode will
append data while merging the new session to the existing one. The result will
be a single-session disc. Use this method to add data after an initial write on
these types of media.

Note:

Since some space on the media is used between each session to mark the end and
start of sessions, one should add sessions with a large amount of data to
optimize media space. The number of sessions is limited to 154 for a DVD+R,
about 2000 for a DVD-R, and 127 for a DVD+R Double Layer.

19.7.8.Â For More Information

To obtain more information about a DVD, use dvd+rw-mediainfo /dev/cd0 while the
disc in the specified drive.

More information about dvd+rw-tools can be found in growisofs(1), on the
dvd+rw-tools web site, and in the cdwrite mailing list archives.

Note:

When creating a problem report related to the use of dvd+rw-tools, always
include the output of dvd+rw-mediainfo.

19.7.9.Â Using a DVD-RAM

19.7.9.1.Â Configuration

DVD-RAM writers can use either a SCSI or ATAPI interface. For ATAPI devices,
DMA access has to be enabled by adding the following line to /boot/loader.conf:

hw.ata.atapi_dma="1"

19.7.9.2.Â Preparing the Media

A DVD-RAM can be seen as a removable hard drive. Like any other hard drive, the
DVD-RAM must be formatted before it can be used. In this example, the whole
disk space will be formatted with a standard UFS2 file system:

# dd if=/dev/zero of=/dev/acd0 bs=2k count=1 # bsdlabel -Bw acd0 # newfs /dev/
acd0

The DVD device, acd0, must be changed according to the configuration.

19.7.9.3.Â Using the Media

Once the DVD-RAM has been formatted, it can be mounted as a normal hard drive:

# mount /dev/acd0 /mnt

Once mounted, the DVD-RAM will be both readable and writeable.

19.8.Â Creating and Using Floppy Disks

Original work by Julio Merino.
Rewritten by Martin Karlsson.

Storing data on floppy disks is sometimes useful, for example when one does not
have any other removable storage media or when one needs to transfer small
amounts of data to another computer.

This section explains how to use floppy disks in FreeBSD. It covers formatting
and usage of 3.5inch DOS floppies, but the concepts are similar for other
floppy disk formats.

19.8.1.Â Formatting Floppies

19.8.1.1.Â The Device

Floppy disks are accessed through entries in /dev, just like other devices. To
access the raw floppy disk, simply use /dev/fdN.

19.8.1.2.Â Formatting

A floppy disk needs to be low-level formatted before it can be used. This is
usually done by the vendor, but formatting is a good way to check media
integrity. Although it is possible to force other disk sizes, 1440kB is what
most floppy disks are designed for.

To low-level format the floppy disk, use fdformat(1). This utility expects the
device name as an argument.

Make note of any error messages, as these can help determine if the disk is
good or bad.

19.8.1.2.1.Â Formatting Floppy Disks

To format the floppy, insert a new 3.5inch floppy disk into the first floppy
drive and issue:

# /usr/sbin/fdformat -f 1440 /dev/fd0

19.8.2.Â The Disk Label

After low-level formatting the disk, a disk label needs to placed on it. This
disk label will be destroyed later, but it is needed by the system to determine
the size of the disk and its geometry.

The new disk label will take over the whole disk and will contain all the
proper information about the geometry of the floppy. The geometry values for
the disk label are listed in /etc/disktab.

To write the disk label, use bsdlabel(8):

# /sbin/bsdlabel -B -w /dev/fd0 fd1440

19.8.3.Â The File System

The floppy is now ready to be high-level formatted. This will place a new file
system on it so that FreeBSD can read and write to the disk. Since creating the
new file system destroys the disk label, the disk label needs to be recreated
whenever the disk is reformatted.

The floppy's file system can be either UFS or FAT. FAT is generally a better
choice for floppies.

To put a new file system on the floppy, issue:

# /sbin/newfs_msdos /dev/fd0

The disk is now ready for use.

19.8.4.Â Using the Floppy

To use the floppy, mount it with mount_msdosfs(8). One can also use emulators/
mtools from the Ports Collection.

19.9.Â Creating and Using Data Tapes

Tape technology has continued to evolve but is less likely to be used in a
modern system. Modern backup systems tend to use off site combined with local
removable disk drive technologies. Still, FreeBSD will support any tape drive
that uses SCSI, such as LTO and older devices such as DAT. There is limited
support for SATA and USB tape drives.

19.9.1.Â Serial Access with sa(4)

FreeBSD uses the sa(4) driver, providing /dev/sa0, /dev/nsa0, and /dev/esa0. In
normal use, only /dev/sa0 is needed. /dev/nsa0 is the same physical drive as /
dev/sa0 but does not rewind the tape after writing a file. This allows writing
more than one file to a tape. Using /dev/esa0 ejects the tape after the device
is closed, if applicable.

19.9.2.Â Controlling the Tape Drive with mt(1)

mt(1) is the FreeBSD utility for controlling other operations of the tape
drive, such as seeking through files on a tape or writing tape control marks to
the tape.

For example, the first three files on a tape can be preserved by skipping past
them before writing a new file:

# mt -f /dev/nsa0 fsf 3

19.9.3.Â Using tar(1) to Read and Write Tape Backups

An example of writing a single file to tape using tar(1):

# tar cvf /dev/sa0 file

Recovering files from a tar(1) archive on tape into the current directory:

# tar xvf /dev/sa0

19.9.4.Â Using dump(8) and restore(8) to Create and Restore Backups

A simple backup of /usr with dump(8):

# dump -0aL -b64 -f /dev/nsa0 /usr

Interactively restoring files from a dump(8) file on tape into the current
directory:

# restore -i -f /dev/nsa0

19.9.5.Â Other Tape Software

Higher-level programs are available to simplify tape backup. The most popular
are Amanda and Bacula. These programs aim to make backups easier and more
convenient, or to automate complex backups of multiple machines. The Ports
Collection contains both these and other tape utility applications.

19.10.Â Backups to Floppies

19.10.1.Â Can I Use Floppies for Backing Up My Data?

Floppy disks are not a suitable media for making backups as:

  * The media is unreliable, especially over long periods of time.

  * Backing up and restoring is very slow.

  * They have a very limited capacity.

However, if no other method of backing up data is available, floppy disks are
better than no backup at all.

When backing up to floppy disks, ensure the floppies are of good quality.
Floppies that have been lying around the office for a couple of years are a bad
choice. Ideally, use new ones from a reputable manufacturer.

19.10.2.Â So How Do I Backup My Data to Floppies?

The best way to backup to floppy disk is to use tar(1) with -M (multi-volume),
which allows backups to span multiple floppies.

To backup all the files in the current directory and sub-directory, use this as
root:

# tar Mcvf /dev/fd0 *

When the first floppy is full, tar(1) will prompt to insert the next volume,
which in this case is the next floppy disk:

Prepare volume #2 for /dev/fd0 and hit return:

This is repeated, with the volume number incrementing, until all the specified
files have been archived.

19.10.3.Â Can I Compress My Backups?

Unfortunately, tar(1) does not support -z for multi-volume archives. Instead,
gzip(1) all the files, tar(1) them to the floppies, then gunzip(1) the files.

19.10.4.Â How Do I Restore My Backups?

To restore the entire archive use:

# tar Mxvf /dev/fd0

There are two methods to restore only specific files. The first is to insert
the first floppy and use:

# tar Mxvf /dev/fd0 filename

tar(1) will prompt to insert subsequent floppies until it finds the required
file.

Alternatively, if the floppy containing the file is known, insert that floppy
and use the same command. If the first file on the floppy is a continuation
from the previous one, tar(1) will warn that it cannot restore it, even if you
have not asked it to.

19.11.Â Backup Strategies

Original work by Lowell Gilbert.

The first requirement in devising a backup plan is to make sure that all of the
following problems are covered:

  * Disk failure.

  * Accidental file deletion.

  * Random file corruption.

  * Complete machine destruction, say by fire, including destruction of any
    on-site backups.

Some systems will be best served by having each of these problems covered by a
completely different technique. Except for strictly personal systems with
low-value data, it is unlikely that one technique will cover all of them.

Some possible techniques include:

  * Archives of the whole system, backed up onto permanent, off-site media.
    This provides protection against all of the problems listed above, but is
    slow and inconvenient to restore from. Copies of the backups can be stored
    on site or online, but there will still be inconveniences in restoring
    files, especially for non-privileged users.

  * Filesystem snapshots, which are really only helpful in the accidental file
    deletion scenario, but can be very helpful in that case, as well as quick
    and easy to deal with.

  * Copies of whole file systems or disks which can be created with a periodic
    net/rsync of the whole machine. This is generally most useful in networks
    with unique requirements. For general protection against disk failure, this
    is usually inferior to RAID. For restoring accidentally deleted files, it
    can be comparable to UFS snapshots.

  * RAID, which minimizes or avoids downtime when a disk fails at the expense
    of having to deal with disk failures more often, because there are more
    disks, albeit at a much lower urgency.

  * Checking fingerprints of files using mtree(8). Although this is not a
    backup, this technique indicates when one needs to resort to backups. This
    is particularly important for offline backups, and should be checked
    periodically.

It is quite easy to come up with more techniques, many of them variations on
the ones listed above. Specialized requirements usually lead to specialized
techniques. For example, backing up a live database usually requires a method
particular to the database software as an intermediate step. The important
thing is to know which dangers should be protected against, and how each will
be handled.

19.12.Â Backup Basics

The major backup programs built into FreeBSD are dump(8), tar(1), cpio(1), and
pax(1).

19.12.1.Â Dump and Restore

The traditional UNIXÂ® backup programs are dump and restore. They operate on
the drive as a collection of disk blocks, below the abstractions of files,
links and directories that are created by the file systems. Unlike other backup
software, dump backs up an entire file system on a device. It is unable to
backup only part of a file system or a directory tree that spans more than one
file system. dump does not write files and directories, but rather writes the
raw data blocks that comprise files and directories. When used to extract data,
restore stores temporary files in /tmp/ by default. When using a recovery disk
with a small /tmp, set TMPDIR to a directory with more free space in order for
the restore to succeed.

Note:

If dump is used on the root directory, it will not back up /home, /usr or many
other directories since these are typically mount points for other file systems
or symbolic links into those file systems.

dump has quirks that remain from its early days in Version 6 of AT&T UNIXÂ
®,circa 1975. The default parameters are suitable for 9-track tapes (6250 bpi),
not the high-density media available today (up to 62,182 ftpi). These defaults
must be overridden on the command line to utilize the capacity of current tape
drives.

It is also possible to backup data across the network to a tape drive attached
to another computer with rdump and rrestore. Both programs rely upon rcmd(3)
and ruserok(3) to access the remote tape drive. Therefore, the user performing
the backup must be listed in .rhosts on the remote computer. The arguments to
rdump and rrestore must be suitable to use on the remote computer. For example,
to rdump from a FreeBSD computer to an Exabyte tape drive connected to a host
called komodo, use:

# /sbin/rdump 0dsbfu 54000 13000 126 komodo:/dev/nsa8 /dev/da0a 2&gt;&1

There are security implications to allowing .rhosts authentication, so use with
caution.

It is also possible to use dump and restore in a more secure fashion over ssh.

ExampleÂ 19.1.Â Using dump over ssh
# /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \
targetuser@targetmachine.example.com dd of=/mybigfiles/dump-usr-l0.gz


Or, use the built-in RSH:

ExampleÂ 19.2.Â Using dump over ssh with RSH Set
# env RSH=/usr/bin/ssh /sbin/dump -0uan -f
targetuser@targetmachine.example.com:/dev/sa0 /usr


19.12.2.Â tar

tar(1) also dates back to Version 6 of AT&T UNIXÂ®, circa 1975. tar operates in
cooperation with the file system and writes files and directories to tape. tar
does not support the full range of options that are available from cpio(1), but
it does not require the unusual command pipeline that cpio uses.

To tar to an Exabyte tape drive connected to a host called komodo:

# tar cf - . | rsh komodo dd of=tape-device obs=20b

When backing up over an insecure network, instead use ssh.

19.12.3.Â cpio

cpio(1) is the original UNIXÂ® file interchange tape program for magnetic
media. cpio includes options to perform byte-swapping, write a number of
different archive formats, and pipe the data to other programs. This last
feature makes cpio an excellent choice for installation media. cpio does not
know how to walk the directory tree and a list of files must be provided
through stdin.

Since cpio does not support backups across the network, use a pipeline and ssh
to send the data to a remote tape drive.

# for f in directory_list; do find $f &gt;&gt; backup.list done # cpio -v -o --format
=newc &lt; backup.list | ssh user@host "cat &gt; backup_device"

Where directory_list is the list of directories to back up, user@host is the
user/hostname combination that will be performing the backups, and
backup_device is where the backups should be written to, such as /dev/nsa0).

19.12.4.Â pax

pax(1) is the IEEE/POSIXÂ® answer to tar and cpio. Over the years the various
versions of tar and cpio have become slightly incompatible. So rather than
fight it out to fully standardize them, POSIXÂ® created a new archive utility.
pax attempts to read and write many of the various cpio and tar formats, plus
new formats of its own. Its command set more resembles cpio than tar.

19.12.5.Â Amanda

Amanda (Advanced Maryland Network Disk Archiver) is a client/server backup
system, rather than a single program. An Amanda server will backup to a single
tape drive any number of computers that have Amanda clients and a network
connection to the Amanda server. A common problem at sites with a number of
large disks is that the length of time required to backup to data directly to
tape exceeds the amount of time available for the task. Amanda solves this
problem by using a â  holding diskâ   to backup several file systems at the
same time. Amanda creates â  archive setsâ  : a group of tapes used over a
period of time to create full backups of all the file systems listed in Amanda
's configuration file. The â  archive setâ   also contains nightly incremental,
or differential, backups of all the file systems. Restoring a damaged file
system requires the most recent full backup and the incremental backups.

The configuration file provides fine grained control of backups and the network
traffic that Amanda generates. Amanda will use any of the above backup programs
to write the data to tape. Amanda is not installed by but is available as
either a port or package.

19.12.6.Â Do Nothing

â  Do nothingâ   is not a computer program, but it is the most widely used
backup strategy. There are no initial costs. There is no backup schedule to
follow. Just say no. If something happens to your data, grin and bear it!

If your time and data is worth little to nothing, then â  Do nothingâ   is the
most suitable backup program for the computer. But beware, FreeBSD is a useful
tool and over time it can be used to create a valuable collection of files.

â  Do nothingâ   is the correct backup method for /usr/obj and other directory
trees that can be exactly recreated by the computer. An example is the files
that comprise the HTML or PostScriptÂ® version of this Handbook. These document
formats have been created from XML input files. Creating backups of the HTML or
PostScriptÂ® files is not necessary if the XML files are backed up regularly.

19.12.7.Â Which Backup Program Is Best?

dump(8) Period. Elizabeth D. Zwicky torture tested all the backup programs
discussed here. The clear choice for preserving all your data and all the
peculiarities of UNIXÂ® file systems is dump. Elizabeth created file systems
containing a large variety of unusual conditions (and some not so unusual ones)
and tested each program by doing a backup and restore of those file systems.
The peculiarities included: files with holes, files with holes and a block of
nulls, files with funny characters in their names, unreadable and unwritable
files, devices, files that change size during the backup, files that are
created/deleted during the backup and more. She presented the results at LISA V
in Oct. 1991. See torture-testing Backup and Archive Programs.

19.12.8.Â Emergency Restore Procedure

19.12.8.1.Â Before the Disaster

There are four steps which should be performed in preparation for any disaster
that may occur.

First, print the bsdlabel of each disk using a command such as bsdlabel da0 |
lpr. Also print a copy of /etc/fstab and all boot messages.

Second, burn a â  livefsâ   CD. This CD contains support for booting into a
FreeBSD â  livefsâ   rescue mode, allowing the user to perform many tasks like
running dump(8), restore(8), fdisk(8), bsdlabel(8), newfs(8), mount(8), and
more. The livefs CD image for FreeBSD/i386Â 8.4-RELEASE is available from ftp:/
/ftp.FreeBSD.org/pub/FreeBSD/releases/i386/ISO-IMAGES/8.4/
FreeBSD-8.4-RELEASE-i386-livefs.iso.

Note:

Livefs CD images are not available for FreeBSDÂ 9.1-RELEASE and later. In
addition to the CDROM installation images, flash drive installation images may
be used to recover a system. The â  memstickâ   image for FreeBSD/
i386Â 9.1-RELEASE is available from ftp://ftp.FreeBSD.org/pub/FreeBSD/releases/
i386/i386/ISO-IMAGES/9.1/FreeBSD-9.1-RELEASE-i386-memstick.img.

Third, create backup tapes regularly. Any changes that made after the last
backup may be irretrievably lost. Write-protect the backup media.

Fourth, test the â  livefsâ   CD and the backups. Make notes of the procedure.
Store these notes with the CD, the printouts, and the backups. These notes may
prevent the inadvertent destruction of the backups while under the stress of
performing an emergency recovery.

For an added measure of security, store an extra â  livefsâ   CD and the latest
backup at a remote location, where a remote location is not the basement of the
same building. A remote location should be physically separated from the
computers and disk drives by a significant distance.

19.12.8.2.Â After the Disaster

First, determine if the hardware survived. Thanks to regular, off-site backups,
there is no need to worry about the software.

If the hardware has been damaged, the parts should be replaced before
attempting to use the computer.

If the hardware is okay, insert the â  livefsâ   CD and boot the computer. The
original install menu will be displayed on the screen. Select the correct
country, then choose Fixit -- Repair mode with CDROM/DVD/floppy or start a
shell. then select CDROM/DVD -- Use the live filesystem CDROM/DVD. restore and
the other needed programs are located in /mnt2/rescue.

Recover each file system separately.

Try to mount the root partition of the first disk using mount /dev/da0a /mnt.
If the bsdlabel was damaged, use bsdlabel to re-partition and label the disk to
match the label that was printed and saved. Use newfs to re-create the file
systems. Re-mount the root partition of the disk read-write using mount -u -o
rw /mnt. Use the backups to recover the data for this file system. Unmount the
file system with umount /mnt. Repeat for each file system that was damaged.

Once the system is running, backup the data onto new media as whatever caused
the crash or data loss may strike again. Another hour spent now may save
further distress later.

19.13.Â Network, Memory, and File-Backed File Systems

Reorganized and enhanced by Marc Fonvieille.

In addition to physical disks such as floppies, CDs, and hard drives, FreeBSD
also supports virtual disks.

These include network file systems such as the Network File System and Coda,
memory-based file systems, and file-backed file systems.

According to the FreeBSD version, the tools used for the creation and use of
file-backed and memory-based file systems differ.

Note:

Use devfs(5) to allocate device nodes transparently for the user.

19.13.1.Â File-Backed File System

mdconfig(8) is used to configure and enable memory disks, md(4), under FreeBSD.
To use mdconfig(8), md(4) must be first loaded. When using a custom kernel
configuration file, ensure it includes this line:

device md

mdconfig(8) supports several types of memory backed virtual disks: memory disks
allocated with malloc(9) and memory disks using a file or swap space as
backing. One possible use is the mounting of CD images.

To mount an existing file system image:

ExampleÂ 19.3.Â Using mdconfig to Mount an Existing File System Image
# mdconfig -a -t vnode -f diskimage -u 0 # mount /dev/md0 /mnt


To create a new file system image with mdconfig(8):

ExampleÂ 19.4.Â Creating a New File-Backed Disk with mdconfig
# dd if=/dev/zero of=newimage bs=1k count=5k 5120+0 records in 5120+0 records
out # mdconfig -a -t vnode -f newimage -u 0 # bsdlabel -w md0 auto # newfs md0a
/dev/md0a: 5.0MB (10224 sectors) block size 16384, fragment size 2048 using 4
cylinder groups of 1.25MB, 80 blks, 192 inodes. super-block backups (for fsck
-b #) at: 160, 2720, 5280, 7840 # mount /dev/md0a /mnt # df /mnt Filesystem
1K-blocks Used Avail Capacity Mounted on /dev/md0a 4710 4 4330 0% /mnt


If unit number is not specified with -u, mdconfig(8) uses the md(4) automatic
allocation to select an unused device. The name of the allocated unit will be
output to stdout, such as md4. Refer to mdconfig(8) for more details about.

While mdconfig(8) is useful, it takes several command lines to create a
file-backed file system. FreeBSD also comes with mdmfs(8) which automatically
configures a md(4) disk using mdconfig(8), puts a UFS file system on it using
newfs(8), and mounts it using mount(8). For example, to create and mount the
same file system image as above, type the following:

ExampleÂ 19.5.Â Configure and Mount a File-Backed Disk with mdmfs
# dd if=/dev/zero of=newimage bs=1k count=5k 5120+0 records in 5120+0 records
out # mdmfs -F newimage -s 5m md0 /mnt # df /mnt Filesystem 1K-blocks Used
Avail Capacity Mounted on /dev/md0 4718 4 4338 0% /mnt


When md is used without a unit number, mdmfs(8) uses the md(4) auto-unit
feature to automatically select an unused device. For more details about mdmfs
(8), refer to its manual page.

19.13.2.Â Memory-Based File System

For a memory-based file system, â  swap backingâ   should normally be used.
This does not mean that the memory disk will be swapped out to disk by default,
but rather that the memory disk will be allocated from a memory pool which can
be swapped out to disk if needed. It is also possible to create memory-based
disks which are malloc(9) backed, but using large malloc backed memory disks
can result in a system panic if the kernel runs out of memory.

ExampleÂ 19.6.Â Creating a New Memory-Based Disk with mdconfig
# mdconfig -a -t swap -s 5m -u 1 # newfs -U md1 /dev/md1: 5.0MB (10240 sectors)
block size 16384, fragment size 2048 using 4 cylinder groups of 1.27MB, 81
blks, 192 inodes. with soft updates super-block backups (for fsck -b #) at:
160, 2752, 5344, 7936 # mount /dev/md1 /mnt # df /mnt Filesystem 1K-blocks Used
Avail Capacity Mounted on /dev/md1 4718 4 4338 0% /mnt

ExampleÂ 19.7.Â Creating a New Memory-Based Disk with mdmfs
# mdmfs -s 5m md2 /mnt # df /mnt Filesystem 1K-blocks Used Avail Capacity
Mounted on /dev/md2 4846 2 4458 0% /mnt


19.13.3.Â Detaching a Memory Disk from the System

When a memory-based or file-based file system is no longer in use, its
resources should be released back to the system. First, unmount the file
system, then use mdconfig(8) to detach the disk from the system and release the
resources.

For example, to detach and free all resources used by /dev/md4:

# mdconfig -d -u 4

It is possible to list information about configured md(4) devices by running
mdconfig -l.

19.14.Â File System Snapshots

Contributed by Tom Rhodes.

FreeBSD offers a feature in conjunction with Soft Updates: file system
snapshots.

UFS snapshots allow a user to create images of specified file systems, and
treat them as a file. Snapshot files must be created in the file system that
the action is performed on, and a user may create no more than 20 snapshots per
file system. Active snapshots are recorded in the superblock so they are
persistent across unmount and remount operations along with system reboots.
When a snapshot is no longer required, it can be removed using rm(1). While
snapshots may be removed in any order, all the used space may not be acquired
because another snapshot will possibly claim some of the released blocks.

The un-alterable snapshot file flag is set by mksnap_ffs(8) after initial
creation of a snapshot file. unlink(1) makes an exception for snapshot files
since it allows them to be removed.

Snapshots are created using mount(8). To place a snapshot of /var in the file /
var/snapshot/snap, use the following command:

# mount -u -o snapshot /var/snapshot/snap /var

Alternatively, use mksnap_ffs(8) to create the snapshot:

# mksnap_ffs /var /var/snapshot/snap

One can find snapshot files on a file system, such as /var, using find(1):

# find /var -flags snapshot

Once a snapshot has been created, it has several uses:

  * Some administrators will use a snapshot file for backup purposes, because
    the snapshot can be transferred to CDs or tape.

  * The file system integrity checker, fsck(8), may be run on the snapshot.
    Assuming that the file system was clean when it was mounted, this should
    always provide a clean and unchanging result.

  * Running dump(8) on the snapshot will produce a dump file that is consistent
    with the file system and the timestamp of the snapshot. dump(8) can also
    take a snapshot, create a dump image, and then remove the snapshot in one
    command by using -L.

  * The snapshot can be mounted as a frozen image of the file system. To mount
    (8) the snapshot /var/snapshot/snap run:

    # mdconfig -a -t vnode -f /var/snapshot/snap -u 4 # mount -r /dev/md4 /mnt

The frozen /var is now available through /mnt. Everything will initially be in
the same state it was during the snapshot creation time. The only exception is
that any earlier snapshots will appear as zero length files. To unmount the
snapshot, use:

# umount /mnt # mdconfig -d -u 4

For more information about softupdates and file system snapshots, including
technical papers, visit Marshall Kirk McKusick's website at http://
www.mckusick.com/.

19.15.Â File System Quotas

Quotas are an optional feature of the operating system that can be used to
limit the amount of disk space or the number of files a user or members of a
group may allocate on a per-file system basis. This is used most often on
timesharing systems where it is desirable to limit the amount of resources any
one user or group of users may allocate. This prevents one user or group of
users from consuming all of the available disk space.

19.15.1.Â Configuring the System to Enable Disk Quotas

Before using disk quotas, quota support must be added to the kernel by adding
the following line to the kernel configuration file:

options QUOTA

The GENERIC kernel does not have this enabled by default, so a custom kernel
must be compiled in order to use disk quotas. Refer to ChapterÂ 9, Configuring
the FreeBSD Kernel for more information on kernel configuration.

Next, enable disk quotas in /etc/rc.conf:

quota_enable="YES"

For finer control over quota startup, an additional configuration variable is
available. Normally on bootup, the quota integrity of each file system is
checked by quotacheck(8). This program insures that the data in the quota
database properly reflects the data on the file system. This is a time
consuming process that will significantly affect the time the system takes to
boot. To skip this step, add this variable to /etc/rc.conf:

check_quotas="NO"

Finally, edit /etc/fstab to enable disk quotas on a per-file system basis. This
is when user or group quotas can be enabled on the file systems.

To enable per-user quotas on a file system, add userquota to the options field
in the /etc/fstab entry for the file system to enable quotas on. For example:

/dev/da1s2g /home ufs rw,userquota 1 2

To enable group quotas, instead use groupquota. To enable both user and group
quotas, change the entry as follows:

/dev/da1s2g /home ufs rw,userquota,groupquota 1 2

By default, the quota files are stored in the root directory of the file system
as quota.user and quota.group. Refer to fstab(5) for more information. Even
though an alternate location for the quota files can be specified, this is not
recommended because the various quota utilities do not seem to handle this
properly.

Once the configuration is complete, reboot the system with the new kernel. /etc
/rc will automatically run the appropriate commands to create the initial quota
files for all of the quotas enabled in /etc/fstab. There is no need to manually
create any zero length quota files.

In the normal course of operations, there should be no need to manually run
quotacheck(8), quotaon(8), or quotaoff(8). However, one should read their
manual pages to be familiar with their operation.

19.15.2.Â Setting Quota Limits

Once the system has been configured to enable quotas, verify they really are
enabled by running:

# quota -v

There should be a one line summary of disk usage and current quota limits for
each file system that quotas are enabled on.

The system is now ready to be assigned quota limits with edquota(8).

Several options are available to enforce limits on the amount of disk space a
user or group may allocate, and how many files they may create. Allocations can
be limited based on disk space (block quotas), number of files (inode quotas),
or a combination of both. Each limits is further broken down into two
categories: hard and soft limits.

A hard limit may not be exceeded. Once a user reaches a hard limit, no further
allocations can be made on that file system by that user. For example, if the
user has a hard limit of 500 kbytes on a file system and is currently using 490
kbytes, the user can only allocate an additional 10 kbytes. Attempting to
allocate an additional 11 kbytes will fail.

Soft limits can be exceeded for a limited amount of time, known as the grace
period, which is one week by default. If a user stays over their limit longer
than the grace period, the soft limit turns into a hard limit and no further
allocations are allowed. When the user drops back below the soft limit, the
grace period is reset.

The following is an example output from edquota(8). When edquota(8) is invoked,
the editor specified by EDITOR is opened in order to edit the quota limits. The
default editor is set to vi.

# edquota -u test
Quotas for user test: /usr: kbytes in use: 65, limits (soft = 50, hard = 75)
inodes in use: 7, limits (soft = 50, hard = 60) /usr/var: kbytes in use: 0,
limits (soft = 50, hard = 75) inodes in use: 0, limits (soft = 50, hard = 60)

There are normally two lines for each file system that has quotas enabled. One
line represents the block limits and the other represents the inode limits.
Change the value to modify the quota limit. For example, to raise this user's
block limit from a soft limit of 50 and a hard limit of 75 to a soft limit of
500 and a hard limit of 600, change:

/usr: kbytes in use: 65, limits (soft = 50, hard = 75)

to:

/usr: kbytes in use: 65, limits (soft = 500, hard = 600)

The new quota limits take affect upon exiting the editor.

Sometimes it is desirable to set quota limits on a range of UIDs. This can be
done by passing -p to edquota(8). First, assign the desired quota limit to a
user, then run edquota -p protouser startuid-enduid. For example, if test has
the desired quota limits, the following command will duplicate those quota
limits for UIDs 10,000 through 19,999:

# edquota -p test 10000-19999

For more information, refer to edquota(8).

19.15.3.Â Checking Quota Limits and Disk Usage

Either quota(1) or repquota(8) can be used to check quota limits and disk
usage. To check individual user or group quotas and disk usage, use quota(1). A
user may only examine their own quota and the quota of a group they are a
member of. Only the superuser may view all user and group quotas. To get a
summary of all quotas and disk usage for file systems with quotas enabled, use
repquota(8).

The following is sample output from quota -v for a user that has quota limits
on two file systems.

Disk quotas for user test (uid 1002): Filesystem usage quota limit grace files
quota limit grace /usr 65* 50 75 5days 7 50 60 /usr/var 0 50 75 0 50 60

In this example, the user is currently 15 kbytes over the soft limit of 50
kbytes on /usr and has 5 days of grace period left. The asterisk * indicates
that the user is currently over the quota limit.

Normally, file systems that the user is not using any disk space on will not
show in the output of quota(1), even if the user has a quota limit assigned for
that file system. Use -v to display those file systems, such as /usr/var in the
above example.

19.15.4.Â Quotas over NFS

Quotas are enforced by the quota subsystem on the NFS server. The rpc.rquotad
(8) daemon makes quota information available to quota(1) on NFS clients,
allowing users on those machines to see their quota statistics.

Enable rpc.rquotad in /etc/inetd.conf like so:

rquotad/1 dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad

Now restart inetd:

# service inetd restart

19.16.Â Encrypting Disk Partitions

Contributed by Lucky Green.

FreeBSD offers excellent online protections against unauthorized data access.
File permissions and Mandatory Access Control (MAC) help prevent unauthorized
users from accessing data while the operating system is active and the computer
is powered up. However, the permissions enforced by the operating system are
irrelevant if an attacker has physical access to a computer and can move the
computer's hard drive to another system to copy and analyze the data.

Regardless of how an attacker may have come into possession of a hard drive or
powered-down computer, both the GEOM Based Disk Encryption (gbde) and geli
cryptographic subsystems in FreeBSD are able to protect the data on the
computer's file systems against even highly-motivated attackers with
significant resources. Unlike cumbersome encryption methods that encrypt only
individual files, gbde and geli transparently encrypt entire file systems. No
cleartext ever touches the hard drive's platter.

19.16.1.Â Disk Encryption with gbde

 1. Configuring gbde requires superuser privileges.

    % su - Password:
 2. If using a custom kernel configuration file, ensure it contains this line:

    options GEOM_BDE

    If the kernel already contains this support, use kldload to load gbde(4):

    # kldload geom_bde

19.16.1.1.Â Preparing the Encrypted Hard Drive

The following example demonstrates adding a new hard drive to a system that
will hold a single encrypted partition. This partition will be mounted as /
private. gbde can also be used to encrypt /home and /var/mail, but this
requires more complex instructions which exceed the scope of this introduction.

 1. Add the New Hard Drive

    Install the new drive to the system as explained in SectionÂ 19.3, â  
    Adding Disksâ  . For the purposes of this example, a new hard drive
    partition has been added as /dev/ad4s1c and /dev/ad0s1* represents the
    existing standard FreeBSD partitions.

    # ls /dev/ad* /dev/ad0 /dev/ad0s1b /dev/ad0s1e /dev/ad4s1 /dev/ad0s1 /dev/
    ad0s1c /dev/ad0s1f /dev/ad4s1c /dev/ad0s1a /dev/ad0s1d /dev/ad4
 2. Create a Directory to Hold gbde Lock Files

    # mkdir /etc/gbde

    The gbde lock file contains information that gbde requires to access
    encrypted partitions. Without access to the lock file, gbde will not be
    able to decrypt the data contained in the encrypted partition without
    significant manual intervention which is not supported by the software.
    Each encrypted partition uses a separate lock file.

 3. Initialize the gbde Partition

    A gbde partition must be initialized before it can be used. This
    initialization needs to be performed only once:

    # gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock

    gbde(8) will open the default editor, in order to set various configuration
    options in a template. For use with UFS1 or UFS2, set the sector_size to
    2048:

    # $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06
    kensmith Exp $ # # Sector size is the smallest unit of data which can be
    read or written. # Making it too small decreases performance and decreases
    available space. # Making it too large may prevent filesystems from
    working. 512 is the # minimum and always safe. For UFS, use the fragment
    size # sector_size = 2048 [...]

    gbde(8) will ask the user twice to type the passphrase used to secure the
    data. The passphrase must be the same both times. The ability of gbde to
    protect data depends entirely on the quality of the passphrase. For tips on
    how to select a secure passphrase that is easy to remember, see the
    Diceware Passphrase website.

    gbde initcreates a lock file for the gbde partition. In this example, it is
    stored as /etc/gbde/ad4s1c.lock. gbde lock files must end in â  .lockâ   in
    order to be correctly detected by the /etc/rc.d/gbde start up script.

    Caution:

    gbde lock files must be backed up together with the contents of any
    encrypted partitions. While deleting a lock file alone cannot prevent a
    determined attacker from decrypting a gbde partition, without the lock
    file, the legitimate owner will be unable to access the data on the
    encrypted partition without a significant amount of work that is totally
    unsupported by gbde(8).

 4. Attach the Encrypted Partition to the Kernel

    # gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock

    This command will prompt to input the passphrase that was selected during
    the initialization of the encrypted partition. The new encrypted device
    will appear in /dev as /dev/device_name.bde:

    # ls /dev/ad* /dev/ad0 /dev/ad0s1b /dev/ad0s1e /dev/ad4s1 /dev/ad0s1 /dev/
    ad0s1c /dev/ad0s1f /dev/ad4s1c /dev/ad0s1a /dev/ad0s1d /dev/ad4 /dev/
    ad4s1c.bde
 5. Create a File System on the Encrypted Device

    Once the encrypted device has been attached to the kernel, a file system
    can be created on the device using newfs(8). This example creates a UFS2
    file system with soft updates enabled.

    # newfs -U /dev/ad4s1c.bde

    Note:

    newfs(8) must be performed on an attached gbde partition which is
    identified by a *.bde extension to the device name.

 6. Mount the Encrypted Partition

    Create a mount point for the encrypted file system:

    # mkdir /private

    Mount the encrypted file system:

    # mount /dev/ad4s1c.bde /private
 7. Verify That the Encrypted File System is Available

    The encrypted file system should now be visible to df(1) and be available
    for use.

    % df -H Filesystem Size Used Avail Capacity Mounted on /dev/ad0s1a 1037M
    72M 883M 8% / /devfs 1.0K 1.0K 0B 100% /dev /dev/ad0s1f 8.1G 55K 7.5G 0% /
    home /dev/ad0s1e 1037M 1.1M 953M 0% /tmp /dev/ad0s1d 6.1G 1.9G 3.7G 35% /
    usr /dev/ad4s1c.bde 150G 4.1K 138G 0% /private

19.16.1.2.Â Mounting Existing Encrypted File Systems

After each boot, any encrypted file systems must be re-attached to the kernel,
checked for errors, and mounted, before the file systems can be used. The
required commands must be executed as root.

 1. Attach the gbde Partition to the Kernel

    # gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock

    This command will prompt for the passphrase that was selected during
    initialization of the encrypted gbde partition.

 2. Check the File System for Errors

    Since encrypted file systems cannot yet be listed in /etc/fstab for
    automatic mounting, the file systems must be checked for errors by running
    fsck(8) manually before mounting:

    # fsck -p -t ffs /dev/ad4s1c.bde
 3. Mount the Encrypted File System

    # mount /dev/ad4s1c.bde /private

    The encrypted file system is now available for use.

19.16.1.2.1.Â Automatically Mounting Encrypted Partitions

It is possible to create a script to automatically attach, check, and mount an
encrypted partition, but for security reasons the script should not contain the
gbde(8) password. Instead, it is recommended that such scripts be run manually
while providing the password via the console or ssh(1).

As an alternative, an rc.d script is provided. Arguments for this script can be
passed via rc.conf(5):

gbde_autoattach_all="YES" gbde_devices="ad4s1c" gbde_lockdir="/etc/gbde"

This requires that the gbde passphrase be entered at boot time. After typing
the correct passphrase, the gbde encrypted partition will be mounted
automatically. This can be useful when using gbde on laptops.

19.16.1.3.Â Cryptographic Protections Employed by gbde

gbde(8) encrypts the sector payload using 128-bit AES in CBC mode. Each sector
on the disk is encrypted with a different AES key. For more information on the
cryptographic design, including how the sector keys are derived from the
user-supplied passphrase, refer to gbde(4).

19.16.1.4.Â Compatibility Issues

sysinstall(8) is incompatible with gbde-encrypted devices. All *.bde devices
must be detached from the kernel before starting sysinstall(8) or it will crash
during its initial probing for devices. To detach the encrypted device used in
the example, use the following command:

# gbde detach /dev/ad4s1c

Also, since vinum(4) does not use the geom(4) subsystem, gbde can not be used
with vinum volumes.

19.16.2.Â Disk Encryption with geli

Contributed by Daniel Gerzo.

An alternative cryptographic GEOM class is available through geli(8). geli
differs from gbde; offers different features, and uses a different scheme for
doing cryptographic work.

geli(8) provides the following features:

  * Utilizes the crypto(9) framework and, when cryptographic hardware is
    available, geli uses it automatically.

  * Supports multiple cryptographic algorithms such as AES, Blowfish, and 3DES.

  * Allows the root partition to be encrypted. The passphrase used to access
    the encrypted root partition will be requested during system boot.

  * Allows the use of two independent keys such as a â  keyâ   and a â  company
    keyâ  .

  * geli is fast as it performs simple sector-to-sector encryption.

  * Allows backup and restore of master keys. If a user destroys their keys, it
    is still possible to get access to the data by restoring keys from the
    backup.

  * Allows a disk to attach with a random, one-time key which is useful for
    swap partitions and temporary file systems.

More geli features can be found in geli(8).

This section describes how to enable support for geli in the FreeBSD kernel and
explains how to create and use a geli encryption provider.

Superuser privileges are required since modifications to the kernel are
necessary.

 1. Adding geli Support to the Kernel

    For a custom kernel, ensure the kernel configuration file contains these
    lines:

    options GEOM_ELI device crypto

    Alternatively, the geli module can be loaded at boot time by adding the
    following line to /boot/loader.conf:

    geom_eli_load="YES"

    geli(8) should now be supported by the kernel.

 2. Generating the Master Key

    The following example describes how to generate a key file which will be
    used as part of the master key for the encrypted provider mounted under /
    private. The key file will provide some random data used to encrypt the
    master key. The master key will also be protected by a passphrase. The
    provider's sector size will be 4kB. The example will describe how to attach
    to the geli provider, create a file system on it, mount it, work with it,
    and finally, how to detach it.

    It is recommended to use a bigger sector size, such as 4kB, for better
    performance.

    The master key will be protected with a passphrase and the data source for
    the key file will be /dev/random. The sector size of the provider /dev/
    da2.eli will be 4kB.

    # dd if=/dev/random of=/root/da2.key bs=64 count=1 # geli init -s 4096 -K /
    root/da2.key /dev/da2 Enter new passphrase: Reenter new passphrase:

    It is not mandatory to use both a passphrase and a key file as either
    method of securing the master key can be used in isolation.

    If the key file is given as â  -â  , standard input will be used. This
    example shows how more than one key file can be used:

    # cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2
 3. Attaching the Provider with the Generated Key

    # geli attach -k /root/da2.key /dev/da2 Enter passphrase:

    The new plaintext device will be named /dev/da2.eli.

    # ls /dev/da2* /dev/da2 /dev/da2.eli
 4. Creating the New File System

    # dd if=/dev/random of=/dev/da2.eli bs=1m # newfs /dev/da2.eli # mount /dev
    /da2.eli /private

    The encrypted file system should now be visible to df(1) and be available
    for use:

    # df -H Filesystem Size Used Avail Capacity Mounted on /dev/ad0s1a 248M 89M
    139M 38% / /devfs 1.0K 1.0K 0B 100% /dev /dev/ad0s1f 7.7G 2.3G 4.9G 32% /
    usr /dev/ad0s1d 989M 1.5M 909M 0% /tmp /dev/ad0s1e 3.9G 1.3G 2.3G 35% /var
    /dev/da2.eli 150G 4.1K 138G 0% /private
 5. Unmounting and Detaching the Provider

    Once the work on the encrypted partition is done, and the /private
    partition is no longer needed, it is prudent to consider unmounting and
    detaching the geli encrypted partition from the kernel:

    # umount /private # geli detach da2.eli

More information about the use of geli(8) can be found in its manual page.

19.16.2.1.Â Using the geli rc.d Script

geli comes with a rc.d script which can be used to simplify the usage of geli.
An example of configuring geli through rc.conf(5) follows:

geli_devices="da2" geli_da2_flags="-p -k /root/da2.key"

This configures /dev/da2 as a geli provider of which the master key file is
located in /root/da2.key. geli will not use a passphrase when attaching to the
provider if -P was given during the geli init phase. The system will detach the
geli provider from the kernel before the system shuts down.

More information about configuring rc.d is provided in the rc.d section of the
Handbook.

19.17.Â Encrypting Swap Space

Written by Christian BrÃŒffer.

Swap encryption in FreeBSD is easy to configure. Depending on which version of
FreeBSD is being used, different options are available and configuration can
vary slightly. The gbde(8) or geli(8) encryption systems can be used for swap
encryption. Both systems use the encswap rc.d script.

19.17.1.Â Why Should Swap be Encrypted?

Like the encryption of disk partitions, encryption of swap space is used to
protect sensitive information. Consider an application that deals with
passwords. As long as these passwords stay in physical memory, all is well.
However, if the operating system starts swapping out memory pages to free space
for other applications, the passwords may be written to the disk platters
unencrypted. Encrypting swap space can be a solution for this scenario.

19.17.2.Â Preparation

Note:

For the remainder of this section, ad0s1b will be the swap partition.

By default, swap is unencrypted. It is possible that it contains passwords or
other sensitive data in cleartext. To rectify this, the data on the swap
partition should be overwritten with random garbage:

# dd if=/dev/random of=/dev/ad0s1b bs=1m

19.17.3.Â Swap Encryption with gbde(8)

The .bde suffix should be added to the device in the respective /etc/fstab swap
line:

# Device Mountpoint FStype Options Dump Pass# /dev/ad0s1b.bde none swap sw 0 0

19.17.4.Â Swap Encryption with geli(8)

The procedure for instead using geli(8) for swap encryption is similar to that
of using gbde(8). The .eli suffix should be added to the device in the
respective /etc/fstab swap line:

# Device Mountpoint FStype Options Dump Pass# /dev/ad0s1b.eli none swap sw 0 0

geli(8) uses the AES algorithm with a key length of 128 bit by default. These
defaults can be altered by using geli_swap_flags in /etc/rc.conf. The following
line tells the encswap rc.d script to create geli(8) swap partitions using the
Blowfish algorithm with a key length of 128 bits and a sectorsize of 4
kilobytes, and sets â  detach on last closeâ  :

geli_swap_flags="-e blowfish -l 128 -s 4096 -d"

Refer to the description of onetime in geli(8) for a list of possible options.

19.17.5.Â Verifying That it Works

Once the system has rebooted, proper operation of the encrypted swap can be
verified using swapinfo.

If gbde(8) is being used:

% swapinfo Device 1K-blocks Used Avail Capacity /dev/ad0s1b.bde 542720 0 542720
0%

If geli(8) is being used:

% swapinfo Device 1K-blocks Used Avail Capacity /dev/ad0s1b.eli 542720 0 542720
0%

19.18.Â Highly Available Storage (HAST)

Contributed by Daniel Gerzo.
With inputs from Freddie Cash, Pawel Jakub Dawidek, Michael W. Lucas and Viktor
Petersson.

19.18.1.Â Synopsis

High availability is one of the main requirements in serious business
applications and highly-available storage is a key component in such
environments. Highly Available STorage, or HASTHighly Available STorage, was
developed by Pawel Jakub Dawidek &lt;pjd@FreeBSD.org&gt; as a framework which allows
transparent storage of the same data across several physically separated
machines connected by a TCP/IP network. HAST can be understood as a
network-based RAID1 (mirror), and is similar to the DRBDÂ® storage system known
from the GNU/LinuxÂ® platform. In combination with other high-availability
features of FreeBSD like CARP, HAST makes it possible to build a
highly-available storage cluster that is resistant to hardware failures.

After reading this section, you will know:

  * What HAST is, how it works and which features it provides.

  * How to set up and use HAST on FreeBSD.

  * How to integrate CARP and devd(8) to build a robust storage system.

Before reading this section, you should:

  * Understand UNIXÂ® and FreeBSD basics.

  * Know how to configure network interfaces and other core FreeBSD subsystems.

  * Have a good understanding of FreeBSD networking.

The HAST project was sponsored by The FreeBSD Foundation with support from
OMCnet Internet Service GmbH and TransIP BV.

19.18.2.Â HAST Features

The main features of the HAST system are:

  * Can be used to mask I/O errors on local hard drives.

  * File system agnostic as it works with any file system supported by FreeBSD.

  * Efficient and quick resynchronization, synchronizing only blocks that were
    modified during the downtime of a node.

  * Can be used in an already deployed environment to add additional
    redundancy.

  * Together with CARP, Heartbeat, or other tools, it can be used to build a
    robust and durable storage system.

19.18.3.Â HAST Operation

As HAST provides a synchronous block-level replication of any storage media to
several machines, it requires at least two physical machines: the primary, also
known as the master node, and the secondary or slave node. These two machines
together are referred to as a cluster.

Note:

HAST is currently limited to two cluster nodes in total.

Since HAST works in a primary-secondary configuration, it allows only one of
the cluster nodes to be active at any given time. The primary node, also called
active, is the one which will handle all the I/O requests to HAST-managed
devices. The secondary node is automatically synchronized from the primary
node.

The physical components of the HAST system are:

  * local disk on primary node, and

  * disk on remote, secondary node.

HAST operates synchronously on a block level, making it transparent to file
systems and applications. HAST provides regular GEOM providers in /dev/hast/
for use by other tools or applications, thus there is no difference between
using HAST-provided devices and raw disks or partitions.

Each write, delete, or flush operation is sent to the local disk and to the
remote disk over TCP/IP. Each read operation is served from the local disk,
unless the local disk is not up-to-date or an I/O error occurs. In such case,
the read operation is sent to the secondary node.

19.18.3.1.Â Synchronization and Replication Modes

HAST tries to provide fast failure recovery. For this reason, it is very
important to reduce synchronization time after a node's outage. To provide fast
synchronization, HAST manages an on-disk bitmap of dirty extents and only
synchronizes those during a regular synchronization, with an exception of the
initial sync.

There are many ways to handle synchronization. HAST implements several
replication modes to handle different synchronization methods:

  * memsync: report write operation as completed when the local write operation
    is finished and when the remote node acknowledges data arrival, but before
    actually storing the data. The data on the remote node will be stored
    directly after sending the acknowledgement. This mode is intended to reduce
    latency, but still provides very good reliability.

  * fullsync: report write operation as completed when local write completes
    and when remote write completes. This is the safest and the slowest
    replication mode. This mode is the default.

  * async: report write operation as completed when local write completes. This
    is the fastest and the most dangerous replication mode. It should be used
    when replicating to a distant node where latency is too high for other
    modes.

19.18.4.Â HAST Configuration

HAST requires GEOM_GATE support which is not present in the default GENERIC
kernel. However, the geom_gate.ko loadable module is available in the default
FreeBSD installation. Alternatively, to build GEOM_GATE support into the kernel
statically, add this line to the custom kernel configuration file:

options GEOM_GATE

The HAST framework consists of several parts from the operating system's point
of view:

  * the hastd(8) daemon responsible for data synchronization,

  * the hastctl(8) userland management utility,

  * and the hast.conf(5) configuration file.

The following example describes how to configure two nodes in master-slave /
primary-secondary operation using HAST to replicate the data between the two.
The nodes will be called hasta with an IP address of 172.16.0.1 and hastb with
an IP of address 172.16.0.2. Both nodes will have a dedicated hard drive /dev/
ad6 of the same size for HAST operation. The HAST pool, sometimes also referred
to as a resource or the GEOM provider in /dev/hast/, will be called test.

Configuration of HAST is done using /etc/hast.conf. This file should be the
same on both nodes. The simplest configuration possible is:

resource test { on hasta { local /dev/ad6 remote 172.16.0.2 } on hastb { local
/dev/ad6 remote 172.16.0.1 } }

For more advanced configuration, refer to hast.conf(5).

Tip:

It is also possible to use host names in the remote statements. In such a case,
make sure that these hosts are resolvable and are defined in /etc/hosts or in
the local DNS.

Now that the configuration exists on both nodes, the HAST pool can be created.
Run these commands on both nodes to place the initial metadata onto the local
disk and to start hastd(8):

# hastctl create test # service hastd onestart

Note:

It is not possible to use GEOM providers with an existing file system or to
convert an existing storage to a HAST-managed pool. This procedure needs to
store some metadata on the provider and there will not be enough required space
available on an existing provider.

A HAST node's primary or secondary role is selected by an administrator, or
software like Heartbeat, using hastctl(8). On the primary node, hasta, issue
this command:

# hastctl role primary test

Similarly, run this command on the secondary node, hastb:

# hastctl role secondary test

Caution:

When the nodes are unable to communicate with each other, and both are
configured as primary nodes, the condition is called split-brain. To
troubleshoot this situation, follow the steps described in SectionÂ 19.18.5.2,
â  Recovering from the Split-brain Conditionâ  .

Verify the result by running hastctl(8) on each node:

# hastctl status test

The important text is the status line, which should say complete on each of the
nodes. If it says degraded, something went wrong. At this point, the
synchronization between the nodes has already started. The synchronization
completes when hastctl status reports 0 bytes of dirty extents.

The next step is to create a filesystem on the /dev/hast/test GEOM provider and
mount it. This must be done on the primary node, as /dev/hast/test appears only
on the primary node. Creating the filesystem can take a few minutes, depending
on the size of the hard drive:

# newfs -U /dev/hast/test # mkdir /hast/test # mount /dev/hast/test /hast/test

Once the HAST framework is configured properly, the final step is to make sure
that HAST is started automatically during system boot. Add this line to /etc/
rc.conf:

hastd_enable="YES"

19.18.4.1.Â Failover Configuration

The goal of this example is to build a robust storage system which is resistant
to the failure of any given node. The scenario is that a primary node of the
cluster fails. If this happens, the secondary node is there to take over
seamlessly, check and mount the file system, and continue to work without
missing a single bit of data.

To accomplish this task, another FreeBSD feature, CARP, provides for automatic
failover on the IP layer. CARP (Common Address Redundancy Protocol) allows
multiple hosts on the same network segment to share an IP address. Set up CARP
on both nodes of the cluster according to the documentation available in
SectionÂ 32.13, â  Common Address Redundancy Protocol (CARP)â  . After setup,
each node will have its own carp0 interface with a shared IP address of
172.16.0.254. The primary HAST node of the cluster must be the master CARP
node.

The HAST pool created in the previous section is now ready to be exported to
the other hosts on the network. This can be accomplished by exporting it
through NFS or Samba, using the shared IP address 172.16.0.254. The only
problem which remains unresolved is an automatic failover should the primary
node fail.

In the event of CARP interfaces going up or down, the FreeBSD operating system
generates a devd(8) event, making it possible to watch for state changes on the
CARP interfaces. A state change on the CARP interface is an indication that one
of the nodes failed or came back online. These state change events make it
possible to run a script which will automatically handle the HAST failover.

To be able to catch state changes on the CARP interfaces, add this
configuration to /etc/devd.conf on each node:

notify 30 { match "system" "IFNET"; match "subsystem" "carp0"; match "type"
"LINK_UP"; action "/usr/local/sbin/carp-hast-switch master"; }; notify 30 {
match "system" "IFNET"; match "subsystem" "carp0"; match "type" "LINK_DOWN";
action "/usr/local/sbin/carp-hast-switch slave"; };

Restart devd(8) on both nodes to put the new configuration into effect:

# service devd restart

When the carp0 interface state changes by going up or down , the system
generates a notification, allowing the devd(8) subsystem to run an arbitrary
script, in this case /usr/local/sbin/carp-hast-switch. This script handles the
automatic failover. For further clarification about the above devd(8)
configuration, refer to devd.conf(5).

An example of such a script could be:

#!/bin/sh # Original script by Freddie Cash &lt;fjwcash@gmail.com&gt; # Modified by
Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt; # and Viktor Petersson
&lt;vpetersson@wireload.net&gt; # The names of the HAST resources, as listed in /etc/
hast.conf resources="test" # delay in mounting HAST resource after becoming
master # make your best guess delay=3 # logging log="local0.debug" name=
"carp-hast" # end of user configurable stuff case "$1" in master) logger -p
$log -t $name "Switching to primary provider for ${resources}." sleep ${delay}
# Wait for any "hastd secondary" processes to stop for disk in ${resources}; do
while $( pgrep -lf "hastd: ${disk} \(secondary\)" &gt; /dev/null 2&gt;&1 ); do sleep
1 done # Switch role for each disk hastctl role primary ${disk} if [ $? -ne 0
]; then logger -p $log -t $name "Unable to change role to primary for resource
${disk}." exit 1 fi done # Wait for the /dev/hast/* devices to appear for disk
in ${resources}; do for I in $( jot 60 ); do [ -c "/dev/hast/${disk}" ] &&
break sleep 0.5 done if [ ! -c "/dev/hast/${disk}" ]; then logger -p $log -t
$name "GEOM provider /dev/hast/${disk} did not appear." exit 1 fi done logger
-p $log -t $name "Role for HAST resources ${resources} switched to primary."
logger -p $log -t $name "Mounting disks." for disk in ${resources}; do mkdir -p
/hast/${disk} fsck -p -y -t ufs /dev/hast/${disk} mount /dev/hast/${disk} /hast
/${disk} done ;; slave) logger -p $log -t $name "Switching to secondary
provider for ${resources}." # Switch roles for the HAST resources for disk in $
{resources}; do if ! mount | grep -q "^/dev/hast/${disk} on " then else umount
-f /hast/${disk} fi sleep $delay hastctl role secondary ${disk} 2&gt;&1 if [ $?
-ne 0 ]; then logger -p $log -t $name "Unable to switch role to secondary for
resource ${disk}." exit 1 fi logger -p $log -t $name "Role switched to
secondary for resource ${disk}." done ;; esac

In a nutshell, the script takes these actions when a node becomes master /
primary:

  * Promotes the HAST pools to primary on a given node.

  * Checks the file system under the HAST pool.

  * Mounts the pools at an appropriate place.

When a node becomes backup / secondary:

  * Unmounts the HAST pools.

  * Degrades the HAST pools to secondary.

Caution:

Keep in mind that this is just an example script which serves as a proof of
concept. It does not handle all the possible scenarios and can be extended or
altered in any way, for example, to start/stop required services.

Tip:

For this example, a standard UFS file system was used. To reduce the time
needed for recovery, a journal-enabled UFS or ZFS file system can be used
instead.

More detailed information with additional examples can be found in the HAST
Wiki page.

19.18.5.Â Troubleshooting

19.18.5.1.Â General Troubleshooting Tips

HAST should generally work without issues. However, as with any other software
product, there may be times when it does not work as supposed. The sources of
the problems may be different, but the rule of thumb is to ensure that the time
is synchronized between all nodes of the cluster.

When troubleshooting HAST problems, the debugging level of hastd(8) should be
increased by starting hastd(8) with -d. This argument may be specified multiple
times to further increase the debugging level. A lot of useful information may
be obtained this way. Consider also using -F, which starts hastd(8) in the
foreground.

19.18.5.2.Â Recovering from the Split-brain Condition

Split-brain is when the nodes of the cluster are unable to communicate with
each other, and both are configured as primary. This is a dangerous condition
because it allows both nodes to make incompatible changes to the data. This
problem must be corrected manually by the system administrator.

The administrator must decide which node has more important changes (or merge
them manually) and let HAST perform full synchronization of the node which has
the broken data. To do this, issue these commands on the node which needs to be
resynchronized:

# hastctl role init &lt;resource&gt; # hastctl create &lt;resource&gt; # hastctl role
secondary &lt;resource&gt;

ChapterÂ 20.Â GEOM: Modular Disk Transformation Framework

Written by Tom Rhodes.
Table of Contents

20.1. Synopsis
20.2. GEOM Introduction
20.3. RAID0 - Striping
20.4. RAID1 - Mirroring
20.5. RAID3 - Byte-level Striping with Dedicated Parity
20.6. GEOM Gate Network Devices
20.7. Labeling Disk Devices
20.8. UFS Journaling Through GEOM

20.1.Â Synopsis

This chapter covers the use of disks under the GEOM framework in FreeBSD. This
includes the major RAID control utilities which use the framework for
configuration. This chapter will not go into in depth discussion on how GEOM
handles or controls I/O, the underlying subsystem, or code. This information is
provided in geom(4) and its various SEE ALSO references. This chapter is also
not a definitive guide to RAID configurations and only GEOM-supported RAID
classifications will be discussed.

After reading this chapter, you will know:

  * What type of RAID support is available through GEOM.

  * How to use the base utilities to configure, maintain, and manipulate the
    various RAID levels.

  * How to mirror, stripe, encrypt, and remotely connect disk devices through
    GEOM.

  * How to troubleshoot disks attached to the GEOM framework.

Before reading this chapter, you should:

  * Understand how FreeBSD treats disk devices.

  * Know how to configure and install a new FreeBSD kernel.

20.2.Â GEOM Introduction

GEOM permits access and control to classes, such as Master Boot Records and BSD
labels, through the use of providers, or the special files in /dev. By
supporting various software RAID configurations, GEOM transparently provides
access to the operating system and operating system utilities.

20.3.Â RAID0 - Striping

Written by Tom Rhodes and Murray Stokely.

Striping combine several disk drives into a single volume. In many cases, this
is done through the use of hardware controllers. The GEOM disk subsystem
provides software support for RAID0, also known as disk striping.

In a RAID0 system, data is split into blocks that get written across all the
drives in the array. Instead of having to wait on the system to write 256k to
one disk, a RAID0 system can simultaneously write 64k to each of four different
disks, offering superior I/O performance. This performance can be enhanced
further by using multiple disk controllers.

Each disk in a RAID0 stripe must be of the same size, since I/O requests are
interleaved to read or write to multiple disks in parallel.

                          Disk Striping Illustration
ProcedureÂ 20.1.Â Creating a Stripe of Unformatted ATA Disks

 1. Load the geom_stripe.ko module:

    # kldload geom_stripe
 2. Ensure that a suitable mount point exists. If this volume will become a
    root partition, then temporarily use another mount point such as /mnt:

    # mkdir /mnt
 3. Determine the device names for the disks which will be striped, and create
    the new stripe device. For example, to stripe two unused and unpartitioned 
    ATA disks with device names of /dev/ad2 and /dev/ad3:

    # gstripe label -v st0 /dev/ad2 /dev/ad3 Metadata value stored on /dev/ad2.
    Metadata value stored on /dev/ad3. Done.
 4. Write a standard label, also known as a partition table, on the new volume
    and install the default bootstrap code:

    # bsdlabel -wB /dev/stripe/st0
 5. This process should create two other devices in /dev/stripe in addition to
    st0. Those include st0a and st0c. At this point, a file system may be
    created on st0a using newfs:

    # newfs -U /dev/stripe/st0a

    Many numbers will glide across the screen, and after a few seconds, the
    process will be complete. The volume has been created and is ready to be
    mounted.

To manually mount the created disk stripe:

# mount /dev/stripe/st0a /mnt

To mount this striped file system automatically during the boot process, place
the volume information in /etc/fstab. In this example, a permanent mount point,
named stripe, is created:

# mkdir /stripe # echo "/dev/stripe/st0a /stripe ufs rw 2 2" \ &gt;&gt; /etc/fstab

The geom_stripe.ko module must also be automatically loaded during system
initialization, by adding a line to /boot/loader.conf:

# echo 'geom_stripe_load="YES"' &gt;&gt; /boot/loader.conf

20.4.Â RAID1 - Mirroring

RAID1, or mirroring, is the technique of writing the same data to more than one
disk drive. Mirrors are usually used to guard against data loss due to drive
failure. Each drive in a mirror contains an identical copy of the data. When an
individual drive fails, the mirror continues to work, providing data from the
drives that are still functioning. The computer keeps running, and the
administrator has time to replace the failed drive without user interruption.

Two common situations are illustrated in these examples. The first creates a
mirror out of two new drives and uses it as a replacement for an existing
single drive. The second example creates a mirror on a single new drive, copies
the old drive's data to it, then inserts the old drive into the mirror. While
this procedure is slightly more complicated, it only requires one new drive.

Traditionally, the two drives in a mirror are identical in model and capacity,
but gmirror(8) does not require that. Mirrors created with dissimilar drives
will have a capacity equal to that of the smallest drive in the mirror. Extra
space on larger drives will be unused. Drives inserted into the mirror later
must have at least as much capacity as the smallest drive already in the
mirror.

Warning:

The mirroring procedures shown here are non-destructive, but as with any major
disk operation, make a full backup first.

20.4.1.Â Metadata Issues

Many disk systems store metadata at the end of each disk. Old metadata should
be erased before reusing the disk for a mirror. Most problems are caused by two
particular types of leftover metadata: GPT partition tables, and old gmirror(8)
metadata from a previous mirror.

GPT metadata can be erased with gpart(8). This example erases both primary and
backup GPT partition tables from disk ada8:

# gpart destroy -F ada8

gmirror(8) can remove a disk from an active mirror and erase the metadata in
one step. Here, the example disk ada8 is removed from the active mirror gm4:

# gmirror remove gm4 ada8

If the mirror is not running but old mirror metadata is still on the disk, use
gmirror clear to remove it:

# gmirror clear ada8

gmirror(8) stores one block of metadata at the end of the disk. Because GPT
partition schemes also store metadata at the end of the disk, mirroring full
GPT disks with gmirror(8) is not recommended. MBR partitioning is used here
because it only stores a partition table at the start of the disk and does not
conflict with gmirror(8).

20.4.2.Â Creating a Mirror with Two New Disks

In this example, FreeBSD has already been installed on a single disk, ada0. Two
new disks, ada1 and ada2, have been connected to the system. A new mirror will
be created on these two disks and used to replace the old single disk.

gmirror(8) requires a kernel module, geom_mirror.ko, either built into the
kernel or loaded at boot- or run-time. Manually load the kernel module now:

# gmirror load

Create the mirror with the two new drives:

# gmirror label -v gm0 /dev/ada1 /dev/ada2

gm0 is a user-chosen device name assigned to the new mirror. After the mirror
has been started, this device name will appear in /dev/mirror/.

MBR and bsdlabel partition tables can now be created on the mirror with gpart
(8). Here we show a traditional split-filesystem layout, with partitions for /,
swap, /var, /tmp, and /usr. A single / filesystem and a swap partition will
also work.

Partitions on the mirror do not have to be the same size as those on the
existing disk, but they must be large enough to hold all the data already
present on ada0.

# gpart create -s MBR mirror/gm0 # gpart add -t freebsd -a 4k mirror/gm0 #
gpart show mirror/gm0 =&gt; 63 156301423 mirror/gm0 MBR (74G) 63 63 - free - (31k)
126 156301299 1 freebsd (74G) 156301425 61 - free - (30k)
# gpart create -s BSD mirror/gm0s1 # gpart add -t freebsd-ufs -a 4k -s 2g
mirror/gm0s1 # gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1 # gpart add
-t freebsd-ufs -a 4k -s 2g mirror/gm0s1 # gpart add -t freebsd-ufs -a 4k -s 1g
mirror/gm0s1 # gpart add -t freebsd-ufs -a 4k mirror/gm0s1 # gpart show mirror/
gm0s1 =&gt; 0 156301299 mirror/gm0s1 BSD (74G) 0 2 - free - (1.0k) 2 4194304 1
freebsd-ufs (2.0G) 4194306 8388608 2 freebsd-swap (4.0G) 12582914 4194304 4
freebsd-ufs (2.0G) 16777218 2097152 5 freebsd-ufs (1.0G) 18874370 137426928 6
freebsd-ufs (65G) 156301298 1 - free - (512B)

Make the mirror bootable by installing bootcode in the MBR and bsdlabel and
setting the active slice:

# gpart bootcode -b /boot/mbr mirror/gm0 # gpart set -a active -i 1 mirror/gm0
# gpart bootcode -b /boot/boot mirror/gm0s1

Format the filesystems on the new mirror, enabling soft-updates.

# newfs -U /dev/mirror/gm0s1a # newfs -U /dev/mirror/gm0s1d # newfs -U /dev/
mirror/gm0s1e # newfs -U /dev/mirror/gm0s1f

Filesystems from the original ada0 disk can now be copied onto the mirror with
dump(8) and restore(8).

# mount /dev/mirror/gm0s1a /mnt # dump -C16 -b64 -0aL -f - / | (cd /mnt &&
restore -rf -) # mount /dev/mirror/gm0s1d /mnt/var # mount /dev/mirror/gm0s1e /
mnt/tmp # mount /dev/mirror/gm0s1f /mnt/usr # dump -C16 -b64 -0aL -f - /var |
(cd /mnt/var && restore -rf -) # dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &
& restore -rf -) # dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf
-)

/mnt/etc/fstab must be edited to point to the new mirror filesystems:

# Device Mountpoint FStype Options Dump Pass# /dev/mirror/gm0s1a / ufs rw 1 1 /
dev/mirror/gm0s1b none swap sw 0 0 /dev/mirror/gm0s1d /var ufs rw 2 2 /dev/
mirror/gm0s1e /tmp ufs rw 2 2 /dev/mirror/gm0s1f /usr ufs rw 2 2

If the gmirror(8) kernel module has not been built into the kernel, /mnt/boot/
loader.conf is edited to load the module at boot:

geom_mirror_load="YES"

Reboot the system to test the new mirror and verify that all data has been
copied. The BIOS will see the mirror as two individual drives rather than a
mirror. Because the drives are identical, it does not matter which is selected
to boot.

See the Troubleshooting section if there are problems booting. Powering down
and disconnecting the original ada0 disk will allow it to be kept as an offline
backup.

In use, the mirror will behave just like the original single drive.

20.4.3.Â Creating a Mirror with an Existing Drive

In this example, FreeBSD has already been installed on a single disk, ada0. A
new disk, ada1, has been connected to the system. A one-disk mirror will be
created on the new disk, the existing system copied onto it, and then the old
disk will be inserted into the mirror. This slightly complex procedure is
required because gmirror(8) needs to put a 512-byte block of metadata at the
end of each disk, and the existing ada0 has usually had all of its space
already allocated.

Load the gmirror(8) kernel module:

# gmirror load

Check the media size of the original disk with diskinfo(8):

# diskinfo -v ada0 | head -n3 /dev/ada0 512 # sectorsize 1000204821504 #
mediasize in bytes (931G)

Create a mirror on the new disk. To make certain that the mirror capacity is
not any larger than the original drive, gnop(8) is used to create a fake drive
of the exact same size. This drive does not store any data, but is used only to
limit the size of the mirror. When gmirror(8) creates the mirror, it will
restrict the capacity to the size of gzero.nop, even if the new drive (ada1)
has more space. Note that the 1000204821504 in the second line should be equal
to ada0's media size as shown by diskinfo(8) above.

# geom zero load # gnop create -s 1000204821504 gzero # gmirror label -v gm0
gzero.nop ada1 # gmirror forget gm0

gzero.nop does not store any data, so the mirror does not see it as connected.
The mirror is told to â  forgetâ   unconnected components, removing references
to gzero.nop. The result is a mirror device containing only a single disk,
ada1.

After creating gm0, view the partition table on ada0.

This output is from a 1Â TB drive. If there is some unallocated space at the
end of the drive, the contents may be copied directly from ada0 to the new
mirror.

However, if the output shows that all of the space on the disk is allocated
like the following listing, there is no space available for the 512-byte
gmirror(8) metadata at the end of the disk.

# gpart show ada0 =&gt; 63 1953525105 ada0 MBR (931G) 63 1953525105 1 freebsd
[active] (931G)

In this case, the partition table must be edited to reduce the capacity by one
sector on mirror/gm0. The procedure will be explained later.

In either case, partition tables on the primary disk should be copied first
with the gpart(8) backup and restore subcommands.

# gpart backup ada0 &gt; table.ada0 # gpart backup ada0s1 &gt; table.ada0s1

These commands create two files, table.ada0 and table.ada0s1. This example is
from a 1Â TB drive:

# cat table.ada0 MBR 4 1 freebsd 63 1953525105 [active]
# cat table.ada0s1 BSD 8 1 freebsd-ufs 0 4194304 2 freebsd-swap 4194304
33554432 4 freebsd-ufs 37748736 50331648 5 freebsd-ufs 88080384 41943040 6
freebsd-ufs 130023424 838860800 7 freebsd-ufs 968884224 984640881

If the output of gpart show shows no free space at the end of the disk, the
size of both the slice and the last partition must be reduced by one sector.
Edit the two files, reducing the size of both the slice and last partition by
one. These are the last numbers in each listing.

# cat table.ada0 MBR 4 1 freebsd 63 1953525104 [active]
# cat table.ada0s1 BSD 8 1 freebsd-ufs 0 4194304 2 freebsd-swap 4194304
33554432 4 freebsd-ufs 37748736 50331648 5 freebsd-ufs 88080384 41943040 6
freebsd-ufs 130023424 838860800 7 freebsd-ufs 968884224 984640880

If at least one sector was unallocated at the end of the disk, these two files
can be used without modification.

Now restore the partition table into mirror/gm0:

# gpart restore mirror/gm0 &lt; table.ada0 # gpart restore mirror/gm0s1 &lt;
table.ada0s1

Check the partition table with gpart show. This example has gm0s1a for /,
gm0s1d for /var, gm0s1e for /usr, gm0s1f for /data1, and gm0s1g for /data2.

# gpart show mirror/gm0 =&gt; 63 1953525104 mirror/gm0 MBR (931G) 63 1953525042 1
freebsd [active] (931G) 1953525105 62 - free - (31k) # gpart show mirror/gm0s1
=&gt; 0 1953525042 mirror/gm0s1 BSD (931G) 0 2097152 1 freebsd-ufs (1.0G) 2097152
16777216 2 freebsd-swap (8.0G) 18874368 41943040 4 freebsd-ufs (20G) 60817408
20971520 5 freebsd-ufs (10G) 81788928 629145600 6 freebsd-ufs (300G) 710934528
1242590514 7 freebsd-ufs (592G) 1953525042 63 - free - (31k)

Both the slice and the last partition should have some free space at the end of
each disk.

Create filesystems on these new partitions. The number of partitions will vary,
matching the partitions on the original disk, ada0.

# newfs -U /dev/mirror/gm0s1a # newfs -U /dev/mirror/gm0s1d # newfs -U /dev/
mirror/gm0s1e # newfs -U /dev/mirror/gm0s1f # newfs -U /dev/mirror/gm0s1g

Make the mirror bootable by installing bootcode in the MBR and bsdlabel and
setting the active slice:

# gpart bootcode -b /boot/mbr mirror/gm0 # gpart set -a active -i 1 mirror/gm0
# gpart bootcode -b /boot/boot mirror/gm0s1

Adjust /etc/fstab to use the new partitions on the mirror. Back up this file
first by copying it to /etc/fstab.orig.

# cp /etc/fstab /etc/fstab.orig

Edit /etc/fstab, replacing /dev/ada0 with mirror/gm0.

# Device Mountpoint FStype Options Dump Pass# /dev/mirror/gm0s1a / ufs rw 1 1 /
dev/mirror/gm0s1b none swap sw 0 0 /dev/mirror/gm0s1d /var ufs rw 2 2 /dev/
mirror/gm0s1e /usr ufs rw 2 2 /dev/mirror/gm0s1f /data1 ufs rw 2 2 /dev/mirror/
gm0s1g /data2 ufs rw 2 2

If the gmirror(8) kernel module has not been built into the kernel, edit /boot/
loader.conf to load it:

geom_mirror_load="YES"

Filesystems from the original disk can now be copied onto the mirror with dump
(8) and restore(8). Note that it may take some time to create a snapshot for
each filesystem dumped with dump -L.

# mount /dev/mirror/gm0s1a /mnt # dump -C16 -b64 -0aL -f - / | (cd /mnt &&
restore -rf -) # mount /dev/mirror/gm0s1d /mnt/var # mount /dev/mirror/gm0s1e /
mnt/usr # mount /dev/mirror/gm0s1f /mnt/data1 # mount /dev/mirror/gm0s1g /mnt/
data2 # dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr && restore -rf -) # dump
-C16 -b64 -0aL -f - /var | (cd /mnt/var && restore -rf -) # dump -C16 -b64 -0aL
-f - /data1 | (cd /mnt/data1 && restore -rf -) # dump -C16 -b64 -0aL -f - /
data2 | (cd /mnt/data2 && restore -rf -)

Restart the system, booting from ada1. If everything is working, the system
will boot from mirror/gm0, which now contains the same data as ada0 had
previously. See the Troubleshooting section if there are problems booting.

At this point, the mirror still consists of only the single ada1 disk.

After booting from mirror/gm0 successfully, the final step is inserting ada0
into the mirror.

Important:

When ada0 is inserted into the mirror, its former contents will be overwritten
by data on the mirror. Make certain that mirror/gm0 has the same contents as
ada0 before adding ada0 to the mirror. If there is something wrong with the
contents copied by dump(8) and restore(8), revert /etc/fstab to mount the
filesystems on ada0, reboot, and try the whole procedure again.

# gmirror insert gm0 ada0 GEOM_MIRROR: Device gm0: rebuilding provider ada0

Synchronization between the two disks will start immediately. gmirror(8) status
shows the progress.

# gmirror status Name Status Components mirror/gm0 DEGRADED ada1 (ACTIVE) ada0
(SYNCHRONIZING, 64%)

After a while, synchronization will finish.

GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished. # gmirror status
Name Status Components mirror/gm0 COMPLETE ada1 (ACTIVE) ada0 (ACTIVE)

mirror/gm0 now consists of the two disks ada0 and ada1, and the contents are
automatically synchronized with each other. In use, mirror/gm0 will behave just
like the original single drive.

20.4.4.Â Troubleshooting

20.4.4.1.Â Problems with Booting

20.4.4.1.1.Â BIOS Settings

BIOS settings may have to be changed to boot from one of the new mirrored
drives. Either mirror drive can be used for booting, as they contain identical
data.

20.4.4.1.2.Â Boot Problems

If the boot stopped with this message, something is wrong with the mirror
device:

Mounting from ufs:/dev/mirror/gm0s1a failed with error 19. Loader variables:
vfs.root.mountfrom=ufs:/dev/mirror/gm0s1a vfs.root.mountfrom.options=rw Manual
root filesystem specification: &lt;fstype&gt;:&lt;device&gt; [options] Mount &lt;device&gt; using
filesystem &lt;fstype&gt; and with the specified (optional) option list. eg. ufs:/dev
/da0s1a zfs:tank cd9660:/dev/acd0 ro (which is equivalent to: mount -t cd9660
-o ro /dev/acd0 /) ? List valid disk boot devices . Yield 1 second (for
background tasks) &lt;empty line&gt; Abort manual input mountroot&gt;

Forgetting to load the geom_mirror module in /boot/loader.conf can cause this
problem. To fix it, boot from a FreeBSDÂ 9.0 or later installation media and
choose Shell at the first prompt. Then load the mirror module and mount the
mirror device:

# gmirror load # mount /dev/mirror/gm0s1a /mnt

Edit /mnt/boot/loader.conf, adding a line to load the mirror module:

geom_mirror_load="YES"

Save the file and reboot.

Other problems that cause error 19 require more effort to fix. Enter ufs:/dev/
ada0s1a at the boot loader prompt. Although the system should boot from ada0,
another prompt to select a shell appears because /etc/fstab is incorrect. Press
the Enter key at the prompt. Undo the modifications so far by reverting /etc/
fstab, mounting filesystems from the original disk (ada0) instead of the
mirror. Reboot the system and try the procedure again.

Enter full pathname of shell or RETURN for /bin/sh: # cp /etc/fstab.orig /etc/
fstab # reboot

20.4.5.Â Recovering from Disk Failure

The benefit of disk mirroring is that an individual disk can fail without
causing the mirror to lose any data. In the above example, if ada0 fails, the
mirror will continue to work, providing data from the remaining working drive,
ada1.

To replace the failed drive, shut down the system and physically replace the
failed drive with a new drive of equal or greater capacity. Manufacturers use
somewhat arbitrary values when rating drives in gigabytes, and the only way to
really be sure is to compare the total count of sectors shown by diskinfo -v. A
drive with larger capacity than the mirror will work, although the extra space
on the new drive will not be used.

After the computer is powered back up, the mirror will be running in a â  
degradedâ   mode with only one drive. The mirror is told to forget drives that
are not currently connected:

# gmirror forget gm0

Any old metadata should be cleared from the replacement disk. Then the disk,
ada4 for this example, is inserted into the mirror:

# gmirror insert gm0 /dev/ada4

Resynchronization begins when the new drive is inserted into the mirror. This
process of copying mirror data to a new drive can take a while. Performance of
the mirror will be greatly reduced during the copy, so inserting new drives is
best done when there is low demand on the computer.

Progress can be monitored with gmirror status, which shows drives that are
being synchronized and the percentage of completion. During resynchronization,
the status will be DEGRADED, changing to COMPLETE when the process is finished.

20.5.Â RAID3 - Byte-level Striping with Dedicated Parity

Written by Mark Gladman and Daniel Gerzo.
Based on documentation by Tom Rhodes and Murray Stokely.

RAID3 is a method used to combine several disk drives into a single volume with
a dedicated parity disk. In a RAID3 system, data is split up into a number of
bytes that are written across all the drives in the array except for one disk
which acts as a dedicated parity disk. This means that reading 1024KB from a 
RAID3 implementation will access all disks in the array. Performance can be
enhanced by using multiple disk controllers. The RAID3 array provides a fault
tolerance of 1 drive, while providing a capacity of 1 - 1/n times the total
capacity of all drives in the array, where n is the number of hard drives in
the array. Such a configuration is mostly suitable for storing data of larger
sizes such as multimedia files.

At least 3 physical hard drives are required to build a RAID3 array. Each disk
must be of the same size, since I/O requests are interleaved to read or write
to multiple disks in parallel. Also, due to the nature of RAID3, the number of
drives must be equal to 3, 5, 9, 17, and so on, or 2^n + 1.

20.5.1.Â Creating a Dedicated RAID3 Array

In FreeBSD, support for RAID3 is implemented by the graid3(8) GEOM class.
Creating a dedicated RAID3 array on FreeBSD requires the following steps.

Note:

While it is theoretically possible to boot from a RAID3 array on FreeBSD, that
configuration is uncommon and is not advised.

 1. First, load the geom_raid3.ko kernel module by issuing the following
    command:

    # graid3 load

    Alternatively, it is possible to manually load the geom_raid3.ko module:

    # kldload geom_raid3.ko
 2. Create or ensure that a suitable mount point exists:

    # mkdir /multimedia/
 3. Determine the device names for the disks which will be added to the array,
    and create the new RAID3 device. The final device listed will act as the
    dedicated parity disk. This example uses three unpartitioned ATA drives:
    ada1 and ada2 for data, and ada3 for parity.

    # graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3 Metadata value stored
    on /dev/ada1. Metadata value stored on /dev/ada2. Metadata value stored on
    /dev/ada3. Done.
 4. Partition the newly created gr0 device and put a UFS file system on it:

    # gpart create -s GPT /dev/raid3/gr0 # gpart add -t freebsd-ufs /dev/raid3/
    gr0 # newfs -j /dev/raid3/gr0p1

    Many numbers will glide across the screen, and after a bit of time, the
    process will be complete. The volume has been created and is ready to be
    mounted:

    # mount /dev/raid3/gr0p1 /multimedia/

    The RAID3 array is now ready to use.

Additional configuration is needed to retain the above setup across system
reboots.

 1. The geom_raid3.ko module must be loaded before the array can be mounted. To
    automatically load the kernel module during system initialization, add the
    following line to /boot/loader.conf:

    geom_raid3_load="YES"
 2. The following volume information must be added to /etc/fstab in order to
    automatically mount the array's file system during the system boot process:

    /dev/raid3/gr0p1 /multimedia ufs rw 2 2

20.6.Â GEOM Gate Network Devices

GEOM supports the remote use of devices, such as disks, CD-ROMs, and files
through the use of the gate utilities. This is similar to NFS.

To begin, an exports file must be created. This file specifies who is permitted
to access the exported resources and what level of access they are offered. For
example, to export the fourth slice on the first SCSI disk, the following /etc/
gg.exports is more than adequate:

192.168.1.0/24 RW /dev/da0s4d

This allows all hosts inside the specified private network access to the file
system on the da0s4d partition.

To export this device, ensure it is not currently mounted, and start the ggated
(8) server daemon:

# ggated

To mount the device on the client machine, issue the following commands:

# ggatec create -o rw 192.168.1.1 /dev/da0s4d ggate0 # mount /dev/ggate0 /mnt

The device may now be accessed through the /mnt mount point.

Note:

However, this will fail if the device is currently mounted on either the server
machine or any other machine on the network.

When the device is no longer needed, unmount it with umount(8), similar to any
other disk device.

20.7.Â Labeling Disk Devices

During system initialization, the FreeBSD kernel creates device nodes as
devices are found. This method of probing for devices raises some issues. For
instance, what if a new disk device is added via USB? It is likely that a flash
device may be handed the device name of da0 and the original da0 shifted to
da1. This will cause issues mounting file systems if they are listed in /etc/
fstab which may also prevent the system from booting.

One solution is to chain SCSI devices in order so a new device added to the 
SCSI card will be issued unused device numbers. But what about USB devices
which may replace the primary SCSI disk? This happens because USB devices are
usually probed before the SCSI card. One solution is to only insert these
devices after the system has been booted. Another method is to use only a
single ATA drive and never list the SCSI devices in /etc/fstab.

A better solution is to use glabel to label the disk devices and use the labels
in /etc/fstab. Because glabel stores the label in the last sector of a given
provider, the label will remain persistent across reboots. By using this label
as a device, the file system may always be mounted regardless of what device
node it is accessed through.

Note:

glabel can create both transient and permanent labels. Only permanent labels
are consistent across reboots. Refer to glabel(8) for more information on the
differences between labels.

20.7.1.Â Label Types and Examples

Permanent labels can be a generic or a file system label. Permanent file system
labels can be created with tunefs(8) or newfs(8). These types of labels are
created in a sub-directory of /dev, and will be named according to the file
system type. For example, UFS2 file system labels will be created in /dev/ufs.
Generic permanent labels can be created with glabel label. These are not file
system specific and will be created in /dev/label.

Temporary labels are destroyed at the next reboot. These labels are created in
/dev/label and are suited to experimentation. A temporary label can be created
using glabel create.

To create a permanent label for a UFS2 file system without destroying any data,
issue the following command:

# tunefs -L home /dev/da3

Warning:

If the file system is full, this may cause data corruption.

A label should now exist in /dev/ufs which may be added to /etc/fstab:

/dev/ufs/home /home ufs rw 2 2

Note:

The file system must not be mounted while attempting to run tunefs.

Now the file system may be mounted:

# mount /home

From this point on, so long as the geom_label.ko kernel module is loaded at
boot with /boot/loader.conf or the GEOM_LABEL kernel option is present, the
device node may change without any ill effect on the system.

File systems may also be created with a default label by using the -L flag with
newfs. Refer to newfs(8) for more information.

The following command can be used to destroy the label:

# glabel destroy home

The following example shows how to label the partitions of a boot disk.

ExampleÂ 20.1.Â Labeling Partitions on the Boot Disk

By permanently labeling the partitions on the boot disk, the system should be
able to continue to boot normally, even if the disk is moved to another
controller or transferred to a different system. For this example, it is
assumed that a single ATA disk is used, which is currently recognized by the
system as ad0. It is also assumed that the standard FreeBSD partition scheme is
used, with /, /var, /usr and /tmp, as well as a swap partition.

Reboot the system, and at the loader(8) prompt, press 4 to boot into single
user mode. Then enter the following commands:

# glabel label rootfs /dev/ad0s1a GEOM_LABEL: Label for provider /dev/ad0s1a is
label/rootfs # glabel label var /dev/ad0s1d GEOM_LABEL: Label for provider /dev
/ad0s1d is label/var # glabel label usr /dev/ad0s1f GEOM_LABEL: Label for
provider /dev/ad0s1f is label/usr # glabel label tmp /dev/ad0s1e GEOM_LABEL:
Label for provider /dev/ad0s1e is label/tmp # glabel label swap /dev/ad0s1b
GEOM_LABEL: Label for provider /dev/ad0s1b is label/swap # exit

The system will continue with multi-user boot. After the boot completes, edit /
etc/fstab and replace the conventional device names, with their respective
labels. The final /etc/fstab will look like this:

# Device Mountpoint FStype Options Dump Pass# /dev/label/swap none swap sw 0 0
/dev/label/rootfs / ufs rw 1 1 /dev/label/tmp /tmp ufs rw 2 2 /dev/label/usr /
usr ufs rw 2 2 /dev/label/var /var ufs rw 2 2

The system can now be rebooted. If everything went well, it will come up
normally and mount will show:

# mount /dev/label/rootfs on / (ufs, local) devfs on /dev (devfs, local) /dev/
label/tmp on /tmp (ufs, local, soft-updates) /dev/label/usr on /usr (ufs,
local, soft-updates) /dev/label/var on /var (ufs, local, soft-updates)


Starting with FreeBSDÂ 7.2, the glabel(8) class supports a new label type for 
UFS file systems, based on the unique file system id, ufsid. These labels may
be found in /dev/ufsid and are created automatically during system startup. It
is possible to use ufsid labels to mount partitions using /etc/fstab. Use
glabel status to receive a list of file systems and their corresponding ufsid
labels:

% glabel status Name Status Components ufsid/486b6fc38d330916 N/A ad4s1d ufsid/
486b6fc16926168e N/A ad4s1f

In the above example, ad4s1d represents /var, while ad4s1f represents /usr.
Using the ufsid values shown, these partitions may now be mounted with the
following entries in /etc/fstab:

/dev/ufsid/486b6fc38d330916 /var ufs rw 2 2 /dev/ufsid/486b6fc16926168e /usr
ufs rw 2 2

Any partitions with ufsid labels can be mounted in this way, eliminating the
need to manually create permanent labels, while still enjoying the benefits of
device name independent mounting.

20.8.Â UFS Journaling Through GEOM

Beginning with FreeBSDÂ 7.0, support for UFS journals is available. The
implementation is provided through the GEOM subsystem and is configured using
gjournal(8).

Journaling stores a log of file system transactions, such as changes that make
up a complete disk write operation, before meta-data and file writes are
committed to the disk. This transaction log can later be replayed to redo file
system transactions, preventing file system inconsistencies.

This method provides another mechanism to protect against data loss and
inconsistencies of the file system. Unlike Soft Updates, which tracks and
enforces meta-data updates, and snapshots, which create an image of the file
system, a log is stored in disk space specifically for this task, and in some
cases, may be stored on another disk entirely.

Unlike other file system journaling implementations, the gjournal method is
block based and not implemented as part of the file system. It is a GEOM
extension.

To enable support for gjournal, the FreeBSD kernel must have the following
option which is the default on FreeBSDÂ 7.0 and later:

options UFS_GJOURNAL

If journaled volumes need to be mounted during startup, the geom_journal.ko
kernel module needs to be loaded, by adding the following line to /boot/
loader.conf:

geom_journal_load="YES"

Alternatively, this function can be built into a custom kernel, by adding the
following line in the kernel configuration file:

options GEOM_JOURNAL

Creating a journal on a free file system may now be done using the following
steps. In this example, da4 is a new SCSI disk:

# gjournal load # gjournal label /dev/da4

At this point, there should be a /dev/da4 device node and a /dev/da4.journal
device node. A file system may now be created on this device:

# newfs -O 2 -J /dev/da4.journal

This command will create a UFS2 file system on the journaled device.

mount the device at the desired point with:

# mount /dev/da4.journal /mnt

Note:

In the case of several slices, a journal will be created for each individual
slice. For instance, if ad4s1 and ad4s2 are both slices, then gjournal will
create ad4s1.journal and ad4s2.journal.

For better performance, the journal may be kept on another disk. In this
configuration, the journal provider or storage device should be listed after
the device to enable journaling on. Journaling may also be enabled on current
file systems by using tunefs. However, always make a backup before attempting
to alter a file system. In most cases, gjournal will fail if it is unable to
create the journal, but this does not protect against data loss incurred as a
result of misusing tunefs.

It is also possible to journal the boot disk of a FreeBSD system. Refer to the
article Implementing UFS Journaling on a Desktop PC for detailed instructions.

ChapterÂ 21.Â File Systems Support

Written by Tom Rhodes.
Table of Contents

21.1. Synopsis
21.2. The Z File System (ZFS)
21.3. LinuxÂ® Filesystems

21.1.Â Synopsis

File systems are an integral part of any operating system. They allow users to
upload and store files, provide access to data, and make hard drives useful.
Different operating systems differ in their native file system. Traditionally,
the native FreeBSD file system has been the Unix File System UFS which has been
modernized as UFS2. Since FreeBSDÂ 7.0, the Z File System ZFS is also available
as a native file system.

In addition to its native file systems, FreeBSD supports a multitude of other
file systems so that data from other operating systems can be accessed locally,
such as data stored on locally attached USB storage devices, flash drives, and
hard disks. This includes support for the LinuxÂ® Extended File System (EXT)
and the MicrosoftÂ® New Technology File System (NTFS).

There are different levels of FreeBSD support for the various file systems.
Some require a kernel module to be loaded and others may require a toolset to
be installed. Some non-native file system support is full read-write while
others are read-only.

After reading this chapter, you will know:

  * The difference between native and supported file systems.

  * Which file systems are supported by FreeBSD.

  * How to enable, configure, access, and make use of non-native file systems.

Before reading this chapter, you should:

  * Understand UNIXÂ® and FreeBSD basics.

  * Be familiar with the basics of kernel configuration and compilation.

  * Feel comfortable installing software in FreeBSD.

  * Have some familiarity with disks, storage, and device names in FreeBSD.

21.2.Â The Z File System (ZFS)

The ZÂ file system, originally developed by Sunâ ¢, is designed to use a pooled
storage method in that space is only used as it is needed for data storage. It
is also designed for maximum data integrity, supporting data snapshots,
multiple copies, and data checksums. It uses a software data replication model,
known as RAID-Z. RAID-Z provides redundancy similar to hardware RAID, but is
designed to prevent data write corruption and to overcome some of the
limitations of hardware RAID.

21.2.1.Â ZFS Tuning

Some of the features provided by ZFS are RAM-intensive, so some tuning may be
required to provide maximum efficiency on systems with limited RAM.

21.2.1.1.Â Memory

At a bare minimum, the total system memory should be at least one gigabyte. The
amount of recommended RAM depends upon the size of the pool and the ZFS
features which are used. A general rule of thumb is 1GB of RAM for every 1TB of
storage. If the deduplication feature is used, a general rule of thumb is 5GB
of RAM per TB of storage to be deduplicated. While some users successfully use
ZFS with less RAM, it is possible that when the system is under heavy load, it
may panic due to memory exhaustion. Further tuning may be required for systems
with less than the recommended RAM requirements.

21.2.1.2.Â Kernel Configuration

Due to the RAM limitations of the i386â ¢ platform, users using ZFS on the i386
â ¢ architecture should add the following option to a custom kernel
configuration file, rebuild the kernel, and reboot:

options KVA_PAGES=512

This option expands the kernel address space, allowing the vm.kvm_size tunable
to be pushed beyond the currently imposed limit of 1Â GB, or the limit of 2Â GB
for PAE. To find the most suitable value for this option, divide the desired
address space in megabytes by four (4). In this example, it is 512 for 2Â GB.

21.2.1.3.Â Loader Tunables

The kmem address space can be increased on all FreeBSD architectures. On a test
system with one gigabyte of physical memory, success was achieved with the
following options added to /boot/loader.conf, and the system restarted:

vm.kmem_size="330M" vm.kmem_size_max="330M" vfs.zfs.arc_max="40M"
vfs.zfs.vdev.cache.size="5M"

For a more detailed list of recommendations for ZFS-related tuning, see http://
wiki.freebsd.org/ZFSTuningGuide.

21.2.2.Â Using ZFS

There is a start up mechanism that allows FreeBSD to mount ZFS pools during
system initialization. To set it, issue the following commands:

# echo 'zfs_enable="YES"' &gt;&gt; /etc/rc.conf # service zfs start

The examples in this section assume three SCSI disks with the device names da0,
da1, and da2. Users of IDE hardware should instead use ad device names.

21.2.2.1.Â Single Disk Pool

To create a simple, non-redundant ZFS pool using a single disk device, use
zpool:

# zpool create example /dev/da0

To view the new pool, review the output of df:

# df Filesystem 1K-blocks Used Avail Capacity Mounted on /dev/ad0s1a 2026030
235230 1628718 13% / devfs 1 1 0 100% /dev /dev/ad0s1d 54098308 1032846
48737598 2% /usr example 17547136 0 17547136 0% /example

This output shows that the example pool has been created and mounted. It is now
accessible as a file system. Files may be created on it and users can browse
it, as seen in the following example:

# cd /example # ls # touch testfile # ls -al total 4 drwxr-xr-x 2 root wheel 3
Aug 29 23:15 . drwxr-xr-x 21 root wheel 512 Aug 29 23:12 .. -rw-r--r-- 1 root
wheel 0 Aug 29 23:15 testfile

However, this pool is not taking advantage of any ZFS features. To create a
dataset on this pool with compression enabled:

# zfs create example/compressed # zfs set compression=gzip example/compressed

The example/compressed dataset is now a ZFS compressed file system. Try copying
some large files to /example/compressed.

Compression can be disabled with:

# zfs set compression=off example/compressed

To unmount a file system, issue the following command and then verify by using
df:

# zfs umount example/compressed # df Filesystem 1K-blocks Used Avail Capacity
Mounted on /dev/ad0s1a 2026030 235232 1628716 13% / devfs 1 1 0 100% /dev /dev/
ad0s1d 54098308 1032864 48737580 2% /usr example 17547008 0 17547008 0% /
example

To re-mount the file system to make it accessible again, and verify with df:

# zfs mount example/compressed # df Filesystem 1K-blocks Used Avail Capacity
Mounted on /dev/ad0s1a 2026030 235234 1628714 13% / devfs 1 1 0 100% /dev /dev/
ad0s1d 54098308 1032864 48737580 2% /usr example 17547008 0 17547008 0% /
example example/compressed 17547008 0 17547008 0% /example/compressed

The pool and file system may also be observed by viewing the output from mount:

# mount /dev/ad0s1a on / (ufs, local) devfs on /dev (devfs, local) /dev/ad0s1d
on /usr (ufs, local, soft-updates) example on /example (zfs, local) example/
data on /example/data (zfs, local) example/compressed on /example/compressed
(zfs, local)

ZFS datasets, after creation, may be used like any file systems. However, many
other features are available which can be set on a per-dataset basis. In the
following example, a new file system, data is created. Important files will be
stored here, the file system is set to keep two copies of each data block:

# zfs create example/data # zfs set copies=2 example/data

It is now possible to see the data and space utilization by issuing df:

# df Filesystem 1K-blocks Used Avail Capacity Mounted on /dev/ad0s1a 2026030
235234 1628714 13% / devfs 1 1 0 100% /dev /dev/ad0s1d 54098308 1032864
48737580 2% /usr example 17547008 0 17547008 0% /example example/compressed
17547008 0 17547008 0% /example/compressed example/data 17547008 0 17547008 0%
/example/data

Notice that each file system on the pool has the same amount of available
space. This is the reason for using df in these examples, to show that the file
systems use only the amount of space they need and all draw from the same pool.
The ZFS file system does away with concepts such as volumes and partitions, and
allows for several file systems to occupy the same pool.

To destroy the file systems and then destroy the pool as they are no longer
needed:

# zfs destroy example/compressed # zfs destroy example/data # zpool destroy
example

21.2.2.2.Â ZFS RAID-Z

There is no way to prevent a disk from failing. One method of avoiding data
loss due to a failed hard disk is to implement RAID. ZFS supports this feature
in its pool design.

To create a RAID-Z pool, issue the following command and specify the disks to
add to the pool:

# zpool create storage raidz da0 da1 da2

Note:

Sunâ ¢ recommends that the amount of devices used in a RAID-Z configuration is
between three and nine. For environments requiring a single pool consisting of
10 disks or more, consider breaking it up into smaller RAID-Z groups. If only
two disks are available and redundancy is a requirement, consider using a ZFS
mirror. Refer to zpool(8) for more details.

This command creates the storage zpool. This may be verified using mount(8) and
df(1). This command makes a new file system in the pool called home:

# zfs create storage/home

It is now possible to enable compression and keep extra copies of directories
and files using the following commands:

# zfs set copies=2 storage/home # zfs set compression=gzip storage/home

To make this the new home directory for users, copy the user data to this
directory, and create the appropriate symbolic links:

# cp -rp /home/* /storage/home # rm -rf /home /usr/home # ln -s /storage/home /
home # ln -s /storage/home /usr/home

Users should now have their data stored on the freshly created /storage/home.
Test by adding a new user and logging in as that user.

Try creating a snapshot which may be rolled back later:

# zfs snapshot storage/home@08-30-08

Note that the snapshot option will only capture a real file system, not a home
directory or a file. The @ character is a delimiter used between the file
system name or the volume name. When a user's home directory gets trashed,
restore it with:

# zfs rollback storage/home@08-30-08

To get a list of all available snapshots, run ls in the file system's .zfs/
snapshot directory. For example, to see the previously taken snapshot:

# ls /storage/home/.zfs/snapshot

It is possible to write a script to perform regular snapshots on user data.
However, over time, snapshots may consume a great deal of disk space. The
previous snapshot may be removed using the following command:

# zfs destroy storage/home@08-30-08

After testing, /storage/home can be made the real /home using this command:

# zfs set mountpoint=/home storage/home

Run df and mount to confirm that the system now treats the file system as the
real /home:

# mount /dev/ad0s1a on / (ufs, local) devfs on /dev (devfs, local) /dev/ad0s1d
on /usr (ufs, local, soft-updates) storage on /storage (zfs, local) storage/
home on /home (zfs, local) # df Filesystem 1K-blocks Used Avail Capacity
Mounted on /dev/ad0s1a 2026030 235240 1628708 13% / devfs 1 1 0 100% /dev /dev/
ad0s1d 54098308 1032826 48737618 2% /usr storage 26320512 0 26320512 0% /
storage storage/home 26320512 0 26320512 0% /home

This completes the RAID-Z configuration. To get status updates about the file
systems created during the nightly periodic(8) runs, issue the following
command:

# echo 'daily_status_zfs_enable="YES"' &gt;&gt; /etc/periodic.conf

21.2.2.3.Â Recovering RAID-Z

Every software RAID has a method of monitoring its state. The status of RAID-Z
devices may be viewed with the following command:

# zpool status -x

If all pools are healthy and everything is normal, the following message will
be returned:

all pools are healthy

If there is an issue, perhaps a disk has gone offline, the pool state will look
similar to:

pool: storage state: DEGRADED status: One or more devices has been taken
offline by the administrator. Sufficient replicas exist for the pool to
continue functioning in a degraded state. action: Online the device using
'zpool online' or replace the device with 'zpool replace'. scrub: none
requested config: NAME STATE READ WRITE CKSUM storage DEGRADED 0 0 0 raidz1
DEGRADED 0 0 0 da0 ONLINE 0 0 0 da1 OFFLINE 0 0 0 da2 ONLINE 0 0 0 errors: No
known data errors

This indicates that the device was previously taken offline by the
administrator using the following command:

# zpool offline storage da1

It is now possible to replace da1 after the system has been powered down. When
the system is back online, the following command may issued to replace the
disk:

# zpool replace storage da1

From here, the status may be checked again, this time without the -x flag to
get state information:

# zpool status storage pool: storage state: ONLINE scrub: resilver completed
with 0 errors on Sat Aug 30 19:44:11 2008 config: NAME STATE READ WRITE CKSUM
storage ONLINE 0 0 0 raidz1 ONLINE 0 0 0 da0 ONLINE 0 0 0 da1 ONLINE 0 0 0 da2
ONLINE 0 0 0 errors: No known data errors

As shown from this example, everything appears to be normal.

21.2.2.4.Â Data Verification

ZFS uses checksums to verify the integrity of stored data. These are enabled
automatically upon creation of file systems and may be disabled using the
following command:

# zfs set checksum=off storage/home

Doing so is not recommended as checksums take very little storage space and are
used to check data integrity using checksum verification in a process is known
as â  scrubbing.â   To verify the data integrity of the storage pool, issue
this command:

# zpool scrub storage

This process may take considerable time depending on the amount of data stored.
It is also very I/O intensive, so much so that only one scrub may be run at any
given time. After the scrub has completed, the status is updated and may be
viewed by issuing a status request:

# zpool status storage pool: storage state: ONLINE scrub: scrub completed with
0 errors on Sat Jan 26 19:57:37 2013 config: NAME STATE READ WRITE CKSUM
storage ONLINE 0 0 0 raidz1 ONLINE 0 0 0 da0 ONLINE 0 0 0 da1 ONLINE 0 0 0 da2
ONLINE 0 0 0 errors: No known data errors

The completion time is displayed and helps to ensure data integrity over a long
period of time.

Refer to zfs(8) and zpool(8) for other ZFS options.

21.2.2.5.Â ZFS Quotas

ZFS supports different types of quotas: the refquota, the general quota, the
user quota, and the group quota. This section explains the basics of each type
and includes some usage instructions.

Quotas limit the amount of space that a dataset and its descendants can
consume, and enforce a limit on the amount of space used by filesystems and
snapshots for the descendants. Quotas are useful to limit the amount of space a
particular user can use.

Note:

Quotas cannot be set on volumes, as the volsize property acts as an implicit
quota.

The refquota=size limits the amount of space a dataset can consume by enforcing
a hard limit on the space used. However, this hard limit does not include space
used by descendants, such as file systems or snapshots.

To enforce a general quota of 10Â GB for storage/home/bob, use the following:

# zfs set quota=10G storage/home/bob

User quotas limit the amount of space that can be used by the specified user.
The general format is userquota@user=size, and the user's name must be in one
of the following formats:

  * POSIX compatible name such as joe.

  * POSIX numeric ID such as 789.

  * SID name such as joe.bloggs@example.com.

  * SID numeric ID such as S-1-123-456-789.

For example, to enforce a quota of 50Â GB for a user named joe, use the
following:

# zfs set userquota@joe=50G

To remove the quota or make sure that one is not set, instead use:

# zfs set userquota@joe=none

User quota properties are not displayed by zfs get all. Non-root users can only
see their own quotas unless they have been granted the userquota privilege.
Users with this privilege are able to view and set everyone's quota.

The group quota limits the amount of space that a specified group can consume.
The general format is groupquota@group=size.

To set the quota for the group firstgroup to 50Â GB, use:

# zfs set groupquota@firstgroup=50G

To remove the quota for the group firstgroup, or to make sure that one is not
set, instead use:

# zfs set groupquota@firstgroup=none

As with the user quota property, non-root users can only see the quotas
associated with the groups that they belong to. However, root or a user with
the groupquota privilege can view and set all quotas for all groups.

To display the amount of space consumed by each user on the specified
filesystem or snapshot, along with any specified quotas, use zfs userspace. For
group information, use zfs groupspace. For more information about supported
options or how to display only specific options, refer to zfs(1).

Users with sufficient privileges and root can list the quota for storage/home/
bob using:

# zfs get quota storage/home/bob

21.2.2.6.Â ZFS Reservations

ZFS supports two types of space reservations. This section explains the basics
of each and includes some usage instructions.

The reservation property makes it possible to reserve a minimum amount of space
guaranteed for a dataset and its descendants. This means that if a 10Â GB
reservation is set on storage/home/bob, if disk space gets low, at least 10Â GB
of space is reserved for this dataset. The refreservation property sets or
indicates the minimum amount of space guaranteed to a dataset excluding
descendants, such as snapshots. As an example, if a snapshot was taken of
storage/home/bob, enough disk space would have to exist outside of the
refreservation amount for the operation to succeed because descendants of the
main data set are not counted by the refreservation amount and so do not
encroach on the space set.

Reservations of any sort are useful in many situations, such as planning and
testing the suitability of disk space allocation in a new system, or ensuring
that enough space is available on file systems for system recovery procedures
and files.

The general format of the reservation property is reservation=size, so to set a
reservation of 10Â GB on storage/home/bob, use:

# zfs set reservation=10G storage/home/bob

To make sure that no reservation is set, or to remove a reservation, use:

# zfs set reservation=none storage/home/bob

The same principle can be applied to the refreservation property for setting a
refreservation, with the general format refreservation=size.

To check if any reservations or refreservations exist on storage/home/bob,
execute one of the following commands:

# zfs get reservation storage/home/bob # zfs get refreservation storage/home/
bob

21.3.Â LinuxÂ® Filesystems

This section describes some of the LinuxÂ® filesystems supported by FreeBSD.

21.3.1.Â ext2

The ext2fs(5) file system kernel implementation has been available since
FreeBSDÂ 2.2. In FreeBSDÂ 8.x and earlier, the code is licensed under the GPL.
Since FreeBSDÂ 9.0, the code has been rewritten and is now BSD licensed.

The ext2fs(5) driver allows the FreeBSD kernel to both read and write to ext2
file systems.

To access an ext2 file system, first load the kernel loadable module:

# kldload ext2fs

Then, to mount an ext2fs(5) volume located on /dev/ad1s1:

# mount -t ext2fs /dev/ad1s1 /mnt

21.3.2.Â XFS

XFS was originally written by SGI for the IRIX operating system and was then
ported to LinuxÂ® and released under the GPL. See this page for more details.
The FreeBSD port was started by Russel Cattelan, Alexander Kabaev &lt;
kan@FreeBSD.org&gt;, and Craig Rodrigues &lt;rodrigc@FreeBSD.org&gt;.

To load XFS as a kernel-loadable module:

# kldload xfs

The xfs(5) driver lets the FreeBSD kernel access XFS filesystems. However, only
read-only access is supported and writing to a volume is not possible.

To mount a xfs(5) volume located on /dev/ad1s1:

# mount -t xfs /dev/ad1s1 /mnt

The sysutils/xfsprogs port includes the mkfs.xfs which enables the creation of 
XFS filesystems, plus utilities for analyzing and repairing them.

The -p flag to mkfs.xfs can be used to create an xfs(5) filesystem which is
populated with files and other metadata. This can be used to quickly create a
read-only filesystem which can be tested on FreeBSD.

21.3.3.Â ReiserFS

The Reiser file system, ReiserFS, was ported to FreeBSD by Jean-SÃ©bastien PÃ©
dron &lt;dumbbell@FreeBSD.org&gt;, and has been released under the GPL .

The ReiserFS driver permits the FreeBSD kernel to access ReiserFS file systems
and read their contents, but not write to them.

First, the kernel-loadable module needs to be loaded:

# kldload reiserfs

Then, to mount a ReiserFS volume located on /dev/ad1s1:

# mount -t reiserfs /dev/ad1s1 /mnt

ChapterÂ 22.Â The vinum Volume Manager

Originally written by Greg Lehey.
Table of Contents

22.1. Synopsis
22.2. Access Bottlenecks
22.3. Data Integrity
22.4. vinum Objects
22.5. Some Examples
22.6. Object Naming
22.7. Configuring vinum
22.8. Using vinum for the Root File System

22.1.Â Synopsis

No matter the type of disks, there are always potential problems. The disks can
be too small, too slow, or too unreliable to meet the system's requirements.
While disks are getting bigger, so are data storage requirements. Often a file
system is needed that is bigger than a disk's capacity. Various solutions to
these problems have been proposed and implemented.

One method is through the use of multiple, and sometimes redundant, disks. In
addition to supporting various cards and controllers for hardware Redundant
Array of Independent Disks RAID systems, the base FreeBSD system includes the
vinum volume manager, a block device driver that implements virtual disk drives
and addresses these three problems. vinum provides more flexibility,
performance, and reliability than traditional disk storage and implements RAID
-0, RAID-1, and RAID-5 models, both individually and in combination.

This chapter provides an overview of potential problems with traditional disk
storage, and an introduction to the vinum volume manager.

Note:

Starting with FreeBSDÂ 5, vinum has been rewritten in order to fit into the
GEOM architecture, while retaining the original ideas, terminology, and on-disk
metadata. This rewrite is called gvinum (for GEOM vinum). While this chapter
uses the term vinum, any command invocations should be performed with gvinum.
The name of the kernel module has changed from the original vinum.ko to
geom_vinum.ko, and all device nodes reside under /dev/gvinum instead of /dev/
vinum. As of FreeBSDÂ 6, the original vinum implementation is no longer
available in the code base.

22.2.Â Access Bottlenecks

Modern systems frequently need to access data in a highly concurrent manner.
For example, large FTP or HTTP servers can maintain thousands of concurrent
sessions and have multiple 100Â Mbit/s connections to the outside world, well
beyond the sustained transfer rate of most disks.

Current disk drives can transfer data sequentially at up to 70Â MB/s, but this
value is of little importance in an environment where many independent
processes access a drive, and where they may achieve only a fraction of these
values. In such cases, it is more interesting to view the problem from the
viewpoint of the disk subsystem. The important parameter is the load that a
transfer places on the subsystem, or the time for which a transfer occupies the
drives involved in the transfer.

In any disk transfer, the drive must first position the heads, wait for the
first sector to pass under the read head, and then perform the transfer. These
actions can be considered to be atomic as it does not make any sense to
interrupt them.

Consider a typical transfer of about 10Â kB: the current generation of
high-performance disks can position the heads in an average of 3.5Â ms. The
fastest drives spin at 15,000Â rpm, so the average rotational latency (half a
revolution) is 2Â ms. At 70Â MB/s, the transfer itself takes about 150Â ÎŒs,
almost nothing compared to the positioning time. In such a case, the effective
transfer rate drops to a little over 1Â MB/s and is clearly highly dependent on
the transfer size.

The traditional and obvious solution to this bottleneck is â  more spindlesâ  :
rather than using one large disk, use several smaller disks with the same
aggregate storage space. Each disk is capable of positioning and transferring
independently, so the effective throughput increases by a factor close to the
number of disks used.

The actual throughput improvement is smaller than the number of disks involved.
Although each drive is capable of transferring in parallel, there is no way to
ensure that the requests are evenly distributed across the drives. Inevitably
the load on one drive will be higher than on another.

The evenness of the load on the disks is strongly dependent on the way the data
is shared across the drives. In the following discussion, it is convenient to
think of the disk storage as a large number of data sectors which are
addressable by number, rather like the pages in a book. The most obvious method
is to divide the virtual disk into groups of consecutive sectors the size of
the individual physical disks and store them in this manner, rather like taking
a large book and tearing it into smaller sections. This method is called 
concatenation and has the advantage that the disks are not required to have any
specific size relationships. It works well when the access to the virtual disk
is spread evenly about its address space. When access is concentrated on a
smaller area, the improvement is less marked. FigureÂ 22.1, â  Concatenated
Organizationâ   illustrates the sequence in which storage units are allocated
in a concatenated organization.

FigureÂ 22.1.Â Concatenated Organization
Concatenated Organization


An alternative mapping is to divide the address space into smaller, equal-sized
components and store them sequentially on different devices. For example, the
first 256 sectors may be stored on the first disk, the next 256 sectors on the
next disk and so on. After filling the last disk, the process repeats until the
disks are full. This mapping is called striping or RAID-0.

RAID offers various forms of fault tolerance, though RAID-0 is somewhat
misleading as it provides no redundancy. Striping requires somewhat more effort
to locate the data, and it can cause additional I/O load where a transfer is
spread over multiple disks, but it can also provide a more constant load across
the disks. FigureÂ 22.2, â  Striped Organizationâ   illustrates the sequence in
which storage units are allocated in a striped organization.

FigureÂ 22.2.Â Striped Organization
Striped Organization


22.3.Â Data Integrity

The final problem with disks is that they are unreliable. Although reliability
has increased tremendously over the last few years, disk drives are still the
most likely core component of a server to fail. When they do, the results can
be catastrophic and replacing a failed disk drive and restoring data can result
in server downtime.

One approach to this problem is mirroring, or RAID-1, which keeps two copies of
the data on different physical hardware. Any write to the volume writes to both
disks; a read can be satisfied from either, so if one drive fails, the data is
still available on the other drive.

Mirroring has two problems:

  * It requires twice as much disk storage as a non-redundant solution.

  * Writes must be performed to both drives, so they take up twice the
    bandwidth of a non-mirrored volume. Reads do not suffer from a performance
    penalty and can even be faster.

An alternative solution is parity, implemented in RAID levels 2, 3, 4 and 5. Of
these, RAID-5 is the most interesting. As implemented in vinum, it is a variant
on a striped organization which dedicates one block of each stripe to parity
one of the other blocks. As implemented by vinum, a RAID-5 plex is similar to a
striped plex, except that it implements RAID-5 by including a parity block in
each stripe. As required by RAID-5, the location of this parity block changes
from one stripe to the next. The numbers in the data blocks indicate the
relative block numbers.

FigureÂ 22.3.Â RAID-5 Organization
RAID-5 Organization


Compared to mirroring, RAID-5 has the advantage of requiring significantly less
storage space. Read access is similar to that of striped organizations, but
write access is significantly slower, approximately 25% of the read
performance. If one drive fails, the array can continue to operate in degraded
mode where a read from one of the remaining accessible drives continues
normally, but a read from the failed drive is recalculated from the
corresponding block from all the remaining drives.

22.4.Â vinum Objects

In order to address these problems, vinum implements a four-level hierarchy of
objects:

  * The most visible object is the virtual disk, called a volume. Volumes have
    essentially the same properties as a UNIXÂ® disk drive, though there are
    some minor differences. For one, they have no size limitations.

  * Volumes are composed of plexes, each of which represent the total address
    space of a volume. This level in the hierarchy provides redundancy. Think
    of plexes as individual disks in a mirrored array, each containing the same
    data.

  * Since vinum exists within the UNIXÂ® disk storage framework, it would be
    possible to use UNIXÂ® partitions as the building block for multi-disk
    plexes. In fact, this turns out to be too inflexible as UNIXÂ® disks can
    have only a limited number of partitions. Instead, vinum subdivides a
    single UNIXÂ® partition, the drive, into contiguous areas called subdisks,
    which are used as building blocks for plexes.

  * Subdisks reside on vinum drives, currently UNIXÂ® partitions. vinum drives
    can contain any number of subdisks. With the exception of a small area at
    the beginning of the drive, which is used for storing configuration and
    state information, the entire drive is available for data storage.

The following sections describe the way these objects provide the functionality
required of vinum.

22.4.1.Â Volume Size Considerations

Plexes can include multiple subdisks spread over all drives in the vinum
configuration. As a result, the size of an individual drive does not limit the
size of a plex or a volume.

22.4.2.Â Redundant Data Storage

vinum implements mirroring by attaching multiple plexes to a volume. Each plex
is a representation of the data in a volume. A volume may contain between one
and eight plexes.

Although a plex represents the complete data of a volume, it is possible for
parts of the representation to be physically missing, either by design (by not
defining a subdisk for parts of the plex) or by accident (as a result of the
failure of a drive). As long as at least one plex can provide the data for the
complete address range of the volume, the volume is fully functional.

22.4.3.Â Which Plex Organization?

vinum implements both concatenation and striping at the plex level:

  * A concatenated plex uses the address space of each subdisk in turn.
    Concatenated plexes are the most flexible as they can contain any number of
    subdisks, and the subdisks may be of different length. The plex may be
    extended by adding additional subdisks. They require less CPU time than
    striped plexes, though the difference in CPU overhead is not measurable. On
    the other hand, they are most susceptible to hot spots, where one disk is
    very active and others are idle.

  * A striped plex stripes the data across each subdisk. The subdisks must all
    be the same size and there must be at least two subdisks in order to
    distinguish it from a concatenated plex. The greatest advantage of striped
    plexes is that they reduce hot spots. By choosing an optimum sized stripe,
    about 256Â kB, the load can be evened out on the component drives.
    Extending a plex by adding new subdisks is so complicated that vinum does
    not implement it.

TableÂ 22.1, â  vinum Plex Organizationsâ   summarizes the advantages and
disadvantages of each plex organization.

TableÂ 22.1.Â vinum Plex Organizations

             Minimum  Can add   Must be
 Plex type   subdisks subdisks   equal                Application
                                 size
                                         Large data storage with maximum
concatenated 1        yes      no        placement flexibility and moderate
                                         performance
striped      2        no       yes       High performance in combination with
                                         highly concurrent access


22.5.Â Some Examples

vinum maintains a configuration database which describes the objects known to
an individual system. Initially, the user creates the configuration database
from one or more configuration files using gvinum(8). vinum stores a copy of
its configuration database on each disk device under its control. This database
is updated on each state change, so that a restart accurately restores the
state of each vinum object.

22.5.1.Â The Configuration File

The configuration file describes individual vinum objects. The definition of a
simple volume might be:

drive a device /dev/da3h volume myvol plex org concat sd length 512m drive a

This file describes four vinum objects:

  * The drive line describes a disk partition (drive) and its location relative
    to the underlying hardware. It is given the symbolic name a. This
    separation of symbolic names from device names allows disks to be moved
    from one location to another without confusion.

  * The volume line describes a volume. The only required attribute is the
    name, in this case myvol.

  * The plex line defines a plex. The only required parameter is the
    organization, in this case concat. No name is necessary as the system
    automatically generates a name from the volume name by adding the suffix .p
    x, where x is the number of the plex in the volume. Thus this plex will be
    called myvol.p0.

  * The sd line describes a subdisk. The minimum specifications are the name of
    a drive on which to store it, and the length of the subdisk. No name is
    necessary as the system automatically assigns names derived from the plex
    name by adding the suffix .sx, where x is the number of the subdisk in the
    plex. Thus vinum gives this subdisk the name myvol.p0.s0.

After processing this file, gvinum(8) produces the following output:

# gvinum -&gt; create config1 Configuration summary Drives: 1 (4 configured)
Volumes: 1 (4 configured) Plexes: 1 (8 configured) Subdisks: 1 (16 configured)
D a State: up Device /dev/da3h Avail: 2061/2573 MB (80%) V myvol State: up
Plexes: 1 Size: 512 MB P myvol.p0 C State: up Subdisks: 1 Size: 512 MB S
myvol.p0.s0 State: up PO: 0 B Size: 512 MB

This output shows the brief listing format of gvinum(8). It is represented
graphically in FigureÂ 22.4, â  A Simple vinum Volumeâ  .

FigureÂ 22.4.Â A Simple vinum Volume
A Simple vinum Volume


This figure, and the ones which follow, represent a volume, which contains the
plexes, which in turn contains the subdisks. In this example, the volume
contains one plex, and the plex contains one subdisk.

This particular volume has no specific advantage over a conventional disk
partition. It contains a single plex, so it is not redundant. The plex contains
a single subdisk, so there is no difference in storage allocation from a
conventional disk partition. The following sections illustrate various more
interesting configuration methods.

22.5.2.Â Increased Resilience: Mirroring

The resilience of a volume can be increased by mirroring. When laying out a
mirrored volume, it is important to ensure that the subdisks of each plex are
on different drives, so that a drive failure will not take down both plexes.
The following configuration mirrors a volume:

drive b device /dev/da4h volume mirror plex org concat sd length 512m drive a
plex org concat sd length 512m drive b

In this example, it was not necessary to specify a definition of drive a again,
since vinum keeps track of all objects in its configuration database. After
processing this definition, the configuration looks like:

Drives: 2 (4 configured) Volumes: 2 (4 configured) Plexes: 3 (8 configured)
Subdisks: 3 (16 configured) D a State: up Device /dev/da3h Avail: 1549/2573 MB
(60%) D b State: up Device /dev/da4h Avail: 2061/2573 MB (80%) V myvol State:
up Plexes: 1 Size: 512 MB V mirror State: up Plexes: 2 Size: 512 MB P myvol.p0
C State: up Subdisks: 1 Size: 512 MB P mirror.p0 C State: up Subdisks: 1 Size:
512 MB P mirror.p1 C State: initializing Subdisks: 1 Size: 512 MB S myvol.p0.s0
State: up PO: 0 B Size: 512 MB S mirror.p0.s0 State: up PO: 0 B Size: 512 MB S
mirror.p1.s0 State: empty PO: 0 B Size: 512 MB

FigureÂ 22.5, â  A Mirrored vinum Volumeâ   shows the structure graphically.

FigureÂ 22.5.Â A Mirrored vinum Volume
A Mirrored vinum Volume


In this example, each plex contains the full 512Â MB of address space. As in
the previous example, each plex contains only a single subdisk.

22.5.3.Â Optimizing Performance

The mirrored volume in the previous example is more resistant to failure than
an unmirrored volume, but its performance is less as each write to the volume
requires a write to both drives, using up a greater proportion of the total
disk bandwidth. Performance considerations demand a different approach: instead
of mirroring, the data is striped across as many disk drives as possible. The
following configuration shows a volume with a plex striped across four disk
drives:

drive c device /dev/da5h drive d device /dev/da6h volume stripe plex org
striped 512k sd length 128m drive a sd length 128m drive b sd length 128m drive
c sd length 128m drive d

As before, it is not necessary to define the drives which are already known to
vinum. After processing this definition, the configuration looks like:

Drives: 4 (4 configured) Volumes: 3 (4 configured) Plexes: 4 (8 configured)
Subdisks: 7 (16 configured) D a State: up Device /dev/da3h Avail: 1421/2573 MB
(55%) D b State: up Device /dev/da4h Avail: 1933/2573 MB (75%) D c State: up
Device /dev/da5h Avail: 2445/2573 MB (95%) D d State: up Device /dev/da6h
Avail: 2445/2573 MB (95%) V myvol State: up Plexes: 1 Size: 512 MB V mirror
State: up Plexes: 2 Size: 512 MB V striped State: up Plexes: 1 Size: 512 MB P
myvol.p0 C State: up Subdisks: 1 Size: 512 MB P mirror.p0 C State: up Subdisks:
1 Size: 512 MB P mirror.p1 C State: initializing Subdisks: 1 Size: 512 MB P
striped.p1 State: up Subdisks: 1 Size: 512 MB S myvol.p0.s0 State: up PO: 0 B
Size: 512 MB S mirror.p0.s0 State: up PO: 0 B Size: 512 MB S mirror.p1.s0
State: empty PO: 0 B Size: 512 MB S striped.p0.s0 State: up PO: 0 B Size: 128
MB S striped.p0.s1 State: up PO: 512 kB Size: 128 MB S striped.p0.s2 State: up
PO: 1024 kB Size: 128 MB S striped.p0.s3 State: up PO: 1536 kB Size: 128 MB

FigureÂ 22.6.Â A Striped vinum Volume
A Striped vinum Volume


This volume is represented in FigureÂ 22.6, â  A Striped vinum Volumeâ  . The
darkness of the stripes indicates the position within the plex address space,
where the lightest stripes come first and the darkest last.

22.5.4.Â Resilience and Performance

With sufficient hardware, it is possible to build volumes which show both
increased resilience and increased performance compared to standard UNIXÂ®
partitions. A typical configuration file might be:

volume raid10 plex org striped 512k sd length 102480k drive a sd length 102480k
drive b sd length 102480k drive c sd length 102480k drive d sd length 102480k
drive e plex org striped 512k sd length 102480k drive c sd length 102480k drive
d sd length 102480k drive e sd length 102480k drive a sd length 102480k drive b

The subdisks of the second plex are offset by two drives from those of the
first plex. This helps to ensure that writes do not go to the same subdisks
even if a transfer goes over two drives.

FigureÂ 22.7, â  A Mirrored, Striped vinum Volumeâ   represents the structure
of this volume.

FigureÂ 22.7.Â A Mirrored, Striped vinum Volume
A Mirrored, Striped vinum Volume


22.6.Â Object Naming

vinum assigns default names to plexes and subdisks, although they may be
overridden. Overriding the default names is not recommended as it does not
bring a significant advantage and it can cause confusion.

Names may contain any non-blank character, but it is recommended to restrict
them to letters, digits and the underscore characters. The names of volumes,
plexes, and subdisks may be up to 64 characters long, and the names of drives
may be up to 32 characters long.

vinum objects are assigned device nodes in the hierarchy /dev/gvinum. The
configuration shown above would cause vinum to create the following device
nodes:

  * Device entries for each volume. These are the main devices used by vinum.
    The configuration above would include the devices /dev/gvinum/myvol, /dev/
    gvinum/mirror, /dev/gvinum/striped, /dev/gvinum/raid5 and /dev/gvinum/
    raid10.

  * All volumes get direct entries under /dev/gvinum/.

  * The directories /dev/gvinum/plex, and /dev/gvinum/sd, which contain device
    nodes for each plex and for each subdisk, respectively.

For example, consider the following configuration file:

drive drive1 device /dev/sd1h drive drive2 device /dev/sd2h drive drive3 device
/dev/sd3h drive drive4 device /dev/sd4h volume s64 setupstate plex org striped
64k sd length 100m drive drive1 sd length 100m drive drive2 sd length 100m
drive drive3 sd length 100m drive drive4

After processing this file, gvinum(8) creates the following structure in /dev/
gvinum:

drwxr-xr-x 2 root wheel 512 Apr 13 16:46 plex crwxr-xr-- 1 root wheel 91, 2 Apr
13 16:46 s64 drwxr-xr-x 2 root wheel 512 Apr 13 16:46 sd /dev/vinum/plex: total
0 crwxr-xr-- 1 root wheel 25, 0x10000002 Apr 13 16:46 s64.p0 /dev/vinum/sd:
total 0 crwxr-xr-- 1 root wheel 91, 0x20000002 Apr 13 16:46 s64.p0.s0
crwxr-xr-- 1 root wheel 91, 0x20100002 Apr 13 16:46 s64.p0.s1 crwxr-xr-- 1 root
wheel 91, 0x20200002 Apr 13 16:46 s64.p0.s2 crwxr-xr-- 1 root wheel 91,
0x20300002 Apr 13 16:46 s64.p0.s3

Although it is recommended that plexes and subdisks should not be allocated
specific names, vinum drives must be named. This makes it possible to move a
drive to a different location and still recognize it automatically. Drive names
may be up to 32 characters long.

22.6.1.Â Creating File Systems

Volumes appear to the system to be identical to disks, with one exception.
Unlike UNIXÂ® drives, vinum does not partition volumes, which thus do not
contain a partition table. This has required modification to some disk
utilities, notably newfs(8), so that it does not try to interpret the last
letter of a vinum volume name as a partition identifier. For example, a disk
drive may have a name like /dev/ad0a or /dev/da2h. These names represent the
first partition (a) on the first (0) IDE disk (ad) and the eighth partition (h)
on the third (2) SCSI disk (da) respectively. By contrast, a vinum volume might
be called /dev/gvinum/concat, which has no relationship with a partition name.

In order to create a file system on this volume, use newfs(8):

# newfs /dev/gvinum/concat

22.7.Â Configuring vinum

The GENERIC kernel does not contain vinum. It is possible to build a custom
kernel which includes vinum, but this is not recommended. The standard way to
start vinum is as a kernel module. kldload(8) is not needed because when gvinum
(8) starts, it checks whether the module has been loaded, and if it is not, it
loads it automatically.

22.7.1.Â Startup

vinum stores configuration information on the disk slices in essentially the
same form as in the configuration files. When reading from the configuration
database, vinum recognizes a number of keywords which are not allowed in the
configuration files. For example, a disk configuration might contain the
following text:

volume myvol state up volume bigraid state down plex name myvol.p0 state up org
concat vol myvol plex name myvol.p1 state up org concat vol myvol plex name
myvol.p2 state init org striped 512b vol myvol plex name bigraid.p0 state
initializing org raid5 512b vol bigraid sd name myvol.p0.s0 drive a plex
myvol.p0 state up len 1048576b driveoffset 265b plexoffset 0b sd name
myvol.p0.s1 drive b plex myvol.p0 state up len 1048576b driveoffset 265b
plexoffset 1048576b sd name myvol.p1.s0 drive c plex myvol.p1 state up len
1048576b driveoffset 265b plexoffset 0b sd name myvol.p1.s1 drive d plex
myvol.p1 state up len 1048576b driveoffset 265b plexoffset 1048576b sd name
myvol.p2.s0 drive a plex myvol.p2 state init len 524288b driveoffset 1048841b
plexoffset 0b sd name myvol.p2.s1 drive b plex myvol.p2 state init len 524288b
driveoffset 1048841b plexoffset 524288b sd name myvol.p2.s2 drive c plex
myvol.p2 state init len 524288b driveoffset 1048841b plexoffset 1048576b sd
name myvol.p2.s3 drive d plex myvol.p2 state init len 524288b driveoffset
1048841b plexoffset 1572864b sd name bigraid.p0.s0 drive a plex bigraid.p0
state initializing len 4194304b driveoff set 1573129b plexoffset 0b sd name
bigraid.p0.s1 drive b plex bigraid.p0 state initializing len 4194304b driveoff
set 1573129b plexoffset 4194304b sd name bigraid.p0.s2 drive c plex bigraid.p0
state initializing len 4194304b driveoff set 1573129b plexoffset 8388608b sd
name bigraid.p0.s3 drive d plex bigraid.p0 state initializing len 4194304b
driveoff set 1573129b plexoffset 12582912b sd name bigraid.p0.s4 drive e plex
bigraid.p0 state initializing len 4194304b driveoff set 1573129b plexoffset
16777216b

The obvious differences here are the presence of explicit location information
and naming, both of which are allowed but discouraged, and the information on
the states. vinum does not store information about drives in the configuration
information. It finds the drives by scanning the configured disk drives for
partitions with a vinum label. This enables vinum to identify drives correctly
even if they have been assigned different UNIXÂ® drive IDs.

22.7.1.1.Â Automatic Startup

Gvinum always features an automatic startup once the kernel module is loaded,
via loader.conf(5). To load the Gvinum module at boot time, add geom_vinum_load
="YES" to /boot/loader.conf.

When vinum is started with gvinum start, vinum reads the configuration database
from one of the vinum drives. Under normal circumstances, each drive contains
an identical copy of the configuration database, so it does not matter which
drive is read. After a crash, however, vinum must determine which drive was
updated most recently and read the configuration from this drive. It then
updates the configuration, if necessary, from progressively older drives.

22.8.Â Using vinum for the Root File System

For a machine that has fully-mirrored file systems using vinum, it is desirable
to also mirror the root file system. Setting up such a configuration is less
trivial than mirroring an arbitrary file system because:

  * The root file system must be available very early during the boot process,
    so the vinum infrastructure must already be available at this time.

  * The volume containing the root file system also contains the system
    bootstrap and the kernel. These must be read using the host system's native
    utilities, such as the BIOS, which often cannot be taught about the details
    of vinum.

In the following sections, the term â  root volumeâ   is generally used to
describe the vinum volume that contains the root file system.

22.8.1.Â Starting up vinum Early Enough for the Root File System

vinum must be available early in the system boot as loader(8) must be able to
load the vinum kernel module before starting the kernel. This can be
accomplished by putting this line in /boot/loader.conf:

geom_vinum_load="YES"

22.8.2.Â Making a vinum-based Root Volume Accessible to the Bootstrap

The current FreeBSD bootstrap is only 7.5 KB of code and does not understand
the internal vinum structures. This means that it cannot parse the vinum
configuration data or figure out the elements of a boot volume. Thus, some
workarounds are necessary to provide the bootstrap code with the illusion of a
standard a partition that contains the root file system.

For this to be possible, the following requirements must be met for the root
volume:

  * The root volume must not be a stripe or RAID-5.

  * The root volume must not contain more than one concatenated subdisk per
    plex.

Note that it is desirable and possible to use multiple plexes, each containing
one replica of the root file system. The bootstrap process will only use one
replica for finding the bootstrap and all boot files, until the kernel mounts
the root file system. Each single subdisk within these plexes needs its own a
partition illusion, for the respective device to be bootable. It is not
strictly needed that each of these faked a partitions is located at the same
offset within its device, compared with other devices containing plexes of the
root volume. However, it is probably a good idea to create the vinum volumes
that way so the resulting mirrored devices are symmetric, to avoid confusion.

In order to set up these a partitions for each device containing part of the
root volume, the following is required:

 1. The location, offset from the beginning of the device, and size of this
    device's subdisk that is part of the root volume needs to be examined,
    using the command:

    # gvinum l -rv root

    vinum offsets and sizes are measured in bytes. They must be divided by 512
    in order to obtain the block numbers that are to be used by bsdlabel.

 2. Run this command for each device that participates in the root volume:

    # bsdlabel -e devname

    devname must be either the name of the disk, like da0 for disks without a
    slice table, or the name of the slice, like ad0s1.

    If there is already an a partition on the device from a pre-vinum root file
    system, it should be renamed to something else so that it remains
    accessible (just in case), but will no longer be used by default to
    bootstrap the system. A currently mounted root file system cannot be
    renamed, so this must be executed either when being booted from a â  Fixitâ
       media, or in a two-step process where, in a mirror, the disk that is not
    been currently booted is manipulated first.

    The offset of the vinum partition on this device (if any) must be added to
    the offset of the respective root volume subdisk on this device. The
    resulting value will become the offset value for the new a partition. The
    size value for this partition can be taken verbatim from the calculation
    above. The fstype should be 4.2BSD. The fsize, bsize, and cpg values should
    be chosen to match the actual file system, though they are fairly
    unimportant within this context.

    That way, a new a partition will be established that overlaps the vinum
    partition on this device. bsdlabel will only allow for this overlap if the
    vinum partition has properly been marked using the vinum fstype.

 3. A faked a partition now exists on each device that has one replica of the
    root volume. It is highly recommendable to verify the result using a
    command like:

    # fsck -n /dev/devnamea

It should be remembered that all files containing control information must be
relative to the root file system in the vinum volume which, when setting up a
new vinum root volume, might not match the root file system that is currently
active. So in particular, /etc/fstab and /boot/loader.conf need to be taken
care of.

At next reboot, the bootstrap should figure out the appropriate control
information from the new vinum-based root file system, and act accordingly. At
the end of the kernel initialization process, after all devices have been
announced, the prominent notice that shows the success of this setup is a
message like:

Mounting root from ufs:/dev/gvinum/root

22.8.3.Â Example of a vinum-based Root Setup

After the vinum root volume has been set up, the output of gvinum l -rv root
could look like:

... Subdisk root.p0.s0: Size: 125829120 bytes (120 MB) State: up Plex root.p0
at offset 0 (0 B) Drive disk0 (/dev/da0h) at offset 135680 (132 kB) Subdisk
root.p1.s0: Size: 125829120 bytes (120 MB) State: up Plex root.p1 at offset 0
(0 B) Drive disk1 (/dev/da1h) at offset 135680 (132 kB)

The values to note are 135680 for the offset, relative to partition /dev/da0h.
This translates to 265 512-byte disk blocks in bsdlabel's terms. Likewise, the
size of this root volume is 245760 512-byte blocks. /dev/da1h, containing the
second replica of this root volume, has a symmetric setup.

The bsdlabel for these devices might look like:

... 8 partitions: # size offset fstype [fsize bsize bps/cpg] a: 245760 281
4.2BSD 2048 16384 0 # (Cyl. 0*- 15*) c: 71771688 0 unused 0 0 # (Cyl. 0 -
4467*) h: 71771672 16 vinum # (Cyl. 0*- 4467*)

It can be observed that the size parameter for the faked a partition matches
the value outlined above, while the offset parameter is the sum of the offset
within the vinum partition h, and the offset of this partition within the
device or slice. This is a typical setup that is necessary to avoid the problem
described in SectionÂ 22.8.4.3, â  Nothing Boots, the Bootstrap Panicsâ  . The
entire a partition is completely within the h partition containing all the
vinum data for this device.

In the above example, the entire device is dedicated to vinum and there is no
leftover pre-vinum root partition.

22.8.4.Â Troubleshooting

The following list contains a few known pitfalls and solutions.

22.8.4.1.Â System Bootstrap Loads, but System Does Not Boot

If for any reason the system does not continue to boot, the bootstrap can be
interrupted by pressing space at the 10-seconds warning. The loader variable
vinum.autostart can be examined by typing show and manipulated using set or
unset.

If the vinum kernel module was not yet in the list of modules to load
automatically, type load geom_vinum.

When ready, the boot process can be continued by typing boot -as which -as
requests the kernel to ask for the root file system to mount (-a) and make the
boot process stop in single-user mode (-s), where the root file system is
mounted read-only. That way, even if only one plex of a multi-plex volume has
been mounted, no data inconsistency between plexes is being risked.

At the prompt asking for a root file system to mount, any device that contains
a valid root file system can be entered. If /etc/fstab is set up correctly, the
default should be something like ufs:/dev/gvinum/root. A typical alternate
choice would be something like ufs:da0d which could be a hypothetical partition
containing the pre-vinum root file system. Care should be taken if one of the
alias a partitions is entered here, that it actually references the subdisks of
the vinum root device, because in a mirrored setup, this would only mount one
piece of a mirrored root device. If this file system is to be mounted
read-write later on, it is necessary to remove the other plex(es) of the vinum
root volume since these plexes would otherwise carry inconsistent data.

22.8.4.2.Â Only Primary Bootstrap Loads

If /boot/loader fails to load, but the primary bootstrap still loads (visible
by a single dash in the left column of the screen right after the boot process
starts), an attempt can be made to interrupt the primary bootstrap by pressing 
space. This will make the bootstrap stop in stage two. An attempt can be made
here to boot off an alternate partition, like the partition containing the
previous root file system that has been moved away from a.

22.8.4.3.Â Nothing Boots, the Bootstrap Panics

This situation will happen if the bootstrap had been destroyed by the vinum
installation. Unfortunately, vinum accidentally leaves only 4 KB at the
beginning of its partition free before starting to write its vinum header
information. However, the stage one and two bootstraps plus the bsdlabel
require 8 KB. So if a vinum partition was started at offset 0 within a slice or
disk that was meant to be bootable, the vinum setup will trash the bootstrap.

Similarly, if the above situation has been recovered, by booting from a â  
Fixitâ   media, and the bootstrap has been re-installed using bsdlabel -B as
described in SectionÂ 13.3.2, â  Stage One, /boot/boot1, and Stage Two, /boot/
boot2â  , the bootstrap will trash the vinum header, and vinum will no longer
find its disk(s). Though no actual vinum configuration data or data in vinum
volumes will be trashed, and it would be possible to recover all the data by
entering exactly the same vinum configuration data again, the situation is hard
to fix. It is necessary to move the entire vinum partition by at least 4 KB, in
order to have the vinum header and the system bootstrap no longer collide.

ChapterÂ 23.Â Virtualization

Contributed by Murray Stokely.
Table of Contents

23.1. Synopsis
23.2. FreeBSD as a Guest OS
23.3. FreeBSD as a Host

23.1.Â Synopsis

Virtualization software allows multiple operating systems to run simultaneously
on the same computer. Such software systems for PCs often involve a host
operating system which runs the virtualization software and supports any number
of guest operating systems.

After reading this chapter, you will know:

  * The difference between a host operating system and a guest operating
    system.

  * How to install FreeBSD on an IntelÂ®-based AppleÂ® MacintoshÂ® computer.

  * How to install FreeBSD on MicrosoftÂ®Â WindowsÂ® with Virtual PC.

  * How to tune a FreeBSD system for best performance under virtualization.

Before reading this chapter, you should:

  * Understand the basics of UNIXÂ® and FreeBSD.

  * Know how to install FreeBSD.

  * Know how to set up a network connection.

  * Know how to install additional third-party software.

23.2.Â FreeBSD as a Guest OS

23.2.1.Â Parallels on MacÂ OSÂ® X

Parallels Desktop for MacÂ® is a commercial software product available for 
IntelÂ® based AppleÂ® MacÂ® computers running MacÂ OSÂ® 10.4.6 or higher.
FreeBSD is a fully supported guest operating system. Once Parallels has been
installed on MacÂ OSÂ® X, the user must configure a virtual machine and then
install the desired guest operating system.

23.2.1.1.Â Installing FreeBSD on Parallels/MacÂ OSÂ® X

The first step in installing FreeBSD on Parallels is to create a new virtual
machine for installing FreeBSD. Select FreeBSD as the Guest OS Type when
prompted:

[parallels-]

Choose a reasonable amount of disk and memory depending on the plans for this
virtual FreeBSD instance. 4GB of disk space and 512MB of RAM work well for most
uses of FreeBSD under Parallels:

[parallels-]
[parallels-]
[parallels-]
[parallels-]

Select the type of networking and a network interface:

[parallels-]
[parallels-]

Save and finish the configuration:

[parallels-]
[parallels-]

After the FreeBSD virtual machine has been created, FreeBSD can be installed on
it. This is best done with an official FreeBSD CD/DVD or with an ISO image
downloaded from an official FTP site. Copy the appropriate ISO image to the
local MacÂ® filesystem or insert a CD/DVD in the MacÂ®'s CD drive. Click on the
disc icon in the bottom right corner of the FreeBSD Parallels window. This will
bring up a window that can be used to associate the CDROM drive in the virtual
machine with the ISO file on disk or with the real CDROM drive.

[parallels-]

Once this association with the CDROM source has been made, reboot the FreeBSD
virtual machine by clicking the reboot icon. Parallels will reboot with a
special BIOS that first checks if there is a CDROM.

[parallels-]

In this case it will find the FreeBSD installation media and begin a normal
FreeBSD installation. Perform the installation, but do not attempt to configure
Xorg at this time.

[parallels-]

When the installation is finished, reboot into the newly installed FreeBSD
virtual machine.

[parallels-]

23.2.1.2.Â Configuring FreeBSD on Parallels

After FreeBSD has been successfully installed on MacÂ OSÂ® X with Parallels,
there are a number of configuration steps that can be taken to optimize the
system for virtualized operation.

 1. Set Boot Loader Variables

    The most important step is to reduce the kern.hz tunable to reduce the CPU
    utilization of FreeBSD under the Parallels environment. This is
    accomplished by adding the following line to /boot/loader.conf:

    kern.hz=100

    Without this setting, an idle FreeBSD Parallels guest will use roughly 15%
    of the CPU of a single processor iMacÂ®. After this change the usage will
    be closer to 5%.

 2. Create a New Kernel Configuration File

    All of the SCSI, FireWire, and USB device drivers can be removed from a
    custom kernel configuration file. Parallels provides a virtual network
    adapter used by the ed(4) driver, so all network devices except for ed(4)
    and miibus(4) can be removed from the kernel.

 3. Configure Networking

    The most basic networking setup uses DHCP to connect the virtual machine to
    the same local area network as the host MacÂ®. This can be accomplished by
    adding ifconfig_ed0="DHCP" to /etc/rc.conf. More advanced networking setups
    are described in ChapterÂ 32, Advanced Networking.

23.2.2.Â Virtual PC on WindowsÂ®

Virtual PC for WindowsÂ® is a MicrosoftÂ® software product available for free
download. See this website for the system requirements. Once Virtual PC has
been installed on MicrosoftÂ®Â WindowsÂ®, the user can configure a virtual
machine and then install the desired guest operating system.

23.2.2.1.Â Installing FreeBSD on Virtual PC

The first step in installing FreeBSD on Virtual PC is to create a new virtual
machine for installing FreeBSD. Select Create a virtual machine when prompted:

[virtualpc-]
[virtualpc-]

Select Other as the Operating system when prompted:

[virtualpc-]

Then, choose a reasonable amount of disk and memory depending on the plans for
this virtual FreeBSD instance. 4GB of disk space and 512MB of RAM work well for
most uses of FreeBSD under Virtual PC:

[virtualpc-]
[virtualpc-]

Save and finish the configuration:

[virtualpc-]

Select the FreeBSD virtual machine and click Settings, then set the type of
networking and a network interface:

[virtualpc-]
[virtualpc-]

After the FreeBSD virtual machine has been created, FreeBSD can be installed on
it. This is best done with an official FreeBSD CD/DVD or with an ISO image
downloaded from an official FTP site. Copy the appropriate ISO image to the
local WindowsÂ® filesystem or insert a CD/DVD in the CD drive, then double
click on the FreeBSD virtual machine to boot. Then, click CD and choose Capture
ISO Image... on the Virtual PC window. This will bring up a window where the
CDROM drive in the virtual machine can be associated with an ISO file on disk
or with the real CDROM drive.

[virtualpc-]
[virtualpc-]

Once this association with the CDROM source has been made, reboot the FreeBSD
virtual machine by clicking Action and Reset. Virtual PC will reboot with a
special BIOS that first checks for a CDROM.

[virtualpc-]

In this case it will find the FreeBSD installation media and begin a normal
FreeBSD installation. Continue with the installation, but do not attempt to
configure Xorg at this time.

[virtualpc-]

When the installation is finished, remember to eject the CD/DVD or release the
ISO image. Finally, reboot into the newly installed FreeBSD virtual machine.

[virtualpc-]

23.2.2.2.Â Configuring FreeBSD on Virtual PC

After FreeBSD has been successfully installed on MicrosoftÂ®Â WindowsÂ® with 
Virtual PC , there are a number of configuration steps that can be taken to
optimize the system for virtualized operation.

 1. Set Boot Loader Variables

    The most important step is to reduce the kern.hz tunable to reduce the CPU
    utilization of FreeBSD under the Virtual PC environment. This is
    accomplished by adding the following line to /boot/loader.conf:

    kern.hz=100

    Without this setting, an idle FreeBSD Virtual PC guest OS will use roughly
    40% of the CPU of a single processor computer. After this change, the usage
    will be closer to 3%.

 2. Create a New Kernel Configuration File

    All of the SCSI, FireWire, and USB device drivers can be removed from a
    custom kernel configuration file. Virtual PC provides a virtual network
    adapter used by the de(4) driver, so all network devices except for de(4)
    and miibus(4) can be removed from the kernel.

 3. Configure Networking

    The most basic networking setup uses DHCP to connect the virtual machine to
    the same local area network as the MicrosoftÂ®Â WindowsÂ® host. This can be
    accomplished by adding ifconfig_de0="DHCP" to /etc/rc.conf. More advanced
    networking setups are described in ChapterÂ 32, Advanced Networking.

23.2.3.Â VMware Fusion on MacÂ OSÂ®

VMware Fusion for MacÂ® is a commercial software product available for IntelÂ®
based AppleÂ® MacÂ® computers running MacÂ OSÂ® 10.4.9 or higher. FreeBSD is a
fully supported guest operating system. Once VMware Fusion has been installed
on MacÂ OSÂ® X, the user can configure a virtual machine and then install the
desired guest operating system.

23.2.3.1.Â Installing FreeBSD on VMware Fusion

The first step is to start VMware Fusion which will load the Virtual Machine
Library. Click New to create the virtual machine:

[vmware-fre]

This will load the New Virtual Machine Assistant. Click Continue to proceed:

[vmware-fre]

Select Other as the Operating System and either FreeBSD or FreeBSD 64-bit, as
the Version when prompted:

[vmware-fre]

Choose the name of the virtual machine and the directory where it should be
saved:

[vmware-fre]

Choose the size of the Virtual Hard Disk for the virtual machine:

[vmware-fre]

Choose the method to install the virtual machine, either from an ISO image or
from a CD/DVD:

[vmware-fre]

Click Finish and the virtual machine will boot:

[vmware-fre]

Install FreeBSD as usual:

[vmware-fre]

Once the install is complete, the settings of the virtual machine can be
modified, such as memory usage:

Note:

The System Hardware settings of the virtual machine cannot be modified while
the virtual machine is running.

[vmware-fre]

The number of CPUs the virtual machine will have access to:

[vmware-fre]

The status of the CDROM device. Normally the CD/DVD/ISO is disconnected from
the virtual machine when it is no longer needed.

[vmware-fre]

The last thing to change is how the virtual machine will connect to the
network. To allow connections to the virtual machine from other machines
besides the host, choose Connect directly to the physical network (Bridged).
Otherwise, Share the host's internet connection (NAT) is preferred so that the
virtual machine can have access to the Internet, but the network cannot access
the virtual machine.

[vmware-fre]

After modifying the settings, boot the newly installed FreeBSD virtual machine.

23.2.3.2.Â Configuring FreeBSD on VMware Fusion

After FreeBSD has been successfully installed on MacÂ OSÂ® X with VMware Fusion
, there are a number of configuration steps that can be taken to optimize the
system for virtualized operation.

 1. Set Boot Loader Variables

    The most important step is to reduce the kern.hz tunable to reduce the CPU
    utilization of FreeBSD under the VMware Fusion environment. This is
    accomplished by adding the following line to /boot/loader.conf:

    kern.hz=100

    Without this setting, an idle FreeBSD VMware Fusion guest will use roughly
    15% of the CPU of a single processor iMacÂ®. After this change, the usage
    will be closer to 5%.

 2. Create a New Kernel Configuration File

    All of the FireWire, and USB device drivers can be removed from a custom
    kernel configuration file. VMware Fusion provides a virtual network adapter
    used by the em(4) driver, so all network devices except for em(4) can be
    removed from the kernel.

 3. Configure Networking

    The most basic networking setup uses DHCP to connect the virtual machine to
    the same local area network as the host MacÂ®. This can be accomplished by
    adding ifconfig_em0="DHCP" to /etc/rc.conf. More advanced networking setups
    are described in ChapterÂ 32, Advanced Networking.

23.2.4.Â VirtualBoxâ ¢ Guest Additions on a FreeBSD Guest

The VirtualBoxâ ¢ guest additions provide support for:

  * Clipboard sharing.

  * Mouse pointer integration.

  * Host time synchronization.

  * Window scaling.

  * Seamless mode.

Note:

The following commands are run in the FreeBSD guest.

First, install the emulators/virtualbox-ose-additions package or port in the
FreeBSD guest. This will install the port:

# cd /usr/ports/emulators/virtualbox-ose-additions && make install clean

Add these lines to /etc/rc.conf:

vboxguest_enable="YES" vboxservice_enable="YES"

If ntpd(8) or ntpdate(8) is used, host time synchronization should be disabled:

vboxservice_flags="--disable-timesync"

The vboxvideo driver should be automatically recognized by Xorg -configure. If
not, modify /etc/X11/xorg.conf for the VirtualBoxâ ¢ video card:

Section "Device" ### Available Driver options are:- ### Values: &lt;i&gt;: integer,
&lt;f&gt;: float, &lt;bool&gt;: "True"/"False", ### &lt;string&gt;: "String", &lt;freq&gt;: "&lt;f&gt; Hz/kHz
/MHz" ### [arg]: arg optional Identifier "Card0" Driver "vboxvideo" VendorName
"InnoTek Systemberatung GmbH" BoardName "VirtualBox Graphics Adapter" BusID
"PCI:0:2:0" EndSection

To use the vboxmouse driver, adjust the mouse section in /etc/X11/xorg.conf:

Section "InputDevice" Identifier "Mouse0" Driver "vboxmouse" EndSection

HAL users should create the following /usr/local/etc/hal/fdi/policy/
90-vboxguest.fdi or copy it from /usr/local/share/hal/fdi/policy/10osvendor/
90-vboxguest.fdi:

&lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;!-- # Sun VirtualBox # Hal driver
description for the vboxmouse driver # $Id: chapter.xml,v 1.33 2012-03-17
04:53:52 eadler Exp $ Copyright (C) 2008-2009 Sun Microsystems, Inc. This file
is part of VirtualBox Open Source Edition (OSE, as available from http://
www.virtualbox.org. This file is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License (GPL) as published
by the Free Software Foundation, in version 2 as it comes in the "COPYING" file
of the VirtualBox OSE distribution. VirtualBox OSE is distributed in the hope
that it will be useful, but WITHOUT ANY WARRANTY of any kind. Please contact
Sun Microsystems, Inc., 4150 Network Circle, Santa Clara, CA 95054 USA or visit
http://www.sun.com if you need additional information or have any questions.
--&gt; &lt;deviceinfo version="0.2"&gt; &lt;device&gt; &lt;match key="info.subsystem" string=
"pci"&gt; &lt;match key="info.product" string="VirtualBox guest Service"&gt; &lt;append key
="info.capabilities" type="strlist"&gt;input&lt;/append&gt; &lt;append key=
"info.capabilities" type="strlist"&gt;input.mouse&lt;/append&gt; &lt;merge key=
"input.x11_driver" type="string"&gt;vboxmouse&lt;/merge&gt; &lt;merge key="input.device"
type="string"&gt;/dev/vboxguest&lt;/merge&gt; &lt;/match&gt; &lt;/match&gt; &lt;/device&gt; &lt;/deviceinfo&gt;

23.3.Â FreeBSD as a Host

VirtualBoxâ ¢ is an actively developed, complete virtualization package, that
is available for most operating systems including WindowsÂ®, MacÂ OSÂ®, LinuxÂ®
and FreeBSD. It is equally capable of running WindowsÂ® or UNIXÂ®-like guests.
It is released as open source software, but with closed-source components
available in a separate extension pack. These components include support for
USB 2.0 devices. More information may be found on the â  Downloadsâ   page of
the VirtualBoxâ ¢ wiki. Currently, these extensions are not available for
FreeBSD.

23.3.1.Â Installing VirtualBoxâ ¢

VirtualBoxâ ¢ is available as a FreeBSD package or port in emulators/
virtualbox-ose. The port can be installed using these commands:

# cd /usr/ports/emulators/virtualbox-ose # make install clean

One useful option in the port's configuration menu is the GuestAdditions suite
of programs. These provide a number of useful features in guest operating
systems, like mouse pointer integration (allowing the mouse to be shared
between host and guest without the need to press a special keyboard shortcut to
switch) and faster video rendering, especially in WindowsÂ® guests. The guest
additions are available in the Devices menu, after the installation of the
guest is finished.

A few configuration changes are needed before VirtualBoxâ ¢ is started for the
first time. The port installs a kernel module in /boot/modules which must be
loaded into the running kernel:

# kldload vboxdrv

To ensure the module always gets loaded after a reboot, add the following line
to /boot/loader.conf:

vboxdrv_load="YES"

To use the kernel modules that allow bridged or host-only networking, add the
following to /etc/rc.conf and reboot the computer:

vboxnet_enable="YES"

The vboxusers group is created during installation of VirtualBoxâ ¢. All users
that need access to VirtualBoxâ ¢ will have to be added as members of this
group. pw can be used to add new members:

# pw groupmod vboxusers -m yourusername

The default permissions for /dev/vboxnetctl are restrictive and need to be
changed for bridged networking:

# chown root:vboxusers /dev/vboxnetctl # chmod 0660 /dev/vboxnetctl

To make this permissions change permanent, add these lines to /etc/devfs.conf:

own vboxnetctl root:vboxusers perm vboxnetctl 0660

To launch VirtualBoxâ ¢, type from a Xorg session:

% VirtualBox

For more information on configuring and using VirtualBoxâ ¢, refer to the
official website. For FreeBSD-specific information and troubleshooting
instructions, refer to the relevant page in the FreeBSD wiki.

23.3.2.Â VirtualBoxâ ¢ USB Support

In order to be able to read and write to USB devices, users need to be members
of operator:

# pw groupmod operator -m jerry

Then, add the following to /etc/devfs.rules, or create this file if it does not
exist yet:

[system=10] add path 'usb/*' mode 0660 group operator

To load these new rules, add the following to /etc/rc.conf:

devfs_system_ruleset="system"

Then, restart devfs:

# service devfs restart

USB can now be enabled in the guest operating system. USB devices should be
visible in the VirtualBoxâ ¢ preferences.

23.3.3.Â VirtualBoxâ ¢ Host DVD/CD Access

Access to the host DVD/CD drives from guests is achieved through the sharing of
the physical drives. Within VirtualBoxâ ¢, this is set up from the Storage
window in the Settings of the virtual machine. If needed, create an empty IDE
CD/DVD device first. Then choose the Host Drive from the popup menu for the
virtual CD/DVD drive selection. A checkbox labeled Passthrough will appear.
This allows the virtual machine to use the hardware directly. For example,
audio CDs or the burner will only function if this option is selected.

HAL needs to run for VirtualBoxâ ¢ DVD/CD functions to work, so enable it in /
etc/rc.conf and start it if it is not already running:

hald_enable="YES"
# service hald start

In order for users to be able to use VirtualBoxâ ¢ DVD/CD functions, they need
access to /dev/xpt0, /dev/cdN, and /dev/passN. This is usually achieved by
making the user a member of operator. Permissions to these devices have to be
corrected by adding the following lines to /etc/devfs.conf:

perm cd* 0600 perm xpt0 0660 perm pass* 0660
# service devfs restart

ChapterÂ 24.Â Localization - i18n/L10n Usage and Setup

Contributed by Andrey Chernov.
Rewritten by Michael C. Wu.
Table of Contents

24.1. Synopsis
24.2. The Basics
24.3. Using Localization
24.4. Compiling i18n Programs
24.5. Localizing FreeBSD to Specific Languages

24.1.Â Synopsis

FreeBSD is a distributed project with users and contributors located all over
the world. This chapter discusses the internationalization and localization
features of FreeBSD that allow non-English speaking users to get real work
done. Since there are many aspects of the i18n implementation in both the
system and application levels, more specific sources of documentation are
referred to, where applicable.

After reading this chapter, you will know:

  * How different languages and locales are encoded on modern operating
    systems.

  * How to set the locale for a login shell.

  * How to configure the console for non-English languages.

  * How to use Xorgeffectively with different languages.

  * Where to find more information about writing i18n-compliant applications.

Before reading this chapter, you should:

  * Know how to install additional third-party applications.

24.2.Â The Basics

24.2.1.Â What Is i18n/L10n?

The term internationalization has been shortened to i18n, which represents the
number of letters between the first and the last letters of
internationalization. L10n uses the same naming scheme, coming from â  
localizationâ  . Combined together, i18n/L10n methods, protocols, and
applications allow users to use languages of their choice.

i18n applications are programmed using i18n kits under libraries. These allow
developers to write a simple file and translate displayed menus and texts to
each language.

24.2.2.Â Why Use i18n/L10n?

Using i18n/L10n allows a user to view, input, or process data in non-English
languages.

24.2.3.Â Which Languages Are Supported?

i18n and L10n are not FreeBSD specific. Currently, one can choose from most of
the major languages, including but not limited to: Chinese, German, Japanese,
Korean, French, Russian, and Vietnamese.

24.3.Â Using Localization

Localization settings are based on three main terms: Language Code, Country
Code, and Encoding. Locale names are constructed from these parts as follows:

LanguageCode_CountryCode.Encoding

24.3.1.Â Language and Country Codes

In order to localize a FreeBSD system to a specific language, the user needs to
determine the codes for the specific country and language as the country code
tells applications which variation of the given language to use. The following
are examples of language/country codes:

     Language/Country Code                        Description
en_US                            English - United States
ru_RU                            Russian for Russia
zh_TW                            Traditional Chinese for Taiwan

A complete listing of available locales can be found by typing:

% locale -a

24.3.2.Â Encodings

Some languages use non-ASCII encodings that are 8-bit, wide, or multibyte
characters. For more information on these encodings, refer to multibyte(3).
Older applications do not recognize these encodings and mistake them for
control characters. Newer applications usually recognize 8-bit characters.
Depending on the implementation, users may be required to compile an
application with wide or multibyte character support, or configure it
correctly. To provide application support for wide or multibyte characters, the
FreeBSD Ports Collection contains programs for several languages. Refer to the 
i18n documentation in the respective FreeBSD port.

Specifically, the user needs to look at the application documentation to decide
how to configure it correctly or to determine which compile options to use when
building the port.

Some things to keep in mind are:

  * Language specific single C chars character sets such as ISO8859-1,
    ISO8859-15, KOI8-R, and CP437. These are described in multibyte(3).

  * Wide or multibyte encodings such as EUC and Big5.

The active list of character sets can be found at the IANA Registry.

Note:

FreeBSD uses Xorg-compatible locale encodings instead.

In the FreeBSD Ports Collection, i18n applications include i18n in their names
for easy identification. However, they do not always support the language
needed.

24.3.3.Â Setting Locale

Usually it is sufficient to export the value of the locale name as LANG in the
login shell. This could be done in the user's ~/.login_conf or in the startup
file of the user's shell: (~/.profile, ~/.bashrc, or ~/.cshrc). There is no
need to set the locale subsets such as LC_CTYPE or LC_CTIME. Refer to
language-specific FreeBSD documentation for more information.

Each user should set the following two environment variables in their
configuration files:

  * LANG for POSIXÂ® setlocale(3) family functions

  * MM_CHARSET for applications' MIME character set

These should be set in the user's shell configuration, the specific application
configuration, and the Xorg configuration.

24.3.3.1.Â Setting Locale Methods

This section describes the two methods for setting locale. The first is
recommended and assigns the environment variables in the login class. The
second method adds the environment variable assignments to the system's shell
startup file.

24.3.3.1.1.Â Login Classes Method

This method allows environment variables needed for locale name and MIME
character sets to be assigned once for every possible shell instead of adding
specific shell assignments to each shell's startup file. User Level Setup can
be performed by each user while Administrator Level Setup requires superuser
privileges.

24.3.3.1.1.1.Â User Level Setup

This provides a minimal example of a .login_conf located in a user's home
directory which has both variables set for the Latin-1 encoding:

me:\ :charset=ISO-8859-1:\ :lang=de_DE.ISO8859-1:

Here is an example of a user's .login_conf that sets the variables for
Traditional Chinese in BIG-5 encoding. More variables are set because some
applications do not correctly respect locale variables for Chinese, Japanese,
and Korean.

#Users who do not wish to use monetary units or time formats #of Taiwan can
manually change each variable me:\ :lang=zh_TW.Big5:\ :setenv=LC_ALL=
zh_TW.Big5:\ :setenv=LC_COLLATE=zh_TW.Big5:\ :setenv=LC_CTYPE=zh_TW.Big5:\
:setenv=LC_MESSAGES=zh_TW.Big5:\ :setenv=LC_MONETARY=zh_TW.Big5:\ :setenv=
LC_NUMERIC=zh_TW.Big5:\ :setenv=LC_TIME=zh_TW.Big5:\ :charset=big5:\
:xmodifiers="@im=gcin": #Set gcin as the XIM Input Server

See Administrator Level Setup and login.conf(5) for more details.

24.3.3.1.1.2.Â Administrator Level Setup

Verify that the user's login class in /etc/login.conf sets the correct
language:

language_name|Account Type Description:\ :charset=MIME_charset:\ :lang=
locale_name:\ :tc=default:

The previous Latin-1 example would look like this:

german|German Users Accounts:\ :charset=ISO-8859-1:\ :lang=de_DE.ISO8859-1:\
:tc=default:

Whenever this file is edited, execute the following command to update the
capability database:

# cap_mkdb /etc/login.conf

Changing Login Classes with vipw(8)

When using vipw to add new users, use language to set the language:

user:password:1111:11:language:0:0:User Name:/home/user:/bin/sh

Changing Login Classes with adduser(8)

When using adduser to add new users, configure the language as follows:

  * If all new users use the same language, set defaultclass = language in /etc
    /adduser.conf.

  * Alternatively, input the specified language at this prompt:

    Enter login class: default []:

    when creating a new user using adduser(8).

  * Another alternative is to use the following when creating a user that uses
    a different language than the one set in /etc/adduser.conf:

    # adduser -class language

Changing Login Classes with pw(8)

If pw(8) is used to add new users, call it in this form:

# pw useradd user_name -L language

24.3.3.1.2.Â Shell Startup File Method

Note:

This method is not recommended because it requires a different setup for each
shell. Use the Login Class Method instead.

To add the locale name and MIME character set, set the two environment
variables shown below in the /etc/profile or /etc/csh.login shell startup
files. This example sets the German language:

In /etc/profile:

LANG=de_DE.ISO8859-1; export LANG MM_CHARSET=ISO-8859-1; export MM_CHARSET

Or in /etc/csh.login:

setenv LANG de_DE.ISO8859-1 setenv MM_CHARSET ISO-8859-1

Alternatively, add the above settings to /usr/share/skel/dot.profile or /usr/
share/skel/dot.login.

To configure Xorg, add one of the following to ~/.xinitrc, depending upon the
shell:

LANG=de_DE.ISO8859-1; export LANG
setenv LANG de_DE.ISO8859-1

24.3.4.Â Console Setup

For all single C chars character sets, set the correct console fonts in /etc/
rc.conf for the language in question with:

font8x16=font_name font8x14=font_name font8x8=font_name

The font_name is taken from /usr/share/syscons/fonts, without the .fnt suffix.

The keymap and screenmap for the single C chars character set can be set using
sysinstall. Once inside sysinstall, choose Configure, then Console.
Alternatively, add the following to /etc/rc.conf:

scrnmap=screenmap_name keymap=keymap_name keychange="fkey_number sequence"

The screenmap_name is taken from /usr/share/syscons/scrnmaps, without the .scm
suffix. A screenmap with a corresponding mapped font is usually needed as a
workaround for expanding bit 8 to bit 9 on a VGA adapter's font character
matrix. This will move letters out of the pseudographics area if the screen
font uses a bit 8 column.

If moused is enabled in /etc/rc.conf, review the mouse cursor information in
the next paragraph.

By default, the mouse cursor of the syscons(4) driver occupies the 0xd0-0xd3
range in the character set. If the language uses this range, move the cursor's
range. To enable this workaround for FreeBSD, add the following line to /etc/
rc.conf:

mousechar_start=3

The keymap_name in the above example is taken from /usr/share/syscons/keymaps,
without the .kbd suffix. When uncertain as to which keymap to use, kbdmap(1)
can be used to test keymaps without rebooting.

The keychange is usually needed to program function keys to match the selected
terminal type because function key sequences cannot be defined in the key map.

Be sure to set the correct console terminal type in /etc/ttys for all virtual
terminal entries. Current pre-defined correspondences are:

                  Character Set                           Terminal Type
ISO8859-1 or ISO8859-15                            cons25l1
ISO8859-2                                          cons25l2
ISO8859-7                                          cons25l7
KOI8-R                                             cons25r
KOI8-U                                             cons25u
CP437 (VGA default)                                cons25
US-ASCII                                           cons25w

For languages with wide or multibyte characters, use the correct FreeBSD port
in /usr/ports/language. Some applications appear as serial terminals to the
system. Reserve enough terminals in /etc/ttys for both Xorg and the
pseudo-serial console. Here is a partial list of applications for using other
languages in the console:

           Language                                Location
Traditional Chinese (BIG-5)    chinese/big5con
Japanese                       japanese/kon2-16dot or japanese/mule-freewnn
Korean                         korean/han

24.3.5.Â Xorg Setup

Although Xorg is not installed with FreeBSD, it can be installed from the Ports
Collection. Refer to ChapterÂ 6, The X Window System for more information on
how to do this. This section discusses how to localize Xorg once it is
installed.

Application specific i18n settings such as fonts and menus can be tuned in ~
/.Xresources.

24.3.5.1.Â Displaying Fonts

After installing x11-servers/xorg-server, install the language's TrueTypeÂ®
fonts. Setting the correct locale should allow users to view their selected
language in graphical application menus.

24.3.5.2.Â Inputting Non-English Characters

The X Input Method (XIM) protocol is an input standard for Xorg clients. All 
Xorg applications should be written as XIM clients that take input from XIM
input servers. There are several XIM servers available for different languages.

24.3.6.Â Printer Setup

Some single C chars character sets are hardware coded into printers. Wide or
multibyte character sets require special setup using a utility such as 
apsfilter. Documents can be converted to PostScriptÂ® or PDF formats using
language specific converters.

24.3.7.Â Kernel and File Systems

The FreeBSD fast filesystem (FFS) is 8-bit clean, so it can be used with any
single C chars character set. However, character set names are not stored in
the filesystem as it is raw 8-bit and does not understand encoding order.
Officially, FFS does not support any form of wide or multibyte character sets.
However, some wide or multibyte character sets have independent patches for
enabling support on FFS. Refer to the respective languages' web sites for more
information and the patch files.

FreeBSD's support for the MS-DOSÂ® filesystem has the configurable ability to
convert between MS-DOSÂ®, Unicode character sets, and chosen FreeBSD filesystem
character sets. Refer to mount_msdosfs(8) for details.

24.4.Â Compiling i18n Programs

Many applications in the FreeBSD Ports Collection have been ported with i18n
support. Some of these include -i18n in the port name. These and many other
programs have built in support for i18n and need no special consideration.

However, some applications such as MySQL need to have their Makefile configured
with the specific charset. This is usually done in the port's Makefile or by
passing a value to configure in the source.

24.5.Â Localizing FreeBSD to Specific Languages

24.5.1.Â Russian Language (KOI8-R Encoding)

Originally contributed by Andrey Chernov.

For more information about KOI8-R encoding, refer to KOI8-R References (Russian
Net Character Set).

24.5.1.1.Â Locale Setup

To set this locale, put the following lines into each user's ~/.login_conf:

me:My Account:\ :charset=KOI8-R:\ :lang=ru_RU.KOI8-R:

24.5.1.2.Â Console Setup

  * Add the following lines to /etc/rc.conf:

    keymap="ru.koi8-r" scrnmap="koi8-r2cp866" font8x16="cp866b-8x16" font8x14=
    "cp866-8x14" font8x8="cp866-8x8" mousechar_start=3
  * For each ttyv entry in /etc/ttys, use cons25r as the terminal type.

24.5.1.3.Â Printer Setup

Since most printers with Russian characters come with hardware code page CP866,
a special output filter is needed to convert from KOI8-R to CP866. FreeBSD
installs a default filter as /usr/libexec/lpr/ru/koi2alt. A Russian printer /
etc/printcap entry should look like:

lp|Russian local line printer:\ :sh:of=/usr/libexec/lpr/ru/koi2alt:\ :lp=/dev/
lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:

Refer to printcap(5) for a more detailed description.

24.5.1.4.Â MS-DOSÂ® and Russian Filenames

The following example fstab(5) entry enables support for Russian filenames in
mounted MS-DOSÂ® filesystems:

/dev/ad0s2 /dos/c msdos rw,-Lru_RU.KOI8-R 0 0

-L selects the locale name. Refer to mount_msdosfs(8) for more details.

24.5.1.5.Â Xorg Setup

 1. First, configure the non-X locale setup.

 2. When using Xorg, install the x11-fonts/xorg-fonts-cyrillic package.

    Check the "Files" section in /etc/X11/xorg.conf. The following line must be
    added before any other FontPath entries:

    FontPath "/usr/local/lib/X11/fonts/cyrillic"

    Note:

    Search the Ports Collection for more Cyrillic fonts.

 3. To activate a Russian keyboard, add the following to the "Keyboard" section
    of /etc/xorg.conf:

    Option "XkbLayout" "us,ru" Option "XkbOptions" "grp:toggle"

    Make sure that XkbDisable is commented out in that file.

    For grp:toggle use Right Alt, for grp:ctrl_shift_toggle use Ctrl+Shift. For
    grp:caps_toggle use CapsLock. The old CapsLock function is still available
    in LAT mode only using Shift+CapsLock. grp:caps_toggle does not work in 
    Xorg for some unknown reason.

    If the keyboard has â  WindowsÂ®â   keys, and some non-alphabetical keys
    are mapped incorrectly, add the following line to /etc/xorg.conf:

    Option "XkbVariant" ",winkeys"

    Note:

    The Russian XKB keyboard may not work with non-localized applications.

Note:

Minimally localized applications should call a XtSetLanguageProc (NULL, NULL,
NULL); function early in the program.

See KOI8-R for X Window for more instructions on localizing Xorg applications.

24.5.2.Â Traditional Chinese Localization for Taiwan

The FreeBSD-Taiwan Project has a Chinese HOWTO for FreeBSD at http://
netlab.cse.yzu.edu.tw/~statue/freebsd/zh-tut/ using many Chinese ports. The
current editor for the FreeBSD Chinese HOWTO is Shen Chuan-Hsing &lt;
statue@freebsd.sinica.edu.tw&gt;.

24.5.3.Â German Language Localization for All ISO 8859-1 Languages

Slaven Rezic &lt;eserte@cs.tu-berlin.de&gt; wrote a tutorial on using umlauts on
FreeBSD. The tutorial is written in German and is available at http://
user.cs.tu-berlin.de/~eserte/FreeBSD/doc/umlaute/umlaute.html.

24.5.4.Â Greek Language Localization

Nikos Kokkalis &lt;nickkokkalis@gmail.com&gt; has written a complete article on Greek
support in FreeBSD. It is available here, in Greek only, as part of the
official FreeBSD Greek documentation.

24.5.5.Â Japanese and Korean Language Localization

For Japanese, refer to http://www.jp.FreeBSD.org/, and for Korean, refer to
http://www.kr.FreeBSD.org/.

24.5.6.Â Non-English FreeBSD Documentation

Some FreeBSD contributors have translated parts of the FreeBSD documentation to
other languages. They are available through links on the main site or in /usr/
share/doc.

ChapterÂ 25.Â Updating and Upgrading FreeBSD

Restructured, reorganized, and parts updated by Jim Mock.
Original work by Jordan Hubbard, Poul-Henning Kamp, John Polstra and Nik 
Clayton.
Table of Contents

25.1. Synopsis
25.2. FreeBSD Update
25.3. Portsnap: a Ports Collection Update Tool
25.4. Updating the Documentation Set
25.5. Tracking a Development Branch
25.6. Synchronizing Source
25.7. Rebuilding â  worldâ  
25.8. Tracking for Multiple Machines

25.1.Â Synopsis

FreeBSD is under constant development between releases. Some people prefer to
use the officially released versions, while others prefer to keep in sync with
the latest developments. However, even official releases are often updated with
security and other critical fixes. Regardless of the version used, FreeBSD
provides all the necessary tools to keep the system updated, and allows for
easy upgrades between versions. This chapter describes how to track the
development system and the basic tools for keeping a FreeBSD system up-to-date.

After reading this chapter, you will know:

  * Which utilities are available to update the system and the Ports
    Collection.

  * How to keep a FreeBSD system up-to-date with freebsd-update, Subversion, or
    CTM.

  * How to compare the state of an installed system against a known pristine
    copy.

  * How to keep the installed documentation up-to-date with Subversion or
    documentation ports.

  * The difference between the two development branches: FreeBSD-STABLE and
    FreeBSD-CURRENT.

  * How to rebuild and reinstall the entire base system.

Before reading this chapter, you should:

  * Properly set up the network connection (ChapterÂ 32, Advanced Networking).

  * Know how to install additional third-party software (ChapterÂ 5, Installing
    Applications: Packages and Ports).

Note:

Throughout this chapter, svn is used to obtain and update FreeBSD sources. To
use it, first install the devel/subversion port or package.

25.2.Â FreeBSD Update

Written by Tom Rhodes.
Based on notes provided by Colin Percival.

Applying security patches is an important part of maintaining computer
software, especially the operating system. For the longest time on FreeBSD,
this process was not an easy one. Patches had to be applied to the source code,
the code rebuilt into binaries, and then the binaries had to be re-installed.

This is no longer the case as FreeBSD now includes a utility called
freebsd-update. This utility provides two separate functions. First, it allows
for binary security and errata updates to be applied to the FreeBSD base system
without the build and install requirements. Second, the utility supports minor
and major release upgrades.

Note:

Binary updates are available for all architectures and releases currently
supported by the security team. Before updating to a new release, its release
announcement should be reviewed as it contains important information pertinent
to the release. Release announcements are available from http://www.FreeBSD.org
/releases/.

If a crontab utilizing the features of freebsd-update(8) exists, it must be
disabled before the following operation is started.

25.2.1.Â The Configuration File

Some users may wish to tweak the default configuration in /etc/
freebsd-update.conf, allowing better control of the process. The options are
well documented, but the following may require a bit more explanation:

# Components of the base system which should be kept updated. Components src
world kernel

This parameter controls which parts of FreeBSD will be kept up-to-date. The
default is to update the source code, the entire base system, and the kernel.
Components are the same as those available during installation. For instance,
adding world/games would allow game patches to be applied. Using src/bin would
allow the source code in src/bin to be updated.

The best option is to leave this at the default as changing it to include
specific items requires the user to list every item to be updated. This could
have disastrous consequences as source code and binaries may become out of
sync.

# Paths which start with anything matching an entry in an IgnorePaths #
statement will be ignored. IgnorePaths

To leave specified directories, such as /bin or /sbin, untouched during the
update process, add their paths to this statement. This option may be used to
prevent freebsd-update from overwriting local modifications.

# Paths which start with anything matching an entry in an UpdateIfUnmodified #
statement will only be updated if the contents of the file have not been #
modified by the user (unless changes are merged; see below). UpdateIfUnmodified
/etc/ /var/ /root/ /.cshrc /.profile

This option will only update unmodified configuration files in the specified
directories. Any changes made by the user will invalidate the automatic
updating of these files. There is another option, KeepModifiedMetadata, which
will instruct freebsd-update to save the changes during the merge.

# When upgrading to a new FreeBSD release, files which match MergeChanges #
will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/

List of directories with configuration files that freebsd-update should attempt
to merge. The file merge process is a series of diff(1) patches similar to
mergemaster(8), but with fewer options. Merges are either accepted, open an
editor, or freebsd-update will abort. When in doubt, backup /etc and just
accept the merges. See SectionÂ 25.7.12.1, â  mergemasterâ   for more
information about mergemaster.

# Directory in which to store downloaded updates and temporary # files used by
FreeBSD Update. # WorkDir /var/db/freebsd-update

This directory is where all patches and temporary files are placed. In cases
where the user is doing a version upgrade, this location should have a least a
gigabyte of disk space available.

# When upgrading between releases, should the list of Components be # read
strictly (StrictComponents yes) or merely as a list of components # which
*might* be installed of which FreeBSD Update should figure out # which actually
are installed and upgrade those (StrictComponents no)? # StrictComponents no

When this option is set to yes, freebsd-update will assume that the Components
list is complete and will not attempt to make changes outside of the list.
Effectively, freebsd-update will attempt to update every file which belongs to
the Components list.

25.2.2.Â Security Patches

FreeBSD security patches may be downloaded and installed using the following
command:

# freebsd-update fetch # freebsd-update install

If the update applied any kernel patches, the system will need a reboot in
order to boot into the patched kernel. Otherwise, the system should be patched
and freebsd-update may be run as a nightly cron(8) job by adding this entry to
/etc/crontab:

@daily root freebsd-update cron

This entry states that freebsd-update will run once every day. When run with
cron, freebsd-update will only check if updates exist. If patches exist, they
will automatically be downloaded to the local disk but will not be applied. The
root user will be sent an email so that they may be reviewed and manually
installed.

If anything goes wrong, freebsd-update has the ability to roll back the last
set of changes with the following command:

# freebsd-update rollback

Once complete, the system should be restarted if the kernel or any kernel
modules were modified. This will allow FreeBSD to load the new binaries into
memory.

Only the GENERIC kernel can be automatically updated by freebsd-update. If a
custom kernel is installed, it will have to be rebuilt and reinstalled after
freebsd-update finishes installing the rest of the updates. However,
freebsd-update will detect and update the GENERIC kernel if /boot/GENERIC
exists, even if it is not the current running kernel of the system.

Note:

It is a good idea to always keep a copy of the GENERIC kernel in /boot/GENERIC.
It will be helpful in diagnosing a variety of problems, and in performing
version upgrades using freebsd-update as described in SectionÂ 25.2.3, â  Major
and Minor Version Upgradesâ  .

Unless the default configuration in /etc/freebsd-update.conf has been changed,
freebsd-update will install the updated kernel sources along with the rest of
the updates. Rebuilding and reinstalling a new custom kernel can then be
performed in the usual way.

Note:

The updates distributed by freebsd-update do not always involve the kernel. It
is not necessary to rebuild a custom kernel if the kernel sources have not been
modified by the execution of freebsd-update install. However, freebsd-update
will always update /usr/src/sys/conf/newvers.sh. The current patch level, as
indicated by the -p number reported by uname -r, is obtained from this file.
Rebuilding a custom kernel, even if nothing else changed, allows uname(1) to
accurately report the current patch level of the system. This is particularly
helpful when maintaining multiple systems, as it allows for a quick assessment
of the updates installed in each one.

25.2.3.Â Major and Minor Version Upgrades

Upgrades from one minor version of FreeBSD to another, like from FreeBSDÂ 9.0
to FreeBSDÂ 9.1, are called minor version upgrades. Generally, installed
applications will continue to work without problems after minor version
upgrades.

Major version upgrades occur when FreeBSD is upgraded from one major version to
another, like from FreeBSDÂ 8.X to FreeBSDÂ 9.X. Major version upgrades remove
old object files and libraries which will break most third party applications.
It is recommended that all installed ports either be removed and re-installed
or upgraded after a major version upgrade using a utility such as ports-mgmt/
portmaster. A brute-force rebuild of all installed applications can be
accomplished with this command:

# portmaster -af

This will ensure everything will be re-installed correctly. Note that setting
the BATCH environment variable to yes will answer yes to any prompts during
this process, removing the need for manual intervention during the build
process.

25.2.3.1.Â Dealing with Custom Kernels

If a custom kernel is in use, the upgrade process is slightly more involved,
and the procedure varies depending on the version of FreeBSD.

25.2.3.1.1.Â Custom Kernels with FreeBSDÂ 8.X

A copy of the GENERIC kernel is needed, and should be placed in /boot/GENERIC.
If the GENERIC kernel is not present in the system, it may be obtained using
one of the following methods:

  * If a custom kernel has only been built once, the kernel in /boot/kernel.old
    is actually GENERIC. Rename this directory to /boot/GENERIC.

  * Assuming physical access to the machine is possible, a copy of the GENERIC
    kernel can be installed from the installation media using the following
    commands:

    # mount /cdrom # cd /cdrom/X.Y-RELEASE/kernels # ./install.sh GENERIC

    Replace X.Y-RELEASE with the actual version of the release being used. The
    GENERIC kernel will be installed in /boot/GENERIC by default.

  * Failing all the above, the GENERIC kernel may be rebuilt and installed from
    source:

    # cd /usr/src # env DESTDIR=/boot/GENERIC make kernel __MAKE_CONF=/dev/null
    SRCCONF=/dev/null # mv /boot/GENERIC/boot/kernel/* /boot/GENERIC # rm -rf /
    boot/GENERIC/boot

    For this kernel to be picked up as GENERIC by freebsd-update, the GENERIC
    configuration file must not have been modified in any way. It is also
    suggested that it is built without any other special options.

Rebooting to the GENERIC kernel is not required at this stage.

25.2.3.1.2.Â Custom Kernels with FreeBSDÂ 9.X and Later

  * If a custom kernel has only been built once, the kernel in /boot/kernel.old
    is actually the GENERIC kernel. Rename this directory to /boot/kernel.

  * If physical access to the machine is available, a copy of the GENERIC
    kernel can be installed from the installation media using these commands:

    # mount /cdrom # cd /cdrom/usr/freebsd-dist # tar -C/ -xvf kernel.txz boot/
    kernel/kernel
  * If the options above cannot be used, the GENERIC kernel may be rebuilt and
    installed from source:

    # cd /usr/src # make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null

    For this kernel to be identified as the GENERIC kernel by freebsd-update,
    the GENERIC configuration file must not have been modified in any way. It
    is also suggested that the kernel is built without any other special
    options.

Rebooting to the GENERIC kernel is not required at this stage.

25.2.3.2.Â Performing the Upgrade

Major and minor version upgrades may be performed by providing freebsd-update
with a release version target. The following command will update to
FreeBSDÂ 9.1:

# freebsd-update -r 9.1-RELEASE upgrade

After the command has been received, freebsd-update will evaluate the
configuration file and current system in an attempt to gather the information
necessary to perform the upgrade. A screen listing will display which
components have and have not been detected. For example:

Looking up update.FreeBSD.org mirrors... 1 mirrors found. Fetching metadata
signature for 9.0-RELEASE from update1.FreeBSD.org... done. Fetching metadata
index... done. Inspecting system... done. The following components of FreeBSD
seem to be installed: kernel/smp src/base src/bin src/contrib src/crypto src/
etc src/games src/gnu src/include src/krb5 src/lib src/libexec src/release src/
rescue src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin world
/base world/info world/lib32 world/manpages The following components of FreeBSD
do not seem to be installed: kernel/generic world/catpages world/dict world/doc
world/games world/proflibs Does this look reasonable (y/n)? y

At this point, freebsd-update will attempt to download all files required for
the upgrade. In some cases, the user may be prompted with questions regarding
what to install or how to proceed.

When using a custom kernel, the above step will produce a warning similar to
the following:

WARNING: This system is running a "MYKERNEL" kernel, which is not a kernel
configuration distributed as part of FreeBSD 9.0-RELEASE. This kernel will not
be updated: you MUST update the kernel manually before running "/usr/sbin/
freebsd-update install"

This warning may be safely ignored at this point. The updated GENERIC kernel
will be used as an intermediate step in the upgrade process.

Once all the patches have been downloaded to the local system, they will be
applied. This process may take a while, depending on the speed and workload of
the machine. Configuration files will then be merged. The merging process
requires some user intervention as a file may be merged or an editor may appear
on screen for a manual merge. The results of every successful merge will be
shown to the user as the process continues. A failed or ignored merge will
cause the process to abort. Users may wish to make a backup of /etc and
manually merge important files, such as master.passwd or group at a later time.

Note:

The system is not being altered yet as all patching and merging is happening in
another directory. Once all patches have been applied successfully, all
configuration files have been merged and it seems the process will go smoothly,
the changes can be committed to disk by the user using the following command:

# freebsd-update install

The kernel and kernel modules will be patched first. At this point, the machine
must be rebooted. If the system is running with a custom kernel, use nextboot
(8) to set the kernel for the next boot to the updated /boot/GENERIC:

# nextboot -k GENERIC

Warning:

Before rebooting with the GENERIC kernel, make sure it contains all the drivers
required for the system to boot properly and connect to the network, if the
machine being updated is accessed remotely. In particular, if the running
custom kernel contains built-in functionality usually provided by kernel
modules, make sure to temporarily load these modules into the GENERIC kernel
using the /boot/loader.conf facility. It is recommended to disable
non-essential services as well as any disk and network mounts until the upgrade
process is complete.

The machine should now be restarted with the updated kernel:

# shutdown -r now

Once the system has come back online, restart freebsd-update using the
following command. The state of the process has been saved and thus,
freebsd-update will not start from the beginning, but will remove all old
shared libraries and object files.

# freebsd-update install

Note:

Depending upon whether any library version numbers were bumped, there may only
be two install phases instead of three.

25.2.3.3.Â Rebuilding Ports After a Major Version Upgrade

After a major version upgrade, all third party software needs to be rebuilt and
re-installed. This is required as installed software may depend on libraries
which have been removed during the upgrade process. This process can be
automated using ports-mgmt/portmaster:

# portmaster -f

Once this has completed, finish the upgrade process with a final call to
freebsd-update in order to tie up all the loose ends in the upgrade process:

# freebsd-update install

If the GENERIC kernel was temporarily used, this is the time to build and
install a new custom kernel in the usual way.

Reboot the machine into the new FreeBSD version. The process is complete.

25.2.4.Â System State Comparison

freebsd-update can be used to test the state of the installed FreeBSD version
against a known good copy. This option evaluates the current version of system
utilities, libraries, and configuration files. To begin the comparison, issue
the following command:

# freebsd-update IDS &gt;&gt; outfile.ids

Warning:

While the command name is IDS it is not a replacement for a real intrusion
detection system such as security/snort. As freebsd-update stores data on disk,
the possibility of tampering is evident. While this possibility may be reduced
using kern.securelevel and by storing the freebsd-update data on a read only
file system when not in use, a better solution would be to compare the system
against a secure disk, such as a DVD or securely stored external USB disk
device.

The system will now be inspected, and a lengthy listing of files, along with
the sha256(1) hash values for both the known value in the release and the
current installation, will be sent to the specified outfile.ids file.

The entries in the listing are extremely long, but the output format may be
easily parsed. For instance, to obtain a list of all files which differ from
those in the release, issue the following command:

# cat outfile.ids | awk '{ print $1 }' | more /etc/master.passwd /etc/motd /etc
/passwd /etc/pf.conf

This sample output has been truncated as many more files exist. Some files have
natural modifications. For example, /etc/passwd has been modified because users
have been added to the system. Other files, such as kernel modules, may differ
as freebsd-update may have updated them. To exclude specific files or
directories, add them to the IDSIgnorePaths option in /etc/freebsd-update.conf.

This system may be used as part of an elaborate upgrade method, aside from the
previously discussed version.

25.3.Â Portsnap: a Ports Collection Update Tool

Written by Tom Rhodes.
Based on notes provided by Colin Percival.

The base system of FreeBSD includes portsnap(8) for updating the Ports
Collection. This utility connects to a FreeBSD site, verifies the secure key,
and downloads a new copy of the Ports Collection. The key is used to verify the
integrity of all downloaded files. To download the latest Ports Collection
files, issue the following command:

# portsnap fetch Looking up portsnap.FreeBSD.org mirrors... 9 mirrors found.
Fetching snapshot tag from geodns-1.portsnap.freebsd.org... done. Fetching
snapshot metadata... done. Updating from Tue May 22 02:12:15 CEST 2012 to Wed
May 23 16:28:31 CEST 2012. Fetching 3 metadata patches.. done. Applying
metadata patches... done. Fetching 3 metadata files... done. Fetching 90
patches.....10....20....30....40....50....60....70....80....90. done. Applying
patches... done. Fetching 133 new ports or files... done.

What this example shows is that portsnap(8) has found and verified several
patches to the current ports data. This also indicates that the utility was run
previously; if it was a first time run, the collection would have simply been
downloaded.

When portsnap(8) successfully completes a fetch operation, the Ports Collection
and subsequent patches which exist on the local system have passed
verification. The first time portsnap is executed, use extract to install the
downloaded files:

# portsnap extract /usr/ports/.cvsignore /usr/ports/CHANGES /usr/ports/
COPYRIGHT /usr/ports/GIDs /usr/ports/KNOBS /usr/ports/LEGAL /usr/ports/MOVED /
usr/ports/Makefile /usr/ports/Mk/bsd.apache.mk /usr/ports/Mk/bsd.autotools.mk /
usr/ports/Mk/bsd.cmake.mk ...

To update an already installed Ports Collection, use portsnap update:

# portsnap update

The process is now complete, and applications may be installed or upgraded
using the updated Ports Collection.

When using fetch, the extract or the update operation may be run consecutively:

# portsnap fetch update

This command downloads the latest version of the Ports Collection and updates
the local version under /usr/ports.

25.4.Â Updating the Documentation Set

Documentation is an integral part of the FreeBSD operating system. While an
up-to-date version of the FreeBSD Documentation Set is always available on the
FreeBSD web site, some users might have slow or no permanent network
connectivity. There are several ways to update the local copy of documentation
with the latest FreeBSD Documentation Set.

25.4.1.Â Using Subversion to Update the Documentation

The FreeBSD documentation sources can be obtained with svn. This section
describes how to:

  * Install the documentation toolchain, the tools that are required to rebuild
    the FreeBSD documentation from its source.

  * Download a copy of the documentation source at /usr/doc, using svn.

  * Rebuild the FreeBSD documentation from its source, and install it under /
    usr/share/doc.

  * Recognize some of the build options that are supported by the build system
    of the documentation, such as the options that build only some of the
    different language translations of the documentation or the options that
    select a specific output format.

25.4.2.Â Installing svn and the Documentation Toolchain

Rebuilding the FreeBSD documentation from source requires a collection of tools
which are not part of the FreeBSD base system due to the amount of disk space
these tools use. They are also not useful to all FreeBSD users, only those
users that are actively writing new documentation for FreeBSD or are frequently
updating their documentation from source.

The required tools, including svn, are available in the textproc/docproj
meta-port developed by the FreeBSD Documentation Project.

Note:

When no PostScriptÂ® or PDF documentation required, one might consider
installing the textproc/docproj-nojadetex port instead. This version of the
documentation toolchain includes everything except the teTeX typesetting
engine. teTeX is a very large collection of tools, so it may be quite sensible
to omit its installation if PDF output is not really necessary.

25.4.3.Â Updating the Documentation Sources

In this example, svn is used to fetch a clean copy of the documentation sources
from the western US mirror using the HTTPS protocol:

# svn checkout https://svn0.us-west.FreeBSD.org/doc/head /usr/doc

Select the closest mirror from the available Subversion mirror sites.

The initial download of the documentation sources may take a while. Let it run
until it completes.

Future updates of the documentation sources may be fetched by running:

# svn update /usr/doc

After checking out the sources, an alternative way of updating the
documentation is supported by the /usr/doc/Makefile by running the following
commands:

# cd /usr/doc # make update

25.4.4.Â Tunable Options of the Documentation Sources

The updating and build system of the FreeBSD documentation set supports a few
options that ease the process of updating only parts of the documentation, or
the build of specific translations. These options can be set either as
system-wide options in /etc/make.conf, or as command-line options passed to
make(1).

The options include:

DOC_LANG

    The list of languages and encodings to build and install, such as
    en_US.ISO8859-1 for English documentation.

FORMATS

    A single format or a list of output formats to be built. Currently, html,
    html-split, txt, ps, pdf, and rtf are supported.

DOCDIR

    Where to install the documentation. It defaults to /usr/share/doc.

For more make variables supported as system-wide options in FreeBSD, refer to
make.conf(5).

For more make variables supported by the build system of the FreeBSD
documentation, refer to the FreeBSD Documentation Project Primer for New
Contributors.

25.4.5.Â Installing the FreeBSD Documentation from Source

Once an up-to-date snapshot of the documentation sources has been fetched to /
usr/doc, everything is ready for an update of the installed documentation.

A full update of all the languages defined in DOC_LANG may be performed by
typing:

# cd /usr/doc # make install clean

If an update of only a specific language is desired, make(1) can be invoked in
a language specific subdirectory of /usr/doc:

# cd /usr/doc/en_US.ISO8859-1 # make update install clean

The output formats that will be installed may be specified by setting FORMATS:

# cd /usr/doc # make FORMATS='html html-split' install clean

For information on editing and submitting corrections to the documentation,
refer to the FreeBSD Documentation Project Primer for New Contributors.

25.4.6.Â Using Documentation Ports

Based on the work of Marc Fonvieille.

The previous section presented a method for updating the FreeBSD documentation
from sources. Source based updates may not be feasible or practical for all
FreeBSD systems as building the documentation sources requires the 
documentation toolchain, a certain level of familiarity with svn and source
checkouts from a repository, and a few manual steps to build the checked out
sources. This section describes an alternative method which uses the Ports
Collection and makes it possible to:

  * Download and install pre-built snapshots of the documentation, without
    having to locally build anything or install the documentation toolchain.

  * Download the documentation sources and build them through the ports
    framework, making the checkout and build steps a bit easier.

These two methods of updating the FreeBSD documentation are supported by a set
of documentation ports, updated by the Documentation Engineering Team &lt;
doceng@FreeBSD.org&gt; on a monthly basis. These are listed in the FreeBSD
PortsÂ Collection, under the docs category.

25.4.6.1.Â Building and Installing Documentation Ports

The documentation ports use the ports building framework to make documentation
builds easier. They automate the process of checking out the documentation
source, running make(1) with the appropriate environment settings and
command-line options, and they make the installation or deinstallation of
documentation as easy as the installation of any other FreeBSD port or package.

Note:

As an extra feature, when the documentation ports are built locally, they
record a dependency to the documentation toolchain ports, so that they are also
automatically installed.

Organization of the documentation ports is as follows:

  * The â  master portâ  , misc/freebsd-doc-en, which installs all of the
    English documentation ports.

  * The â  all in one portâ  , misc/freebsd-doc-all, builds and installs all
    documentation in all available languages.

  * There is a â  slave portâ   for each translation, such as misc/
    freebsd-doc-hu for the Hungarian-language documents.

For example, to build and install the English documentation in split HTML
format, similar to the format used on http://www.FreeBSD.org, to /usr/local/
share/doc/freebsd, install the following port

# cd /usr/ports/misc/freebsd-doc-en # make install clean

25.4.6.1.1.Â Common Knobs and Options

There are many options for modifying the default behavior of the documentation
ports, including:

WITH_HTML

    Builds the HTML format with a single HTML file per document. The formatted
    documentation is saved to a file called article.html, or book.html, as
    appropriate, plus images.

WITH_PDF

    Builds the AdobeÂ® Portable Document Format (PDF). The formatted
    documentation is saved to a file called article.pdf or book.pdf, as
    appropriate.

DOCBASE

    Specifies where to install the documentation. It defaults to /usr/local/
    share/doc/freebsd.

    Note:

    The default target directory differs from the directory used svn. This is
    because ports are usually installed within /usr/local. This can be
    overridden by using PREFIX.

This example uses variables to install the Hungarian documentation as a PDF:

# cd /usr/ports/misc/freebsd-doc-hu # make -DWITH_PDF DOCBASE=share/doc/freebsd
/hu install clean

25.4.6.2.Â Using Documentation Packages

Building the documentation ports from source, as described in the previous
section, requires a local installation of the documentation toolchain and a bit
of disk space for the build of the ports. When resources are not available to
install the documentation toolchain, or because the build from sources would
take too much disk space, it is still possible to install pre-built snapshots
of the documentation ports.

The Documentation Engineering Team &lt;doceng@FreeBSD.org&gt; prepares monthly
snapshots of the FreeBSD documentation packages. These binary packages can be
used with any of the bundled package tools, like pkg_add(1), pkg_delete(1), and
so on.

Note:

When binary packages are used, the FreeBSD documentation will be installed in 
all available formats for the given language.

For example, the following command will install the latest pre-built package of
the Hungarian documentation:

# pkg_add -r hu-freebsd-doc

Note:

Packages use a format that differs from the corresponding port's name: lang
-freebsd-doc, where lang is the short format of the language code, such as hu
for Hungarian, or zh_cn for Simplified Chinese.

25.4.6.3.Â Updating Documentation Ports

Documentation ports can be updated like any other port. For example, the
following command updates the installed Hungarian documentation using
ports-mgmt/portmaster by using packages only:

# portmaster -PP hu-freebsd-doc

25.5.Â Tracking a Development Branch

There are two development branches to FreeBSD: FreeBSD-CURRENT and
FreeBSD-STABLE. This section provides an explanation of each and describes how
to keep a system up-to-date with each respective tree. FreeBSD-CURRENT will be
discussed first, then FreeBSD-STABLE.

25.5.1.Â Staying Current with FreeBSD

FreeBSD-CURRENT is the â  bleeding edgeâ   of FreeBSD development.
FreeBSD-CURRENT users are expected to have a high degree of technical skill and
should be capable of solving difficult system problems on their own. If you are
new to FreeBSD, track FreeBSD-STABLE instead.

25.5.1.1.Â What Is FreeBSD-CURRENT?

FreeBSD-CURRENT is the latest working sources for FreeBSD. This includes work
in progress, experimental changes, and transitional mechanisms that might or
might not be present in the next official release of the software. While many
FreeBSD developers compile the FreeBSD-CURRENT source code daily, there are
periods of time when the sources are not buildable. These problems are resolved
as quickly as possible, but whether or not FreeBSD-CURRENT brings disaster or
greatly desired functionality can be a matter of when the source code was
synced

25.5.1.2.Â Who Needs FreeBSD-CURRENT?

FreeBSD-CURRENT is made available for three primary interest groups:

 1. Members of the FreeBSD community who are actively working on some part of
    the source tree and for whom keeping â  currentâ   is an absolute
    requirement.

 2. Members of the FreeBSD community who are active testers, willing to spend
    time solving problems in order to ensure that FreeBSD-CURRENT remains as
    sane as possible. These testers wish to make topical suggestions on changes
    and the general direction of FreeBSD, and submit patches to implement them.

 3. Those who merely wish to keep an eye on things, or to use the current
    sources for reference purposes. These people also make the occasional
    comment or contribute code.

25.5.1.3.Â What Is FreeBSD-CURRENT Not?

 1. A fast-track to getting new features before the next release. Pre-release
    features are not yet fully tested and most likely contain bugs.

 2. A quick way of getting bug fixes, though the fix is just as likely to
    introduce new bugs as to fix existing ones.

 3. In no way â  officially supportedâ  .

25.5.1.4.Â Using FreeBSD-CURRENT

 1. Join the freebsd-current and the svn-src-head lists. This is essential in
    order to see the comments that people are making about the current state of
    the system and to receive important bulletins which may be critical to the
    system's continued health.

    The svn-src-head list records the commit log entry for each change as it is
    made, along with any pertinent information on possible side-effects.

    To join these lists, go to http://lists.FreeBSD.org/mailman/listinfo, click
    on the list to subscribe to, and follow the instructions. In order to track
    changes to the whole source tree, subscribe to the svn-src-all list.

 2. Grab the sources from a FreeBSD mirror site using one of the following
    methods:

     a. Use svn to check out the desired development or release branch. This is
        the recommended method, providing access to FreeBSD development as it
        occurs. Checkout the -CURRENT code from the head branch of one of the
        Subversion mirror sites. Due to the size of the repository, it is
        recommended that only desired subtrees be checked out.

     b. Use the CTM facility. If you have bad connectivity such as high price
        connections or only email access, CTM is an option, but it is not as
        reliable as Subversion. For this reason, Subversion is the recommended
        method for any system with Internet connectivity.

 3. If you plan to run, and not just look at the sources, download all of
    FreeBSD-CURRENT, not just selected portions. Various parts of the source
    depend on updates elsewhere, and trying to compile just a subset is almost
    guaranteed to cause problems.

    Before compiling FreeBSD-CURRENT, read /usr/src/Makefile very carefully.
    Install a new kernel and rebuild the world the first time through as part
    of the upgrading process. Read the FreeBSD-CURRENT mailing list and /usr/
    src/UPDATING to stay up-to-date on other bootstrapping procedures that
    sometimes become necessary on the road to the next release.

 4. Be active! FreeBSD-CURRENT users are encouraged to submit their suggestions
    for enhancements or bug fixes. Suggestions with accompanying code are
    received most enthusiastically!

25.5.2.Â Staying Stable with FreeBSD

25.5.2.1.Â What Is FreeBSD-STABLE?

FreeBSD-STABLE is the development branch from which major releases are made.
Changes go into this branch at a different pace, and with the general
assumption that they have first gone into FreeBSD-CURRENT for testing. This is 
still a development branch, however, and this means that at any given time, the
sources for FreeBSD-STABLE may or may not be suitable for any particular
purpose. It is simply another engineering development track, not a resource for
end-users.

25.5.2.2.Â Who Needs FreeBSD-STABLE?

Those interested in tracking or contributing to the FreeBSD development
process, especially as it relates to the next â  pointâ   release of FreeBSD,
should consider following FreeBSD-STABLE.

While security fixes go into the FreeBSD-STABLE branch, one does not need to
track FreeBSD-STABLE to receive security fixes. Every security advisory for
FreeBSD explains how to fix the problem for the releases it affects which are
not yet EOL. ^[7].

While the FreeBSD-STABLE branch should compile and run at all times, this
cannot be guaranteed. While code is developed in FreeBSD-CURRENT before
including it in FreeBSD-STABLE, more people run FreeBSD-STABLE than
FreeBSD-CURRENT, so it is inevitable that bugs and corner cases will sometimes
be found in FreeBSD-STABLE that were not apparent in FreeBSD-CURRENT.

For these reasons, one should not blindly track FreeBSD-STABLE. It is
particularly important not to update any production servers to FreeBSD-STABLE
without first thoroughly testing the code in that development environment.

Except for those users who have the resources to perform testing, it is
recommended that users instead run the most recent release of FreeBSD, and use
the binary update mechanism to move from release to release.

25.5.2.3.Â Using FreeBSD-STABLE

 1. Join the freebsd-stable list in order to stay informed of
    build-dependencies that may appear in FreeBSD-STABLE or any other issues
    requiring special attention. Developers will also make announcements in
    this mailing list when they are contemplating some controversial fix or
    update, giving the users a chance to respond if they have any issues to
    raise concerning the proposed change.

    Join the relevant SVN list for the branch being tracked. For example, users
    tracking the 9-STABLE branch should join the svn-src-stable-9 list. This
    list records the commit log entry for each change as it is made, along with
    any pertinent information on possible side-effects.

    To join these lists, go to http://lists.FreeBSD.org/mailman/listinfo, click
    on the list to subscribe to, and follow the instructions. In order to track
    changes for the whole source tree, subscribe to svn-src-all.

 2. To install a new system in order to run monthly snapshots built from
    FreeBSD-STABLE, refer to Snapshotsfor more information. Alternatively, it
    is possible to install the most recent FreeBSD-STABLE release from the
    mirror sites and follow the instructions below to upgrade the system to the
    most up-to-date FreeBSD-STABLE source code.

    Several methods are available to upgrade from a FreeBSD mirror site on a
    system already running a previous release of FreeBSD:

     a. Use svn to check out the desired development or release branch. This is
        the recommended method, providing access to FreeBSD development as it
        occurs. Branch names include head for the current development head, and
        branches identified in the release engineering page, such as stable/9
        or releng/9.0. URL prefixes for Subversion checkout of the base system
        are shown in Subversion mirror sites. Because of the size of the
        repository, it is recommended that only desired subtrees be checked
        out.

     b. Consider using CTM if you do not have a fast connection to the
        Internet.

 3. If you need rapid on-demand access to the source and communications
    bandwidth is not a consideration, use Subversion. Otherwise, use CTM.

 4. Before compiling FreeBSD-STABLE, read /usr/src/Makefile carefully. Install
    a new kernel and rebuild the world the first time through as part of the
    upgrading process. Read FreeBSD-STABLE mailing list and /usr/src/UPDATING
    to keep up-to-date on other bootstrapping procedures that sometimes become
    necessary on the road to the next release.

25.6.Â Synchronizing Source

There are various ways of using an Internet or email connection to stay
up-to-date with any given area, or all areas, of the FreeBSD project sources.
The primary services are Subversion and CTM.

Warning:

While it is possible to update only parts of the source tree, the only
supported update procedure is to update the entire tree and recompile all the
programs that run in user space, such as those in /bin and /sbin, and kernel
sources. Updating only part of the source tree, only the kernel, or only the
userland programs will often result in problems ranging from compile errors to
kernel panics or data corruption.

Subversion uses the pull model of updating sources. The user, or a cron script,
invokes the svn program, and it brings files up-to-date. Subversion is the
preferred means of updating local source trees. The updates are
up-to-the-minute and the user controls when they are downloaded. It is easy to
restrict updates to specific files or directories and the requested updates are
generated on the fly by the server.

CTM does not interactively compare the local sources with those on the master
archive or otherwise pull them across. Instead, a script which identifies
changes in files since its previous run is executed several times a day on the
master CTM machine. Any detected changes are compressed, stamped with a
sequence-number, and encoded for transmission over email in printable ASCII
only. Once received, these â  CTM deltasâ   can then be handed to the ctm_rmail
(1) utility which will automatically decode, verify, and apply the changes to
the user's copy of the sources. This process is more efficient than Subversion
and places less strain on server resources since it is a push rather than a 
pull model.

There are other trade-offs. If a user inadvertently wipes out portions of the
local archive, Subversion will detect and rebuild the damaged portions. CTM
will not do this, and if a user deletes some portion of the source tree and
does not have a backup, they will have to start from scratch from the most
recent CTM â  base deltaâ   and rebuild it all with CTM.

25.7.Â Rebuilding â  worldâ  

Once the local source tree is synchronized against a particular version of
FreeBSD such as FreeBSD-STABLE or FreeBSD-CURRENT, the source tree can be used
to rebuild the system.

Make a Backup:

It cannot be stressed enough how important it is to make a backup of the system
before rebuilding the system. While rebuilding the world is an easy task, there
will inevitably be times when mistakes in the source tree render the system
unbootable.

Create and verify a backup and have a bootable installation media at hand. You
will probably never have to use it, but it is better to be safe than sorry!

Subscribe to the Right Mailing List:

The FreeBSD-STABLE and FreeBSD-CURRENT branches are, by their nature, in
development. People that contribute to FreeBSD are human, and mistakes
occasionally happen.

Sometimes these mistakes can be quite harmless, just causing the system to
print a new diagnostic warning. Or the change may be catastrophic, and render
the system unbootable or destroy file systems.

When problems occur, a â  heads upâ   is posted to the appropriate mailing
list, explaining the nature of the problem and which systems it affects. An â  
all clearâ   announcement is posted when the problem has been solved.

Users who track FreeBSD-STABLE or FreeBSD-CURRENT and do not read
FreeBSD-STABLE mailing list or FreeBSD-CURRENT mailing list respectively, are
asking for trouble.

Do Not Use make world:

Some older documentation recommends using make world. However, that command
skips some important steps and should only be used by experts. For almost all
circumstances make world is the wrong thing to do, and the procedure described
here should be used instead.

25.7.1.Â The Canonical Way to Update Your System

Before updating the system, read /usr/src/UPDATING for any pre-buildworld steps
necessary for that version of the sources. Then, use the procedure outlined
here.

These upgrade steps assume an upgrade from an older FreeBSD version, consisting
of an old compiler, old kernel, old world, and old configuration files. â  
Worldâ   includes the core system binaries, libraries, and programming files.
The compiler is part of â  worldâ  , but has a few special concerns.

These steps also assume that the sources to a newer version have already been
obtained. If the sources are not up-to-date, refer to SectionÂ 25.6, â  
Synchronizing Sourceâ   for detailed help about synchronizing to a newer
version.

Updating the system from source is a more subtle process than it might
initially seem to be, and the FreeBSD developers have found it necessary over
the years to change the recommended approach fairly dramatically as new kinds
of unavoidable dependencies come to light. The rest of this section describes
the rationale behind the currently recommended upgrade sequence.

Any successful update sequence must deal with the following issues:

  * The old compiler might have a bug and not be able to compile the new
    kernel. So, the new kernel should be built with the new compiler, meaning
    that the new compiler must be built before the new kernel is built. This
    does not necessarily mean that the new compiler must be installed before
    building the new kernel.

  * The new world might rely on new kernel features. So, the new kernel must be
    installed before the new world is installed.

These first two issues are the basis for the core buildworld, buildkernel,
installkernel, installworld sequence described in the following paragraphs.
Other reasons for using these steps are listed below:

  * The old world might not run correctly on the new kernel, so the new world
    must be installed immediately upon installing the new kernel.

  * Some configuration changes must be made before the new world is installed,
    but others might break the old world. Hence, two different configuration
    upgrade steps are generally needed.

  * For the most part, the update process only replaces or adds files and
    existing old files are not deleted. In a few cases, this can cause
    problems. As a result, the update procedure will sometimes specify certain
    files that should be manually deleted at certain steps. This may or may not
    be automated in the future.

These concerns have led to the following recommended sequence. Note that the
detailed sequence for particular updates may require additional steps, but this
core process should remain unchanged for some time:

 1. make buildworld

    This first compiles the new compiler and a few related tools, then uses the
    new compiler to compile the rest of the new world. The result ends up in /
    usr/obj.

 2. make buildkernel

    This uses the new compiler residing in /usr/obj in order to protect against
    compiler-kernel mismatches.

 3. make installkernel

    Place the new kernel and kernel modules onto the disk, making it possible
    to boot with the newly updated kernel.

 4. Reboot into single user mode.

    Single user mode minimizes problems from updating software that is already
    running. It also minimizes any problems from running the old world on a new
    kernel.

 5. mergemaster -p

    This does some initial configuration file updates in preparation for the
    new world. For instance, it may add new user groups to the system, or new
    user names to the password database. This is often necessary when new
    groups or special system-user accounts have been added since the last
    update, so that the installworld step will be able to use the newly
    installed system user or system group names without problems.

 6. make installworld

    Copies the world from /usr/obj. The new kernel and new world are now
    installed on disk.

 7. mergemaster

    Repeated to update the remaining configuration files, now that the new
    world is on disk.

 8. make delete-old

    This target deletes old (obsolete) files. This is important because
    sometimes they cause problems if left on the disk, for example the presence
    of the old utmp.h causes problems in some ports when the new utmpx.h is
    installed.

 9. Reboot.

    A full machine reboot is needed now to load the new kernel and new world
    with new configuration files.

10. make delete-old-libs

    Remove any obsolete libraries to avoid conflicts with newer ones. Make sure
    that all ports have been rebuilt before old libraries are removed.

Upgrades from one release of the same FreeBSD branch to a more recent release
of the same branch, such as from 9.0 to 9.1, may not need this procedure since
it is less likely to run into serious mismatches between compiler, kernel,
userland, and configuration files. The approach of make world followed by
building and installing a new kernel might work well enough for minor updates.

When upgrading across major releases, people who do not follow this procedure
should expect some problems.

It is also worth noting that many upgrades may require specific additional
steps such as renaming or deleting specific files prior to installworld. Read /
usr/src/UPDATING carefully, especially at the end, where the currently
recommended upgrade sequence is explicitly spelled out.

This procedure has evolved over time as the developers have found it impossible
to completely prevent certain kinds of mismatch problems. Hopefully, the
current procedure will remain stable for a long time.

To summarize, the currently recommended way of upgrading FreeBSD from sources
is:

# cd /usr/src # make buildworld # make buildkernel # make installkernel #
shutdown -r now

Note:

There are a few rare cases when an extra run of mergemaster -p is needed before
the buildworld step. These are described in UPDATING. In general, though, this
step can safely be omitted when not updating across one or more major FreeBSD
versions.

After installkernel finishes successfully, boot into single user mode using
boot -s from the loader prompt. Then run:

# mount -u / # mount -a -t ufs # adjkerntz -i # mergemaster -p # cd /usr/src #
make installworld # mergemaster # make delete-old # reboot # make
delete-old-libs

Read Further Explanations:

The following sections clearly describe each step, especially when using a
custom kernel configuration.

25.7.2.Â Read /usr/src/UPDATING

Before updating, read /usr/src/UPDATING. This file contains important
information about potential problems and may specify the order to run certain
commands. If UPDATING contradicts the procedure in this section, UPDATING takes
precedence.

Important:

Reading UPDATING is not an acceptable substitute for subscribing to the correct
mailing list. The two requirements are complementary, not exclusive.

25.7.3.Â Check /etc/make.conf

Available make(1) options are shown in make.conf(5) and /usr/share/examples/etc
/make.conf. These settings can be added to /etc/make.conf to control the way
make(1) runs and how it builds programs. Changes to some settings can have
far-reaching and potentially surprising effects. Read the comments in both
locations and keep in mind that the defaults have been chosen for a combination
of performance and safety.

Options set in /etc/make.conf take effect every time make(1) is used, including
compiling applications from the Ports Collection or user-written C programs, or
building the FreeBSD operating system.

25.7.4.Â Check /etc/src.conf

/etc/src.conf controls the building of the operating system from source code.
Unlike /etc/make.conf, the contents of /etc/src.conf only take effect when the
FreeBSD operating system itself is being built. Descriptions of the many
options available for this file are shown in src.conf(5). Be cautious about
disabling seemingly unneeded kernel modules and build options. Sometimes there
are unexpected or subtle interactions.

25.7.5.Â Update the Files in /etc

/etc contains a large part of the system's configuration information, as well
as scripts that are run at system startup. Some of these scripts change between
FreeBSD versions.

Some of the configuration files are used in the day to day running of the
system, such as /etc/group.

There have been occasions when the installation part of make installworld
expected certain usernames or groups to exist. When performing an upgrade, it
is likely that these users or groups do not yet exist. In some cases make
buildworld will check to see if these users or groups exist.

The solution is to run mergemaster(8) in pre-buildworld mode with -p. This
compares only those files that are essential for the success of buildworld or
installworld.

Tip:

To check which files are owned by the group being renamed or deleted:

# find / -group GID -print

This command will show all files owned by group GID, which can be either a
group name or a numeric group ID.

25.7.6.Â Drop to Single User Mode

Consider compiling the system in single user mode. Reinstalling the system
touches a lot of important system files, all the standard system binaries,
libraries, and include files. Changing these on a running system, particularly
one with active users, is asking for trouble.

Another method is to compile the system in multi-user mode, and then drop into
single user mode for the installation. With this method, hold off on the
following steps until the build has completed. Drop to single user mode in
order to run installkernel or installworld.

To enter single user mode from a running system:

# shutdown now

Alternatively, reboot the system, and at the boot prompt, select the â  single
userâ   option. Once at the single user mode shell prompt, run:

# fsck -p # mount -u / # mount -a -t ufs # swapon -a

This checks the file systems, remounts / read/write, mounts all the other UFS
file systems referenced in /etc/fstab, and turns swapping on.

Note:

If the CMOS clock is set to local time and not to GMT (this is true if the
output of date(1) does not show the correct time and zone), run the following
command:

# adjkerntz -i

This ensures that the local time-zone settings get set up correctly.

25.7.7.Â Remove /usr/obj

As parts of the system are rebuilt, they are, by default, placed in
subdirectories of /usr/obj. The directories shadow those under /usr/src.

To speed up the make buildworld process, and possibly save some dependency
headaches, remove this directory if it already exists.

Some files below /usr/obj may have the immutable flag set which must be removed
first using chflags(1).

# cd /usr/obj # chflags -R noschg * # rm -rf *

25.7.8.Â Recompile the Base System

25.7.8.1.Â Saving the Output

It is a good idea to save the output from running make(1) to a file. If
something goes wrong, a copy of the error message can be posted to one of the
FreeBSD mailing lists.

The easiest way to do this is to use script(1) with a parameter that specifies
the name of the file to save all output to. Run this command immediately before
rebuilding the world, and then type exit when the process has finished:

# script /var/tmp/mw.out Script started, output file is /var/tmp/mw.out # make
TARGET â Š compile, compile, compile â Š # exit Script done, â Š

Do not save the output in /tmp as this directory may be cleared at next reboot.
A better place to save the file is /var/tmp or in root's home directory.

25.7.8.2.Â Compile the Base System

While in /usr/src type:

# cd /usr/src

To rebuild the world, use make(1). This command reads instructions from the
Makefile, which describes how the programs that comprise FreeBSD should be
built and the order in which they should be built.

The general format of the command is as follows:

# make -x -DVARIABLE target

In this example, -x is an option passed to make(1). Refer to make(1) for an
examples of available options.

-DVARIABLE passes a variable to the Makefile. The behavior of the Makefile is
controlled by these variables. These are the same variables as are set in /etc/
make.conf, and this provides another way of setting them. For example:

# make -DNO_PROFILE target

is another way of specifying that profiled libraries should not be built, and
corresponds with the

NO_PROFILE= true # Avoid compiling profiled libraries

line in /etc/make.conf.

target tells make(1) what to do. Each Makefile defines a number of different â 
 targetsâ  , and the choice of target determines what happens.

Some targets listed in the Makefile are used by the build process to break out
the steps necessary to rebuild the system into a number of sub-steps.

Most of the time, no parameters need to be passed to make(1) and the command
looks like this:

# make target

Where target is one of many build options. The first target should always be
buildworld.

As the names imply, buildworld builds a complete new tree under /usr/obj and
installworld installs this tree on the current machine.

Having separate options is useful for two reasons. First, it allows for a â  
self hostedâ   build that does not affect any components of a running system.
Because of this, buildworld can be run on a machine running in multi-user mode
with no fear of ill-effects. It is still recommended that installworld be run
in part in single user mode, though.

Secondly, it allows NFS mounts to be used to upgrade multiple machines on a
network. If order to upgrade three machines, A, B and C, run make buildworld
and make installworld on A. B and C should then NFS mount /usr/src and /usr/obj
from A, and run make installworld to install the results of the build on B and
C.

Although the world target still exists, users are strongly encouraged not to
use it.

Instead, run:

# make buildworld

It is possible to specify -j which will cause make to spawn several
simultaneous processes. This is most useful on multi-CPU machines. However,
since much of the compiling process is I/O bound rather than CPU bound, it is
also useful on single CPU machines.

On a typical single-CPU machine, run:

# make -j4 buildworld

make(1) will then have up to 4 processes running at any one time. Empirical
evidence posted to the mailing lists shows this generally gives the best
performance benefit.

On a multi-CPU machine using an SMP configured kernel, try values between 6 and
10 and see how they speed things up.

25.7.8.3.Â Timings

Many factors influence the build time, but fairly recent machines may only take
a one or two hours to build the FreeBSD-STABLE tree, with no tricks or
shortcuts used during the process. A FreeBSD-CURRENT tree will take somewhat
longer.

25.7.9.Â Compile and Install a New Kernel

To take full advantage of the new system, recompile the kernel. This is
practically a necessity, as certain memory structures may have changed, and
programs like ps(1) and top(1) will fail to work until the kernel and source
code versions are the same.

The simplest, safest way to do this is to build and install a kernel based on
GENERIC. While GENERIC may not have all the necessary devices for the system,
it should contain everything necessary to boot the system back to single user
mode. This is a good test that the new system works properly. After booting
from GENERIC and verifying that the system works, a new kernel can be built
based on a custom kernel configuration file.

On FreeBSD it is important to build world before building a new kernel.

Note:

To build a custom kernel with an existing customized configuration file, use
KERNCONF=MYKERNEL:

# cd /usr/src # make buildkernel KERNCONF=MYKERNEL # make installkernel
KERNCONF=MYKERNEL

If kern.securelevel has been raised above 1 and noschg or similar flags have
been set on the kernel binary, drop into single user mode to use installkernel.
Otherwise, both these commands can be run from multi user mode without
problems. See init(8) for details about kern.securelevel and chflags(1) for
details about the various file flags.

25.7.10.Â Reboot into Single User Mode

Reboot into single user mode to test that the new kernel works using the
instructions in SectionÂ 25.7.6, â  Drop to Single User Modeâ  .

25.7.11.Â Install the New System Binaries

Next, use installworld to install the new system binaries:

# cd /usr/src # make installworld

Note:

If variables were specified to make buildworld, specify the same variables to
make installworld. However, -j must never be used with installworld.

For example, if you ran:

# make -DNO_PROFILE buildworld

install the results with:

# make -DNO_PROFILE installworld

otherwise, the command will try to install profiled libraries that were not
built during the make buildworld phase.

25.7.12.Â Update Files Not Updated by make installworld

Remaking the world will not update certain directories, such as /etc, /var and
/usr, with new or changed configuration files.

The simplest way to update the files in these directories is to use mergemaster
(8). Be sure to first make a backup of /etc in case anything goes wrong.

25.7.12.1.Â mergemaster

Contributed by Tom Rhodes.

mergemaster(8) is a Bourne script to aid in determining the differences between
the configuration files in /etc, and the configuration files in the source tree
/usr/src/etc. This is the recommended solution for keeping the system
configuration files up to date with those located in the source tree.

To begin, type mergemaster and it will build a temporary root environment, from
/ down, and populate it with various system configuration files. Those files
are then compared to the ones currently installed in the system. Files that
differ will be shown in diff(1) format, with the + sign representing added or
modified lines, and - representing lines that will be either removed
completely, or replaced with a new file. Refer to diff(1) for more information
about the diff(1) syntax and how file differences are shown.

mergemaster(8) will then display each file that differs, and present the
options of either deleting the new file, referred to as the temporary file,
installing the temporary file in its unmodified state, merging the temporary
file with the currently installed file, or viewing the diff(1) results again.

Choosing to delete the temporary file will tell mergemaster(8) to keep the
current file unchanged and to delete the new version. This option is not
recommended, unless there is no reason to change the current file. To get help
at any time, type ? at the mergemaster(8) prompt. If the user chooses to skip a
file, it will be presented again after all other files have been dealt with.

Choosing to install the unmodified temporary file will replace the current file
with the new one. For most unmodified files, this is the best option.

Choosing to merge the file will present a text editor, and the contents of both
files. The files can be merged by reviewing both files side by side on the
screen, and choosing parts from both to create a finished product. When the
files are compared side by side, l selects the left contents and r selects
contents from the right. The final output will be a file consisting of both
parts, which can then be installed. This option is customarily used for files
where settings have been modified by the user.

Choosing to view the diff(1) results again will display the file differences
just like mergemaster(8) did before prompting an option.

After mergemaster(8) is done with the system files, it will prompt for other
options. mergemaster(8) may prompt to rebuild the password file and will finish
up with an option to remove left-over temporary files.

25.7.12.2.Â Manual Update

To perform the update manually instead, do not just copy over the files from /
usr/src/etc to /etc and expect it to work. Some files must be â  installedâ  
first as /usr/src/etc is not a copy of what /etc should look like. In addition,
some files that should be in /etc are not in /usr/src/etc.

If you are using mergemaster(8) (as recommended), you can skip forward to the
next section.

The simplest way to merge files by hand is to install the files into a new
directory, and then work through them looking for differences.

Backup Your Existing /etc:

It is recommended to first copy the existing /etc somewhere safe, like so:

# cp -Rp /etc /etc.old

where -R does a recursive copy and -p preserves times and the ownerships on
files.

Build a temporary set of directories into which the new /etc and other files
can be installed:

# mkdir /var/tmp/root # cd /usr/src/etc # make DESTDIR=/var/tmp/root
distrib-dirs distribution

This will build the necessary directory structure and install the files. A lot
of the subdirectories that have been created under /var/tmp/root are empty and
should be deleted. The simplest way to do this is to:

# cd /var/tmp/root # find -d . -type d | xargs rmdir 2&gt;/dev/null

This will remove all empty directories while redirecting standard error to /dev
/null to prevent the warnings about the directories that are not empty.

/var/tmp/root now contains all the files that should be placed in appropriate
locations below /. Go through each of these files, determining how they differ
from the system's existing files.

Some of the files installed into /var/tmp/root have a leading â  .â  . Make
sure to use ls -a in order to catch them.

The simplest way to compare files is to use diff(1):

# diff /etc/shells /var/tmp/root/etc/shells

This command will show the differences between the existing /etc/shells and the
new /var/tmp/root/etc/shells. Review the differences to decide whether to merge
in custom changes or to replace the existing file with the new one.

Name the New Root Directory (/var/tmp/root) with a Time Stamp, so You Can
Easily Compare Differences Between Versions:

Frequently rebuilding world entails frequently updating /etc as well, which can
be a bit of a chore.

To speed up this process, use the following procedure to keep a copy of the
last set of changed files that were merged into /etc.

 1. Make the world as normal. When updating /etc and the other directories,
    give the target directory a name based on the current date:

    # mkdir /var/tmp/root-20130214 # cd /usr/src/etc # make DESTDIR=/var/tmp/
    root-20130214 \ distrib-dirs distribution
 2. Merge in the changes from this directory as outlined above. Do not remove
    the /var/tmp/root-20130214 directory when you have finished.

 3. After downloading the latest version of the source and remaking it, follow
    step 1. Create a new directory, which reflects the new date. This example
    uses /var/tmp/root-20130221.

 4. Use diff(1) to see the differences that have been made in the intervening
    week by creating a recursive diff between the two directories:

    # cd /var/tmp # diff -r root-20130214 root-20130221

    Typically, this will be a much smaller set of differences than those
    between /var/tmp/root-20130221/etc and /etc. Because the set of differences
    is smaller, it is easier to migrate those changes across into /etc.

 5. When finished, remove the older of the two /var/tmp/root-* directories:

    # rm -rf /var/tmp/root-20130214
 6. Repeat this process whenever merging in changes to /etc.

Use date(1) to automate the generation of the directory names:

# mkdir /var/tmp/root-`date "+%Y%m%d"`

25.7.13.Â Deleting Obsolete Files and Directories

Based on notes provided by Anton Shterenlikht.

As a part of the FreeBSD development lifecycle, files and their contents
occasionally become obsolete. This may be because functionality is implemented
elsewhere, the version number of the library has changed, or it was removed
from the system entirely. This includes old files, libraries, and directories,
which should be removed when updating the system. The benefit is that the
system is not cluttered with old files which take up unnecessary space on the
storage and backup media. Additionally, if the old library has a security or
stability issue, the system should be updated to the newer library to keep it
safe and to prevent crashes caused by the old library. Files, directories, and
libraries which are considered obsolete are listed in /usr/src/
ObsoleteFiles.inc. The following instructions should be used to remove obsolete
files during the system upgrade process.

After the make installworld and the subsequent mergemaster have finished
successfully, check for obsolete files and libraries as follows:

# cd /usr/src # make check-old

If any obsolete files are found, they can be deleted using the following
command:

# make delete-old

Tip:

Refer to /usr/src/Makefile for more targets of interest.

A prompt is displayed before deleting each obsolete file. To skip the prompt
and let the system remove these files automatically, use
BATCH_DELETE_OLD_FILES:

# make -DBATCH_DELETE_OLD_FILES delete-old

The same goal can be achieved by piping these commands through yes:

# yes|make delete-old

25.7.14.Â Rebooting

Verify that everything appears to be in the right place, then reboot the system
using shutdown(8):

# shutdown -r now

25.7.15.Â Deleting obsolete libraries

Warning:

Deleting obsolete files will break applications that still depend on those
obsolete files. This is especially true for old libraries. In most cases, the
programs, ports, or libraries that used the old library need to be recompiled
before make delete-old-libs is executed.

Utilities for checking shared library dependencies are available from the Ports
Collection in sysutils/libchk or sysutils/bsdadminscripts.

Obsolete shared libraries can conflict with newer libraries, causing messages
like these:

/usr/bin/ld: warning: libz.so.4, needed by /usr/local/lib/libtiff.so, may
conflict with libz.so.5 /usr/bin/ld: warning: librpcsvc.so.4, needed by /usr/
local/lib/libXext.so, may conflict with librpcsvc.so.5

To solve these problems, determine which port installed the library:

# pkg_info -W /usr/local/lib/libtiff.so /usr/local/lib/libtiff.so was installed
by package tiff-3.9.4 # pkg_info -W /usr/local/lib/libXext.so /usr/local/lib/
libXext.so was installed by package libXext-1.1.1,1

Then deinstall, rebuild and reinstall the port. ports-mgmt/portmaster can be
used to automate this process. After all ports are rebuilt and no longer use
the old libraries, delete the old libraries using the following command:

# make delete-old-libs

You should now have successfully upgraded the FreeBSD system. Congratulations.

If things went slightly wrong, it is easy to rebuild a particular piece of the
system. For example, if /etc/magic was accidentally deleted as part of the
upgrade or merge of /etc, file(1) will stop working. To fix this, run:

# cd /usr/src/usr.bin/file # make all install

25.7.16.Â Questions

25.7.16.1. Do I need to re-make the world for every change?
25.7.16.2. My compile failed with lots of signal 11 (or other signal number)
    errors. What happened?
25.7.16.3. Can /usr/obj be removed when finished?
25.7.16.4. Can interrupted builds be resumed?
25.7.16.5. How can I speed up making the world?
25.7.16.6. What do I do if something goes wrong?

25.7.16.1. Do I need to re-make the world for every change?

           There is no easy answer, as it depends on the nature of the change.
           For example, if running svn only shows the following files as being
           updated:

           src/games/cribbage/instr.c src/games/sail/pl_main.c src/release/
           sysinstall/config.c src/release/sysinstall/media.c src/share/mk/
           bsd.port.mk

           it probably is not worth rebuilding the entire world. Instead, go
           into the appropriate sub-directories and run make all install. But
           if something major changed, such as src/lib/libc/stdlib, either
           re-make world, or at least those parts of it that are statically
           linked.

           At the end of the day, it is your call. Some users re-make the world
           every fortnight and let changes accumulate over that fortnight.
           Others only re-make those things that have changed and are careful
           to spot all the dependencies.

           It all depends on how often a user wants to upgrade and whether they
           are tracking FreeBSD-STABLE or FreeBSD-CURRENT.

25.7.16.2. My compile failed with lots of signal 11 (or other signal number)
           errors. What happened?

           This normally indicates hardware problems. (Re)making world is an
           effective way to stress test hardware, and will frequently throw up
           memory problems which normally manifest themselves as the compiler
           mysteriously aborts.

           A sure indicator of this occurs when make is restarted and it dies
           at a different point in the process.

           To resolve this error, start swapping around the components in the
           machine to determine which one is failing.

25.7.16.3. Can /usr/obj be removed when finished?

           The short answer is yes.

           /usr/obj contains all the object files that were produced during the
           compilation phase. Normally, one of the first steps in the make
           buildworld process is to remove this directory and start afresh.
           Keeping /usr/obj around when finished makes little sense, and its
           removal frees up a approximately 2Â GB of disk space.

           Advances users can instruct make buildworld to skip this step. This
           speeds up subsequent builds, since most of the sources will not need
           to be recompiled. The flip side is that subtle dependency problems
           can creep in, causing the build to fail in odd ways. This frequently
           generates noise on the FreeBSD mailing lists, when one person
           complains that their build has failed, not realizing that it is
           because they have tried to cut corners.

25.7.16.4. Can interrupted builds be resumed?

           This depends on how far into the process the problem occurs.

           In general, make buildworld builds new copies of essential tools,
           such as gcc(1) and make(1), and the system libraries. These tools
           and libraries are then installed, used to rebuild themselves, and
           are installed again. The entire system, including regular user
           programs such as ls(1) or grep(1), is then rebuilt with the new
           system files.

           During the last stage, it is fairly safe to:

           â Š fix the problem â Š # cd /usr/src # make -DNO_CLEAN all

           This will not undo the work of the previous make buildworld.

           If you see the message:

           --------------------------------------------------------------
           Building everything..
           --------------------------------------------------------------

           in the make buildworld output, it is probably fairly safe to do so.

           If that message is not displayed, or you are not sure, it is always
           better to be safe than sorry, and restart the build from scratch.

25.7.16.5. How can I speed up making the world?

             * Run it in single user mode.

             * Put /usr/src and /usr/obj on separate file systems held on
               separate disks. If possible, put these disks on separate disk
               controllers.

             * Alternately, put these file systems across multiple disks using
               ccd(4).

             * Turn off profiling by setting â  NO_PROFILE=trueâ   in /etc/
               make.conf.

             * Pass -jn to make(1) to run multiple processes in parallel. This
               usually helps on both single and multi processor machines.

             * The file system holding /usr/src can be mounted or remounted
               with noatime. This prevents the file system from recording the
               file access time which is probably not needed.

               # mount -u -o noatime /usr/src

               Warning:

               This example assumes /usr/src is on its own file system. If it
               is part of /usr, then use that file system mount point instead.

             * The file system holding /usr/obj can be mounted or remounted
               with async so that disk writes happen asynchronously. The write
               completes immediately, and the data is written to the disk a few
               seconds later. This allows writes to be clustered together, and
               can provide a dramatic performance boost.

               Warning:

               Keep in mind that this option makes the file system more
               fragile. With this option, there is an increased chance that,
               should power fail, the file system will be in an unrecoverable
               state when the machine restarts.

               If /usr/obj is the only directory on this file system, this is
               not a problem. If you have other, valuable data on the same file
               system, ensure that there are verified backups before enabling
               this option.

               # mount -u -o async /usr/obj

               Warning:

               If /usr/obj is not on its own file system, replace it in the
               example with the name of the appropriate mount point.

25.7.16.6. What do I do if something goes wrong?

           Make absolutely sure that the environment has no extraneous cruft
           from earlier builds:

           # chflags -R noschg /usr/obj/usr # rm -rf /usr/obj/usr # cd /usr/src
           # make cleandir # make cleandir

           Yes, make cleandir really should be run twice.

           Then, restart the whole process, starting with make buildworld.

           If problems persist, send the error and the output of uname -a to
           FreeBSD general questions mailing list. Be prepared to answer other
           questions about the setup!

25.8.Â Tracking for Multiple Machines

Contributed by Mike Meyer.

When multiple machines need to track the same source tree, it is a waste of
disk space, network bandwidth, and CPU cycles to have each system download the
sources and rebuild everything. The solution is to have one machine do most of
the work, while the rest of the machines mount that work via NFS. This section
outlines a method of doing so.

25.8.1.Â Preliminaries

First, identify a set of machines which will run the same set of binaries,
known as a build set. Each machine can have a custom kernel, but will run the
same userland binaries. From that set, choose a machine to be the build machine
that the world and kernel are built on. Ideally, this is a fast machine that
has sufficient spare CPU to run make buildworld and make buildkernel. Select a
machine to be the test machine, which will test software updates before they
are put into production. This must be a machine that can afford to be down for
an extended period of time. It can be the build machine, but need not be.

All the machines in this build set need to mount /usr/obj and /usr/src from the
same machine, and at the same point. Ideally, those directories are on two
different drives on the build machine, but they can be NFS mounted on that
machine as well. For multiple build sets, /usr/src should be on one build
machine, and NFS mounted on the rest.

Finally, ensure that /etc/make.conf and /etc/src.conf on all the machines in
the build set agree with the build machine. That means that the build machine
must build all the parts of the base system that any machine in the build set
is going to install. Also, each build machine should have its kernel name set
with KERNCONF in /etc/make.conf, and the build machine should list them all in
KERNCONF, listing its own kernel first. The build machine must have the kernel
configuration files for each machine in /usr/src/sys/arch/conf if it is going
to build their kernels.

25.8.2.Â The Base System

On the build machine, build the kernel and world as described in
SectionÂ 25.7.8.2, â  Compile the Base Systemâ  , but do not install anything.
After the build has finished, go to the test machine, and install the built
kernel. If this machine mounts /usr/src and /usr/obj via NFS, enable the
network and mount these directories after rebooting to single user mode. The
easiest way to do this is to boot to multi-user, then run shutdown now to go to
single user mode. Once there, install the new kernel and world and run
mergemaster as usual. When done, reboot to return to normal multi-user
operations for this machine.

After verifying that everything on the test machine is working properly, use
the same procedure to install the new software on each of the other machines in
the build set.

25.8.3.Â Ports

The same ideas can be used for the ports tree. The first critical step is to
mount /usr/ports from the same machine to all the machines in the build set.
Then, configure /etc/make.conf properly to share distfiles. Set DISTDIR to a
common shared directory that is writable by whichever user root is mapped to by
the NFS mounts. Each machine should set WRKDIRPREFIX to a local build
directory. Finally, if the system is to build and distribute packages, set
PACKAGES to a directory similar to DISTDIR.


------------

^[7] For a complete description of the current security policy for old releases
of FreeBSD, refer to http://www.FreeBSD.org/security/.

ChapterÂ 26.Â DTrace

Written by Tom Rhodes.
Table of Contents

26.1. Synopsis
26.2. Implementation Differences
26.3. Enabling DTrace Support
26.4. Using DTrace
26.5. The D Language

26.1.Â Synopsis

DTrace, also known as Dynamic Tracing, was developed by Sunâ ¢ as a tool for
locating performance bottlenecks in production and pre-production systems. It
is not, in any way, a debugging tool, but a tool for real time system analysis
to locate performance and other issues.

DTrace is a remarkable profiling tool, with an impressive array of features for
diagnosing system issues. It may also be used to run pre-written scripts to
take advantage of its capabilities. Users may even author their own utilities
using the DTrace D Language, allowing them to customize their profiling based
on specific needs.

After reading this chapter, you will know:

  * What DTrace is and what features it provides.

  * Differences between the Solarisâ ¢ DTrace implementation and the one
    provided by FreeBSD.

  * How to enable and use DTrace on FreeBSD.

Before reading this chapter, you should:

  * Understand UNIXÂ® and FreeBSD basics (ChapterÂ 4, UNIX Basics).

  * Be familiar with the basics of kernel configuration/compilation (
    ChapterÂ 9, Configuring the FreeBSD Kernel).

  * Have some familiarity with security and how it pertains to FreeBSD (
    ChapterÂ 15, Security).

  * Understand how to obtain and rebuild the FreeBSD sources (ChapterÂ 25, 
    Updating and Upgrading FreeBSD).

Warning:

This feature is considered experimental. Some options may be lacking in
functionality, other parts may not work at all. In time, this feature will be
considered production ready and this documentation will be altered to fit that
situation.

26.2.Â Implementation Differences

While the DTrace in FreeBSD is very similar to that found in Solarisâ ¢,
differences exist that should be explained before continuing. The primary
difference users will notice is that on FreeBSD, DTrace needs to be
specifically enabled. There are kernel options and modules which must be
enabled for DTrace to work properly. These will be explained later.

There is a DDB_CTF kernel option which is used to enable support for loading
the CTF data from kernel modules and the kernel itself. CTF is the Solarisâ ¢
Compact C Type Format which encapsulates a reduced form of debugging
information similar to DWARF and the venerable stabs. This CTF data is added to
the binaries by the ctfconvert and ctfmerge build tools. The ctfconvert utility
parses DWARF ELF debug sections created by the compiler and ctfmerge merges CTF
ELF sections from objects into either executables or shared libraries. More on
how to enable this for the kernel and FreeBSD build is forthcoming.

Some different providers exist for FreeBSD than for Solarisâ ¢. Most notable is
the dtmalloc provider, which allows tracing malloc() by type in the FreeBSD
kernel.

Only root may use DTrace on FreeBSD. This is related to security differences, 
Solarisâ ¢ has a few low level security checks which do not yet exist in
FreeBSD. As such, the /dev/dtrace/dtrace is strictly limited to root users
only.

Finally, the DTrace software falls under Sunâ ¢'s CDDL license. The Common
Development and Distribution License comes with FreeBSD, see the /usr/src/cddl/
contrib/opensolaris/OPENSOLARIS.LICENSE or view it online at http://
www.opensolaris.org/os/licensing.

This license means that a FreeBSD kernel with the DTrace options is still BSD
licensed; however the CDDL kicks in when the modules are distributed in binary
form, or the binaries are loaded.

26.3.Â Enabling DTrace Support

To enable support for DTrace, add the following lines to the kernel
configuration file:

options KDTRACE_HOOKS options DDB_CTF

Note:

Users of the AMD64 architecture will want to add the following line to their
kernel configuration file:

options KDTRACE_FRAME

This option provides support for the FBT feature. DTrace will work without this
option; however, there will be limited support for function boundary tracing.

All sources must be rebuilt and installed with CTF options. To accomplish this
task, rebuild the FreeBSD sources using:

# cd /usr/src # make WITH_CTF=1 kernel

The system will need to be restarted.

After rebooting and allowing the new kernel to be loaded into memory, support
for the Korn shell should be added. This is needed as the DTraceToolkit has
several utilities written in ksh. Install the shells/ksh93. It is also possible
to run these tools under shells/pdksh or shells/mksh.

Finally, obtain the current DTraceToolkit. If you are running FreeBSD 10, you
will find the DTraceToolkit in /usr/share/dtrace. Otherwise, you can install
the DTraceToolkit using the sysutils/DTraceToolkit port.

26.4.Â Using DTrace

Before making use of DTrace functionality, the DTrace device must exist. To
load the device, issue the following command:

# kldload dtraceall

DTrace support should now be available. To view all probes the administrator
may now execute the following command:

# dtrace -l | more

All output is passed to the more utility as it will quickly overflow the screen
buffer. At this point, DTrace should be considered working. It is now time to
review the toolkit.

The toolkit is a collection of ready-made scripts to run with DTrace to collect
system information. There are scripts to check open files, memory, CPU usage
and a lot more. Extract the scripts with the following command:

# gunzip -c DTraceToolkit* | tar xvf -

Change into that directory with the cd and change the execution permissions on
all files, designated as those files with lower case names, to 755.

All of these scripts will need modifications to their contents. The ones which
refer to /usr/bin/ksh need that changed to /usr/local/bin/ksh, the others which
use /usr/bin/sh need to be altered to use /bin/sh, and finally the ones which
use /usr/bin/perl will need altered to use /usr/local/bin/perl.

Important:

At this point it is prudent to remind the reader that DTrace support in FreeBSD
is incomplete and experimental. Many of these scripts will not work as they are
either too Solarisâ ¢-specific or use probes which are unsupported at this
time.

At the time of this writing only two of the scripts of the DTrace Toolkit are
fully supported in FreeBSD: the hotkernel and procsystime scripts. These are
the two we will explore in the following parts of this section.

The hotkernel is designed to identify which function is using the most kernel
time. Run normally, it will produce output similar to the following:

# cd /usr/share/dtrace/toolkit # ./hotkernel Sampling... Hit Ctrl-C to end.

The system administrator must use the Ctrl+C key combination to stop the
process. Upon termination, the script will display a list of kernel functions
and timing information, sorting the output in increasing order of time:

kernel`_thread_lock_flags 2 0.0% 0xc1097063 2 0.0% kernel`sched_userret 2 0.0%
kernel`kern_select 2 0.0% kernel`generic_copyin 3 0.0% kernel`_mtx_assert 3
0.0% kernel`vm_fault 3 0.0% kernel`sopoll_generic 3 0.0% kernel`fixup_filename
4 0.0% kernel`_isitmyx 4 0.0% kernel`find_instance 4 0.0% kernel
`_mtx_unlock_flags 5 0.0% kernel`syscall 5 0.0% kernel`DELAY 5 0.0% 0xc108a253
6 0.0% kernel`witness_lock 7 0.0% kernel`read_aux_data_no_wait 7 0.0% kernel
`Xint0x80_syscall 7 0.0% kernel`witness_checkorder 7 0.0% kernel`sse2_pagezero
8 0.0% kernel`strncmp 9 0.0% kernel`spinlock_exit 10 0.0% kernel
`_mtx_lock_flags 11 0.0% kernel`witness_unlock 15 0.0% kernel`sched_idletd 137
0.3% 0xc10981a5 42139 99.3%

This script will also work with kernel modules. To use this feature, run the
script with the -m flag:

# ./hotkernel -m Sampling... Hit Ctrl-C to end. ^C MODULE COUNT PCNT 0xc107882e
1 0.0% 0xc10e6aa4 1 0.0% 0xc1076983 1 0.0% 0xc109708a 1 0.0% 0xc1075a5d 1 0.0%
0xc1077325 1 0.0% 0xc108a245 1 0.0% 0xc107730d 1 0.0% 0xc1097063 2 0.0%
0xc108a253 73 0.0% kernel 874 0.4% 0xc10981a5 213781 99.6%

The procsystime script captures and prints the system call time usage for a
given PID or process name. In the following example, a new instance of /bin/csh
was spawned. The procsystime was executed and remained waiting while a few
commands were typed on the other incarnation of csh. These are the results of
this test:

# ./procsystime -n csh Tracing... Hit Ctrl-C to end... ^C Elapsed Times for
processes csh, SYSCALL TIME (ns) getpid 6131 sigreturn 8121 close 19127 fcntl
19959 dup 26955 setpgid 28070 stat 31899 setitimer 40938 wait4 62717 sigaction
67372 sigprocmask 119091 gettimeofday 183710 write 263242 execve 492547 ioctl
770073 vfork 3258923 sigsuspend 6985124 read 3988049784

As shown, the read() system call seems to use the most time in nanoseconds with
the getpid() system call used the least amount of time.

26.5.Â The D Language

The DTrace Toolkit includes many scripts in the special language of DTrace.
This language is called â  the D languageâ   by Sunâ ¢ documentation, and it is
very similar to C++. An in depth discussion of the language is beyond the scope
of this document. It is extensively discussed at http://wikis.oracle.com/
display/DTrace/Documentation.

PartÂ IV.Â Network Communication

FreeBSD is one of the most widely deployed operating systems for high
performance network servers. The chapters in this part cover:

  * Serial communication

  * PPP and PPP over Ethernet

  * Electronic Mail

  * Running Network Servers

  * Firewalls

  * Other Advanced Networking Topics

These chapters are designed to be read when you need the information. You do
not have to read them in any particular order, nor do you need to read all of
them before you can begin using FreeBSD in a network environment.

Table of Contents

27. Serial Communications

    27.1. Synopsis
    27.2. Introduction
    27.3. Terminals
    27.4. Dial-in Service
    27.5. Dial-out Service
    27.6. Setting Up the Serial Console

28. PPP and SLIP

    28.1. Synopsis
    28.2. Using User PPP
    28.3. Using Kernel PPP
    28.4. Troubleshooting PPP Connections
    28.5. Using PPP over Ethernet (PPPoE)
    28.6. Using PPP over ATM (PPPoA)
    28.7. Using SLIP

29. Electronic Mail

    29.1. Synopsis
    29.2. Using Electronic Mail
    29.3. sendmail Configuration
    29.4. Changing Your Mail Transfer Agent
    29.5. Troubleshooting
    29.6. Advanced Topics
    29.7. Setting Up to Send Only
    29.8. Using Mail with a Dialup Connection
    29.9. SMTP Authentication
    29.10. Mail User Agents
    29.11. Using fetchmail
    29.12. Using procmail

30. Network Servers

    30.1. Synopsis
    30.2. The inetd â  Super-Serverâ  
    30.3. Network File System (NFS)
    30.4. Network Information System (NIS/YP)
    30.5. Automatic Network Configuration (DHCP)
    30.6. Domain Name System (DNS)
    30.7. Apache HTTP Server
    30.8. File Transfer Protocol (FTP)
    30.9. File and Print Services for MicrosoftÂ®Â WindowsÂ® Clients (Samba)
    30.10. Clock Synchronization with NTP
    30.11. Remote Host Logging with syslogd

31. Firewalls

    31.1. Introduction
    31.2. Firewall Concepts
    31.3. Firewall Packages
    31.4. PF and ALTQ
    31.5. The IPFILTER (IPF) Firewall
    31.6. IPFW

32. Advanced Networking

    32.1. Synopsis
    32.2. Gateways and Routes
    32.3. Wireless Networking
    32.4. Bluetooth
    32.5. Bridging
    32.6. Link Aggregation and Failover
    32.7. Diskless Operation
    32.8. PXE Booting with an NFS Root File System
    32.9. ISDN
    32.10. Network Address Translation
    32.11. IPv6
    32.12. Asynchronous Transfer Mode (ATM)
    32.13. Common Address Redundancy Protocol (CARP)

ChapterÂ 27.Â Serial Communications

Table of Contents

27.1. Synopsis
27.2. Introduction
27.3. Terminals
27.4. Dial-in Service
27.5. Dial-out Service
27.6. Setting Up the Serial Console

27.1.Â Synopsis

UNIXÂ® has always had support for serial communications as the very first UNIXÂ
® machines relied on serial lines for user input and output. Things have
changed a lot from the days when the average terminal consisted of a
10-character-per-second serial printer and a keyboard. This chapter covers some
of the ways serial communications can be used on FreeBSD.

After reading this chapter, you will know:

  * How to connect terminals to a FreeBSD system.

  * How to use a modem to dial out to remote hosts.

  * How to allow remote users to login to a FreeBSD system with a modem.

  * How to boot a FreeBSD system from a serial console.

Before reading this chapter, you should:

  * Know how to configure and install a custom kernel.

  * Understand FreeBSD permissions and processes.

  * Have access to the technical manual for the serial hardware to be used with
    FreeBSD.

27.2.Â Introduction

27.2.1.Â Terminology

bps

    Bits per Second (bps) is the rate at which data is transmitted.

DTE
   
    An example of a Data Terminal Equipment (DTE) is a computer.

DCE
   
    An example of a Data Communications Equipment (DTE) is a modem.

RS-232
   
    The original standard for hardware serial communications. It is now usually
    referred to as TIA-232

When talking about communications data rates, this section does not use the
term â  baudâ  . Baud refers to the number of electrical state transitions that
may be made in a period of time, while bps is the correct term to use.

27.2.2.Â Cables and Ports

To connect a modem or serial terminal to a FreeBSD system, a serial port on the
computer and the proper cable to connect to the serial device are needed. Users
who are already familiar with serial hardware and cabling can safely skip this
section.

27.2.2.1.Â Cables

There are several different kinds of serial cables. The two most common types
are null-modem cables and standard RS-232 cables. The documentation for the
hardware should describe the type of cable required.

27.2.2.1.1.Â Null-modem Cables

A null-modem cable passes some signals, such as â  Signal Groundâ  , straight
through, but switches other signals. For example, the â  Transmitted Dataâ  
pin on one end goes to the â  Received Dataâ   pin on the other end.

A null-modem cable can be constructed for use with terminals. The following
table shows the RS-232C signal names and the pin numbers on a DB-25 connector.
While the standard calls for a straight-through pin 1 to pin 1 Protective
Ground line, it is often omitted. Some terminals work using only pins 2, 3, and
7, while others require different configurations than the examples shown below.

TableÂ 27.1.Â DB-25 to DB-25 Null-Modem Cable

Signal         Pin #                  Â              Pin #       Signal
SG             7           connects to               7           SG
TD             2           connects to               3           RD
RD             3           connects to               2           TD
RTS            4           connects to               5           CTS
CTS            5           connects to               4           RTS
DTR            20          connects to               6           DSR
DTR            20          connects to               8           DCD
DSR            6           connects to               20          DTR
DCD            8           connects to               20          DTR


The next two tables show two other common schemes.

TableÂ 27.2.Â DB-9 to DB-9 Null-Modem Cable

Signal         Pin #                  Â              Pin #       Signal
RD             2           connects to               3           TD
TD             3           connects to               2           RD
DTR            4           connects to               6           DSR
DTR            4           connects to               1           DCD
SG             5           connects to               5           SG
DSR            6           connects to               4           DTR
DCD            1           connects to               4           DTR
RTS            7           connects to               8           CTS
CTS            8           connects to               7           RTS


TableÂ 27.3.Â DB-9 to DB-25 Null-Modem Cable

Signal         Pin #                  Â              Pin #       Signal
RD             2           connects to               2           TD
TD             3           connects to               3           RD
DTR            4           connects to               6           DSR
DTR            4           connects to               8           DCD
SG             5           connects to               7           SG
DSR            6           connects to               20          DTR
DCD            1           connects to               20          DTR
RTS            7           connects to               5           CTS
CTS            8           connects to               4           RTS


Note:

When one pin at one end connects to a pair of pins at the other end, it is
usually implemented with one short wire between the pair of pins in their
connector and a long wire to the other single pin.

The above designs seem to be the most popular. In another variation, SG
connects to SG, TD connects to RD, RTS and CTS connect to DCD, DTR connects to
DSR, and vice-versa.

27.2.2.1.2.Â Standard RS-232C Cables

A standard serial cable passes all of the RS-232C signals straight through. The
â  Transmitted Dataâ   pin on one end of the cable goes to the â  Transmitted
Dataâ   pin on the other end. This is the type of cable used to connect a modem
to the FreeBSD system, and is also appropriate for some terminals.

27.2.2.2.Â Ports

Serial ports are the devices through which data is transferred between the
FreeBSD host computer and the terminal. This section describes the kinds of
ports that exist and how they are addressed in FreeBSD.

27.2.2.2.1.Â Kinds of Ports

Several kinds of serial ports exist. Before purchasing or constructing a cable,
make sure it will fit the ports on the terminal and on the FreeBSD system.

Most terminals have DB-25 ports. Personal computers may have DB-25 or DB-9
ports. A multiport serial card may have RJ-12 or RJ-45 ports.

See the documentation that accompanied the hardware for specifications on the
kind of port or visually verify the type of port.

27.2.2.2.2.Â Port Names

In FreeBSD, each serial port is accessed through an entry in /dev. There are
two different kinds of entries:

  * Call-in ports are named /dev/ttyuN where N is the port number, starting
    from zero. Generally, the call-in port is used for terminals. Call-in ports
    require that the serial line assert the Data Carrier Detect (DCD) signal to
    work correctly.

  * Call-out ports are named /dev/cuauN. Call-out ports are usually not used
    for terminals, but are used for modems. The call-out port can be used if
    the serial cable or the terminal does not support the carrier detect
    signal.

If a terminal is connected to the first serial port(COM1), use /dev/ttyu0 to
refer to the terminal. If the terminal is on the second serial port (COM2), use
/dev/ttyu1, and so forth.

27.2.3.Â Kernel Configuration

FreeBSD supports four serial ports by default. In the MS-DOSÂ® world, these are
known as COM1, COM2, COM3, and COM4. FreeBSD currently supports â  dumbâ  
multiport serial interface cards, such as the BocaBoard 1008 and 2016, as well
as more intelligent multi-port cards such as those made by Digiboard and
Stallion Technologies. However, the default kernel only looks for the standard
COM ports.

To see if the kernel recognizes the serial ports, watch for messages while the
kernel is booting, or use /sbin/dmesg to replay the kernel's boot messages.
Look for messages that start with the characters uart:

# /sbin/dmesg | grep 'uart'

If the kernel does not recognize all of the serial ports, configure /boot/
device.hints. When editing this file, one can comment out or completely remove
lines for devices that do not exist on the system.

Note:

port IO_COM1 is a substitution for port 0x3f8, IO_COM2 is 0x2f8, IO_COM3 is
0x3e8, and IO_COM4 is 0x2e8. These are fairly common port addresses for their
respective serial ports and interrupts 4, 3, 5, and 9 are fairly common
interrupt request lines. Regular serial ports cannot share interrupts on
ISA-bus PCs. Multiport boards have on-board electronics that allow all the
16550A's on the board to share one or two interrupt request lines.

27.2.4.Â Device Special Files

Most devices in the kernel are accessed through â  device special filesâ  
which are located in /dev. The sio devices are accessed through the /dev/ttyuN
(dial-in) and /dev/cuauN (call-out) devices. FreeBSD also provides
initialization devices (/dev/ttyuN.init and /dev/cuauN.init) and locking
devices (/dev/ttyuN.lock and /dev/cuauN.lock). The initialization devices are
used to initialize communications port parameters each time a port is opened,
such as crtscts for modems which use RTS/CTS signaling for flow control. The
locking devices are used to lock flags on ports to prevent users or programs
changing certain parameters. Refer to termios(4), sio(4), and stty(1) for
information on terminal settings, locking and initializing devices, and setting
terminal options, respectively.

27.2.5.Â Serial Port Configuration

The ttyuN (or cuauN) is the regular device to open for applications. When a
process opens the device, it will have a default set of terminal I/O settings.
These settings can be viewed with the command:

# stty -a -f /dev/ttyu1

When the settings are changed for a device, the settings are in effect until
the device is closed. When the device is reopened, it goes back to the default
set. To permanently change the default set, open and adjust the settings of the
â  initial stateâ   device. For example, to turn on CLOCAL mode, 8 bit
communication, and XON/XOFF flow control for ttyu5, type:

# stty -f /dev/ttyu5.init clocal cs8 ixon ixoff

System-wide initialization of serial devices is controlled by /etc/rc.d/serial.
This file affects the default settings of serial devices.

To prevent certain settings from being changed by an application, make
adjustments to the â  lock stateâ   device. For example, to lock the speed of
ttyu5 to 57600Â bps, type:

# stty -f /dev/ttyu5.lock 57600

Now, an application that opens ttyu5 and tries to change the speed of the port
will be stuck with 57600Â bps.

The initial state and lock state devices should only be writable by root.

27.3.Â Terminals

Contributed by Sean Kelly.

Terminals provide a convenient and low-cost way to access a FreeBSD system when
not at the computer's console or on a connected network. This section describes
how to use terminals with FreeBSD.

27.3.1.Â Uses and Types of Terminals

The original UNIXÂ® systems did not have consoles. Instead, users logged in and
ran programs through terminals that were connected to the computer's serial
ports.

The ability to establish a login session on a serial port still exists in
nearly every UNIXÂ®-like operating system today, including FreeBSD. By using a
terminal attached to an unused serial port, a user can log in and run any text
program that can normally be run on the console or in an xterm window.

Many terminals can be attached to a FreeBSD system. An older spare computer can
be used as a terminal wired into a more powerful computer running FreeBSD. This
can turn what might otherwise be a single-user computer into a powerful
multiple user system.

This section describes three kinds of terminals supported by FreeBSD: dumb
terminals, computers acting as terminals, and X terminals.

27.3.1.1.Â Dumb Terminals

Dumb terminals are specialized hardware that connect to computers over serial
lines. They are called â  dumbâ   because they have only enough computational
power to display, send, and receive text. No programs can be run on these
devices. Dumb terminals connect to a computer that has all the power to run
text editors, compilers, email, games, and so forth.

There are hundreds of kinds of dumb terminals made by many manufacturers, and
just about any kind will work with FreeBSD. Some high-end terminals can even
display graphics, but only certain software packages can take advantage of
these advanced features.

Dumb terminals are popular in work environments where workers do not need
access to graphical applications.

27.3.1.2.Â Computers Acting as Terminals

If a dumb terminal has just enough ability to display, send, and receive text,
any spare computer can be a dumb terminal. All that is needed is the proper
cable and some terminal emulation software to run on the computer.

This configuration can be useful. For example, if one user is busy working at
the FreeBSD system's console, another user can do some text-only work at the
same time from a less powerful personal computer hooked up as a terminal to the
FreeBSD system.

There are at least two utilities in the base-system of FreeBSD that can be used
to work through a serial connection: cu(1) and tip(1).

To connect from a client system that runs FreeBSD to the serial connection of
another system, use:

# cu -l serial-port-device

Where â  serial-port-deviceâ   is the name of a special device file denoting a
serial port on the system. These device files are called /dev/cuauN.

The â  Nâ  -part of a device name is the serial port number.

Note:

Note that device numbers in FreeBSD start from zero and not one. This means
that COM1 is /dev/cuau0 in FreeBSD.

Note:

Some people prefer to use other programs available through the Ports
Collection, such as comms/minicom.

27.3.1.3.Â X Terminals

X terminals are the most sophisticated kind of terminal available. Instead of
connecting to a serial port, they usually connect to a network like Ethernet.
Instead of being relegated to text-only applications, they can display any X
application.

This chapter does not cover the setup, configuration, or use of X terminals.

27.3.2.Â Configuration

This section describes how to configure a FreeBSD system to enable a login
session on a terminal. It assumes that the kernel is configured to support the
serial port to which the terminal is connected and that the terminal is
connected.

The init process is responsible for all process control and initialization at
system startup. One of the tasks performed by init is to read /etc/ttys and
start a getty process on the available terminals. The getty process is
responsible for reading a login name and starting the login program.

To configure terminals for a FreeBSD system, the following steps should be
taken as root:

 1. Add a line to /etc/ttys for the entry in /dev for the serial port if it is
    not already there.

 2. Specify that /usr/libexec/getty be run on the port, and specify the
    appropriate getty type from /etc/gettytab.

 3. Specify the default terminal type.

 4. Set the port to â  on.â  

 5. Specify whether the port should be â  secure.â  

 6. Force init to reread /etc/ttys.

As an optional step, create a custom getty type for use in step 2 by making an
entry in /etc/gettytab. For more information, refer to gettytab(5) and getty(8)
.

27.3.2.1.Â Adding an Entry to /etc/ttys

/etc/ttys lists all of the ports on the FreeBSD system which allow logins. For
example, the first virtual console, ttyv0, has an entry in this file, allowing
logins on the console. This file also contains entries for the other virtual
consoles, serial ports, and pseudo-ttys. For a hardwired terminal, list the
serial port's /dev entry without the /dev part. For example, /dev/ttyv0 would
be listed as ttyv0.

A default FreeBSD install includes an /etc/ttys with support for the first four
serial ports: ttyu0 through ttyu3. When attaching a terminal to one of those
ports, this file does not need to be edited.

ExampleÂ 27.1.Â Adding Terminal Entries to /etc/ttys

This example configures two terminals: a Wyse-50 and an old 286 IBM PC running 
Procomm terminal software emulating a VT-100 terminal. The Wyse is connected to
the second serial port and the 286 to the sixth serial port on a multiport
serial card. The corresponding entries in /etc/ttys would look like this:

ttyu11 "/usr/libexec/getty std.38400"2 wy503 on4 insecure5 ttyu5 "/usr/libexec/
getty std.19200" vt100 on insecure

1    The first field normally specifies the name of the terminal special file
     as it is found in /dev.

2    The second field is the command to execute for this line, which is usually
     getty(8). getty initializes and opens the line, sets the speed, prompts
     for a user name, and then executes login(1).

     The getty program accepts one (optional) parameter on its command line,
     the getty type. A getty type configures characteristics on the terminal
     line, like bps rate and parity. getty reads these characteristics from /
     etc/gettytab.

     /etc/gettytab contains many entries for terminal lines, both old and new.
     In almost all cases, the entries that start with the text std will work
     for hardwired terminals as these entries ignore parity. There is a std
     entry for each bps rate from 110 to 115200. gettytab(5) provides more
     information.

     When setting the getty type in /etc/ttys, make sure that the
     communications settings on the terminal match.

     For this example, the Wyse-50 uses no parity and connects at 38400Â bps.
     The 286Â PC uses no parity and connects at 19200Â bps.

3    The third field is the type of terminal usually connected to that terminal
     line. For dial-up ports, unknown or dialup is typically used since users
     may dial up with practically any type of terminal or software. Since the
     terminal type does not change for hardwired terminals, a real terminal
     type from termcap(5) can be used in this field.

     For this example, the Wyse-50 uses the real terminal type while the 286 PC
     running Procomm will be set to emulate at VT-100.

4    The fourth field specifies if the port should be enabled. If set to on,
     the init process will start the program in the second field, getty. If
     this field is set to off, there will be no getty, and hence no logins on
     the port.

5    The final field is used to specify whether the port is secure. Marking a
     port as secure means that it is trusted enough to allow root, or any
     account with a UID of 0, to login from that port. Insecure ports do not
     allow root logins. On an insecure port, users must login from unprivileged
     accounts and then use su(1) or a similar mechanism to gain superuser
     privileges.

     It is highly recommended to use insecure, even for terminals that are
     behind locked doors. It is quite easy to login and use su when superuser
     privileges are needed.


27.3.2.2.Â Force init to Reread /etc/ttys

After making any changes to /etc/ttys, send a SIGHUP (hangup) signal to the
init process to force it to re-read its configuration file:

# kill -HUP 1

Note:

init is always the first process run on a system, therefore it will always have
a process ID of 1.

If everything is set up correctly, all cables are in place, and the terminals
are powered up, then a getty process should be running on each terminal and
login prompts should be available on each terminal.

27.3.3.Â Troubleshooting the Connection

Even with the most meticulous attention to detail, something could still go
wrong while setting up a terminal. Here is a list of common symptoms and some
suggested fixes.

27.3.3.1.Â No Login Prompt Appears

Make sure the terminal is plugged in and powered up. If it is a personal
computer acting as a terminal, make sure it is running terminal emulation
software on the correct serial port.

Make sure the cable is connected firmly to both the terminal and the FreeBSD
computer. Make sure it is the right kind of cable.

Make sure the terminal and FreeBSD agree on the bps rate and parity settings.
For a video display terminal, make sure the contrast and brightness controls
are turned up. If it is a printing terminal, make sure paper and ink are in
good supply.

Make sure that a getty process is running and serving the terminal. For
example, to get a list of running getty processes with ps, type:

# ps -axww|grep getty

There should be an entry for the terminal. For example, the following display
shows that a getty is running on the second serial port, ttyu1, and is using
the std.38400 entry in /etc/gettytab:

22189 d1 Is+ 0:00.03 /usr/libexec/getty std.38400 ttyu1

If no getty process is running, make sure the port is enabled in /etc/ttys.
Remember to run kill -HUP 1 after modifying /etc/ttys.

If the getty process is running but the terminal still does not display a login
prompt, or if it displays a prompt but will not accept typed input, the
terminal or cable may not support hardware handshaking. Try changing the entry
in /etc/ttys from std.38400 to 3wire.38400, then run kill -HUP 1 after
modifying /etc/ttys. The 3wire entry is similar to std, but ignores hardware
handshaking. The baud rate may need to be reduced or software flow control
enabled when using 3wire to prevent buffer overflows.

27.3.3.2.Â If Garbage Appears Instead of a Login Prompt

Make sure the terminal and FreeBSD agree on the bps rate and parity settings.
Check the getty processes to make sure the correct getty type is in use. If
not, edit /etc/ttys and run kill -HUP 1.

27.3.3.3.Â Characters Appear Doubled and the Password Appears When Typed

Switch the terminal, or the terminal emulation software, from â  half duplexâ  
or â  local echoâ   to â  full duplex.â  

27.4.Â Dial-in Service

Contributed by Guy Helmer.
Additions by Sean Kelly.

Configuring a FreeBSD system for dial-in service is similar to connecting
terminals except that modems are used instead of terminal devices.

27.4.1.Â External Versus Internal Modems

External modems are more convenient for dial-up because they often can be
semi-permanently configured via parameters stored in non-volatile RAM and they
usually provide lighted indicators that display the state of important RS-232
signals, indicating whether the modem is operating properly.

Internal modems usually lack non-volatile RAM, so their configuration may be
limited to setting DIP switches. If the internal modem has any signal indicator
lights, they are difficult to view when the system's cover is in place.

27.4.1.1.Â Modems and Cables

When using an external modem, a proper cable is needed. A standard RS-232C
serial cable should suffice as long as all of the normal signals are wired:

TableÂ 27.4.Â Signal Names

Acronyms  Names
RD        Received Data
TD        Transmitted Data
DTR       Data Terminal Ready
DSR       Data Set Ready
DCD       Data Carrier Detect (RS-232's Received Line Signal Detector)
SG        Signal Ground
RTS       Request to Send
CTS       Clear to Send


FreeBSD needs the RTS and CTS signals for flow control at speeds above
2400Â bps, the CD signal to detect when a call has been answered or the line
has been hung up, and the DTR signal to reset the modem after a session is
complete. Some cables are wired without all of the needed signals, so if a
login session does not go away when the line hangs up, there may be a problem
with the cable.

Like other UNIXÂ®-like operating systems, FreeBSD uses the hardware signals to
find out when a call has been answered or a line has been hung up and to hangup
and reset the modem after a call. FreeBSD avoids sending commands to the modem
or watching for status reports from the modem.

27.4.2.Â Serial Interface Considerations

FreeBSD supports the NS8250-, NS16450-, NS16550-, and NS16550A-based EIA
RS-232C (CCITT V.24) communications interfaces. The 8250 and 16450 devices have
single-character buffers. The 16550 device provides a 16-character buffer,
which allows for better system performance. Bugs in plain 16550's prevent the
use of the 16-character buffer, so use 16550A's if possible. Because
single-character-buffer devices require more work by the operating system than
the 16-character-buffer devices, 16550A-based serial interface cards are
preferred. If the system has many active serial ports or will have a heavy
load, 16550A-based cards are better for low-error-rate communications.

27.4.3.Â Quick Overview

As with terminals, init spawns a getty process for each configured serial port
for dial-in connections. For example, if a modem is attached to /dev/ttyu0, ps
ax might show this:

4850 ?? I 0:00.09 /usr/libexec/getty V19200 ttyu0

When a user dials the modem's line and the modems connect, the Carrier Detect (
CD) line is reported by the modem. The kernel notices that the carrier has been
detected and instructs getty to open the port. getty sends a login: prompt at
the specified initial line speed. getty watches to see if legitimate characters
are received, and, in a typical configuration, if it finds junk (probably due
to the modem's connection speed being different than getty's speed), getty
tries adjusting the line speeds until it receives reasonable characters.

After the user enters their login name, getty executes /usr/bin/login, which
completes the login by asking for the user's password and then starting the
user's shell.

27.4.4.Â Configuration Files

There are three system configuration files in /etc that probably need to be
edited to allow dial-up access to the FreeBSD system. /etc/gettytab contains
configuration information for the /usr/libexec/getty daemon. /etc/ttys holds
information that tells init which ttys should have getty processes running on
them. Lastly, port initialization commands can be placed in /etc/rc.d/serial.

There are two schools of thought regarding dial-up modems on UNIXÂ®. One group
likes to configure their modems and systems so that no matter at what speed a
remote user dials in, the local computer-to-modem RS-232 interface runs at a
locked speed. The benefit of this configuration is that the remote user always
sees a system login prompt immediately. The downside is that the system does
not know what a user's true data rate is, so full-screen programs like Emacs
will not adjust their screen-painting methods to make their response better for
slower connections.

The other group configures their modems' RS-232 interface to vary its speed
based on the remote user's connection speed. For example, V.32bis (14.4Â Kbps)
connections to the modem might make the modem run its RS-232 interface at
19.2Â Kbps, while 2400Â bps connections make the modem's RS-232 interface run
at 2400Â bps. Because getty does not understand any particular modem's
connection speed reporting, getty gives a login: message at an initial speed
and watches the characters that come back in response. If the user sees junk,
it is assumed that they know they should press Enter until they see a
recognizable prompt. If the data rates do not match, getty sees anything the
user types as â  junkâ  , tries going to the next speed and gives the login:
prompt again. This procedure normally only takes a keystroke or two before the
user sees a good prompt. This login sequence does not look as clean as the â  
locked-speedâ   method, but a user on a low-speed connection should receive
better interactive response from full-screen programs.

This section will try to give balanced configuration information, but is biased
towards having the modem's data rate follow the connection rate.

27.4.4.1.Â /etc/gettytab

/etc/gettytab is a termcap(5)-style file of configuration information for getty
(8). Refer to gettytab(5) for complete information on the format of the file
and the list of capabilities.

27.4.4.1.1.Â Locked-speed Config

When locking a modem's data communications rate at a particular speed, no
changes to /etc/gettytab should be needed.

27.4.4.1.2.Â Matching-speed Config

Set up an entry in /etc/gettytab to give getty information about the speeds to
use for the modem. For a 2400Â bps modem, use the existing D2400 entry.

# # Fast dialup terminals, 2400/1200/300 rotary (can start either way) # D2400|
d2400|Fast-Dial-2400:\ :nx=D1200:tc=2400-baud: 3|D1200|Fast-Dial-1200:\ :nx=
D300:tc=1200-baud: 5|D300|Fast-Dial-300:\ :nx=D2400:tc=300-baud:

For a higher speed modem, add an entry in /etc/gettytab. This entry is for a
14.4Â Kbps modem with a top interface speed of 19.2Â Kbps:

# # Additions for a V.32bis Modem # um|V300|High Speed Modem at 300,8-bit:\ :nx
=V19200:tc=std.300: un|V1200|High Speed Modem at 1200,8-bit:\ :nx=V300:tc=
std.1200: uo|V2400|High Speed Modem at 2400,8-bit:\ :nx=V1200:tc=std.2400: up|
V9600|High Speed Modem at 9600,8-bit:\ :nx=V2400:tc=std.9600: uq|V19200|High
Speed Modem at 19200,8-bit:\ :nx=V9600:tc=std.19200:

This will result in 8-bit, no parity connections.

The example above starts the communications rate at 19.2Â Kbps (for a V.32bis
connection), then cycles through 9600Â bps (for V.32), 2400Â bps, 1200Â bps,
300Â bps, and back to 19.2Â Kbps. Communications rate cycling is implemented
with the nx= (â  next tableâ  ) capability. Each of the lines uses a tc= (â  
table continuationâ  ) entry to pick up the rest of the â  standardâ   settings
for a particular data rate.

For a 28.8Â Kbps modem or to take advantage of compression on a 14.4Â Kbps
modem, use a higher communications rate than 19.2Â Kbps. Here is an example of
a gettytab entry starting a 57.6Â Kbps:

# # Additions for a V.32bis or V.34 Modem # Starting at 57.6 Kbps # vm|VH300|
Very High Speed Modem at 300,8-bit:\ :nx=VH57600:tc=std.300: vn|VH1200|Very
High Speed Modem at 1200,8-bit:\ :nx=VH300:tc=std.1200: vo|VH2400|Very High
Speed Modem at 2400,8-bit:\ :nx=VH1200:tc=std.2400: vp|VH9600|Very High Speed
Modem at 9600,8-bit:\ :nx=VH2400:tc=std.9600: vq|VH57600|Very High Speed Modem
at 57600,8-bit:\ :nx=VH9600:tc=std.57600:

For a slow CPU or a heavily loaded system without 16550A-based serial ports,
there may be sio â  siloâ   errors at 57.6Â Kbps.

27.4.4.2.Â /etc/ttys

Configuration of /etc/ttys is covered in ExampleÂ 27.1, â  Adding Terminal
Entries to /etc/ttysâ  . Configuration for modems is similar, but a different
argument is passed to getty and a different terminal type is specified. The
general format for both locked-speed and matching-speed configurations is:

ttyu0 "/usr/libexec/getty xxx" dialup on

The first item in the above line is the device special file for this entry.
ttyu0 indicates that getty is watching /dev/ttyu0. The xxx will replace the
initial gettytab capability and is the process init will run on the device. The
third item, dialup, is the default terminal type. The fourth parameter, on,
indicates to init that the line is operational. There can be a fifth parameter,
secure, but it should only be used for terminals which are physically secure,
such as the system console.

The default terminal type, dialup in this example, may depend on local
preferences. dialup is the traditional default terminal type on dial-up lines
so that users may customize their login scripts to notice when the terminal is
dialup and automatically adjust their terminal type. Setting vt102 as the
default terminal type allows users to use VT102 emulation on their remote
systems.

After editing /etc/ttys, send the init process a HUP signal to re-read the
file:

# kill -HUP 1

Wait until the modem is properly configured and connected before signaling
init.

27.4.4.2.1.Â Locked-speed Config

For a locked-speed configuration, the ttys entry needs to have a fixed-speed
entry provided to getty. For a modem whose port speed is locked at 19.2Â Kbps,
the ttys entry might look like this:

ttyu0 "/usr/libexec/getty std.19200" dialup on

If the modem is locked at a different data rate, substitute the appropriate
value for std.speed instead of std.19200. Make sure to use a valid type listed
in /etc/gettytab.

27.4.4.2.2.Â Matching-speed Config

In a matching-speed configuration, the ttys entry needs to reference the
appropriate beginning â  auto-baudâ   entry in /etc/gettytab. For example, for
the above suggested entry for a matching-speed modem that starts at 19.2Â Kbps,
the /etc/ttys entry might look like this:

ttyu0 "/usr/libexec/getty V19200" dialup on

27.4.4.3.Â /etc/rc.d/serial

High-speed modems, like V.32, V.32bis, and V.34 modems, need to use hardware
(RTS/CTS) flow control. stty can be used to set the hardware flow control flag
in the FreeBSD kernel for the modem ports.

For example, to set the termios flag crtscts on COM2's dial-in and dial-out
initialization devices, the following lines could be added to /etc/rc.d/serial:

# Serial port initial configuration stty -f /dev/ttyu1.init crtscts stty -f /
dev/cuau1.init crtscts

27.4.5.Â Modem Settings

For a modem whose parameters may be permanently set in non-volatile RAM, a
terminal program such as tip can be used to set the parameters. Connect to the
modem using the same communications speed as the initial speed getty will use
and configure the modem's non-volatile RAM to match these requirements:

  * CD asserted when connected.

  * DTR asserted for operation and dropping DTR hangs up the line and resets
    the modem.

  * CTS transmitted data flow control.

  * Disable XON/XOFF flow control.

  * RTS received data flow control.

  * Quiet mode (no result codes).

  * No command echo.

Read the documentation for the modem to find out which commands and/or DIP
switch settings are needed.

For example, to set the above parameters on a U.S. RoboticsÂ® SportsterÂ®
14,400 external modem, give these commands to the modem:

ATZ AT&C1&D2&H1&I0&R2&W

Other settings can be adjusted in the modem, such as whether it will use
V.42bis and/or MNP5 compression.

The U.S. RoboticsÂ® SportsterÂ® 14,400 external modem also has some DIP
switches that need to be set. Other modems, may need these settings:

  * Switch 1: UP â   DTR Normal

  * Switch 2: N/A (Verbal Result Codes/Numeric Result Codes)

  * Switch 3: UP â   Suppress Result Codes

  * Switch 4: DOWN â   No echo, offline commands

  * Switch 5: UP â   Auto Answer

  * Switch 6: UP â   Carrier Detect Normal

  * Switch 7: UP â   Load NVRAM Defaults

  * Switch 8: N/A (Smart Mode/Dumb Mode)

Result codes should be disabled/suppressed for dial-up modems to avoid problems
that can occur if getty mistakenly gives a login: prompt to a modem that is in
command mode and the modem echoes the command or returns a result code. This
sequence can result in an extended, silly conversation between getty and the
modem.

27.4.5.1.Â Locked-speed Config

For a locked-speed configuration, configure the modem to maintain a constant
modem-to-computer data rate independent of the communications rate. On a U.S.
RoboticsÂ® SportsterÂ® 14,400 external modem, these commands will lock the
modem-to-computer data rate at the speed used to issue the commands:

ATZ AT&B1&W

27.4.5.2.Â Matching-speed Config

For a variable-speed configuration, configure the modem to adjust its serial
port data rate to match the incoming call rate. On a U.S. RoboticsÂ® SportsterÂ
® 14,400 external modem, these commands will lock the modem's error-corrected
data rate to the speed used to issue the commands, while allowing the serial
port rate to vary for non-error-corrected connections:

ATZ AT&B2&W

27.4.5.3.Â Checking the Modem's Configuration

Most high-speed modems provide commands to view the modem's current operating
parameters in a somewhat human-readable fashion. On the U.S. RoboticsÂ® 
SportsterÂ® 14,400 external modem, ATI5 displays the settings that are stored
in the non-volatile RAM. To see the true operating parameters of the modem, as
influenced by the modem's DIP switch settings, use ATZ and then ATI4.

For a different brand of modem, check the modem's manual to see how to
double-check the modem's configuration parameters.

27.4.6.Â Troubleshooting

Here are a few steps for troubleshooting a dial-up modem on a FreeBSD system.

27.4.6.1.Â Checking Out the FreeBSD System

Hook up the modem to the FreeBSD system, boot the system, and, if the modem has
status indication lights, watch to see whether the modem's DTR indicator lights
when the login: prompt appears on the system's console. If it lights up, that
should mean that FreeBSD has started a getty process on the appropriate
communications port and is waiting for the modem to accept a call.

If the DTR indicator does not light, login to the FreeBSD system through the
console and type ps ax to see if FreeBSD is trying to run a getty process on
the correct port:

114 ?? I 0:00.10 /usr/libexec/getty V19200 ttyu0 115 ?? I 0:00.10 /usr/libexec/
getty V19200 ttyu1

If something like this is displayed instead:

114 d0 I 0:00.10 /usr/libexec/getty V19200 ttyu0

and the modem has not accepted a call yet, this means that getty has completed
its open on the communications port. This could indicate a problem with the
cabling or a misconfigured modem, because getty should not be able to open the
communications port until carrier detect has been asserted by the modem.

If no getty processes are waiting to open the desired ttyuN port, double-check
the entries in /etc/ttys to see if there are any mistakes. Also, check /var/log
/messages to see if there are any log messages from init or getty. If there are
any messages, triple-check /etc/ttys and /etc/gettytab, as well as the
appropriate device special files, /dev/ttyuN, for any mistakes, missing
entries, or missing device special files.

27.4.6.2.Â Try Dialing In

Try dialing into the system. Be sure to use 8 bits, no parity, and 1 stop bit
on the remote system. If a prompt does not appear right away, or the prompt
shows garbage, try pressing Enter about once per second. If there is still no
login: prompt after a while, try sending a BREAK. When using a high-speed
modem, try dialing again after locking the dialing modem's interface speed.

If there is still no login: prompt, check /etc/gettytab again and double-check
that:

  * The initial capability name specified in the entry in /etc/ttys matches the
    name of a capability in /etc/gettytab.

  * Each nx= entry matches another gettytab capability name.

  * Each tc= entry matches another gettytab capability name.

If the modem on the FreeBSD system will not answer, make sure that the modem is
configured to answer the phone when DTR is asserted. If the modem seems to be
configured correctly, verify that the DTR line is asserted by checking the
modem's indicator lights.

If it still does not work, take a break and come back to it later. If it still
does not work, try sending an email message to the FreeBSD general questions
mailing list describing the modem and the problem.

27.5.Â Dial-out Service

The following are tips for getting the host to connect over the modem to
another computer. This is appropriate for establishing a terminal session with
a remote host.

This kind of connection can be helpful to get a file on the Internet if there
are problems using PPP. If PPP is not working, use the terminal session to FTP
the needed file. Then use zmodem to transfer it to the machine.

27.5.1.Â Using a Stock Hayes Modem

A generic Hayes dialer is built into tip. Use at=hayes in /etc/remote.

The Hayes driver is not smart enough to recognize some of the advanced features
of newer modems messages like BUSY, NO DIALTONE, or CONNECT 115200. Turn those
messages off when using tip with ATX0&W.

The dial timeout for tip is 60 seconds. The modem should use something less, or
else tip will think there is a communication problem. Try ATS7=45&W.

27.5.2.Â Using AT Commands

Create a â  directâ   entry in /etc/remote. For example, if the modem is hooked
up to the first serial port, /dev/cuau0, use the following line:

cuau0:dv=/dev/cuau0:br#19200:pa=none

Use the highest bps rate the modem supports in the br capability. Then, type
tip cuau0 to connect to the modem.

Or, use cu as root with the following command:

# cu -lline -sspeed

line is the serial port, such as /dev/cuau0, and speed is the speed, such as
57600. When finished entering the AT commands, type ~. to exit.

27.5.3.Â The @ Sign Does Not Work

The @ sign in the phone number capability tells tip to look in /etc/phones for
a phone number. But, the @ sign is also a special character in capability files
like /etc/remote, so it needs to be escaped with a backslash:

pn=\@

27.5.4.Â Dialing from the Command Line

Put a â  genericâ   entry in /etc/remote. For example:

tip115200|Dial any phone number at 115200 bps:\ :dv=/dev/cuau0:br#115200:at=
hayes:pa=none:du: tip57600|Dial any phone number at 57600 bps:\ :dv=/dev/
cuau0:br#57600:at=hayes:pa=none:du:

This should now work:

# tip -115200 5551234

Users who prefer cu over tip, can use a generic cu entry:

cu115200|Use cu to dial any number at 115200bps:\ :dv=/dev/cuau1:br#57600:at=
hayes:pa=none:du:

and type:

# cu 5551234 -s 115200

27.5.5.Â Setting the bps Rate

Put in an entry for tip1200 or cu1200, but go ahead and use whatever bps rate
is appropriate with the br capability. tip thinks a good default is 1200Â bps
which is why it looks for a tip1200 entry. 1200Â bps does not have to be used,
though.

27.5.6.Â Accessing a Number of Hosts Through a Terminal Server

Rather than waiting until connected and typing CONNECT host each time, use
tip's cm capability. For example, these entries in /etc/remote will let you
type tip pain or tip muffin to connect to the hosts pain or muffin, and tip
deep13 to connect to the terminal server.

pain|pain.deep13.com|Forrester's machine:\ :cm=CONNECT pain\n:tc=deep13: muffin
|muffin.deep13.com|Frank's machine:\ :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\ :dv=/dev/cuau2:br#38400:at=
hayes:du:pa=none:pn=5551234:

27.5.7.Â Using More Than One Line with tip

This is often a problem where a university has several modem lines and several
thousand students trying to use them.

Make an entry in /etc/remote and use @ for the pn capability:

big-university:\ :pn=\@:tc=dialout dialout:\ :dv=/dev/cuau3:br#9600:at=
courier:du:pa=none:

Then, list the phone numbers in /etc/phones:

big-university 5551111 big-university 5551112 big-university 5551113
big-university 5551114

tip will try each number in the listed order, then give up. To keep retrying,
run tip in a while loop.

27.5.8.Â Using the Force Character

Ctrl+P is the default â  forceâ   character, used to tell tip that the next
character is literal data. The force character can be set to any other
character with the ~s escape, which means â  set a variable.â  

Type ~sforce=single-char followed by a newline. single-char is any single
character. If single-char is left out, then the force character is the null
character, which is accessed by typing Ctrl+2 or Ctrl+Space. A pretty good
value for single-char is Shift+Ctrl+6, which is only used on some terminal
servers.

To change the force character, specify the following in ~/.tiprc:

force=single-char

27.5.9.Â Upper Case Characters

This happens when Ctrl+A is pressed, which is tip's â  raise characterâ  ,
specially designed for people with broken caps-lock keys. Use ~s to set
raisechar to something reasonable. It can be set to be the same as the force
character, if neither feature is used.

Here is a sample ~/.tiprc for Emacs users who need to type Ctrl+2 and Ctrl+A:

force=^^ raisechar=^^

The ^^ is Shift+Ctrl+6.

27.5.10.Â File Transfers with tip

When talking to another UNIXÂ®-like operating system, files can be sent and
received using ~p (put) and ~t (take). These commands run cat and echo on the
remote system to accept and send files. The syntax is:

~p local-file [remote-file]

~t remote-file [local-file]

There is no error checking, so another protocol, like zmodem, should probably
be used.

27.5.11.Â Using zmodem with tip?

To receive files, start the sending program on the remote end. Then, type ~C rz
to begin receiving them locally.

To send files, start the receiving program on the remote end. Then, type ~C sz
files to send them to the remote system.

27.6.Â Setting Up the Serial Console

Contributed by Kazutaka YOKOTA.
Based on a document by Bill Paul.

27.6.1.Â Introduction

FreeBSD has the ability to boot a system with a dumb terminal on a serial port
as a console. This configuration is useful for system administrators who wish
to install FreeBSD on machines that have no keyboard or monitor attached, and
developers who want to debug the kernel or device drivers.

As described in ChapterÂ 13, The FreeBSD Booting Process, FreeBSD employs a
three stage bootstrap. The first two stages are in the boot block code which is
stored at the beginning of the FreeBSD slice on the boot disk. The boot block
then loads and runs the boot loader as the third stage code.

In order to set up booting from a serial console, the boot block code, the boot
loader code, and the kernel need to be configured.

27.6.2.Â Quick Serial Console Configuration

This section assumes the default setup and provides a fast overview of setting
up the serial console.

 1. Connect the serial cable to COM1 and the controlling terminal.

 2. To see all the boot messages on the serial console, issue the following
    command as the superuser:

    # echo 'console="comconsole"' &gt;&gt; /boot/loader.conf
 3. Edit /etc/ttys and change off to on and dialup to vt100 for the ttyu0
    entry. Otherwise, a password will not be required to connect via the serial
    console, resulting in a potential security hole.

 4. Reboot the system to see if the changes took effect.

If a different configuration is required, see the next section for a more
in-depth configuration explanation.

27.6.3.Â In-Depth Serial Console Configuration

 1. Prepare a serial cable.

    Use either a null-modem cable or a standard serial cable and a null-modem
    adapter. See SectionÂ 27.2.2, â  Cables and Portsâ   for a discussion on
    serial cables.

 2. Unplug the keyboard.

    Many PC systems probe for the keyboard during the Power-On Self-Test (POST)
    and will generate an error if the keyboard is not detected. Some machines
    will refuse to boot until the keyboard is plugged in.

    If the computer complains about the error, but boots anyway, no further
    configuration is needed.

    If the computer refuses to boot without a keyboard attached, the BIOS needs
    to be configured so that it ignores this error (if it can). Consult the
    motherboard's manual for details on how to do this.

    Tip:

    Try setting the keyboard to â  Not installedâ   in the BIOS. The keyboard
    can still be used as this setting just tells the BIOS not to probe for a
    keyboard at power-on. The BIOS should not complain if the keyboard is
    absent. You can leave the keyboard plugged in even with this flag set to â 
     Not installedâ   and the keyboard will still work. If the above option is
    not present in the BIOS, look for an â  Halt on Errorâ   option instead.
    Setting this to â  All but Keyboardâ   or even to â  No Errorsâ  , will
    have the same effect.

    Note:

    If the system has a PS/2Â® mouse, chances are good that both the mouse and
    keyboard need to be unplugged. This is because PS/2Â® mice share some
    hardware with the keyboard and leaving the mouse plugged in can fool the
    keyboard probe into thinking the keyboard is still there.

 3. Plug a dumb terminal into COM1 (sio0).

    If a dumb terminal is not available, use an old computer with a modem
    program, or the serial port on another UNIXÂ® box. If there is no COM1
    (sio0), get one. At this time, there is no way to select a port other than
    COM1 for the boot blocks without recompiling the boot blocks. If COM1 is
    being used by another device, temporarily remove that device and install a
    new boot block and kernel once FreeBSD is up and running.

 4. Make sure the configuration file of the custom kernel has appropriate flags
    set for COM1 (sio0).

    Relevant flags are:

    0x10

        Enables console support for this unit. The other console flags are
        ignored unless this is set. Currently, at most one unit can have
        console support. The first one, in config file order, with this flag
        set is preferred. This option alone will not make the serial port the
        console. Set the following flag or use -h as described below, together
        with this flag.

    0x20

        Forces this unit to be the console, unless there is another higher
        priority console, regardless of -h as discussed below. The flag 0x20
        must be used together with the 0x10 flag.

    0x40

        Reserves this unit (in conjunction with 0x10) and makes the unit
        unavailable for normal access. This flag should not be set to the
        serial port to use as the serial console. The only use of this flag is
        to designate the unit for kernel remote debugging. See The Developer's
        Handbook for more information on remote debugging.

    Here is an example setting:

    device sio0 flags 0x10

    Refer to sio(4) for more details.

    If the flags were not set, run UserConfig on a different console or
    recompile the kernel.

 5. Create boot.config in the root directory of the a partition on the boot
    drive.

    This file instructs the boot block code how to boot the system. In order to
    activate the serial console, one or more of the following options are
    needed. When using multiple options, include them all on the same line:

    -h

        Toggles between the internal and serial consoles. Use this to switch
        console devices. For instance, to boot from the internal (video)
        console, use -h to direct the boot loader and the kernel to use the
        serial port as its console device. Alternatively, to boot from the
        serial port, use -h to tell the boot loader and the kernel to use the
        video display as the console instead.

    -D

        Toggles between the single and dual console configurations. In the
        single configuration, the console will be either the internal console
        (video display) or the serial port, depending on the state of -h. In
        the dual console configuration, both the video display and the serial
        port will become the console at the same time, regardless of the state
        of -h. However, the dual console configuration takes effect only while
        the boot block is running. Once the boot loader gets control, the
        console specified by -h becomes the only console.

    -P

        Makes the boot block probe the keyboard. If no keyboard is found, the
        -D and -h options are automatically set.

        Note:

        Due to space constraints in the current version of the boot blocks, -P
        is capable of detecting extended keyboards only. Keyboards with less
        than 101 keys and without F11 and F12 keys may not be detected.
        Keyboards on some laptops may not be properly found because of this
        limitation. If this is the case, do not use -P. Unfortunately there is
        no workaround for this problem.

    Use either -P to select the console automatically, or -h to activate the
    serial console.

    Other options are described in boot(8).

    The options, except for -P, are passed to the boot loader. The boot loader
    will determine whether the internal video or the serial port should become
    the console by examining the state of -h. This means that if -D is
    specified but -h is not specified in /boot.config, the serial port can be
    used as the console only during the boot block as the boot loader will use
    the internal video display as the console.

 6. Boot the machine.

    When FreeBSD starts, the boot blocks echo the contents of /boot.config to
    the console. For example:

    /boot.config: -P Keyboard: no

    The second line appears only if -P is in /boot.config and indicates the
    presence or absence of the keyboard. These messages go to either the serial
    or internal console, or both, depending on the option in /boot.config.

    Options                         Message goes to
    none                            internal console
    -h                              serial console
    -D                              serial and internal consoles
    -Dh                             serial and internal consoles
    -P, keyboard present            internal console
    -P, keyboard absent             serial console

    After the message, there will be a small pause before the boot blocks
    continue loading the boot loader and before any further messages are
    printed to the console. Under normal circumstances, there is no need to
    interrupt the boot blocks, but one can do so in order to make sure things
    are set up correctly.

    Press any key, other than Enter, at the console to interrupt the boot
    process. The boot blocks will then prompt for further action:

    &gt;&gt; FreeBSD/i386 BOOT Default: 0:ad(0,a)/boot/loader boot:

    Verify that the above message appears on either the serial or internal
    console, or both, according to the options in /boot.config. If the message
    appears in the correct console, press Enter to continue the boot process.

    If there is no prompt on the serial terminal, something is wrong with the
    settings. Enter -h then Enter or Return to tell the boot block (and then
    the boot loader and the kernel) to choose the serial port for the console.
    Once the system is up, go back and check what went wrong.

During the third stage of the boot process, one can still switch between the
internal console and the serial console by setting appropriate environment
variables in the boot loader. See SectionÂ 27.6.6, â  Changing Console from the
Boot Loaderâ   for more information.

27.6.4.Â Summary

Here is the summary of the various settings discussed in this section:

27.6.4.1.Â Case 1: Set the Flags to 0x10 for sio0

device sio0 flags 0x10

Options in /        Console during boot   Console during boot   Console in
boot.config         blocks                loader                kernel
nothing             internal              internal              internal
-h                  serial                serial                serial
-D                  serial and internal   internal              internal
-Dh                 serial and internal   serial                serial
-P, keyboard        internal              internal              internal
present
-P, keyboard absent serial and internal   serial                serial

27.6.4.2.Â Case 2: Set the Flags to 0x30 for sio0

device sio0 flags 0x30

Options in /        Console during boot   Console during boot   Console in
boot.config         blocks                loader                kernel
nothing             internal              internal              serial
-h                  serial                serial                serial
-D                  serial and internal   internal              serial
-Dh                 serial and internal   serial                serial
-P, keyboard        internal              internal              serial
present
-P, keyboard absent serial and internal   serial                serial

27.6.5.Â Tips for the Serial Console

27.6.5.1.Â Setting a Faster Serial Port Speed

By default, the serial port settings are 9600 baud, 8 bits, no parity, and 1
stop bit. To change the default console speed, the following options are
available:

  * Recompile the boot blocks with BOOT_COMCONSOLE_SPEED set to the new console
    speed. See SectionÂ 27.6.5.2, â  Using a Serial Port Other Than sio0 for
    the Consoleâ   for detailed instructions about building and installing new
    boot blocks.

    If the serial console is configured in some other way than by booting with
    -h, or if the serial console used by the kernel is different from the one
    used by the boot blocks, add the following option to a custom kernel
    configuration file and compile a new kernel:

    options CONSPEED=19200
  * Add the -S boot option to /boot.config. See boot(8) for a description of
    how to add options to /boot.config and a list of the supported options.

  * Enable comconsole_speed in /boot/loader.conf. This option depends on
    console, boot_serial, and boot_multicons being set in /boot/loader.conf
    too. An example of using comconsole_speed to change the serial console
    speed is:

    boot_multicons="YES" boot_serial="YES" comconsole_speed="115200" console=
    "comconsole,vidconsole"

27.6.5.2.Â Using a Serial Port Other Than sio0 for the Console

Using a port other than sio0 as the console requires the boot blocks, the boot
loader, and the kernel to be recompiled as follows.

 1. Get the kernel source as described in ChapterÂ 25, Updating and Upgrading
    FreeBSD.

 2. Edit /etc/make.conf and set BOOT_COMCONSOLE_PORT to the address of the port
    to use: 0x3F8, 0x2F8, 0x3E8 or 0x2E8. Only sio0 through sio3 (COM1 through
    COM4) can be used as multiport serial cards will not work. No interrupt
    setting is needed.

 3. Create a custom kernel configuration file and add appropriate flags for the
    serial port to use. For example, to make sio1 (COM2) the console:

    device sio1 flags 0x10

    or

    device sio1 flags 0x30

    The console flags for the other serial ports should not be set.

 4. Recompile and install the boot blocks and the boot loader:

    # cd /sys/boot # make clean # make # make install
 5. Rebuild and install the kernel.

 6. Write the boot blocks to the boot disk with bsdlabel(8) and boot from the
    new kernel.

27.6.5.3.Â Entering the DDB Debugger from the Serial Line

To drop into the kernel debugger from the serial console, compile a custom
kernel with the following options. Note that while this is useful for remote
diagnostics, it is also dangerous if a spurious BREAK is generated on the
serial port.

options BREAK_TO_DEBUGGER options DDB

27.6.5.4.Â Getting a Login Prompt on the Serial Console

While this is not required, it is possible to get a login prompt over the
serial line. First, make sure that the boot messages are displayed and it is
possible to enter the kernel debugging session through the serial console.

Open /etc/ttys with a text editor and locate the lines:

ttyu0 "/usr/libexec/getty std.9600" unknown off secure ttyu1 "/usr/libexec/
getty std.9600" unknown off secure ttyu2 "/usr/libexec/getty std.9600" unknown
off secure ttyu3 "/usr/libexec/getty std.9600" unknown off secure

ttyu0 through ttyu3 correspond to COM1 through COM4. Change off to on for the
desired port. If the speed of the serial port has been changed, change std.9600
to match the new setting.

The terminal type can also be changed from unknown to the actual type of the
serial terminal.

After editing the file, type kill -HUP 1 to make this change take effect.

27.6.6.Â Changing Console from the Boot Loader

Previous sections described how to set up the serial console by tweaking the
boot block. This section shows how to specify the console by entering some
commands and environment variables in the boot loader. As the boot loader is
invoked at the third stage of the boot process, the settings in the boot loader
will override the settings in the boot block.

27.6.6.1.Â Setting Up the Serial Console

The boot loader and the kernel to use the serial console can be specified by
writing one line in /boot/loader.conf:

console="comconsole"

This will take effect regardless of the settings in the boot block discussed in
the previous section.

This line should be the first line of /boot/loader.conf so as to see boot
messages on the serial console as early as possible.

Likewise, to specify the internal console:

console="vidconsole"

If the boot loader environment variable console is not set, the boot loader,
and subsequently the kernel, will use whichever console is indicated by -h in
the boot block.

The console can be specified in /boot/loader.conf.local or in /boot/
loader.conf.

See loader.conf(5) for more information.

Note:

At the moment, the boot loader has no option equivalent to -P in the boot
block, and there is no provision to automatically select the internal console
and the serial console based on the presence of the keyboard.

27.6.6.2.Â Using a Serial Port Other Than sio0 for the Console

The boot loader needs to be compiled in order to use a serial port other than
sio0 for the serial console. Follow the procedure described in
SectionÂ 27.6.5.2, â  Using a Serial Port Other Than sio0 for the Consoleâ  .

27.6.7.Â Caveats

While most systems will boot without a keyboard, quite a few will not boot
without a graphics adapter. Machines with AMI BIOSes can be configured to boot
with no graphics adapter installed by changing the â  graphics adapterâ  
setting in the CMOS configuration to â  Not installed.â  

However, many machines do not support this option and will refuse to boot if
there is no display hardware in the system. With these machines, leave some
kind of graphics card plugged in, even if it is just a junky mono board. A
monitor does not need to be attached. One might also try installing an AMI
BIOS.

ChapterÂ 28.Â PPP and SLIP

Restructured, reorganized, and updated by Jim Mock.
Table of Contents

28.1. Synopsis
28.2. Using User PPP
28.3. Using Kernel PPP
28.4. Troubleshooting PPP Connections
28.5. Using PPP over Ethernet (PPPoE)
28.6. Using PPP over ATM (PPPoA)
28.7. Using SLIP

28.1.Â Synopsis

FreeBSD has a number of ways to link one computer to another. To establish a
network or Internet connection through a dial-up modem, or to allow others to
do so through you, requires the use of PPP or SLIP. This chapter describes
setting up these modem-based communication services in detail.

After reading this chapter, you will know:

  * How to set up user PPP.

  * How to set up kernel PPP (FreeBSD 7.X only).

  * How to set up PPPoE (PPP over Ethernet).

  * How to set up PPPoA (PPP over ATM).

  * How to configure and set up a SLIP client and server (FreeBSDÂ 7.X only).

Before reading this chapter, you should:

  * Be familiar with basic network terminology.

  * Understand the basics and purpose of a dialup connection and PPP and/or
    SLIP.

You may be wondering what the main difference is between user PPP and kernel
PPP. The answer is simple: user PPP processes the inbound and outbound data in
userland rather than in the kernel. This is expensive in terms of copying the
data between the kernel and userland, but allows a far more feature-rich PPP
implementation. User PPP uses the tun device to communicate with the outside
world whereas kernel PPP uses the ppp device.

Note:

Throughout in this chapter, user PPP will simply be referred to as ppp unless a
distinction needs to be made between it and any other PPP software such as pppd
(FreeBSDÂ 7.X only). Unless otherwise stated, all of the commands explained in
this chapter should be executed as root.

28.2.Â Using User PPP

Updated and enhanced by Tom Rhodes.
Originally contributed by Brian Somers.
With input from Nik Clayton, Dirk FrÃ¶mberg and Peter Childs.

28.2.1.Â User PPP

28.2.1.1.Â Assumptions

This document assumes you have the following:

  * An account with an Internet Service Provider (ISP) which you connect to
    using PPP.

  * A modem or other device connected to your system and properly configured to
    allow you to connect to your ISP.

  * The dial-up number(s) of your ISP.

  * Your login name and password. (Either a regular UNIXÂ® style login and
    password pair, or a PAP or CHAP login and password pair).

  * The IP address of one or more name servers. Normally, you will be given two
    IP addresses by your ISP to use for this. If they have not given you at
    least one, then you can use the enable dns command in ppp.conf and ppp will
    set the name servers for you. This feature depends on your ISPs PPP
    implementation supporting DNS negotiation.

The following information may be supplied by your ISP, but is not completely
necessary:

  * The IP address of your ISP's gateway. The gateway is the machine to which
    you will connect and will be set up as your default route. If you do not
    have this information, we can make one up and your ISP's PPP server will
    tell us the correct value when we connect.

    This IP number is referred to as HISADDR by ppp.

  * The netmask you should use. If your ISP has not provided you with one, you
    can safely use 255.255.255.255.

  * If your ISP provides you with a static IP address and hostname, you can
    enter it. Otherwise, we simply let the peer assign whatever IP address it
    sees fit.

If you do not have any of the required information, contact your ISP.

Note:

Throughout this section, many of the examples showing the contents of
configuration files are numbered by line. These numbers serve to aid in the
presentation and discussion only and are not meant to be placed in the actual
file. Proper indentation with tab and space characters is also important.

28.2.1.2.Â Automatic PPP Configuration

Both ppp and pppd (the kernel level implementation of PPP, FreeBSDÂ 7.X only)
use the configuration files located in the /etc/ppp directory. Examples for
user ppp can be found in /usr/share/examples/ppp/.

Configuring ppp requires that you edit a number of files, depending on your
requirements. What you put in them depends to some extent on whether your ISP
allocates IP addresses statically (i.e., you get given one IP address, and
always use that one) or dynamically (i.e., your IP address changes each time
you connect to your ISP).

28.2.1.2.1.Â PPP and Static IP Addresses

You will need to edit the /etc/ppp/ppp.conf configuration file. It should look
similar to the example below.

Note:

Lines that end in a : start in the first column (beginning of the line)â   all
other lines should be indented as shown using spaces or tabs.

1 default: 2 set log Phase Chat LCP IPCP CCP tun command 3 ident user-ppp
VERSION (built COMPILATIONDATE) 4 set device /dev/cuau0 5 set speed 115200 6
set dial "ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \ 7 \"\" AT OK-AT-OK ATE1Q0
OK \\dATDT\\T TIMEOUT 40 CONNECT" 8 set timeout 180 9 enable dns 10 11
provider: 12 set phone "(123) 456 7890" 13 set authname foo 14 set authkey bar
15 set login "TIMEOUT 10 \"\" \"\" gin:--gin: \\U word: \\P col: ppp" 16 set
timeout 300 17 set ifaddr x.x.x.x y.y.y.y 255.255.255.255 0.0.0.0 18 add
default HISADDR

Line 1:

    Identifies the default entry. Commands in this entry are executed
    automatically when ppp is run.

Line 2:

    Enables logging parameters. When the configuration is working
    satisfactorily, this line should be reduced to saying:

    set log phase tun

    in order to avoid excessive log file sizes.

Line 3:

    Tells PPP how to identify itself to the peer. PPP identifies itself to the
    peer if it has any trouble negotiating and setting up the link, providing
    information that the peers administrator may find useful when investigating
    such problems.

Line 4:

    Identifies the device to which the modem is connected. COM1 is /dev/cuau0
    and COM2 is /dev/cuau1.

Line 5:

    Sets the speed you want to connect at. If 115200 does not work (it should
    with any reasonably new modem), try 38400 instead.

Line 6 & 7:
   
    The dial string. User PPP uses an expect-send syntax similar to the chat(8)
    program. Refer to the manual page for information on the features of this
    language.

    Note that this command continues onto the next line for readability. Any
    command in ppp.conf may do this if the last character on the line is a \
    character.

Line 8:

    Sets the idle timeout for the link. 180 seconds is the default, so this
    line is purely cosmetic.

Line 9:

    Tells PPP to ask the peer to confirm the local resolver settings. If you
    run a local name server, this line should be commented out or removed.

Line 10:

    A blank line for readability. Blank lines are ignored by PPP.

Line 11:

    Identifies an entry for a provider called â  providerâ  . This could be
    changed to the name of your ISP so that later you can use the load ISP to
    start the connection.

Line 12:

    Sets the phone number for this provider. Multiple phone numbers may be
    specified using the colon (:) or pipe character (|) as a separator. The
    difference between the two separators is described in ppp(8). To summarize,
    if you want to rotate through the numbers, use a colon. If you want to
    always attempt to dial the first number first and only use the other
    numbers if the first number fails, use the pipe character. Always quote the
    entire set of phone numbers as shown.

    You must enclose the phone number in quotation marks (") if there is any
    intention on using spaces in the phone number. This can cause a simple, yet
    subtle error.

Line 13 & 14:

    Identifies the user name and password. When connecting using a UNIXÂ® style
    login prompt, these values are referred to by the set login command using
    the \U and \P variables. When connecting using PAP or CHAP, these values
    are used at authentication time.

Line 15:
   
    If you are using PAP or CHAP, there will be no login at this point, and
    this line should be commented out or removed. See PAP and CHAP
    authentication for further details.

    The login string is of the same chat-like syntax as the dial string. In
    this example, the string works for a service whose login session looks like
    this:

    J. Random Provider login: foo password: bar protocol: ppp

    You will need to alter this script to suit your own needs. When you write
    this script for the first time, you should ensure that you have enabled â  
    chatâ   logging so you can determine if the conversation is going as
    expected.

Line 16:
   
    Sets the default idle timeout (in seconds) for the connection. Here, the
    connection will be closed automatically after 300 seconds of inactivity. If
    you never want to timeout, set this value to zero or use the -ddial command
    line switch.

Line 17:
   
    Sets the interface addresses. The string x.x.x.x should be replaced by the
    IP address that your provider has allocated to you. The string y.y.y.y
    should be replaced by the IP address that your ISP indicated for their
    gateway (the machine to which you connect). If your ISP has not given you a
    gateway address, use 10.0.0.2/0. If you need to use a â  guessedâ  
    address, make sure that you create an entry in /etc/ppp/ppp.linkup as per
    the instructions for PPP and Dynamic IP addresses. If this line is omitted,
    ppp cannot run in -auto mode.

Line 18:

    Adds a default route to your ISP's gateway. The special word HISADDR is
    replaced with the gateway address specified on line 17. It is important
    that this line appears after line 17, otherwise HISADDR will not yet be
    initialized.

    If you do not wish to run ppp in -auto, this line should be moved to the
    ppp.linkup file.

It is not necessary to add an entry to ppp.linkup when you have a static IP
address and are running ppp in -auto mode as your routing table entries are
already correct before you connect. You may however wish to create an entry to
invoke programs after connection. This is explained later with the sendmail
example.

Example configuration files can be found in the /usr/share/examples/ppp/
directory.

28.2.1.2.2.Â PPP and Dynamic IP Addresses

If your service provider does not assign static IP addresses, ppp can be
configured to negotiate the local and remote addresses. This is done by â  
guessingâ   an IP address and allowing ppp to set it up correctly using the IP
Configuration Protocol (IPCP) after connecting. The ppp.conf configuration is
the same as PPP and Static IP Addresses, with the following change:

17 set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0

Again, do not include the line number, it is just for reference. Indentation of
at least one space is required.

Line 17:

    The number after the / character is the number of bits of the address that
    ppp will insist on. You may wish to use IP numbers more appropriate to your
    circumstances, but the above example will always work.

    The last argument (0.0.0.0) tells PPP to start negotiations using address
    0.0.0.0 rather than 10.0.0.1 and is necessary for some ISPs. Do not use
    0.0.0.0 as the first argument to set ifaddr as it prevents PPP from setting
    up an initial route in -auto mode.

If you are not running in -auto mode, you will need to create an entry in /etc/
ppp/ppp.linkup. ppp.linkup is used after a connection has been established. At
this point, ppp will have assigned the interface addresses and it will now be
possible to add the routing table entries:

1 provider: 2 add default HISADDR

Line 1:

    On establishing a connection, ppp will look for an entry in ppp.linkup
    according to the following rules: First, try to match the same label as we
    used in ppp.conf. If that fails, look for an entry for the IP address of
    our gateway. This entry is a four-octet IP style label. If we still have
    not found an entry, look for the MYADDR entry.

Line 2:

    This line tells ppp to add a default route that points to HISADDR. HISADDR
    will be replaced with the IP number of the gateway as negotiated by the
    IPCP.

See the pmdemand entry in the files /usr/share/examples/ppp/ppp.conf.sample and
/usr/share/examples/ppp/ppp.linkup.sample for a detailed example.

28.2.1.2.3.Â Receiving Incoming Calls

When you configure ppp to receive incoming calls on a machine connected to a
LAN, you must decide if you wish to forward packets to the LAN. If you do, you
should allocate the peer an IP number from your LAN's subnet, and use the
command enable proxy in your /etc/ppp/ppp.conf file. You should also confirm
that the /etc/rc.conf file contains the following:

gateway_enable="YES"

28.2.1.2.4.Â Which getty?

Configuring FreeBSD for Dial-up Services provides a good description on
enabling dial-up services using getty(8).

An alternative to getty is mgetty (from comms/mgetty+sendfax port), a smarter
version of getty designed with dial-up lines in mind.

The advantages of using mgetty is that it actively talks to modems, meaning if
port is turned off in /etc/ttys then your modem will not answer the phone.

Later versions of mgetty (from 0.99beta onwards) also support the automatic
detection of PPP streams, allowing your clients script-less access to your
server.

Refer to Mgetty and AutoPPP for more information on mgetty.

28.2.1.2.5.Â PPP Permissions

The ppp command must normally be run as the root user. If however, you wish to
allow ppp to run in server mode as a normal user by executing ppp as described
below, that user must be given permission to run ppp by adding them to the
network group in /etc/group.

You will also need to give them access to one or more sections of the
configuration file using the allow command:

allow users fred mary

If this command is used in the default section, it gives the specified users
access to everything.

28.2.1.2.6.Â PPP Shells for Dynamic-IP Users

Create a file called /etc/ppp/ppp-shell containing the following:

#!/bin/sh IDENT=`echo $0 | sed -e 's/^.*-\(.*\)$/\1/'` CALLEDAS="$IDENT" TTY=
`tty` if [ x$IDENT = xdialup ]; then IDENT=`basename $TTY` fi echo "PPP for
$CALLEDAS on $TTY" echo "Starting PPP for $IDENT" exec /usr/sbin/ppp -direct
$IDENT

This script should be executable. Now make a symbolic link called ppp-dialup to
this script using the following commands:

# ln -s ppp-shell /etc/ppp/ppp-dialup

You should use this script as the shell for all of your dialup users. This is
an example from /etc/passwd for a dialup PPP user with username pchilds
(remember do not directly edit the password file, use vipw(8)).

pchilds:*:1011:300:Peter Childs PPP:/home/ppp:/etc/ppp/ppp-dialup

Create a /home/ppp directory that is world readable containing the following 0
byte files:

-r--r--r-- 1 root wheel 0 May 27 02:23 .hushlogin -r--r--r-- 1 root wheel 0 May
27 02:22 .rhosts

which prevents /etc/motd from being displayed.

28.2.1.2.7.Â PPP Shells for Static-IP Users

Create the ppp-shell file as above, and for each account with statically
assigned IPs create a symbolic link to ppp-shell.

For example, if you have three dialup customers, fred, sam, and mary, that you
route /24 CIDR networks for, you would type the following:

# ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-fred # ln -s /etc/ppp/ppp-shell /etc/
ppp/ppp-sam # ln -s /etc/ppp/ppp-shell /etc/ppp/ppp-mary

Each of these users dialup accounts should have their shell set to the symbolic
link created above (for example, mary's shell should be /etc/ppp/ppp-mary).

28.2.1.2.8.Â Setting Up ppp.conf for Dynamic-IP Users

The /etc/ppp/ppp.conf file should contain something along the lines of:

default: set debug phase lcp chat set timeout 0 ttyu0: set ifaddr 203.14.100.1
203.14.100.20 255.255.255.255 enable proxy ttyu1: set ifaddr 203.14.100.1
203.14.100.21 255.255.255.255 enable proxy

Note:

The indenting is important.

The default: section is loaded for each session. For each dialup line enabled
in /etc/ttys create an entry similar to the one for ttyu0: above. Each line
should get a unique IP address from your pool of IP addresses for dynamic
users.

28.2.1.2.9.Â Setting Up ppp.conf for Static-IP Users

Along with the contents of the sample /usr/share/examples/ppp/ppp.conf above
you should add a section for each of the statically assigned dialup users. We
will continue with our fred, sam, and mary example.

fred: set ifaddr 203.14.100.1 203.14.101.1 255.255.255.255 sam: set ifaddr
203.14.100.1 203.14.102.1 255.255.255.255 mary: set ifaddr 203.14.100.1
203.14.103.1 255.255.255.255

The file /etc/ppp/ppp.linkup should also contain routing information for each
static IP user if required. The line below would add a route for the
203.14.101.0/24 network via the client's ppp link.

fred: add 203.14.101.0 netmask 255.255.255.0 HISADDR sam: add 203.14.102.0
netmask 255.255.255.0 HISADDR mary: add 203.14.103.0 netmask 255.255.255.0
HISADDR

28.2.1.2.10.Â mgetty and AutoPPP

By default the comms/mgetty+sendfax port comes with the AUTO_PPP option enabled
allowing mgetty to detect the LCP phase of PPP connections and automatically
spawn off a ppp shell. However, since the default login/password sequence does
not occur it is necessary to authenticate users using either PAP or CHAP.

This section assumes the user has successfully compiled, and installed the
comms/mgetty+sendfax port on his system.

Make sure your /usr/local/etc/mgetty+sendfax/login.config file has the
following in it:

/AutoPPP/ - - /etc/ppp/ppp-pap-dialup

This will tell mgetty to run the ppp-pap-dialup script for detected PPP
connections.

Create a file called /etc/ppp/ppp-pap-dialup containing the following (the file
should be executable):

#!/bin/sh exec /usr/sbin/ppp -direct pap$IDENT

For each dialup line enabled in /etc/ttys, create a corresponding entry in /etc
/ppp/ppp.conf. This will happily co-exist with the definitions we created
above.

pap: enable pap set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40 enable
proxy

Each user logging in with this method will need to have a username/password in
/etc/ppp/ppp.secret file, or alternatively add the following option to
authenticate users via PAP from the /etc/passwd file.

enable passwdauth

If you wish to assign some users a static IP number, you can specify the number
as the third argument in /etc/ppp/ppp.secret. See /usr/share/examples/ppp/
ppp.secret.sample for examples.

28.2.1.2.11.Â MS Extensions

It is possible to configure PPP to supply DNS and NetBIOS nameserver addresses
on demand.

To enable these extensions with PPP version 1.x, the following lines might be
added to the relevant section of /etc/ppp/ppp.conf.

enable msext set ns 203.14.100.1 203.14.100.2 set nbns 203.14.100.5

And for PPP version 2 and above:

accept dns set dns 203.14.100.1 203.14.100.2 set nbns 203.14.100.5

This will tell the clients the primary and secondary name server addresses, and
a NetBIOS nameserver host.

In version 2 and above, if the set dns line is omitted, PPP will use the values
found in /etc/resolv.conf.

28.2.1.2.12.Â PAP and CHAP Authentication

Some ISPs set their system up so that the authentication part of your
connection is done using either of the PAP or CHAP authentication mechanisms.
If this is the case, your ISP will not give a login: prompt when you connect,
but will start talking PPP immediately.

PAP is less secure than CHAP, but security is not normally an issue here as
passwords, although being sent as plain text with PAP, are being transmitted
down a serial line only. There is not much room for crackers to â  eavesdropâ  
.

Referring back to the PPP and Static IP addresses or PPP and Dynamic IP
addresses sections, the following alterations must be made:

13 set authname MyUserName 14 set authkey MyPassword 15 set login

Line 13:

    This line specifies your PAP/CHAP user name. You will need to insert the
    correct value for MyUserName.

Line 14:
   
    This line specifies your PAP/CHAP password. You will need to insert the
    correct value for MyPassword. You may want to add an additional line, such
    as:

    16 accept PAP

    or

    16 accept CHAP

    to make it obvious that this is the intention, but PAP and CHAP are both
    accepted by default.

Line 15:

    Your ISP will not normally require that you log into the server if you are
    using PAP or CHAP. You must therefore disable your â  set loginâ   string.

28.2.1.2.13.Â Changing Your ppp Configuration on the Fly

It is possible to talk to the ppp program while it is running in the
background, but only if a suitable diagnostic port has been set up. To do this,
add the following line to your configuration:

set server /var/run/ppp-tun%d DiagnosticPassword 0177

This will tell PPP to listen to the specified UNIXÂ® domain socket, asking
clients for the specified password before allowing access. The %d in the name
is replaced with the tun device number that is in use.

Once a socket has been set up, the pppctl(8) program may be used in scripts
that wish to manipulate the running program.

28.2.1.3.Â Using PPP Network Address Translation Capability

PPP has ability to use internal NAT without kernel diverting capabilities. This
functionality may be enabled by the following line in /etc/ppp/ppp.conf:

nat enable yes

Alternatively, PPP NAT may be enabled by command-line option -nat. There is
also /etc/rc.conf knob named ppp_nat, which is enabled by default.

If you use this feature, you may also find useful the following /etc/ppp/
ppp.conf options to enable incoming connections forwarding:

nat port tcp 10.0.0.2:ftp ftp nat port tcp 10.0.0.2:http http

or do not trust the outside at all

nat deny_incoming yes

28.2.1.4.Â Final System Configuration

You now have ppp configured, but there are a few more things to do before it is
ready to work. They all involve editing the /etc/rc.conf file.

Working from the top down in this file, make sure the hostname= line is set,
e.g.:

hostname="foo.example.com"

If your ISP has supplied you with a static IP address and name, it is probably
best that you use this name as your host name.

Look for the network_interfaces variable. If you want to configure your system
to dial your ISP on demand, make sure the tun0 device is added to the list,
otherwise remove it.

network_interfaces="lo0 tun0" ifconfig_tun0=

Note:

The ifconfig_tun0 variable should be empty, and a file called /etc/
start_if.tun0 should be created. This file should contain the line:

ppp -auto mysystem

This script is executed at network configuration time, starting your ppp daemon
in automatic mode. If you have a LAN for which this machine is a gateway, you
may also wish to use the -alias switch. Refer to the manual page for further
details.

Make sure that the router program is set to NO with the following line in your
/etc/rc.conf:

router_enable="NO"

It is important that the routed daemon is not started, as routed tends to
delete the default routing table entries created by ppp.

It is probably a good idea to ensure that the sendmail_flags line does not
include the -q option, otherwise sendmail will attempt to do a network lookup
every now and then, possibly causing your machine to dial out. You may try:

sendmail_flags="-bd"

The downside of this is that you must force sendmail to re-examine the mail
queue whenever the ppp link is up by typing:

# /usr/sbin/sendmail -q

You may wish to use the !bg command in ppp.linkup to do this automatically:

1 provider: 2 delete ALL 3 add 0 0 HISADDR 4 !bg sendmail -bd -q30m

If you do not like this, it is possible to set up a â  dfilterâ   to block SMTP
traffic. Refer to the sample files for further details.

All that is left is to reboot the machine. After rebooting, you can now either
type:

# ppp

and then dial provider to start the PPP session, or, if you want ppp to
establish sessions automatically when there is outbound traffic (and you have
not created the start_if.tun0 script), type:

# ppp -auto provider

28.2.1.5.Â Summary

To recap, the following steps are necessary when setting up ppp for the first
time:

Client side:

 1. Ensure that the tun device is built into your kernel.

 2. Ensure that the tunN device file is available in the /dev directory.

 3. Create an entry in /etc/ppp/ppp.conf. The pmdemand example should suffice
    for most ISPs.

 4. If you have a dynamic IP address, create an entry in /etc/ppp/ppp.linkup.

 5. Update your /etc/rc.conf file.

 6. Create a start_if.tun0 script if you require demand dialing.

Server side:

 1. Ensure that the tun device is built into your kernel.

 2. Ensure that the tunN device file is available in the /dev directory.

 3. Create an entry in /etc/passwd (using the vipw(8) program).

 4. Create a profile in this users home directory that runs ppp -direct
    direct-server or similar.

 5. Create an entry in /etc/ppp/ppp.conf. The direct-server example should
    suffice.

 6. Create an entry in /etc/ppp/ppp.linkup.

 7. Update your /etc/rc.conf file.

28.3.Â Using Kernel PPP

Parts originally contributed by Gennady B. Sorokopud and Robert Huff.

Warning:

This section applies and is valid only for FreeBSDÂ 7.X.

28.3.1.Â Setting Up Kernel PPP

Before you start setting up PPP on your machine, make sure that pppd is located
in /usr/sbin and the directory /etc/ppp exists.

pppd can work in two modes:

 1. As a â  clientâ   â   you want to connect your machine to the outside world
    via a PPP serial connection or modem line.

 2. As a â  serverâ   â   your machine is located on the network, and is used
    to connect other computers using PPP.

In both cases you will need to set up an options file (/etc/ppp/options or ~
/.ppprc if you have more than one user on your machine that uses PPP).

You will also need some modem/serial software (preferably comms/kermit), so you
can dial and establish a connection with the remote host.

28.3.2.Â Using pppd as a Client

Based on information provided by Trev Roydhouse.

The following /etc/ppp/options might be used to connect to a Cisco terminal
server PPP line.

crtscts # enable hardware flow control modem # modem control line noipdefault #
remote PPP server must supply your IP address # if the remote host does not
send your IP during IPCP # negotiation, remove this option passive # wait for
LCP packets domain ppp.foo.com # put your domain name here :remote_ip # put the
IP of remote PPP host here # it will be used to route packets via PPP link # if
you didn't specified the noipdefault option # change this line to local_ip:
remote_ip defaultroute # put this if you want that PPP server will be your #
default router

To connect:

 1. Dial to the remote host using Kermit (or some other modem program), and
    enter your user name and password (or whatever is needed to enable PPP on
    the remote host).

 2. Exit Kermit (without hanging up the line).

 3. Enter the following:

    # /usr/sbin/pppd /dev/tty01 19200

    Be sure to use the appropriate speed and device name.

Now your computer is connected with PPP. If the connection fails, you can add
the debug option to the /etc/ppp/options file, and check console messages to
track the problem.

Following /etc/ppp/pppup script will make all 3 stages automatic:

#!/bin/sh pgrep -l pppd pid=`pgrep pppd` if [ "X${pid}" != "X" ] ; then echo
'killing pppd, PID=' ${pid} kill ${pid} fi pgrep -l kermit pid=`pgrep kermit`
if [ "X${pid}" != "X" ] ; then echo 'killing kermit, PID=' ${pid} kill -9 $
{pid} fi ifconfig ppp0 down ifconfig ppp0 delete kermit -y /etc/ppp/kermit.dial
pppd /dev/tty01 19200

/etc/ppp/kermit.dial is a Kermit script that dials and makes all necessary
authorization on the remote host (an example of such a script is attached to
the end of this document).

Use the following /etc/ppp/pppdown script to disconnect the PPP line:

#!/bin/sh pid=`pgrep pppd` if [ X${pid} != "X" ] ; then echo 'killing pppd, PID
=' ${pid} kill -TERM ${pid} fi pgrep -l kermit pid=`pgrep kermit` if [ "X${pid}
" != "X" ] ; then echo 'killing kermit, PID=' ${pid} kill -9 ${pid} fi /sbin/
ifconfig ppp0 down /sbin/ifconfig ppp0 delete kermit -y /etc/ppp/kermit.hup /
etc/ppp/ppptest

Check to see if pppd is still running by executing /usr/etc/ppp/ppptest, which
should look like this:

#!/bin/sh pid=`pgrep pppd` if [ X${pid} != "X" ] ; then echo 'pppd running: PID
=' ${pid-NONE} else echo 'No pppd running.' fi set -x netstat -n -I ppp0
ifconfig ppp0

To hang up the modem, execute /etc/ppp/kermit.hup, which should contain:

set line /dev/tty01 ; put your modem device here set speed 19200 set file type
binary set file names literal set win 8 set rec pack 1024 set send pack 1024
set block 3 set term bytesize 8 set command bytesize 8 set flow none pau 1 out
+++ inp 5 OK out ATH0\13 echo \13 exit

Here is an alternate method using chat instead of kermit:

The following two files are sufficient to accomplish a pppd connection.

/etc/ppp/options:

/dev/cuad1 115200 crtscts # enable hardware flow control modem # modem control
line connect "/usr/bin/chat -f /etc/ppp/login.chat.script" noipdefault # remote
PPP serve must supply your IP address # if the remote host doesn't send your IP
during # IPCP negotiation, remove this option passive # wait for LCP packets
domain your.domain # put your domain name here : # put the IP of remote PPP
host here # it will be used to route packets via PPP link # if you didn't
specified the noipdefault option # change this line to local_ip:remote_ip
defaultroute # put this if you want that PPP server will be # your default
router

/etc/ppp/login.chat.script:

Note:

The following should go on a single line.

ABORT BUSY ABORT 'NO CARRIER' "" AT OK ATDTphone.number CONNECT "" TIMEOUT 10
ogin:-\\r-ogin: login-id TIMEOUT 5 sword: password

Once these are installed and modified correctly, all you need to do is run
pppd, like so:

# pppd

28.3.3.Â Using pppd as a Server

/etc/ppp/options should contain something similar to the following:

crtscts # Hardware flow control netmask 255.255.255.0 # netmask (not required)
192.114.208.20:192.114.208.165 # IP's of local and remote hosts # local ip must
be different from one # you assigned to the Ethernet (or other) # interface on
your machine. # remote IP is IP address that will be # assigned to the remote
machine domain ppp.foo.com # your domain passive # wait for LCP modem # modem
line

The following /etc/ppp/pppserv script will tell pppd to behave as a server:

#!/bin/sh pgrep -l pppd pid=`pgrep pppd` if [ "X${pid}" != "X" ] ; then echo
'killing pppd, PID=' ${pid} kill ${pid} fi pgrep -l kermit pid=`pgrep kermit`
if [ "X${pid}" != "X" ] ; then echo 'killing kermit, PID=' ${pid} kill -9 $
{pid} fi # reset ppp interface ifconfig ppp0 down ifconfig ppp0 delete # enable
autoanswer mode kermit -y /etc/ppp/kermit.ans # run ppp pppd /dev/tty01 19200

Use this /etc/ppp/pppservdown script to stop the server:

#!/bin/sh pgrep -l pppd pid=`pgrep pppd` if [ "X${pid}" != "X" ] ; then echo
'killing pppd, PID=' ${pid} kill ${pid} fi pgrep -l kermit pid=`pgrep kermit`
if [ "X${pid}" != "X" ] ; then echo 'killing kermit, PID=' ${pid} kill -9 $
{pid} fi ifconfig ppp0 down ifconfig ppp0 delete kermit -y /etc/ppp/
kermit.noans

The following Kermit script (/etc/ppp/kermit.ans) will enable/disable
autoanswer mode on your modem. It should look like this:

set line /dev/tty01 set speed 19200 set file type binary set file names literal
set win 8 set rec pack 1024 set send pack 1024 set block 3 set term bytesize 8
set command bytesize 8 set flow none pau 1 out +++ inp 5 OK out ATH0\13 inp 5
OK echo \13 out ATS0=1\13 ; change this to out ATS0=0\13 if you want to disable
; autoanswer mode inp 5 OK echo \13 exit

A script named /etc/ppp/kermit.dial is used for dialing and authenticating on
the remote host. You will need to customize it for your needs. Put your login
and password in this script; you will also need to change the input statement
depending on responses from your modem and remote host.

; ; put the com line attached to the modem here: ; set line /dev/tty01 ; ; put
the modem speed here: ; set speed 19200 set file type binary ; full 8 bit file
xfer set file names literal set win 8 set rec pack 1024 set send pack 1024 set
block 3 set term bytesize 8 set command bytesize 8 set flow none set modem
hayes set dial hangup off set carrier auto ; Then SET CARRIER if necessary, set
dial display on ; Then SET DIAL if necessary, set input echo on set input
timeout proceed set input case ignore def \%x 0 ; login prompt counter goto
slhup :slcmd ; put the modem in command mode echo Put the modem in command
mode. clear ; Clear unread characters from input buffer pause 1 output +++ ;
hayes escape sequence input 1 OK\13\10 ; wait for OK if success goto slhup
output \13 pause 1 output at\13 input 1 OK\13\10 if fail goto slcmd ; if modem
doesn't answer OK, try again :slhup ; hang up the phone clear ; Clear unread
characters from input buffer pause 1 echo Hanging up the phone. output ath0\13
; hayes command for on hook input 2 OK\13\10 if fail goto slcmd ; if no OK
answer, put modem in command mode :sldial ; dial the number pause 1 echo
Dialing. output atdt9,550311\13\10 ; put phone number here assign \%x 0 ; zero
the time counter :look clear ; Clear unread characters from input buffer
increment \%x ; Count the seconds input 1 {CONNECT } if success goto sllogin
reinput 1 {NO CARRIER\13\10} if success goto sldial reinput 1 {NO DIALTONE\13\
10} if success goto slnodial reinput 1 {\255} if success goto slhup reinput 1
{\127} if success goto slhup if &lt; \%x 60 goto look else goto slhup :sllogin ;
login assign \%x 0 ; zero the time counter pause 1 echo Looking for login
prompt. :slloop increment \%x ; Count the seconds clear ; Clear unread
characters from input buffer output \13 ; ; put your expected login prompt
here: ; input 1 {Username: } if success goto sluid reinput 1 {\255} if success
goto slhup reinput 1 {\127} if success goto slhup if &lt; \%x 10 goto slloop ; try
10 times to get a login prompt else goto slhup ; hang up and start again if 10
failures :sluid ; ; put your userid here: ; output ppp-login\13 input 1
{Password: } ; ; put your password here: ; output ppp-password\13 input 1
{Entering SLIP mode.} echo quit :slnodial echo \7No dialtone. Check the
telephone line!\7 exit 1 ; local variables: ; mode: csh ; comment-start: "; " ;
comment-start-skip: "; " ; end:

28.4.Â Troubleshooting PPP Connections

Contributed by Tom Rhodes.

This section covers a few issues which may arise when using PPP over a modem
connection. For instance, perhaps you need to know exactly what prompts the
system you are dialing into will present. Some ISPs present the ssword prompt,
and others will present password; if the ppp script is not written accordingly,
the login attempt will fail. The most common way to debug ppp connections is by
connecting manually. The following information will walk you through a manual
connection step by step.

28.4.1.Â Check the Device Nodes

When using a custom kernel, make sure to include the following line in your
kernel configuration file:

device uart

The uart device is already included in the GENERIC kernel, so no additional
steps are necessary in this case. Just check the dmesg output for the modem
device with:

# dmesg | grep uart

You should get some pertinent output about the uart devices. These are the COM
ports we need. If your modem acts like a standard serial port then you should
see it listed on uart1, or COM2. If so, you are not required to rebuild the
kernel. When matching up sio modem is on uart1 or COM2 if you are in DOS, then
your modem device would be /dev/cuau1.

28.4.2.Â Connecting Manually

Connecting to the Internet by manually controlling ppp is quick, easy, and a
great way to debug a connection or just get information on how your ISP treats
ppp client connections. Lets start PPP from the command line. Note that in all
of our examples we will use example as the hostname of the machine running PPP.
You start ppp by just typing ppp:

# ppp

We have now started ppp.

ppp ON example&gt; set device /dev/cuau1

We set our modem device, in this case it is cuau1.

ppp ON example&gt; set speed 115200

Set the connection speed, in this case we are using 115,200 kbps.

ppp ON example&gt; enable dns

Tell ppp to configure our resolver and add the nameserver lines to /etc/
resolv.conf. If ppp cannot determine our hostname, we can set one manually
later.

ppp ON example&gt; term

Switch to â  terminalâ   mode so that we can manually control the modem.

deflink: Entering terminal mode on /dev/cuau1 type '~h' for help
at OK atdt123456789

Use at to initialize the modem, then use atdt and the number for your ISP to
begin the dial in process.

CONNECT

Confirmation of the connection, if we are going to have any connection
problems, unrelated to hardware, here is where we will attempt to resolve them.

ISP Login:myusername

Here you are prompted for a username, return the prompt with the username that
was provided by the ISP.

ISP Pass:mypassword

This time we are prompted for a password, just reply with the password that was
provided by the ISP. Just like logging into FreeBSD, the password will not
echo.

Shell or PPP:ppp

Depending on your ISP this prompt may never appear. Here we are being asked if
we wish to use a shell on the provider, or to start ppp. In this example, we
have chosen to use ppp as we want an Internet connection.

Ppp ON example&gt;

Notice that in this example the first p has been capitalized. This shows that
we have successfully connected to the ISP.

PPp ON example&gt;

We have successfully authenticated with our ISP and are waiting for the
assigned IP address.

PPP ON example&gt;

We have made an agreement on an IP address and successfully completed our
connection.

PPP ON example&gt;add default HISADDR

Here we add our default route, we need to do this before we can talk to the
outside world as currently the only established connection is with the peer. If
this fails due to existing routes you can put a bang character ! in front of
the add. Alternatively, you can set this before making the actual connection
and it will negotiate a new route accordingly.

If everything went good we should now have an active connection to the
Internet, which could be thrown into the background using CTRL+z If you notice
the PPP return to ppp then we have lost our connection. This is good to know
because it shows our connection status. Capital P's show that we have a
connection to the ISP and lowercase p's show that the connection has been lost
for whatever reason. ppp only has these 2 states.

28.4.2.1.Â Debugging

If you have a direct line and cannot seem to make a connection, then turn
hardware flow CTS/RTS to off with the set ctsrts off. This is mainly the case
if you are connected to some PPP capable terminal servers, where PPP hangs when
it tries to write data to your communication link, so it would be waiting for a
CTS, or Clear To Send signal which may never come. If you use this option
however, you should also use the set accmap option, which may be required to
defeat hardware dependent on passing certain characters from end to end, most
of the time XON/XOFF. See the ppp(8) manual page for more information on this
option, and how it is used.

If you have an older modem, you may need to use the set parity even. Parity is
set at none be default, but is used for error checking (with a large increase
in traffic) on older modems and some ISPs. You may need this option for the
Compuserve ISP.

PPP may not return to the command mode, which is usually a negotiation error
where the ISP is waiting for your side to start negotiating. At this point,
using the ~p command will force ppp to start sending the configuration
information.

If you never obtain a login prompt, then most likely you need to use PAP or 
CHAP authentication instead of the UNIXÂ® style in the example above. To use 
PAP or CHAP just add the following options to PPP before going into terminal
mode:

ppp ON example&gt; set authname myusername

Where myusername should be replaced with the username that was assigned by the 
ISP.

ppp ON example&gt; set authkey mypassword

Where mypassword should be replaced with the password that was assigned by the 
ISP.

If you connect fine, but cannot seem to find any domain name, try to use ping
(8) with an IP address and see if you can get any return information. If you
experience 100 percent (100%) packet loss, then it is most likely that you were
not assigned a default route. Double check that the option add default HISADDR
was set during the connection. If you can connect to a remote IP address then
it is possible that a resolver address has not been added to the /etc/
resolv.conf. This file should look like:

domain example.com nameserver x.x.x.x nameserver y.y.y.y

Where x.x.x.x and y.y.y.y should be replaced with the IP address of your ISP's
DNS servers. This information may or may not have been provided when you signed
up, but a quick call to your ISP should remedy that.

You could also have syslog(3) provide a logging function for your PPP
connection. Just add:

!ppp *.* /var/log/ppp.log

to /etc/syslog.conf. In most cases, this functionality already exists.

28.5.Â Using PPP over Ethernet (PPPoE)

Contributed (from http://node.to/freebsd/how-tos/how-to-freebsd-pppoe.html) by 
Jim Mock.

This section describes how to set up PPP over Ethernet (PPPoE).

28.5.1.Â Configuring the Kernel

No kernel configuration is necessary for PPPoE any longer. If the necessary
netgraph support is not built into the kernel, it will be dynamically loaded by
ppp.

28.5.2.Â Setting Up ppp.conf

Here is an example of a working ppp.conf:

default: set log Phase tun command # you can add more detailed logging if you
wish set ifaddr 10.0.0.1/0 10.0.0.2/0 name_of_service_provider: set device
PPPoE:xl1 # replace xl1 with your Ethernet device set authname YOURLOGINNAME
set authkey YOURPASSWORD set dial set login add default HISADDR

28.5.3.Â Running ppp

As root, you can run:

# ppp -ddial name_of_service_provider

28.5.4.Â Starting ppp at Boot

Add the following to your /etc/rc.conf file:

ppp_enable="YES" ppp_mode="ddial" ppp_nat="YES" # if you want to enable nat for
your local network, otherwise NO ppp_profile="name_of_service_provider"

28.5.5.Â Using a PPPoE Service Tag

Sometimes it will be necessary to use a service tag to establish your
connection. Service tags are used to distinguish between different PPPoE
servers attached to a given network.

You should have been given any required service tag information in the
documentation provided by your ISP. If you cannot locate it there, ask your
ISP's tech support personnel.

As a last resort, you could try the method suggested by the Roaring Penguin
PPPoE program which can be found in the Ports Collection. Bear in mind however,
this may de-program your modem and render it useless, so think twice before
doing it. Simply install the program shipped with the modem by your provider.
Then, access the System menu from the program. The name of your profile should
be listed there. It is usually ISP.

The profile name (service tag) will be used in the PPPoE configuration entry in
ppp.conf as the provider part of the set device command (see the ppp(8) manual
page for full details). It should look like this:

set device PPPoE:xl1:ISP

Do not forget to change xl1 to the proper device for your Ethernet card.

Do not forget to change ISP to the profile you have just found above.

For additional information, see:

  * Cheaper Broadband with FreeBSD on DSL by Renaud Waldura.

28.5.6.Â PPPoE with a 3ComÂ® HomeConnectÂ® ADSL Modem Dual Link

This modem does not follow RFC 2516 (A Method for transmitting PPP over
Ethernet (PPPoE), written by L. Mamakos, K. Lidl, J. Evarts, D. Carrel, D.
Simone, and R. Wheeler). Instead, different packet type codes have been used
for the Ethernet frames. Please complain to 3Com if you think it should comply
with the PPPoE specification.

In order to make FreeBSD capable of communicating with this device, a sysctl
must be set. This can be done automatically at boot time by updating /etc/
sysctl.conf:

net.graph.nonstandard_pppoe=1

or can be done immediately with the command:

# sysctl net.graph.nonstandard_pppoe=1

Unfortunately, because this is a system-wide setting, it is not possible to
talk to a normal PPPoE client or server and a 3ComÂ® HomeConnectÂ® ADSL Modem
at the same time.

28.6.Â Using PPP over ATM (PPPoA)

The following describes how to set up PPP over ATM (PPPoA). PPPoA is a popular
choice among European DSL providers.

28.6.1.Â Using PPPoA with the Alcatel SpeedTouchâ ¢ USB

PPPoA support for this device is supplied as a port in FreeBSD because the
firmware is distributed under Alcatel's license agreement and can not be
redistributed freely with the base system of FreeBSD.

To install the software, simply use the Ports Collection. Install the net/pppoa
port and follow the instructions provided with it.

Like many USB devices, the Alcatel SpeedTouchâ ¢ USB needs to download firmware
from the host computer to operate properly. It is possible to automate this
process in FreeBSD so that this transfer takes place whenever the device is
plugged into a USB port. The following information can be added to the /etc/
usbd.conf file to enable this automatic firmware transfer. This file must be
edited as the root user.

device "Alcatel SpeedTouch USB" devname "ugen[0-9]+" vendor 0x06b9 product
0x4061 attach "/usr/local/sbin/modem_run -f /usr/local/libdata/mgmt.o"

To enable the USB daemon, usbd, put the following the line into /etc/rc.conf:

usbd_enable="YES"

It is also possible to set up ppp to dial up at startup. To do this add the
following lines to /etc/rc.conf. Again, for this procedure you will need to be
logged in as the root user.

ppp_enable="YES" ppp_mode="ddial" ppp_profile="adsl"

For this to work correctly you will need to have used the sample ppp.conf which
is supplied with the net/pppoa port.

28.6.2.Â Using mpd

You can use mpd to connect to a variety of services, in particular PPTP
services. You can find mpd in the Ports Collection, net/mpd. Many ADSL modems
require that a PPTP tunnel is created between the modem and computer, one such
modem is the Alcatel SpeedTouchâ ¢ Home.

First you must install the port, and then you can configure mpd to suit your
requirements and provider settings. The port places a set of sample
configuration files which are well documented in PREFIX/etc/mpd/. Note here
that PREFIX means the directory into which your ports are installed, this
defaults to /usr/local/. A complete guide to configure mpd is available in HTML
format once the port has been installed. It is placed in PREFIX/share/doc/mpd/.
Here is a sample configuration for connecting to an ADSL service with mpd. The
configuration is spread over two files, first the mpd.conf:

Note:

This example of the mpd.conf file only works with mpd 4.x.

default: load adsl adsl: new -i ng0 adsl adsl set bundle authname username 1
set bundle password password 2 set bundle disable multilink set link no pap
acfcomp protocomp set link disable chap set link accept chap set link
keep-alive 30 10 set ipcp no vjcomp set ipcp ranges 0.0.0.0/0 0.0.0.0/0 set
iface route default set iface disable on-demand set iface enable proxy-arp set
iface idle 0 open

1  The username used to authenticate with your ISP.

2  The password used to authenticate with your ISP.

The mpd.links file contains information about the link, or links, you wish to
establish. An example mpd.links to accompany the above example is given
beneath:

adsl: set link type pptp set pptp mode active set pptp enable originate outcall
set pptp self 10.0.0.1 1 set pptp peer 10.0.0.138 2

1    The IP address of your FreeBSD computer which you will be using mpd from.

2    The IP address of your ADSL modem. For the Alcatel SpeedTouchâ ¢ Home this
     address defaults to 10.0.0.138.

It is possible to initialize the connection easily by issuing the following
command as root:

# mpd -b adsl

You can see the status of the connection with the following command:

% ifconfig ng0 ng0: flags=88d1&lt;UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST&gt;
mtu 1500 inet 216.136.204.117 --&gt; 204.152.186.171 netmask 0xffffffff

Using mpd is the recommended way to connect to an ADSL service with FreeBSD.

28.6.3.Â Using pptpclient

It is also possible to use FreeBSD to connect to other PPPoA services using net
/pptpclient.

To use net/pptpclient to connect to a DSL service, install the port or package
and edit your /etc/ppp/ppp.conf. You will need to be root to perform both of
these operations. An example section of ppp.conf is given below. For further
information on ppp.conf options consult the ppp manual page, ppp(8).

adsl: set log phase chat lcp ipcp ccp tun command set timeout 0 enable dns set
authname username 1 set authkey password 2 set ifaddr 0 0 add default HISADDR

1   The username of your account with the DSL provider.

2   The password for your account.

Warning:

Because you must put your account's password in the ppp.conf file in plain text
form you should make sure than nobody can read the contents of this file. The
following series of commands will make sure the file is only readable by the
root account. Refer to the manual pages for chmod(1) and chown(8) for further
information.

# chown root:wheel /etc/ppp/ppp.conf # chmod 600 /etc/ppp/ppp.conf

This will open a tunnel for a PPP session to your DSL router. Ethernet DSL
modems have a preconfigured LAN IP address which you connect to. In the case of
the Alcatel SpeedTouchâ ¢ Home this address is 10.0.0.138. Your router
documentation should tell you which address your device uses. To open the
tunnel and start a PPP session execute the following command:

# pptp address adsl

Tip:

You may wish to add an ampersand (â  &â  ) to the end of the previous command
because pptp will not return your prompt to you otherwise.

A tun virtual tunnel device will be created for interaction between the pptp
and ppp processes. Once you have been returned to your prompt, or the pptp
process has confirmed a connection you can examine the tunnel like so:

% ifconfig tun0 tun0: flags=8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
inet 216.136.204.21 --&gt; 204.152.186.171 netmask 0xffffff00 Opened by PID 918

If you are unable to connect, check the configuration of your router, which is
usually accessible via telnet or with a web browser. If you still cannot
connect you should examine the output of the pptp command and the contents of
the ppp log file, /var/log/ppp.log for clues.

28.7.Â Using SLIP

Originally contributed by Satoshi Asami.
With input from Guy Helmer and Piero Serini.

Warning:

This section applies and is valid only for FreeBSDÂ 7.X.

28.7.1.Â Setting Up a SLIP Client

The following is one way to set up a FreeBSD machine for SLIP on a static host
network. For dynamic hostname assignments (your address changes each time you
dial up), you probably need to have a more complex setup.

First, determine which serial port your modem is connected to. Many people set
up a symbolic link, such as /dev/modem, to point to the real device name, /dev/
cuadN. This allows you to abstract the actual device name should you ever need
to move the modem to a different port. It can become quite cumbersome when you
need to fix a bunch of files in /etc and .kermrc files all over the system!

Note:

/dev/cuad0 is COM1, /dev/cuad1 is COM2, etc.

Make sure you have the following in your kernel configuration file:

device sl

It is included in the GENERIC kernel, so this should not be a problem unless
you have deleted it.

28.7.1.1.Â Things You Have to Do Only Once

 1. Add your home machine, the gateway and nameservers to your /etc/hosts file.
    Ours looks like this:

    127.0.0.1 localhost loghost 136.152.64.181 water.CS.Example.EDU water.CS
    water 136.152.64.1 inr-3.CS.Example.EDU inr-3 slip-gateway 128.32.136.9
    ns1.Example.EDU ns1 128.32.136.12 ns2.Example.EDU ns2
 2. Make sure you have files before dns in the hosts: section of your /etc/
    nsswitch.conf file. Without these parameters funny things may happen.

 3. Edit the /etc/rc.conf file.

     1. Set your hostname by editing the line that says:

        hostname="myname.my.domain"

        Your machine's full Internet hostname should be placed here.

     2. Designate the default router by changing the line:

        defaultrouter="NO"

        to:

        defaultrouter="slip-gateway"
 4. Make a file /etc/resolv.conf which contains:

    domain CS.Example.EDU nameserver 128.32.136.9 nameserver 128.32.136.12
   
    As you can see, these set up the nameserver hosts. Of course, the actual
    domain names and addresses depend on your environment.

 5. Set the password for root and toor (and any other accounts that do not have
    a password).

 6. Reboot your machine and make sure it comes up with the correct hostname.

28.7.1.2.Â Making a SLIP Connection

 1. Dial up, type slip at the prompt, enter your machine name and password.
    What is required to be entered depends on your environment. If you use 
    Kermit, you can try a script like this:

    # kermit setup set modem hayes set line /dev/modem set speed 115200 set
    parity none set flow rts/cts set terminal bytesize 8 set file type binary #
    The next macro will dial up and login define slip dial 643-9600, input 10
    =&gt;, if failure stop, - output slip\x0d, input 10 Username:, if failure
    stop, - output silvia\x0d, input 10 Password:, if failure stop, - output
    ***\x0d, echo \x0aCONNECTED\x0a

    Of course, you have to change the username and password to fit yours. After
    doing so, you can just type slip from the Kermit prompt to connect.

    Note:

    Leaving your password in plain text anywhere in the filesystem is generally
    a bad idea. Do it at your own risk.

 2. Leave the Kermit there (you can suspend it by Ctrl+z) and as root, type:

    # slattach -h -c -s 115200 /dev/modem

    If you are able to ping hosts on the other side of the router, you are
    connected! If it does not work, you might want to try -a instead of -c as
    an argument to slattach.

28.7.1.3.Â How to Shutdown the Connection

Do the following:

# kill -INT `cat /var/run/slattach.modem.pid`

to kill slattach. Keep in mind you must be root to do the above. Then go back
to kermit (by running fg if you suspended it) and exit from it (q).

The slattach(8) manual page says you have to use ifconfig sl0 down to mark the
interface down, but this does not seem to make any difference. (ifconfig sl0
reports the same thing.)

Some times, your modem might refuse to drop the carrier. In that case, simply
start kermit and quit it again. It usually goes out on the second try.

28.7.1.4.Â Troubleshooting

If it does not work, feel free to ask on freebsd-net mailing list. The things
that people tripped over so far:

  * Not using -c or -a in slattach (This should not be fatal, but some users
    have reported that this solves their problems.)

  * Using s10 instead of sl0 (might be hard to see the difference on some
    fonts).

  * Try ifconfig sl0 to see your interface status. For example, you might get:

    # ifconfig sl0 sl0: flags=10&lt;POINTOPOINT&gt; inet 136.152.64.181 --&gt;
    136.152.64.1 netmask ffffff00
  * If you get no route to host messages from ping(8), there may be a problem
    with your routing table. You can use the netstat -r command to display the
    current routes :

    # netstat -r Routing tables Destination Gateway Flags Refs Use IfaceMTU Rtt
    Netmasks: (root node) (root node) Route Tree for Protocol Family inet:
    (root node) =&gt; default inr-3.Example.EDU UG 8 224515 sl0 - -
    localhost.Exampl localhost.Example. UH 5 42127 lo0 - 0.438 inr-3.Example.ED
    water.CS.Example.E UH 1 0 sl0 - - water.CS.Example localhost.Example. UGH
    34 47641234 lo0 - 0.438 (root node)

    The preceding examples are from a relatively busy system. The numbers on
    your system will vary depending on network activity.

28.7.2.Â Setting Up a SLIP Server

This document provides suggestions for setting up SLIP Server services on a
FreeBSD system, which typically means configuring your system to automatically
start up connections upon login for remote SLIP clients.

28.7.2.1.Â Prerequisites

This section is very technical in nature, so background knowledge is required.
It is assumed that you are familiar with the TCP/IP network protocol, and in
particular, network and node addressing, network address masks, subnetting,
routing, and routing protocols, such as RIP. Configuring SLIP services on a
dial-up server requires a knowledge of these concepts, and if you are not
familiar with them, please read a copy of either Craig Hunt's TCP/IP Network
Administration published by O'Reilly & Associates, Inc. (ISBN Number
0-937175-82-X), or Douglas Comer's books on the TCP/IP protocol.

It is further assumed that you have already set up your modem(s) and configured
the appropriate system files to allow logins through your modems. If you have
not prepared your system for this yet, please see SectionÂ 27.4, â  Dial-in
Serviceâ   for details on dialup services configuration. You may also want to
check the manual pages or sio(4) for information on the serial port device
driver and ttys(5), gettytab(5), getty(8), & init(8) for information relevant
to configuring the system to accept logins on modems, and perhaps stty(1) for
information on setting serial port parameters (such as clocal for
directly-connected serial interfaces).

28.7.2.2.Â Quick Overview

In its typical configuration, using FreeBSD as a SLIP server works as follows:
a SLIP user dials up your FreeBSD SLIP Server system and logs in with a special
SLIP login ID that uses /usr/sbin/sliplogin as the special user's shell. The
sliplogin program browses the file /etc/sliphome/slip.hosts to find a matching
line for the special user, and if it finds a match, connects the serial line to
an available SLIP interface and then runs the shell script /etc/sliphome/
slip.login to configure the SLIP interface.

28.7.2.2.1.Â An Example of a SLIP Server Login

For example, if a SLIP user ID were Shelmerg, Shelmerg's entry in /etc/
master.passwd would look something like this:

Shelmerg:password:1964:89::0:0:Guy Helmer - SLIP:/usr/users/Shelmerg:/usr/sbin/
sliplogin

When Shelmerg logs in, sliplogin will search /etc/sliphome/slip.hosts for a
line that had a matching user ID; for example, there may be a line in /etc/
sliphome/slip.hosts that reads:

Shelmerg dc-slip sl-helmer 0xfffffc00 autocomp

sliplogin will find that matching line, hook the serial line into the next
available SLIP interface, and then execute /etc/sliphome/slip.login like this:

/etc/sliphome/slip.login 0 19200 Shelmerg dc-slip sl-helmer 0xfffffc00 autocomp

If all goes well, /etc/sliphome/slip.login will issue an ifconfig for the SLIP
interface to which sliplogin attached itself (SLIP interface 0, in the above
example, which was the first parameter in the list given to slip.login) to set
the local IP address (dc-slip), remote IP address (sl-helmer), network mask for
the SLIP interface (0xfffffc00), and any additional flags (autocomp). If
something goes wrong, sliplogin usually logs good informational messages via
the syslogd daemon facility, which usually logs to /var/log/messages (see the
manual pages for syslogd(8) and syslog.conf(5) and perhaps check /etc/
syslog.conf to see to what syslogd is logging and where it is logging to).

28.7.2.3.Â Kernel Configuration

FreeBSD's default kernel (GENERIC) comes with SLIP (sl(4)) support; in case of
a custom kernel, you have to add the following line to your kernel
configuration file:

device sl

By default, your FreeBSD machine will not forward packets. If you want your
FreeBSD SLIP Server to act as a router, you will have to edit the /etc/rc.conf
file and change the setting of the gateway_enable variable to YES. This will
make sure that setting the routing option will be persistent after a reboot.

To apply the settings immediately you can execute the following command as
root:

# service routing start

Please refer to ChapterÂ 9, Configuring the FreeBSD Kernel on Configuring the
FreeBSD Kernel for help in reconfiguring your kernel.

28.7.2.4.Â Sliplogin Configuration

As mentioned earlier, there are three files in the /etc/sliphome directory that
are part of the configuration for /usr/sbin/sliplogin (see sliplogin(8) for the
actual manual page for sliplogin): slip.hosts, which defines the SLIP users and
their associated IP addresses; slip.login, which usually just configures the
SLIP interface; and (optionally) slip.logout, which undoes slip.login's effects
when the serial connection is terminated.

28.7.2.4.1.Â slip.hosts Configuration

/etc/sliphome/slip.hosts contains lines which have at least four items
separated by whitespace:

  * SLIP user's login ID

  * Local address (local to the SLIP server) of the SLIP link

  * Remote address of the SLIP link

  * Network mask

The local and remote addresses may be host names (resolved to IP addresses by /
etc/hosts or by the domain name service, depending on your specifications in
the file /etc/nsswitch.conf), and the network mask may be a name that can be
resolved by a lookup into /etc/networks. On a sample system, /etc/sliphome/
slip.hosts looks like this:

# # login local-addr remote-addr mask opt1 opt2 # (normal,compress,noicmp) #
Shelmerg dc-slip sl-helmerg 0xfffffc00 autocomp

At the end of the line is one or more of the options:

  * normal â   no header compression

  * compress â   compress headers

  * autocomp â   compress headers if the remote end allows it

  * noicmp â   disable ICMP packets (so any â  pingâ   packets will be dropped
    instead of using up your bandwidth)

Your choice of local and remote addresses for your SLIP links depends on
whether you are going to dedicate a TCP/IP subnet or if you are going to use â 
 proxy ARPâ   on your SLIP server (it is not â  trueâ   proxy ARP, but that is
the terminology used in this section to describe it). If you are not sure which
method to select or how to assign IP addresses, please refer to the TCP/IP
books referenced in the SLIP Prerequisites (SectionÂ 28.7.2.1, â  
Prerequisitesâ  ) and/or consult your IP network manager.

If you are going to use a separate subnet for your SLIP clients, you will need
to allocate the subnet number out of your assigned IP network number and assign
each of your SLIP client's IP numbers out of that subnet. Then, you will
probably need to configure a static route to the SLIP subnet via your SLIP
server on your nearest IP router.

Otherwise, if you will use the â  proxy ARPâ   method, you will need to assign
your SLIP client's IP addresses out of your SLIP server's Ethernet subnet, and
you will also need to adjust your /etc/sliphome/slip.login and /etc/sliphome/
slip.logout scripts to use arp(8) to manage the â  proxy ARPâ   entries in the
SLIP server's ARP table.

28.7.2.4.2.Â slip.login Configuration

The typical /etc/sliphome/slip.login file looks like this:

#!/bin/sh - # # @(#)slip.login 5.1 (Berkeley) 7/1/90 # # generic login file for
a slip line. sliplogin invokes this with # the parameters: # 1 2 3 4 5 6 7-n #
slipunit ttyspeed loginname local-addr remote-addr mask opt-args # /sbin/
ifconfig sl$1 inet $4 $5 netmask $6

This slip.login file merely runs ifconfig for the appropriate SLIP interface
with the local and remote addresses and network mask of the SLIP interface.

If you have decided to use the â  proxy ARPâ   method (instead of using a
separate subnet for your SLIP clients), your /etc/sliphome/slip.login file will
need to look something like this:

#!/bin/sh - # # @(#)slip.login 5.1 (Berkeley) 7/1/90 # # generic login file for
a slip line. sliplogin invokes this with # the parameters: # 1 2 3 4 5 6 7-n #
slipunit ttyspeed loginname local-addr remote-addr mask opt-args # /sbin/
ifconfig sl$1 inet $4 $5 netmask $6 # Answer ARP requests for the SLIP client
with our Ethernet addr /usr/sbin/arp -s $5 00:11:22:33:44:55 pub

The additional line in this slip.login, arp -s $5 00:11:22:33:44:55 pub,
creates an ARP entry in the SLIP server's ARP table. This ARP entry causes the
SLIP server to respond with the SLIP server's Ethernet MAC address whenever
another IP node on the Ethernet asks to speak to the SLIP client's IP address.

When using the example above, be sure to replace the Ethernet MAC address
(00:11:22:33:44:55) with the MAC address of your system's Ethernet card, or
your â  proxy ARPâ   will definitely not work! You can discover your SLIP
server's Ethernet MAC address by looking at the results of running netstat -i;
the second line of the output should look something like:

ed0 1500 &lt;Link&gt;0.2.c1.28.5f.4a 191923 0 129457 0 116

This indicates that this particular system's Ethernet MAC address is
00:02:c1:28:5f:4a â   the periods in the Ethernet MAC address given by netstat
-i must be changed to colons and leading zeros should be added to each
single-digit hexadecimal number to convert the address into the form that arp
(8) desires; see the manual page on arp(8) for complete information on usage.

Note:

When you create /etc/sliphome/slip.login and /etc/sliphome/slip.logout, the â  
executeâ   bit (i.e., chmod 755 /etc/sliphome/slip.login /etc/sliphome/
slip.logout) must be set, or sliplogin will be unable to execute it.

28.7.2.4.3.Â slip.logout Configuration

/etc/sliphome/slip.logout is not strictly needed (unless you are implementing â
  proxy ARPâ  ), but if you decide to create it, this is an example of a basic
slip.logout script:

#!/bin/sh - # # slip.logout # # logout file for a slip line. sliplogin invokes
this with # the parameters: # 1 2 3 4 5 6 7-n # slipunit ttyspeed loginname
local-addr remote-addr mask opt-args # /sbin/ifconfig sl$1 down

If you are using â  proxy ARPâ  , you will want to have /etc/sliphome/
slip.logout remove the ARP entry for the SLIP client:

#!/bin/sh - # # @(#)slip.logout # # logout file for a slip line. sliplogin
invokes this with # the parameters: # 1 2 3 4 5 6 7-n # slipunit ttyspeed
loginname local-addr remote-addr mask opt-args # /sbin/ifconfig sl$1 down #
Quit answering ARP requests for the SLIP client /usr/sbin/arp -d $5

The arp -d $5 removes the ARP entry that the â  proxy ARPâ   slip.login added
when the SLIP client logged in.

It bears repeating: make sure /etc/sliphome/slip.logout has the execute bit set
after you create it (i.e., chmod 755 /etc/sliphome/slip.logout).

28.7.2.5.Â Routing Considerations

If you are not using the â  proxy ARPâ   method for routing packets between
your SLIP clients and the rest of your network (and perhaps the Internet), you
will probably have to add static routes to your closest default router(s) to
route your SLIP clients subnet via your SLIP server.

28.7.2.5.1.Â Static Routes

Adding static routes to your nearest default routers can be troublesome (or
impossible if you do not have authority to do so...). If you have a
multiple-router network in your organization, some routers, such as those made
by Cisco and Proteon, may not only need to be configured with the static route
to the SLIP subnet, but also need to be told which static routes to tell other
routers about, so some expertise and troubleshooting/tweaking may be necessary
to get static-route-based routing to work.

ChapterÂ 29.Â Electronic Mail

Original work by Bill Lloyd.
Rewritten by Jim Mock.
Table of Contents

29.1. Synopsis
29.2. Using Electronic Mail
29.3. sendmail Configuration
29.4. Changing Your Mail Transfer Agent
29.5. Troubleshooting
29.6. Advanced Topics
29.7. Setting Up to Send Only
29.8. Using Mail with a Dialup Connection
29.9. SMTP Authentication
29.10. Mail User Agents
29.11. Using fetchmail
29.12. Using procmail

29.1.Â Synopsis

â  Electronic Mailâ  , better known as email, is one of the most widely used
forms of communication today. This chapter provides a basic introduction to
running a mail server on FreeBSD, as well as an introduction to sending and
receiving email using FreeBSD; however, it is not a complete reference and in
fact many important considerations are omitted. For more complete coverage of
the subject, the reader is referred to the many excellent books listed in
AppendixÂ B, Bibliography.

After reading this chapter, you will know:

  * What software components are involved in sending and receiving electronic
    mail.

  * Where basic sendmail configuration files are located in FreeBSD.

  * The difference between remote and local mailboxes.

  * How to block spammers from illegally using your mail server as a relay.

  * How to install and configure an alternate Mail Transfer Agent on your
    system, replacing sendmail.

  * How to troubleshoot common mail server problems.

  * How to set up the system to send mail only.

  * How to use mail with a dialup connection.

  * How to configure SMTP Authentication for added security.

  * How to install and use a Mail User Agent, such as mutt to send and receive
    email.

  * How to download your mail from a remote POP or IMAP server.

  * How to automatically apply filters and rules to incoming email.

Before reading this chapter, you should:

  * Properly set up your network connection (ChapterÂ 32, Advanced Networking).

  * Properly set up the DNS information for your mail host (ChapterÂ 30, 
    Network Servers).

  * Know how to install additional third-party software (ChapterÂ 5, Installing
    Applications: Packages and Ports).

29.2.Â Using Electronic Mail

There are five major parts involved in an email exchange. They are: the user
program, the server daemon, DNS, a remote or local mailbox, and of course, the
mailhost itself.

29.2.1.Â The User Program

This includes command line programs such as mutt, alpine, elm, and mail, and 
GUI programs such as balsa, xfmail to name a few, and something more â  
sophisticatedâ   like a WWW browser. These programs simply pass off the email
transactions to the local â  mailhostâ  , either by calling one of the server
daemons available, or delivering it over TCP.

29.2.2.Â Mailhost Server Daemon

FreeBSD ships with sendmail by default, but also support numerous other mail
server daemons, just some of which include:

  * exim;

  * postfix;

  * qmail.

The server daemon usually has two functionsâ  it is responsible for receiving
incoming mail as well as delivering outgoing mail. It is not responsible for
the collection of mail using protocols such as POP or IMAP to read your email,
nor does it allow connecting to local mbox or Maildir mailboxes. You may
require an additional daemon for that.

Warning:

Older versions of sendmail have some serious security issues which may result
in an attacker gaining local and/or remote access to your machine. Make sure
that you are running a current version to avoid these problems. Optionally,
install an alternative MTA from the FreeBSD Ports Collection.

29.2.3.Â Email and DNS

The Domain Name System (DNS) and its daemon named play a large role in the
delivery of email. In order to deliver mail from your site to another, the
server daemon will look up the remote site in the DNS to determine the host
that will receive mail for the destination. This process also occurs when mail
is sent from a remote host to your mail server.

DNS is responsible for mapping hostnames to IP addresses, as well as for
storing information specific to mail delivery, known as MX records. The MX
(Mail eXchanger) record specifies which host, or hosts, will receive mail for a
particular domain. If you do not have an MX record for your hostname or domain,
the mail will be delivered directly to your host provided you have an A record
pointing your hostname to your IP address.

You may view the MX records for any domain by using the host(1) command, as
seen in the example below:

% host -t mx FreeBSD.org FreeBSD.org mail is handled (pri=10) by
mx1.FreeBSD.org

29.2.4.Â Receiving Mail

Receiving mail for your domain is done by the mail host. It will collect all
mail sent to your domain and store it either in mbox (the default method for
storing mail) or Maildir format, depending on your configuration. Once mail has
been stored, it may either be read locally using applications such as mail(1)
or mutt, or remotely accessed and collected using protocols such as POP or IMAP
. This means that should you only wish to read mail locally, you are not
required to install a POP or IMAP server.

29.2.4.1.Â Accessing remote mailboxes using POP and IMAP

In order to access mailboxes remotely, you are required to have access to a POP
or IMAP server. These protocols allow users to connect to their mailboxes from
remote locations with ease. Though both POP and IMAP allow users to remotely
access mailboxes, IMAP offers many advantages, some of which are:

  * IMAP can store messages on a remote server as well as fetch them.

  * IMAP supports concurrent updates.

  * IMAP can be extremely useful over low-speed links as it allows users to
    fetch the structure of messages without downloading them; it can also
    perform tasks such as searching on the server in order to minimize data
    transfer between clients and servers.

In order to install a POP or IMAP server, the following steps should be
performed:

 1. Choose an IMAP or POP server that best suits your needs. The following POP
    and IMAP servers are well known and serve as some good examples:

      * qpopper;

      * teapop;

      * imap-uw;

      * courier-imap;

      * dovecot;

 2. Install the POP or IMAP daemon of your choosing from the ports collection.

 3. Where required, modify /etc/inetd.conf to load the POP or IMAP server.

Warning:

It should be noted that both POP and IMAP transmit information, including
username and password credentials in clear-text. This means that if you wish to
secure the transmission of information across these protocols, you should
consider tunneling sessions over ssh(1) or using SSL. Tunneling sessions is
described in SectionÂ 15.10.8, â  SSH Tunnelingâ   and SSL is described in
SectionÂ 15.8, â  OpenSSLâ  .

29.2.4.2.Â Accessing Local Mailboxes

Mailboxes may be accessed locally by directly utilizing MUAs on the server on
which the mailbox resides. This can be done using applications such as mutt or
mail(1).

29.2.5.Â The Mail Host

The mail host is the name given to a server that is responsible for delivering
and receiving mail for your host, and possibly your network.

29.3.Â sendmail Configuration

Contributed by Christopher Shumway.

sendmail(8) is the default Mail Transfer Agent (MTA) in FreeBSD. sendmail's job
is to accept mail from Mail User Agents (MUA) and deliver it to the appropriate
mailer as defined by its configuration file. sendmail can also accept network
connections and deliver mail to local mailboxes or deliver it to another
program.

sendmail uses the following configuration files:

           Filename                                Function
/etc/mail/access                sendmail access database file
/etc/mail/aliases               Mailbox aliases
/etc/mail/local-host-names      Lists of hosts sendmail accepts mail for
/etc/mail/mailer.conf           Mailer program configuration
/etc/mail/mailertable           Mailer delivery table
/etc/mail/sendmail.cf           sendmail master configuration file
/etc/mail/virtusertable         Virtual users and domain tables

29.3.1.Â /etc/mail/access

The access database defines what host(s) or IP addresses have access to the
local mail server and what kind of access they have. Hosts can be listed as OK,
REJECT, RELAY or simply passed to sendmail's error handling routine with a
given mailer error. Hosts that are listed as OK, which is the default, are
allowed to send mail to this host as long as the mail's final destination is
the local machine. Hosts that are listed as REJECT are rejected for all mail
connections. Hosts that have the RELAY option for their hostname are allowed to
send mail for any destination through this mail server.

ExampleÂ 29.1.Â Configuring the sendmail Access Database
cyberspammer.com 550 We do not accept mail from spammers FREE.STEALTH.MAILER@
550 We do not accept mail from spammers another.source.of.spam REJECT
okay.cyberspammer.com OK 128.32 RELAY


In this example we have five entries. Mail senders that match the left hand
side of the table are affected by the action on the right side of the table.
The first two examples give an error code to sendmail's error handling routine.
The message is printed to the remote host when a mail matches the left hand
side of the table. The next entry rejects mail from a specific host on the
Internet, another.source.of.spam. The next entry accepts mail connections from
a host okay.cyberspammer.com, which is more exact than the cyberspammer.com
line above. More specific matches override less exact matches. The last entry
allows relaying of electronic mail from hosts with an IP address that begins
with 128.32. These hosts would be able to send mail through this mail server
that are destined for other mail servers.

When this file is updated, you need to run make in /etc/mail/ to update the
database.

29.3.2.Â /etc/mail/aliases

The aliases database contains a list of virtual mailboxes that are expanded to
other user(s), files, programs or other aliases. Here are a few examples that
can be used in /etc/mail/aliases:

ExampleÂ 29.2.Â Mail Aliases
root: localuser ftp-bugs: joe,eric,paul bit.bucket: /dev/null procmail: "|/usr/
local/bin/procmail"


The file format is simple; the mailbox name on the left side of the colon is
expanded to the target(s) on the right. The first example expands the mailbox
root to the mailbox localuser, which is then looked up again in the aliases
database. If no match is found, then the message is delivered to the local user
localuser. The next example shows a mail list. Mail to the mailbox ftp-bugs is
expanded to the three local mailboxes joe, eric, and paul. Note that a remote
mailbox could be specified as &lt;user@example.com&gt;. The next example shows
writing mail to a file, in this case /dev/null. The last example shows sending
mail to a program, in this case the mail message is written to the standard
input of /usr/local/bin/procmail through a UNIXÂ® pipe.

When this file is updated, you need to run make in /etc/mail/ to update the
database.

29.3.3.Â /etc/mail/local-host-names

This is a list of hostnames sendmail(8) is to accept as the local host name.
Place any domains or hosts that sendmail is to be receiving mail for. For
example, if this mail server was to accept mail for the domain example.com and
the host mail.example.com, its local-host-names might look something like this:

example.com mail.example.com

When this file is updated, sendmail(8) needs to be restarted to read the
changes.

29.3.4.Â /etc/mail/sendmail.cf

sendmail's master configuration file, sendmail.cf controls the overall behavior
of sendmail, including everything from rewriting e-mail addresses to printing
rejection messages to remote mail servers. Naturally, with such a diverse role,
this configuration file is quite complex and its details are a bit out of the
scope of this section. Fortunately, this file rarely needs to be changed for
standard mail servers.

The master sendmail configuration file can be built from m4(1) macros that
define the features and behavior of sendmail. Please see /usr/src/contrib/
sendmail/cf/README for some of the details.

When changes to this file are made, sendmail needs to be restarted for the
changes to take effect.

29.3.5.Â /etc/mail/virtusertable

The virtusertable maps mail addresses for virtual domains and mailboxes to real
mailboxes. These mailboxes can be local, remote, aliases defined in /etc/mail/
aliases or files.

ExampleÂ 29.3.Â Example Virtual Domain Mail Map
root@example.com root postmaster@example.com postmaster@noc.example.net
@example.com joe


In the above example, we have a mapping for a domain example.com. This file is
processed in a first match order down the file. The first item maps &lt;
root@example.com&gt; to the local mailbox root. The next entry maps &lt;
postmaster@example.com&gt; to the mailbox postmaster on the host noc.example.net.
Finally, if nothing from example.com has matched so far, it will match the last
mapping, which matches every other mail message addressed to someone at
example.com. This will be mapped to the local mailbox joe.

29.4.Â Changing Your Mail Transfer Agent

Written by Andrew Boothman.
Information taken from e-mails written byGregory Neil Shapiro.

As already mentioned, FreeBSD comes with sendmail already installed as your MTA
(Mail Transfer Agent). Therefore by default it is in charge of your outgoing
and incoming mail.

However, for a variety of reasons, some system administrators want to change
their system's MTA. These reasons range from merely wanting to try out another
MTA to needing a specific feature or package which relies on another mailer.
Fortunately, whatever the reason, FreeBSD makes it easy to make the change.

29.4.1.Â Install a New MTA

You have a wide choice of MTAs available. A good starting point is the FreeBSD
Ports Collection where you will be able to find many. Of course you are free to
use any MTA you want from any location, as long as you can make it run under
FreeBSD.

Start by installing your new MTA. Once it is installed it gives you a chance to
decide if it really fulfills your needs, and also gives you the opportunity to
configure your new software before getting it to take over from sendmail. When
doing this, you should be sure that installing the new software will not
attempt to overwrite system binaries such as /usr/bin/sendmail. Otherwise, your
new mail software has essentially been put into service before you have
configured it.

Please refer to your chosen MTA's documentation for information on how to
configure the software you have chosen.

29.4.2.Â Disable sendmail

Warning:

If you disable sendmail's outgoing mail service, it is important that you
replace it with an alternative mail delivery system. If you choose not to,
system functions such as periodic(8) will be unable to deliver their results by
e-mail as they would normally expect to. Many parts of your system may expect
to have a functional sendmail-compatible system. If applications continue to
use sendmail's binaries to try to send e-mail after you have disabled them,
mail could go into an inactive sendmail queue, and never be delivered.

In order to completely disable sendmail, including the outgoing mail service,
you must use

sendmail_enable="NO" sendmail_submit_enable="NO" sendmail_outbound_enable="NO"
sendmail_msp_queue_enable="NO"

in /etc/rc.conf.

If you only want to disable sendmail's incoming mail service, you should set

sendmail_enable="NO"

in /etc/rc.conf. More information on sendmail's startup options is available
from the rc.sendmail(8) manual page.

29.4.3.Â Running Your New MTA on Boot

The new MTA can be started during boot by adding a configuration line to /etc/
rc.conf like the following example for postfix:

# echo 'postfix_enable=â  YESâ  ' &gt;&gt; /etc/rc.conf

The MTA will now be automatically started during boot.

29.4.4.Â Replacing sendmail as the System's Default Mailer

The program sendmail is so ubiquitous as standard software on UNIXÂ® systems
that some software just assumes it is already installed and configured. For
this reason, many alternative MTA's provide their own compatible
implementations of the sendmail command-line interface; this facilitates using
them as â  drop-inâ   replacements for sendmail.

Therefore, if you are using an alternative mailer, you will need to make sure
that software trying to execute standard sendmail binaries such as /usr/bin/
sendmail actually executes your chosen mailer instead. Fortunately, FreeBSD
provides a system called mailwrapper(8) that does this job for you.

When sendmail is operating as installed, you will find something like the
following in /etc/mail/mailer.conf:

sendmail /usr/libexec/sendmail/sendmail send-mail /usr/libexec/sendmail/
sendmail mailq /usr/libexec/sendmail/sendmail newaliases /usr/libexec/sendmail/
sendmail hoststat /usr/libexec/sendmail/sendmail purgestat /usr/libexec/
sendmail/sendmail

This means that when any of these common commands (such as sendmail itself) are
run, the system actually invokes a copy of mailwrapper named sendmail, which
checks mailer.conf and executes /usr/libexec/sendmail/sendmail instead. This
system makes it easy to change what binaries are actually executed when these
default sendmail functions are invoked.

Therefore if you wanted /usr/local/supermailer/bin/sendmail-compat to be run
instead of sendmail, you could change /etc/mail/mailer.conf to read:

sendmail /usr/local/supermailer/bin/sendmail-compat send-mail /usr/local/
supermailer/bin/sendmail-compat mailq /usr/local/supermailer/bin/mailq-compat
newaliases /usr/local/supermailer/bin/newaliases-compat hoststat /usr/local/
supermailer/bin/hoststat-compat purgestat /usr/local/supermailer/bin/
purgestat-compat

29.4.5.Â Finishing

Once you have everything configured the way you want it, you should either kill
the sendmail processes that you no longer need and start the processes
belonging to your new software, or simply reboot. Rebooting will also give you
the opportunity to ensure that you have correctly configured your system to
start your new MTA automatically on boot.

29.5.Â Troubleshooting

29.5.1. Why do I have to use the FQDN for hosts on my site?
29.5.2. sendmail says mail loops back to myself
29.5.3. How can I run a mail server on a dial-up PPP host?
29.5.4. Why do I keep getting Relaying Denied errors when sending mail from
    other hosts?

29.5.1. Why do I have to use the FQDN for hosts on my site?

        You will probably find that the host is actually in a different domain;
        for example, if you are in foo.bar.edu and you wish to reach a host
        called mumble in the bar.edu domain, you will have to refer to it by
        the fully-qualified domain name, mumble.bar.edu, instead of just
        mumble.

        Traditionally, this was allowed by BSD BIND resolvers. However the
        current version of BIND that ships with FreeBSD no longer provides
        default abbreviations for non-fully qualified domain names other than
        the domain you are in. So an unqualified host mumble must either be
        found as mumble.foo.bar.edu, or it will be searched for in the root
        domain.

        This is different from the previous behavior, where the search
        continued across mumble.bar.edu, and mumble.edu. Have a look at RFC
        1535 for why this was considered bad practice, or even a security hole.

        As a good workaround, you can place the line:

        search foo.bar.edu bar.edu

        instead of the previous:

        domain foo.bar.edu

        into your /etc/resolv.conf. However, make sure that the search order
        does not go beyond the â  boundary between local and public
        administrationâ  , as RFC 1535 calls it.

29.5.2. sendmail says mail loops back to myself

        This is answered in the sendmail FAQ as follows:

        I'm getting these error messages: 553 MX list for domain.net points
        back to relay.domain.net 554 &lt;user@domain.net&gt;... Local configuration
        error How can I solve this problem? You have asked mail to the domain
        (e.g., domain.net) to be forwarded to a specific host (in this case,
        relay.domain.net) by using an MX record, but the relay machine does not
        recognize itself as domain.net. Add domain.net to /etc/mail/
        local-host-names [known as /etc/sendmail.cw prior to version 8.10] (if
        you are using FEATURE(use_cw_file)) or add â  Cw domain.netâ   to /etc/
        mail/sendmail.cf.

        The sendmail FAQ can be found at http://www.sendmail.org/faq/ and is
        recommended reading if you want to do any â  tweakingâ   of your mail
        setup.

29.5.3. How can I run a mail server on a dial-up PPP host?

        You want to connect a FreeBSD box on a LAN to the Internet. The FreeBSD
        box will be a mail gateway for the LAN. The PPP connection is
        non-dedicated.

        There are at least two ways to do this. One way is to use UUCP.

        Another way is to get a full-time Internet server to provide secondary
        MX services for your domain. For example, if your company's domain is
        example.com and your Internet service provider has set example.net up
        to provide secondary MX services to your domain:

        example.com. MX 10 example.com. MX 20 example.net.

        Only one host should be specified as the final recipient (add Cw
        example.com in /etc/mail/sendmail.cf on example.com).

        When the sending sendmail is trying to deliver the mail it will try to
        connect to you (example.com) over the modem link. It will most likely
        time out because you are not online. The program sendmail will
        automatically deliver it to the secondary MX site, i.e., your Internet
        provider (example.net). The secondary MX site will then periodically
        try to connect to your host and deliver the mail to the primary MX host
        (example.com).

        You might want to use something like this as a login script:

        #!/bin/sh # Put me in /usr/local/bin/pppmyisp ( sleep 60 ; /usr/sbin/
        sendmail -q ) & /usr/sbin/ppp -direct pppmyisp

        If you are going to create a separate login script for a user you could
        use sendmail -qRexample.com instead in the script above. This will
        force all mail in your queue for example.com to be processed
        immediately.

        A further refinement of the situation is as follows:

        Message stolen from the FreeBSD Internet service provider's mailing
        list.

        &gt; we provide the secondary MX for a customer. The customer connects to
        &gt; our services several times a day automatically to get the mails to &gt;
        his primary MX (We do not call his site when a mail for his domains &gt;
        arrived). Our sendmail sends the mailqueue every 30 minutes. At the &gt;
        moment he has to stay 30 minutes online to be sure that all mail is &gt;
        gone to the primary MX. &gt; &gt; Is there a command that would initiate
        sendmail to send all the mails &gt; now? The user has not root-privileges
        on our machine of course. In the â  privacy flagsâ   section of
        sendmail.cf, there is a definition Opgoaway,restrictqrun Remove
        restrictqrun to allow non-root users to start the queue processing. You
        might also like to rearrange the MXs. We are the 1st MX for our
        customers like this, and we have defined: # If we are the best MX for a
        host, try directly instead of generating # local config error. OwTrue
        That way a remote site will deliver straight to you, without trying the
        customer connection. You then send to your customer. Only works for â  
        hostsâ  , so you need to get your customer to name their mail machine â
          customer.comâ   as well as â  hostname.customer.comâ   in the DNS.
        Just put an A record in the DNS for â  customer.comâ  .
29.5.4. Why do I keep getting Relaying Denied errors when sending mail from
        other hosts?

        In default FreeBSD installations, sendmail is configured to only send
        mail from the host it is running on. For example, if a POP server is
        available, then users will be able to check mail from school, work, or
        other remote locations but they still will not be able to send outgoing
        emails from outside locations. Typically, a few moments after the
        attempt, an email will be sent from MAILER-DAEMON with a 5.7 Relaying
        Denied error message.

        There are several ways to get around this. The most straightforward
        solution is to put your ISP's address in a relay-domains file at /etc/
        mail/relay-domains. A quick way to do this would be:

        # echo "your.isp.example.com" &gt; /etc/mail/relay-domains

        After creating or editing this file you must restart sendmail. This
        works great if you are a server administrator and do not wish to send
        mail locally, or would like to use a point and click client/system on
        another machine or even another ISP. It is also very useful if you only
        have one or two email accounts set up. If there are a large number of
        addresses to add, open this file in your favorite text editor and then
        add the domains, one per line:

        your.isp.example.com other.isp.example.net users-isp.example.org
        www.example.org

        Now any mail sent through your system, by any host in this list
        (provided the user has an account on your system), will succeed. This
        is a very nice way to allow users to send mail from your system
        remotely without allowing people to send SPAM through your system.

29.6.Â Advanced Topics

The following section covers more involved topics such as mail configuration
and setting up mail for your entire domain.

29.6.1.Â Basic Configuration

Out of the box, you should be able to send email to external hosts as long as
you have set up /etc/resolv.conf or are running your own name server. If you
would like to have mail for your host delivered to the MTA (e.g., sendmail) on
your own FreeBSD host, there are two methods:

  * Run your own name server and have your own domain. For example, FreeBSD.org

  * Get mail delivered directly to your host. This is done by delivering mail
    directly to the current DNS name for your machine. For example,
    example.FreeBSD.org.

Regardless of which of the above you choose, in order to have mail delivered
directly to your host, it must have a permanent static IP address (not a
dynamic address, as with most PPP dial-up configurations). If you are behind a
firewall, it must pass SMTP traffic on to you. If you want to receive mail
directly at your host, you need to be sure of either of two things:

  * Make sure that the (lowest-numbered) MX record in your DNS points to your
    host's IP address.

  * Make sure there is no MX entry in your DNS for your host.

Either of the above will allow you to receive mail directly at your host.

Try this:

# hostname example.FreeBSD.org # host example.FreeBSD.org example.FreeBSD.org
has address 204.216.27.XX

If that is what you see, mail directly to &lt;yourlogin@example.FreeBSD.org&gt;
should work without problems (assuming sendmail is running correctly on
example.FreeBSD.org).

If instead you see something like this:

# host example.FreeBSD.org example.FreeBSD.org has address 204.216.27.XX
example.FreeBSD.org mail is handled (pri=10) by hub.FreeBSD.org

All mail sent to your host (example.FreeBSD.org) will end up being collected on
hub under the same username instead of being sent directly to your host.

The above information is handled by your DNS server. The DNS record that
carries mail routing information is the Mail eXchange entry. If no MX record
exists, mail will be delivered directly to the host by way of its IP address.

The MX entry for freefall.FreeBSD.org at one time looked like this:

freefall MX 30 mail.crl.net freefall MX 40 agora.rdrop.com freefall MX 10
freefall.FreeBSD.org freefall MX 20 who.cdrom.com

As you can see, freefall had many MX entries. The lowest MX number is the host
that receives mail directly if available; if it is not accessible for some
reason, the others (sometimes called â  backup MXesâ  ) accept messages
temporarily, and pass it along when a lower-numbered host becomes available,
eventually to the lowest-numbered host.

Alternate MX sites should have separate Internet connections from your own in
order to be most useful. Your ISP or another friendly site should have no
problem providing this service for you.

29.6.2.Â Mail for Your Domain

In order to set up a â  mailhostâ   (aka mail server) you need to have any mail
sent to various workstations directed to it. Basically, you want to â  claimâ  
any mail for any hostname in your domain (in this case *.FreeBSD.org) and
divert it to your mail server so your users can receive their mail on the
master mail server.

To make life easiest, a user account with the same username should exist on
both machines. Use adduser(8) to do this.

The mailhost you will be using must be the designated mail exchanger for each
workstation on the network. This is done in your DNS configuration like so:

example.FreeBSD.org A 204.216.27.XX ; Workstation MX 10 hub.FreeBSD.org ;
Mailhost

This will redirect mail for the workstation to the mailhost no matter where the
A record points. The mail is sent to the MX host.

You cannot do this yourself unless you are running a DNS server. If you are
not, or cannot run your own DNS server, talk to your ISP or whoever provides
your DNS.

If you are doing virtual email hosting, the following information will come in
handy. For this example, we will assume you have a customer with his own
domain, in this case customer1.org, and you want all the mail for customer1.org
sent to your mailhost, mail.myhost.com. The entry in your DNS should look like
this:

customer1.org MX 10 mail.myhost.com

You do not need an A record for customer1.org if you only want to handle email
for that domain.

Note:

Be aware that pinging customer1.org will not work unless an A record exists for
it.

The last thing that you must do is tell sendmail on your mailhost what domains
and/or hostnames it should be accepting mail for. There are a few different
ways this can be done. Either of the following will work:

  * Add the hosts to your /etc/mail/local-host-names file if you are using the
    FEATURE(use_cw_file). If you are using a version of sendmail earlier than
    8.10, the file is /etc/sendmail.cw.

  * Add a Cwyour.host.com line to your /etc/sendmail.cf or /etc/mail/
    sendmail.cf if you are using sendmail 8.10 or higher.

29.7.Â Setting Up to Send Only

Contributed by Bill Moran.

There are many instances where you may only want to send mail through a relay.
Some examples are:

  * Your computer is a desktop machine, but you want to use programs such as
    send-pr(1). To do so, you should use your ISP's mail relay.

  * The computer is a server that does not handle mail locally, but needs to
    pass off all mail to a relay for processing.

Just about any MTA is capable of filling this particular niche. Unfortunately,
it can be very difficult to properly configure a full-featured MTA just to
handle offloading mail. Programs such as sendmail and postfix are largely
overkill for this use.

Additionally, if you are using a typical Internet access service, your
agreement may forbid you from running a â  mail serverâ  .

The easiest way to fulfill those needs is to install the mail/ssmtp port.
Execute the following commands as root:

# cd /usr/ports/mail/ssmtp # make install replace clean

Once installed, mail/ssmtp can be configured with a four-line file located at /
usr/local/etc/ssmtp/ssmtp.conf:

root=yourrealemail@example.com mailhub=mail.example.com rewriteDomain=
example.com hostname=_HOSTNAME_

Make sure you use your real email address for root. Enter your ISP's outgoing
mail relay in place of mail.example.com (some ISPs call this the â  outgoing
mail serverâ   or â  SMTP serverâ  ).

Make sure you disable sendmail, including the outgoing mail service. See
SectionÂ 29.4.2, â  Disable sendmailâ   for details.

mail/ssmtp has some other options available. See the example configuration file
in /usr/local/etc/ssmtp or the manual page of ssmtp for some examples and more
information.

Setting up ssmtp in this manner will allow any software on your computer that
needs to send mail to function properly, while not violating your ISP's usage
policy or allowing your computer to be hijacked for spamming.

29.8.Â Using Mail with a Dialup Connection

If you have a static IP address, you should not need to adjust anything from
the defaults. Set your host name to your assigned Internet name and sendmail
will do the rest.

If you have a dynamically assigned IP number and use a dialup PPP connection to
the Internet, you will probably have a mailbox on your ISPs mail server. Let's
assume your ISP's domain is example.net, and that your user name is user, you
have called your machine bsd.home, and your ISP has told you that you may use
relay.example.net as a mail relay.

In order to retrieve mail from your mailbox, you must install a retrieval
agent. The fetchmail utility is a good choice as it supports many different
protocols. This program is available as a package or from the Ports Collection
(mail/fetchmail). Usually, your ISP will provide POP. If you are using user PPP
, you can automatically fetch your mail when an Internet connection is
established with the following entry in /etc/ppp/ppp.linkup:

MYADDR: !bg su user -c fetchmail

If you are using sendmail (as shown below) to deliver mail to non-local
accounts, you probably want to have sendmail process your mailqueue as soon as
your Internet connection is established. To do this, put this command after the
fetchmail command in /etc/ppp/ppp.linkup:

!bg su user -c "sendmail -q"

Assume that you have an account for user on bsd.home. In the home directory of
user on bsd.home, create a .fetchmailrc file:

poll example.net protocol pop3 fetchall pass MySecret

This file should not be readable by anyone except user as it contains the
password MySecret.

In order to send mail with the correct from: header, you must tell sendmail to
use &lt;user@example.net&gt; rather than &lt;user@bsd.home&gt;. You may also wish to tell 
sendmail to send all mail via relay.example.net, allowing quicker mail
transmission.

The following .mc file should suffice:

VERSIONID(`bsd.home.mc version 1.0') OSTYPE(bsd4.4)dnl FEATURE(nouucp)dnl
MAILER(local)dnl MAILER(smtp)dnl Cwlocalhost Cwbsd.home MASQUERADE_AS
(`example.net')dnl FEATURE(allmasquerade)dnl FEATURE(masquerade_envelope)dnl
FEATURE(nocanonify)dnl FEATURE(nodns)dnl define(`SMART_HOST',
`relay.example.net') Dmbsd.home define(`confDOMAIN_NAME',`bsd.home')dnl define
(`confDELIVERY_MODE',`deferred')dnl

Refer to the previous section for details of how to turn this .mc file into a
sendmail.cf file. Also, do not forget to restart sendmail after updating
sendmail.cf.

29.9.Â SMTP Authentication

Written by James Gorham.

Having SMTP Authentication in place on your mail server has a number of
benefits. SMTP Authentication can add another layer of security to sendmail,
and has the benefit of giving mobile users who switch hosts the ability to use
the same mail server without the need to reconfigure their mail client settings
each time.

 1. Install security/cyrus-sasl2 from the ports. You can find this port in
    security/cyrus-sasl2. The security/cyrus-sasl2 port supports a number of
    compile-time options. For the SMTP Authentication method we will be using
    here, make sure that the LOGIN option is not disabled.

 2. After installing security/cyrus-sasl2, edit /usr/local/lib/sasl2/
    Sendmail.conf (or create it if it does not exist) and add the following
    line:

    pwcheck_method: saslauthd
 3. Next, install security/cyrus-sasl2-saslauthd, edit /etc/rc.conf to add the
    following line:

    saslauthd_enable="YES"

    and finally start the saslauthd daemon:

    # service saslauthd start

    This daemon serves as a broker for sendmail to authenticate against your
    FreeBSD passwd database. This saves the trouble of creating a new set of
    usernames and passwords for each user that needs to use SMTP
    authentication, and keeps the login and mail password the same.

 4. Now edit /etc/make.conf and add the following lines:

    SENDMAIL_CFLAGS=-I/usr/local/include/sasl -DSASL SENDMAIL_LDFLAGS=-L/usr/
    local/lib SENDMAIL_LDADD=-lsasl2

    These lines will give sendmail the proper configuration options for linking
    to cyrus-sasl2 at compile time. Make sure that cyrus-sasl2 has been
    installed before recompiling sendmail.

 5. Recompile sendmail by executing the following commands:

    # cd /usr/src/lib/libsmutil # make cleandir && make obj && make # cd /usr/
    src/lib/libsm # make cleandir && make obj && make # cd /usr/src/usr.sbin/
    sendmail # make cleandir && make obj && make && make install

    The compile of sendmail should not have any problems if /usr/src has not
    been changed extensively and the shared libraries it needs are available.

 6. After sendmail has been compiled and reinstalled, edit your /etc/mail/
    freebsd.mc file (or whichever file you use as your .mc file. Many
    administrators choose to use the output from hostname(1) as the .mc file
    for uniqueness). Add these lines to it:

    dnl set SASL options TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl
    define(`confAUTH_MECHANISMS', `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN')dnl

    These options configure the different methods available to sendmail for
    authenticating users. If you would like to use a method other than pwcheck,
    please see the included documentation.

 7. Finally, run make(1) while in /etc/mail. That will run your new .mc file
    and create a .cf file named freebsd.cf (or whatever name you have used for
    your .mc file). Then use the command make install restart, which will copy
    the file to sendmail.cf, and will properly restart sendmail. For more
    information about this process, you should refer to /etc/mail/Makefile.

If all has gone correctly, you should be able to enter your login information
into the mail client and send a test message. For further investigation, set
the LogLevel of sendmail to 13 and watch /var/log/maillog for any errors.

For more information, please see the sendmail page regarding SMTP
authentication.

29.10.Â Mail User Agents

Contributed by Marc Silver.

A Mail User Agent (MUA) is an application that is used to send and receive
email. Furthermore, as email â  evolvesâ   and becomes more complex, MUA's are
becoming increasingly powerful in the way they interact with email; this gives
users increased functionality and flexibility. FreeBSD contains support for
numerous mail user agents, all of which can be easily installed using the
FreeBSD Ports Collection. Users may choose between graphical email clients such
as evolution or balsa, console based clients such as mutt, alpine or mail, or
the web interfaces used by some large organizations.

29.10.1.Â mail

mail(1) is the default Mail User Agent (MUA) in FreeBSD. It is a console based 
MUA that offers all the basic functionality required to send and receive
text-based email, though it is limited in interaction abilities with
attachments and can only support local mailboxes.

Although mail does not natively support interaction with POP or IMAP servers,
these mailboxes may be downloaded to a local mbox file using an application
such as fetchmail, which will be discussed later in this chapter (
SectionÂ 29.11, â  Using fetchmailâ  ).

In order to send and receive email, run mail:

% mail

The contents of the user mailbox in /var/mail are automatically read by the
mail utility. Should the mailbox be empty, the utility exits with a message
indicating that no mails could be found. Once the mailbox has been read, the
application interface is started, and a list of messages will be displayed.
Messages are automatically numbered, as can be seen in the following example:

Mail version 8.1 6/6/93. Type ? for help. "/var/mail/marcs": 3 messages 3 new &gt;
N 1 root@localhost Mon Mar 8 14:05 14/510 "test" N 2 root@localhost Mon Mar 8
14:05 14/509 "user account" N 3 root@localhost Mon Mar 8 14:05 14/509 "sample"

Messages can now be read by using the t mail command, suffixed by the message
number that should be displayed. In this example, we will read the first email:

& t 1 Message 1: From root@localhost Mon Mar 8 14:05:52 2004 X-Original-To:
marcs@localhost Delivered-To: marcs@localhost To: marcs@localhost Subject: test
Date: Mon, 8 Mar 2004 14:05:52 +0200 (SAST) From: root@localhost (Charlie Root)
This is a test message, please reply if you receive it.

As can be seen in the example above, the t key will cause the message to be
displayed with full headers. To display the list of messages again, the h key
should be used.

If the email requires a response, you may use mail to reply, by using either
the R or r mail keys. The R key instructs mail to reply only to the sender of
the email, while r replies not only to the sender, but also to other recipients
of the message. You may also suffix these commands with the mail number which
you would like make a reply to. Once this has been done, the response should be
entered, and the end of the message should be marked by a single . on a new
line. An example can be seen below:

& R 1 To: root@localhost Subject: Re: test Thank you, I did get your email. .
EOT

In order to send new email, the m key should be used, followed by the recipient
email address. Multiple recipients may also be specified by separating each
address with the , delimiter. The subject of the message may then be entered,
followed by the message contents. The end of the message should be specified by
putting a single . on a new line.

& mail root@localhost Subject: I mastered mail Now I can send and receive email
using mail ... :) . EOT

While inside the mail utility, the ? command may be used to display help at any
time, the mail(1) manual page should also be consulted for more help with mail.

Note:

As previously mentioned, the mail(1) command was not originally designed to
handle attachments, and thus deals with them very poorly. Newer MUAs such as 
mutt handle attachments in a much more intelligent way. But should you still
wish to use the mail command, the converters/mpack port may be of considerable
use.

29.10.2.Â mutt

mutt is a small yet very powerful Mail User Agent, with excellent features,
just some of which include:

  * The ability to thread messages;

  * PGP support for digital signing and encryption of email;

  * MIME Support;

  * Maildir Support;

  * Highly customizable.

All of these features help to make mutt one of the most advanced mail user
agents available. See http://www.mutt.org for more information on mutt.

mutt may be installed using the mail/mutt port. After the port has been
installed, mutt can be started by issuing the following command:

% mutt

mutt will automatically read the contents of the user mailbox in /var/mail and
display the contents if applicable. If no mails are found in the user mailbox,
then mutt will wait for commands from the user. The example below shows mutt
displaying a list of messages:

[mutt1]

In order to read an email, select it using the cursor keys and press the Enter
key. An example of mutt displaying email can be seen below:

[mutt2]

As with the mail(1) command, mutt allows users to reply only to the sender of
the message as well as to all recipients. To reply only to the sender of the
email, use the r keyboard shortcut. To send a group reply, which will be sent
to the original sender as well as all the message recipients, use the g
shortcut.

Note:

mutt makes use of the vi(1) command as an editor for creating and replying to
emails. This may be customized by the user by creating or editing their own
.muttrc file in their home directory and setting the editor variable or by
setting the EDITOR environment variable. See http://www.mutt.org/ for more
information about configuring mutt.

In order to compose a new mail message, press m. After a valid subject has been
given, mutt will start vi(1) and the mail can be written. Once the contents of
the mail are complete, save and quit from vi and mutt will resume, displaying a
summary screen of the mail that is to be delivered. In order to send the mail,
press y. An example of the summary screen can be seen below:

[mutt3]

mutt also contains extensive help, which can be accessed from most of the menus
by pressing the ? key. The top line also displays the keyboard shortcuts where
appropriate.

29.10.3.Â alpine

alpine is aimed at a beginner user, but also includes some advanced features.

Warning:

The alpine software has had several remote vulnerabilities discovered in the
past, which allowed remote attackers to execute arbitrary code as users on the
local system, by the action of sending a specially-prepared email. All such 
known problems have been fixed, but the alpine code is written in a very
insecure style and the FreeBSD Security Officer believes there are likely to be
other undiscovered vulnerabilities. You install alpine at your own risk.

The current version of alpine may be installed using the mail/alpine port. Once
the port has installed, alpine can be started by issuing the following command:

% alpine

The first time that alpine is run it displays a greeting page with a brief
introduction, as well as a request from the alpine development team to send an
anonymous email message allowing them to judge how many users are using their
client. To send this anonymous message, press Enter, or alternatively press E
to exit the greeting without sending an anonymous message. An example of the
greeting page can be seen below:

[pine1]

Users are then presented with the main menu, which can be easily navigated
using the cursor keys. This main menu provides shortcuts for the composing new
mails, browsing of mail directories, and even the administration of address
book entries. Below the main menu, relevant keyboard shortcuts to perform
functions specific to the task at hand are shown.

The default directory opened by alpine is the inbox. To view the message index,
press I, or select the MESSAGE INDEX option as seen below:

[pine2]

The message index shows messages in the current directory, and can be navigated
by using the cursor keys. Highlighted messages can be read by pressing the 
Enter key.

[pine3]

In the screenshot below, a sample message is displayed by alpine. Keyboard
shortcuts are displayed as a reference at the bottom of the screen. An example
of one of these shortcuts is the r key, which tells the MUA to reply to the
current message being displayed.

[pine4]

Replying to an email in alpine is done using the pico editor, which is
installed by default with alpine. The pico utility makes it easy to navigate
around the message and is slightly more forgiving on novice users than vi(1) or
mail(1). Once the reply is complete, the message can be sent by pressing Ctrl+X
. The alpine application will ask for confirmation.

[pine5]

The alpine application can be customized using the SETUP option from the main
menu. Consult http://www.washington.edu/alpine/ for more information.

29.11.Â Using fetchmail

Contributed by Marc Silver.

fetchmail is a full-featured IMAP and POP client which allows users to
automatically download mail from remote IMAP and POP servers and save it into
local mailboxes; there it can be accessed more easily. fetchmail can be
installed using the mail/fetchmail port, and offers various features, some of
which include:

  * Support of POP3, APOP, KPOP, IMAP, ETRN and ODMR protocols.

  * Ability to forward mail using SMTP, which allows filtering, forwarding, and
    aliasing to function normally.

  * May be run in daemon mode to check periodically for new messages.

  * Can retrieve multiple mailboxes and forward them based on configuration, to
    different local users.

While it is outside the scope of this document to explain all of fetchmail's
features, some basic features will be explained. The fetchmail utility requires
a configuration file known as .fetchmailrc, in order to run correctly. This
file includes server information as well as login credentials. Due to the
sensitive nature of the contents of this file, it is advisable to make it
readable only by the owner, with the following command:

% chmod 600 .fetchmailrc

The following .fetchmailrc serves as an example for downloading a single user
mailbox using POP. It tells fetchmail to connect to example.com using a
username of joesoap and a password of XXX. This example assumes that the user
joesoap is also a user on the local system.

poll example.com protocol pop3 username "joesoap" password "XXX"

The next example connects to multiple POP and IMAP servers and redirects to
different local usernames where applicable:

poll example.com proto pop3: user "joesoap", with password "XXX", is "jsoap"
here; user "andrea", with password "XXXX"; poll example2.net proto imap: user
"john", with password "XXXXX", is "myth" here;

The fetchmail utility can be run in daemon mode by running it with the -d flag,
followed by the interval (in seconds) that fetchmail should poll servers listed
in the .fetchmailrc file. The following example would cause fetchmail to poll
every 600 seconds:

% fetchmail -d 600

More information on fetchmail can be found at http://fetchmail.berlios.de/.

29.12.Â Using procmail

Contributed by Marc Silver.

The procmail utility is an incredibly powerful application used to filter
incoming mail. It allows users to define â  rulesâ   which can be matched to
incoming mails to perform specific functions or to reroute mail to alternative
mailboxes and/or email addresses. procmail can be installed using the mail/
procmail port. Once installed, it can be directly integrated into most MTAs;
consult your MTA documentation for more information. Alternatively, procmail
can be integrated by adding the following line to a .forward in the home
directory of the user utilizing procmail features:

"|exec /usr/local/bin/procmail || exit 75"

The following section will display some basic procmail rules, as well as brief
descriptions on what they do. These rules, and others must be inserted into a
.procmailrc file, which must reside in the user's home directory.

The majority of these rules can also be found in the procmailex(5) manual page.

Forward all mail from &lt;user@example.com&gt; to an external address of &lt;
goodmail@example2.com&gt;:

:0 * ^From.*user@example.com ! goodmail@example2.com

Forward all mails shorter than 1000 bytes to an external address of &lt;
goodmail@example2.com&gt;:

:0 * &lt; 1000 ! goodmail@example2.com

Send all mail sent to &lt;alternate@example.com&gt; into a mailbox called alternate:

:0 * ^TOalternate@example.com alternate

Send all mail with a subject of â  Spamâ   to /dev/null:

:0 ^Subject:.*Spam /dev/null

A useful recipe that parses incoming FreeBSD.org mailing lists and places each
list in its own mailbox:

:0 * ^Sender:.owner-freebsd-\/[^@]+@FreeBSD.ORG { LISTNAME=${MATCH} :0 *
LISTNAME??^\/[^@]+ FreeBSD-${MATCH} }

ChapterÂ 30.Â Network Servers

Reorganized by Murray Stokely.
Table of Contents

30.1. Synopsis
30.2. The inetd â  Super-Serverâ  
30.3. Network File System (NFS)
30.4. Network Information System (NIS/YP)
30.5. Automatic Network Configuration (DHCP)
30.6. Domain Name System (DNS)
30.7. Apache HTTP Server
30.8. File Transfer Protocol (FTP)
30.9. File and Print Services for MicrosoftÂ®Â WindowsÂ® Clients (Samba)
30.10. Clock Synchronization with NTP
30.11. Remote Host Logging with syslogd

30.1.Â Synopsis

This chapter will cover some of the more frequently used network services on 
UNIXÂ® systems. We will cover how to install, configure, test, and maintain
many different types of network services. Example configuration files are
included throughout this chapter for you to benefit from.

After reading this chapter, you will know:

  * How to manage the inetd daemon.

  * How to set up a network file system.

  * How to set up a network information server for sharing user accounts.

  * How to set up automatic network settings using DHCP.

  * How to set up a domain name server.

  * How to set up the Apache HTTP Server.

  * How to set up a File Transfer Protocol (FTP) Server.

  * How to set up a file and print server for WindowsÂ® clients using Samba.

  * How to synchronize the time and date, and set up a time server, with the
    NTP protocol.

  * How to configure the standard logging daemon, syslogd, to accept logs from
    remote hosts.

Before reading this chapter, you should:

  * Understand the basics of the /etc/rc scripts.

  * Be familiar with basic network terminology.

  * Know how to install additional third-party software (ChapterÂ 5, Installing
    Applications: Packages and Ports).

30.2.Â The inetd â  Super-Serverâ  

Contributed by Chern Lee.
Updated by The FreeBSD Documentation Project.

30.2.1.Â Overview

inetd(8) is sometimes referred to as the â  Internet Super-Serverâ   because it
manages connections for several services. When a connection is received by 
inetd, it determines which program the connection is destined for, spawns the
particular process and delegates the socket to it (the program is invoked with
the service socket as its standard input, output and error descriptors).
Running inetd for servers that are not heavily used can reduce the overall
system load, when compared to running each daemon individually in stand-alone
mode.

Primarily, inetd is used to spawn other daemons, but several trivial protocols
are handled directly, such as chargen, auth, and daytime.

This section will cover the basics in configuring inetd through its
command-line options and its configuration file, /etc/inetd.conf.

30.2.2.Â Settings

inetd is initialized through the rc(8) system. The inetd_enable option is set
to NO by default, but may be turned on by sysinstall during installation,
depending on the configuration chosen by the user. Placing:

inetd_enable="YES"

or

inetd_enable="NO"

into /etc/rc.conf will enable or disable inetd starting at boot time. The
command:

# service inetd rcvar

can be run to display the current effective setting.

Additionally, different command-line options can be passed to inetd via the
inetd_flags option.

30.2.3.Â Command-Line Options

Like most server daemons, inetd has a number of options that it can be passed
in order to modify its behaviour. See the inetd(8) manual page for the full
list of options.

Options can be passed to inetd using the inetd_flags option in /etc/rc.conf. By
default, inetd_flags is set to -wW -C 60, which turns on TCP wrapping for inetd
's services, and prevents any single IP address from requesting any service
more than 60 times in any given minute.

Although we mention rate-limiting options below, novice users may be pleased to
note that these parameters usually do not need to be modified. These options
may be useful should you find that you are receiving an excessive amount of
connections. A full list of options can be found in the inetd(8) manual.

-c maximum

    Specify the default maximum number of simultaneous invocations of each
    service; the default is unlimited. May be overridden on a per-service basis
    with the max-child parameter.

-C rate

    Specify the default maximum number of times a service can be invoked from a
    single IP address in one minute; the default is unlimited. May be
    overridden on a per-service basis with the
    max-connections-per-ip-per-minute parameter.

-R rate

    Specify the maximum number of times a service can be invoked in one minute;
    the default is 256. A rate of 0 allows an unlimited number of invocations.

-s maximum

    Specify the maximum number of times a service can be invoked from a single
    IP address at any one time; the default is unlimited. May be overridden on
    a per-service basis with the max-child-per-ip parameter.

30.2.4.Â inetd.conf

Configuration of inetd is done via the file /etc/inetd.conf.

When a modification is made to /etc/inetd.conf, inetd can be forced to re-read
its configuration file by running the command:

ExampleÂ 30.1.Â Reloading the inetd Configuration File
# service inetd reload


Each line of the configuration file specifies an individual daemon. Comments in
the file are preceded by a â  #â  . The format of each entry in /etc/inetd.conf
is as follows:

service-name socket-type protocol {wait|nowait}[/max-child[/
max-connections-per-ip-per-minute[/max-child-per-ip]]] user[:group][/
login-class] server-program server-program-arguments

An example entry for the ftpd(8) daemon using IPv4 might read:

ftp stream tcp nowait root /usr/libexec/ftpd ftpd -l

service-name

    This is the service name of the particular daemon. It must correspond to a
    service listed in /etc/services. This determines which port inetd must
    listen to. If a new service is being created, it must be placed in /etc/
    services first.

socket-type

    Either stream, dgram, raw, or seqpacket. stream must be used for
    connection-based, TCP daemons, while dgram is used for daemons utilizing
    the UDP transport protocol.

protocol

    One of the following:

           Protocol                             Explanation
    tcp, tcp4               TCP IPv4
    udp, udp4               UDP IPv4
    tcp6                    TCP IPv6
    udp6                    UDP IPv6
    tcp46                   Both TCP IPv4 and v6
    udp46                   Both UDP IPv4 and v6

{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/
    max-child-per-ip]]]

    wait|nowait indicates whether the daemon invoked from inetd is able to
    handle its own socket or not. dgram socket types must use the wait option,
    while stream socket daemons, which are usually multi-threaded, should use
    nowait. wait usually hands off multiple sockets to a single daemon, while
    nowait spawns a child daemon for each new socket.

    The maximum number of child daemons inetd may spawn can be set using the
    max-child option. If a limit of ten instances of a particular daemon is
    needed, a /10 would be placed after nowait. Specifying /0 allows an
    unlimited number of children

    In addition to max-child, two other options which limit the maximum
    connections from a single place to a particular daemon can be enabled.
    max-connections-per-ip-per-minute limits the number of connections from any
    particular IP address per minutes, e.g., a value of ten would limit any
    particular IP address connecting to a particular service to ten attempts
    per minute. max-child-per-ip limits the number of children that can be
    started on behalf on any single IP address at any moment. These options are
    useful to prevent intentional or unintentional excessive resource
    consumption and Denial of Service (DoS) attacks to a machine.

    In this field, either of wait or nowait is mandatory. max-child,
    max-connections-per-ip-per-minute and max-child-per-ip are optional.

    A stream-type multi-threaded daemon without any max-child,
    max-connections-per-ip-per-minute or max-child-per-ip limits would simply
    be: nowait.

    The same daemon with a maximum limit of ten daemons would read: nowait/10.

    The same setup with a limit of twenty connections per IP address per minute
    and a maximum total limit of ten child daemons would read: nowait/10/20.

    These options are utilized by the default settings of the fingerd(8)
    daemon, as seen here:

    finger stream tcp nowait/3/10 nobody /usr/libexec/fingerd fingerd -s

    Finally, an example of this field with a maximum of 100 children in total,
    with a maximum of 5 for any one IP address would read: nowait/100/0/5.

user

    This is the username that the particular daemon should run as. Most
    commonly, daemons run as the root user. For security purposes, it is common
    to find some servers running as the daemon user, or the least privileged
    nobody user.

server-program

    The full path of the daemon to be executed when a connection is received.
    If the daemon is a service provided by inetd internally, then internal
    should be used.

server-program-arguments

    This works in conjunction with server-program by specifying the arguments,
    starting with argv[0], passed to the daemon on invocation. If mydaemon -d
    is the command line, mydaemon -d would be the value of
    server-program-arguments. Again, if the daemon is an internal service, use
    internal here.

30.2.5.Â Security

Depending on the choices made at install time, many of inetd's services may be
enabled by default. If there is no apparent need for a particular daemon,
consider disabling it. Place a â  #â   in front of the daemon in question in /
etc/inetd.conf, and then reload the inetd configuration. Some daemons, such as 
fingerd, may not be desired at all because they provide information that may be
useful to an attacker.

Some daemons are not security-conscious and have long, or non-existent,
timeouts for connection attempts. This allows an attacker to slowly send
connections to a particular daemon, thus saturating available resources. It may
be a good idea to place max-connections-per-ip-per-minute, max-child or
max-child-per-ip limitations on certain daemons if you find that you have too
many connections.

By default, TCP wrapping is turned on. Consult the hosts_access(5) manual page
for more information on placing TCP restrictions on various inetd invoked
daemons.

30.2.6.Â Miscellaneous

daytime, time, echo, discard, chargen, and auth are all internally provided
services of inetd.

The auth service provides identity network services, and is configurable to a
certain degree, whilst the others are simply on or off.

Consult the inetd(8) manual page for more in-depth information.

30.3.Â Network File System (NFS)

Reorganized and enhanced by Tom Rhodes.
Written by Bill Swingle.

Among the many different file systems that FreeBSD supports is the Network File
System, also known as NFS. NFS allows a system to share directories and files
with others over a network. By using NFS, users and programs can access files
on remote systems almost as if they were local files.

Some of the most notable benefits that NFS can provide are:

  * Local workstations use less disk space because commonly used data can be
    stored on a single machine and still remain accessible to others over the
    network.

  * There is no need for users to have separate home directories on every
    network machine. Home directories could be set up on the NFS server and
    made available throughout the network.

  * Storage devices such as floppy disks, CDROM drives, and ZipÂ® drives can be
    used by other machines on the network. This may reduce the number of
    removable media drives throughout the network.

30.3.1.Â How NFS Works

NFS consists of at least two main parts: a server and one or more clients. The
client remotely accesses the data that is stored on the server machine. In
order for this to function properly a few processes have to be configured and
running.

The server has to be running the following daemons:

Daemon                                Description
nfsd    The NFS daemon which services requests from the NFS clients.
mountd  The NFS mount daemon which carries out the requests that nfsd(8) passes
        on to it.
rpcbind This daemon allows NFS clients to discover which port the NFS server is
        using.

The client can also run a daemon, known as nfsiod. The nfsiod daemon services
the requests from the NFS server. This is optional, and improves performance,
but is not required for normal and correct operation. See the nfsiod(8) manual
page for more information.

30.3.2.Â Configuring NFS

NFS configuration is a relatively straightforward process. The processes that
need to be running can all start at boot time with a few modifications to your
/etc/rc.conf file.

On the NFS server, make sure that the following options are configured in the /
etc/rc.conf file:

rpcbind_enable="YES" nfs_server_enable="YES" mountd_flags="-r"

mountd runs automatically whenever the NFS server is enabled.

On the client, make sure this option is present in /etc/rc.conf:

nfs_client_enable="YES"

The /etc/exports file specifies which file systems NFS should export (sometimes
referred to as â  shareâ  ). Each line in /etc/exports specifies a file system
to be exported and which machines have access to that file system. Along with
what machines have access to that file system, access options may also be
specified. There are many such options that can be used in this file but only a
few will be mentioned here. You can easily discover other options by reading
over the exports(5) manual page.

Here are a few example /etc/exports entries:

The following examples give an idea of how to export file systems, although the
settings may be different depending on your environment and network
configuration. For instance, to export the /cdrom directory to three example
machines that have the same domain name as the server (hence the lack of a
domain name for each) or have entries in your /etc/hosts file. The -ro flag
makes the exported file system read-only. With this flag, the remote system
will not be able to write any changes to the exported file system.

/cdrom -ro host1 host2 host3

The following line exports /home to three hosts by IP address. This is a useful
setup if you have a private network without a DNS server configured. Optionally
the /etc/hosts file could be configured for internal hostnames; please review
hosts(5) for more information. The -alldirs flag allows the subdirectories to
be mount points. In other words, it will not mount the subdirectories but
permit the client to mount only the directories that are required or needed.

/home -alldirs 10.0.0.2 10.0.0.3 10.0.0.4

The following line exports /a so that two clients from different domains may
access the file system. The -maproot=root flag allows the root user on the
remote system to write data on the exported file system as root. If the
-maproot=root flag is not specified, then even if a user has root access on the
remote system, he will not be able to modify files on the exported file system.

/a -maproot=root host.example.com box.example.org

In order for a client to access an exported file system, the client must have
permission to do so. Make sure the client is listed in your /etc/exports file.

In /etc/exports, each line represents the export information for one file
system to one host. A remote host can only be specified once per file system,
and may only have one default entry. For example, assume that /usr is a single
file system. The following /etc/exports would be invalid:

# Invalid when /usr is one file system /usr/src client /usr/ports client

One file system, /usr, has two lines specifying exports to the same host,
client. The correct format for this situation is:

/usr/src /usr/ports client

The properties of one file system exported to a given host must all occur on
one line. Lines without a client specified are treated as a single host. This
limits how you can export file systems, but for most people this is not an
issue.

The following is an example of a valid export list, where /usr and /exports are
local file systems:

# Export src and ports to client01 and client02, but only # client01 has root
privileges on it /usr/src /usr/ports -maproot=root client01 /usr/src /usr/ports
client02 # The client machines have root and can mount anywhere # on /exports.
Anyone in the world can mount /exports/obj read-only /exports -alldirs -maproot
=root client01 client02 /exports/obj -ro

The mountd daemon must be forced to recheck the /etc/exports file whenever it
has been modified, so the changes can take effect. This can be accomplished
either by sending a HUP signal to the running daemon:

# kill -HUP `cat /var/run/mountd.pid`

or by invoking the mountd rc(8) script with the appropriate parameter:

# service mountd onereload

Please refer to SectionÂ 12.7, â  Using rc(8) Under FreeBSDâ   for more
information about using rc scripts.

Alternatively, a reboot will make FreeBSD set everything up properly. A reboot
is not necessary though. Executing the following commands as root should start
everything up.

On the NFS server:

# rpcbind # nfsd -u -t -n 4 # mountd -r

On the NFS client:

# nfsiod -n 4

Now everything should be ready to actually mount a remote file system. In these
examples the server's name will be server and the client's name will be client.
If you only want to temporarily mount a remote file system or would rather test
the configuration, just execute a command like this as root on the client:

# mount server:/home /mnt

This will mount the /home directory on the server at /mnt on the client. If
everything is set up correctly you should be able to enter /mnt on the client
and see all the files that are on the server.

If you want to automatically mount a remote file system each time the computer
boots, add the file system to the /etc/fstab file. Here is an example:

server:/home /mnt nfs rw 0 0

The fstab(5) manual page lists all the available options.

30.3.3.Â Locking

Some applications (e.g., mutt) require file locking to operate correctly. In
the case of NFS, rpc.lockd can be used for file locking. To enable it, add the
following to the /etc/rc.conf file on both client and server (it is assumed
that the NFS client and server are configured already):

rpc_lockd_enable="YES" rpc_statd_enable="YES"

Start the application by using:

# service lockd start # service statd start

If real locking between the NFS clients and NFS server is not required, it is
possible to let the NFS client do locking locally by passing -L to mount_nfs(8)
. Refer to the mount_nfs(8) manual page for further details.

30.3.4.Â Practical Uses

NFS has many practical uses. Some of the more common ones are listed below:

  * Set several machines to share a CDROM or other media among them. This is
    cheaper and often a more convenient method to install software on multiple
    machines.

  * On large networks, it might be more convenient to configure a central NFS
    server in which to store all the user home directories. These home
    directories can then be exported to the network so that users would always
    have the same home directory, regardless of which workstation they log in
    to.

  * Several machines could have a common /usr/ports/distfiles directory. That
    way, when you need to install a port on several machines, you can quickly
    access the source without downloading it on each machine.

30.3.5.Â Automatic Mounts with amd

Contributed by Wylie Stilwell.
Rewritten by Chern Lee.

amd(8) (the automatic mounter daemon) automatically mounts a remote file system
whenever a file or directory within that file system is accessed. Filesystems
that are inactive for a period of time will also be automatically unmounted by 
amd. Using amd provides a simple alternative to permanent mounts, as permanent
mounts are usually listed in /etc/fstab.

amd operates by attaching itself as an NFS server to the /host and /net
directories. When a file is accessed within one of these directories, amd looks
up the corresponding remote mount and automatically mounts it. /net is used to
mount an exported file system from an IP address, while /host is used to mount
an export from a remote hostname.

An access to a file within /host/foobar/usr would tell amd to attempt to mount
the /usr export on the host foobar.

ExampleÂ 30.2.Â Mounting an Export with amd

You can view the available mounts of a remote host with the showmount command.
For example, to view the mounts of a host named foobar, you can use:

% showmount -e foobar Exports list on foobar: /usr 10.10.10.0 /a 10.10.10.0 %
cd /host/foobar/usr


As seen in the example, the showmount shows /usr as an export. When changing
directories to /host/foobar/usr, amd attempts to resolve the hostname foobar
and automatically mount the desired export.

amd can be started by the startup scripts by placing the following lines in /
etc/rc.conf:

amd_enable="YES"

Additionally, custom flags can be passed to amd from the amd_flags option. By
default, amd_flags is set to:

amd_flags="-a /.amd_mnt -l syslog /host /etc/amd.map /net /etc/amd.map"

The /etc/amd.map file defines the default options that exports are mounted
with. The /etc/amd.conf file defines some of the more advanced features of amd.

Consult the amd(8) and amd.conf(5) manual pages for more information.

30.3.6.Â Problems Integrating with Other Systems

Contributed by John Lind.

Certain Ethernet adapters for ISA PC systems have limitations which can lead to
serious network problems, particularly with NFS. This difficulty is not
specific to FreeBSD, but FreeBSD systems are affected by it.

The problem nearly always occurs when (FreeBSD) PC systems are networked with
high-performance workstations, such as those made by Silicon Graphics, Inc.,
and Sun Microsystems, Inc. The NFS mount will work fine, and some operations
may succeed, but suddenly the server will seem to become unresponsive to the
client, even though requests to and from other systems continue to be
processed. This happens to the client system, whether the client is the FreeBSD
system or the workstation. On many systems, there is no way to shut down the
client gracefully once this problem has manifested itself. The only solution is
often to reset the client, because the NFS situation cannot be resolved.

Though the â  correctâ   solution is to get a higher performance and capacity
Ethernet adapter for the FreeBSD system, there is a simple workaround that will
allow satisfactory operation. If the FreeBSD system is the server, include the
option -w=1024 on the mount from the client. If the FreeBSD system is the 
client, then mount the NFS file system with the option -r=1024. These options
may be specified using the fourth field of the fstab entry on the client for
automatic mounts, or by using the -o parameter of the mount(8) command for
manual mounts.

It should be noted that there is a different problem, sometimes mistaken for
this one, when the NFS servers and clients are on different networks. If that
is the case, make certain that your routers are routing the necessary UDP
information, or you will not get anywhere, no matter what else you are doing.

In the following examples, fastws is the host (interface) name of a
high-performance workstation, and freebox is the host (interface) name of a
FreeBSD system with a lower-performance Ethernet adapter. Also, /sharedfs will
be the exported NFS file system (see exports(5)), and /project will be the
mount point on the client for the exported file system. In all cases, note that
additional options, such as hard or soft and bg may be desirable in your
application.

Examples for the FreeBSD system (freebox) as the client in /etc/fstab on
freebox:

fastws:/sharedfs /project nfs rw,-r=1024 0 0

As a manual mount command on freebox:

# mount -t nfs -o -r=1024 fastws:/sharedfs /project

Examples for the FreeBSD system as the server in /etc/fstab on fastws:

freebox:/sharedfs /project nfs rw,-w=1024 0 0

As a manual mount command on fastws:

# mount -t nfs -o -w=1024 freebox:/sharedfs /project

Nearly any 16-bit Ethernet adapter will allow operation without the above
restrictions on the read or write size.

For anyone who cares, here is what happens when the failure occurs, which also
explains why it is unrecoverable. NFS typically works with a â  blockâ   size
of 8Â K (though it may do fragments of smaller sizes). Since the maximum
Ethernet packet is around 1500Â bytes, the NFS â  blockâ   gets split into
multiple Ethernet packets, even though it is still a single unit to the
upper-level code, and must be received, assembled, and acknowledged as a unit.
The high-performance workstations can pump out the packets which comprise the
NFS unit one right after the other, just as close together as the standard
allows. On the smaller, lower capacity cards, the later packets overrun the
earlier packets of the same unit before they can be transferred to the host and
the unit as a whole cannot be reconstructed or acknowledged. As a result, the
workstation will time out and try again, but it will try again with the entire
8Â K unit, and the process will be repeated, ad infinitum.

By keeping the unit size below the Ethernet packet size limitation, we ensure
that any complete Ethernet packet received can be acknowledged individually,
avoiding the deadlock situation.

Overruns may still occur when a high-performance workstations is slamming data
out to a PC system, but with the better cards, such overruns are not guaranteed
on NFS â  unitsâ  . When an overrun occurs, the units affected will be
retransmitted, and there will be a fair chance that they will be received,
assembled, and acknowledged.

30.4.Â Network Information System (NIS/YP)

Written by Bill Swingle.
Enhanced by Eric Ogren and Udo Erdelhoff.

30.4.1.Â What Is It?

NIS, which stands for Network Information Services, was developed by Sun
Microsystems to centralize administration of UNIXÂ® (originally SunOSâ ¢)
systems. It has now essentially become an industry standard; all major UNIXÂ®
like systems (Solarisâ ¢, HP-UX, AIXÂ®, Linux, NetBSD, OpenBSD, FreeBSD, etc)
support NIS.

NIS was formerly known as Yellow Pages, but because of trademark issues, Sun
changed the name. The old term (and yp) is still often seen and used.

It is a RPC-based client/server system that allows a group of machines within
an NIS domain to share a common set of configuration files. This permits a
system administrator to set up NIS client systems with only minimal
configuration data and add, remove or modify configuration data from a single
location.

It is similar to the WindowsÂ NTÂ® domain system; although the internal
implementation of the two are not at all similar, the basic functionality can
be compared.

30.4.2.Â Terms/Processes You Should Know

There are several terms and several important user processes that you will come
across when attempting to implement NIS on FreeBSD, whether you are trying to
create an NIS server or act as an NIS client:

    Term                                 Description
              An NIS master server and all of its clients (including its slave
NIS           servers) have a NIS domainname. Similar to an WindowsÂ NTÂ®
domainname    domain name, the NIS domainname does not have anything to do with
              DNS.
              Must be running in order to enable RPC (Remote Procedure Call, a
rpcbind       network protocol used by NIS). If rpcbind is not running, it will
              be impossible to run an NIS server, or to act as an NIS client.
              â  Bindsâ   an NIS client to its NIS server. It will take the NIS
              domainname from the system, and using RPC, connect to the server.
ypbind        ypbind is the core of client-server communication in an NIS
              environment; if ypbind dies on a client machine, it will not be
              able to access the NIS server.
              Should only be running on NIS servers; this is the NIS server
              process itself. If ypserv(8) dies, then the server will no longer
              be able to respond to NIS requests (hopefully, there is a slave
ypserv        server to take over for it). There are some implementations of
              NIS (but not the FreeBSD one), that do not try to reconnect to
              another server if the server it used before dies. Often, the only
              thing that helps in this case is to restart the server process
              (or even the whole server) or the ypbind process on the client.
              Another process that should only be running on NIS master
              servers; this is a daemon that will allow NIS clients to change
rpc.yppasswdd their NIS passwords. If this daemon is not running, users will
              have to login to the NIS master server and change their passwords
              there.

30.4.3.Â How Does It Work?

There are three types of hosts in an NIS environment: master servers, slave
servers, and clients. Servers act as a central repository for host
configuration information. Master servers hold the authoritative copy of this
information, while slave servers mirror this information for redundancy.
Clients rely on the servers to provide this information to them.

Information in many files can be shared in this manner. The master.passwd,
group, and hosts files are commonly shared via NIS. Whenever a process on a
client needs information that would normally be found in these files locally,
it makes a query to the NIS server that it is bound to instead.

30.4.3.1.Â Machine Types

  * A NIS master server. This server, analogous to a WindowsÂ NTÂ® primary
    domain controller, maintains the files used by all of the NIS clients. The
    passwd, group, and other various files used by the NIS clients live on the
    master server.

    Note:

    It is possible for one machine to be an NIS master server for more than one
    NIS domain. However, this will not be covered in this introduction, which
    assumes a relatively small-scale NIS environment.

  * NIS slave servers. Similar to the WindowsÂ NTÂ® backup domain controllers,
    NIS slave servers maintain copies of the NIS master's data files. NIS slave
    servers provide the redundancy, which is needed in important environments.
    They also help to balance the load of the master server: NIS Clients always
    attach to the NIS server whose response they get first, and this includes
    slave-server-replies.

  * NIS clients. NIS clients, like most WindowsÂ NTÂ® workstations,
    authenticate against the NIS server (or the WindowsÂ NTÂ® domain controller
    in the WindowsÂ NTÂ® workstations case) to log on.

30.4.4.Â Using NIS/YP

This section will deal with setting up a sample NIS environment.

30.4.4.1.Â Planning

Let us assume that you are the administrator of a small university lab. This
lab, which consists of 15 FreeBSD machines, currently has no centralized point
of administration; each machine has its own /etc/passwd and /etc/master.passwd.
These files are kept in sync with each other only through manual intervention;
currently, when you add a user to the lab, you must run adduser on all 15
machines. Clearly, this has to change, so you have decided to convert the lab
to use NIS, using two of the machines as servers.

Therefore, the configuration of the lab now looks something like:

    Machine name           IP address                  Machine role
ellington            10.0.0.2               NIS master
coltrane             10.0.0.3               NIS slave
basie                10.0.0.4               Faculty workstation
bird                 10.0.0.5               Client machine
cli[1-11]            10.0.0.[6-17]          Other client machines

If you are setting up a NIS scheme for the first time, it is a good idea to
think through how you want to go about it. No matter what the size of your
network, there are a few decisions that need to be made.

30.4.4.1.1.Â Choosing a NIS Domain Name

This might not be the â  domainnameâ   that you are used to. It is more
accurately called the â  NIS domainnameâ  . When a client broadcasts its
requests for info, it includes the name of the NIS domain that it is part of.
This is how multiple servers on one network can tell which server should answer
which request. Think of the NIS domainname as the name for a group of hosts
that are related in some way.

Some organizations choose to use their Internet domainname for their NIS
domainname. This is not recommended as it can cause confusion when trying to
debug network problems. The NIS domainname should be unique within your network
and it is helpful if it describes the group of machines it represents. For
example, the Art department at Acme Inc. might be in the â  acme-artâ   NIS
domain. For this example, assume you have chosen the name test-domain.

However, some operating systems (notably SunOSâ ¢) use their NIS domain name as
their Internet domain name. If one or more machines on your network have this
restriction, you must use the Internet domain name as your NIS domain name.

30.4.4.1.2.Â Physical Server Requirements

There are several things to keep in mind when choosing a machine to use as a
NIS server. One of the unfortunate things about NIS is the level of dependency
the clients have on the server. If a client cannot contact the server for its
NIS domain, very often the machine becomes unusable. The lack of user and group
information causes most systems to temporarily freeze up. With this in mind you
should make sure to choose a machine that will not be prone to being rebooted
regularly, or one that might be used for development. The NIS server should
ideally be a stand alone machine whose sole purpose in life is to be an NIS
server. If you have a network that is not very heavily used, it is acceptable
to put the NIS server on a machine running other services, just keep in mind
that if the NIS server becomes unavailable, it will affect all of your NIS
clients adversely.

30.4.4.2.Â NIS Servers

The canonical copies of all NIS information are stored on a single machine
called the NIS master server. The databases used to store the information are
called NIS maps. In FreeBSD, these maps are stored in /var/yp/[domainname]
where [domainname] is the name of the NIS domain being served. A single NIS
server can support several domains at once, therefore it is possible to have
several such directories, one for each supported domain. Each domain will have
its own independent set of maps.

NIS master and slave servers handle all NIS requests with the ypserv daemon.
ypserv is responsible for receiving incoming requests from NIS clients,
translating the requested domain and map name to a path to the corresponding
database file and transmitting data from the database back to the client.

30.4.4.2.1.Â Setting Up a NIS Master Server

Setting up a master NIS server can be relatively straight forward, depending on
your needs. FreeBSD comes with support for NIS out-of-the-box. All you need is
to add the following lines to /etc/rc.conf, and FreeBSD will do the rest for
you.

 1. nisdomainname="test-domain"

    This line will set the NIS domainname to test-domain upon network setup
    (e.g., after reboot).

 2. nis_server_enable="YES"

    This will tell FreeBSD to start up the NIS server processes when the
    networking is next brought up.

 3. nis_yppasswdd_enable="YES"

    This will enable the rpc.yppasswdd daemon which, as mentioned above, will
    allow users to change their NIS password from a client machine.

Note:

Depending on your NIS setup, you may need to add further entries. See the
section about NIS servers that are also NIS clients, below, for details.

After setting up the above entries, run the command /etc/netstart as superuser.
It will set up everything for you, using the values you defined in /etc/
rc.conf. As a last step, before initializing the NIS maps, start the ypserv
daemon manually:

# service ypserv start

30.4.4.2.2.Â Initializing the NIS Maps

The NIS maps are database files, that are kept in the /var/yp directory. They
are generated from configuration files in the /etc directory of the NIS master,
with one exception: the /etc/master.passwd file. This is for a good reason, you
do not want to propagate passwords to your root and other administrative
accounts to all the servers in the NIS domain. Therefore, before we initialize
the NIS maps, you should:

# cp /etc/master.passwd /var/yp/master.passwd # cd /var/yp # vi master.passwd

You should remove all entries regarding system accounts (bin, tty, kmem, games,
etc), as well as any accounts that you do not want to be propagated to the NIS
clients (for example root and any other UID 0 (superuser) accounts).

Note:

Make sure the /var/yp/master.passwd is neither group nor world readable (mode
600)! Use the chmod command, if appropriate.

When you have finished, it is time to initialize the NIS maps! FreeBSD includes
a script named ypinit to do this for you (see its manual page for more
information). Note that this script is available on most UNIXÂ® Operating
Systems, but not on all. On Digital UNIX/Compaq Tru64 UNIX it is called
ypsetup. Because we are generating maps for an NIS master, we are going to pass
the -m option to ypinit. To generate the NIS maps, assuming you already
performed the steps above, run:

ellington# ypinit -m test-domain Server Type: MASTER Domain: test-domain
Creating an YP server will require that you answer a few questions. Questions
will all be asked at the beginning of the procedure. Do you want this procedure
to quit on non-fatal errors? [y/n: n] n Ok, please remember to go back and redo
manually whatever fails. If you don't, something might not work. At this point,
we have to construct a list of this domains YP servers. rod.darktech.org is
already known as master server. Please continue to add any slave servers, one
per line. When you are done with the list, type a &lt;control D&gt;. master server :
ellington next host to add: coltrane next host to add: ^D The current list of
NIS servers looks like this: ellington coltrane Is this correct? [y/n: y] y
[..output from map generation..] NIS Map update completed. ellington has been
setup as an YP master server without any errors.

ypinit should have created /var/yp/Makefile from /var/yp/Makefile.dist. When
created, this file assumes that you are operating in a single server NIS
environment with only FreeBSD machines. Since test-domain has a slave server as
well, you must edit /var/yp/Makefile:

ellington# vi /var/yp/Makefile

You should comment out the line that says

NOPUSH = "True"

(if it is not commented out already).

30.4.4.2.3.Â Setting up a NIS Slave Server

Setting up an NIS slave server is even more simple than setting up the master.
Log on to the slave server and edit the file /etc/rc.conf as you did before.
The only difference is that we now must use the -s option when running ypinit.
The -s option requires the name of the NIS master be passed to it as well, so
our command line looks like:

coltrane# ypinit -s ellington test-domain Server Type: SLAVE Domain:
test-domain Master: ellington Creating an YP server will require that you
answer a few questions. Questions will all be asked at the beginning of the
procedure. Do you want this procedure to quit on non-fatal errors? [y/n: n] n
Ok, please remember to go back and redo manually whatever fails. If you don't,
something might not work. There will be no further questions. The remainder of
the procedure should take a few minutes, to copy the databases from ellington.
Transferring netgroup... ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser... ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost... ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid... ypxfr: Exiting: Map successfully
transferred Transferring passwd.byuid... ypxfr: Exiting: Map successfully
transferred Transferring passwd.byname... ypxfr: Exiting: Map successfully
transferred Transferring group.bygid... ypxfr: Exiting: Map successfully
transferred Transferring group.byname... ypxfr: Exiting: Map successfully
transferred Transferring services.byname... ypxfr: Exiting: Map successfully
transferred Transferring rpc.bynumber... ypxfr: Exiting: Map successfully
transferred Transferring rpc.byname... ypxfr: Exiting: Map successfully
transferred Transferring protocols.byname... ypxfr: Exiting: Map successfully
transferred Transferring master.passwd.byname... ypxfr: Exiting: Map
successfully transferred Transferring networks.byname... ypxfr: Exiting: Map
successfully transferred Transferring networks.byaddr... ypxfr: Exiting: Map
successfully transferred Transferring netid.byname... ypxfr: Exiting: Map
successfully transferred Transferring hosts.byaddr... ypxfr: Exiting: Map
successfully transferred Transferring protocols.bynumber... ypxfr: Exiting: Map
successfully transferred Transferring ypservers... ypxfr: Exiting: Map
successfully transferred Transferring hosts.byname... ypxfr: Exiting: Map
successfully transferred coltrane has been setup as an YP slave server without
any errors. Don't forget to update map ypservers on ellington.

You should now have a directory called /var/yp/test-domain. Copies of the NIS
master server's maps should be in this directory. You will need to make sure
that these stay updated. The following /etc/crontab entries on your slave
servers should do the job:

20 * * * * root /usr/libexec/ypxfr passwd.byname 21 * * * * root /usr/libexec/
ypxfr passwd.byuid

These two lines force the slave to sync its maps with the maps on the master
server. These entries are not mandatory because the master server automatically
attempts to push any map changes to its slaves. However, due to the importance
of correct password information on other clients depending on the slave server,
it is recommended to specifically force the password map updates frequently.
This is especially important on busy networks where map updates might not
always complete.

Now, run the command /etc/netstart on the slave server as well, which again
starts the NIS server.

30.4.4.3.Â NIS Clients

An NIS client establishes what is called a binding to a particular NIS server
using the ypbind daemon. ypbind checks the system's default domain (as set by
the domainname command), and begins broadcasting RPC requests on the local
network. These requests specify the name of the domain for which ypbind is
attempting to establish a binding. If a server that has been configured to
serve the requested domain receives one of the broadcasts, it will respond to
ypbind, which will record the server's address. If there are several servers
available (a master and several slaves, for example), ypbind will use the
address of the first one to respond. From that point on, the client system will
direct all of its NIS requests to that server. ypbind will occasionally â  ping
â   the server to make sure it is still up and running. If it fails to receive
a reply to one of its pings within a reasonable amount of time, ypbind will
mark the domain as unbound and begin broadcasting again in the hopes of
locating another server.

30.4.4.3.1.Â Setting Up a NIS Client

Setting up a FreeBSD machine to be a NIS client is fairly straightforward.

 1. Edit the file /etc/rc.conf and add the following lines in order to set the
    NIS domainname and start ypbind upon network startup:

    nisdomainname="test-domain" nis_client_enable="YES"
 2. To import all possible password entries from the NIS server, remove all
    user accounts from your /etc/master.passwd file and use vipw to add the
    following line to the end of the file:

    +:::::::::

    Note:

    This line will afford anyone with a valid account in the NIS server's
    password maps an account. There are many ways to configure your NIS client
    by changing this line. See the netgroups section below for more
    information. For more detailed reading see O'Reilly's book on Managing NFS
    and NIS.

    Note:

    You should keep at least one local account (i.e. not imported via NIS) in
    your /etc/master.passwd and this account should also be a member of the
    group wheel. If there is something wrong with NIS, this account can be used
    to log in remotely, become root, and fix things.

 3. To import all possible group entries from the NIS server, add this line to
    your /etc/group file:

    +:*::

To start the NIS client immediately, execute the following commands as the
superuser:

# /etc/netstart # service ypbind start

After completing these steps, you should be able to run ypcat passwd and see
the NIS server's passwd map.

30.4.5.Â NIS Security

In general, any remote user can issue an RPC to ypserv(8) and retrieve the
contents of your NIS maps, provided the remote user knows your domainname. To
prevent such unauthorized transactions, ypserv(8) supports a feature called â  
securenetsâ   which can be used to restrict access to a given set of hosts. At
startup, ypserv(8) will attempt to load the securenets information from a file
called /var/yp/securenets.

Note:

This path varies depending on the path specified with the -p option. This file
contains entries that consist of a network specification and a network mask
separated by white space. Lines starting with â  #â   are considered to be
comments. A sample securenets file might look like this:

# allow connections from local host -- mandatory 127.0.0.1 255.255.255.255 #
allow connections from any host # on the 192.168.128.0 network 192.168.128.0
255.255.255.0 # allow connections from any host # between 10.0.0.0 to
10.0.15.255 # this includes the machines in the testlab 10.0.0.0 255.255.240.0

If ypserv(8) receives a request from an address that matches one of these
rules, it will process the request normally. If the address fails to match a
rule, the request will be ignored and a warning message will be logged. If the
/var/yp/securenets file does not exist, ypserv will allow connections from any
host.

The ypserv program also has support for Wietse Venema's TCP Wrapper package.
This allows the administrator to use the TCP Wrapper configuration files for
access control instead of /var/yp/securenets.

Note:

While both of these access control mechanisms provide some security, they, like
the privileged port test, are vulnerable to â  IP spoofingâ   attacks. All
NIS-related traffic should be blocked at your firewall.

Servers using /var/yp/securenets may fail to serve legitimate NIS clients with
archaic TCP/IP implementations. Some of these implementations set all host bits
to zero when doing broadcasts and/or fail to observe the subnet mask when
calculating the broadcast address. While some of these problems can be fixed by
changing the client configuration, other problems may force the retirement of
the client systems in question or the abandonment of /var/yp/securenets.

Using /var/yp/securenets on a server with such an archaic implementation of TCP
/IP is a really bad idea and will lead to loss of NIS functionality for large
parts of your network.

The use of the TCP Wrapper package increases the latency of your NIS server.
The additional delay may be long enough to cause timeouts in client programs,
especially in busy networks or with slow NIS servers. If one or more of your
client systems suffers from these symptoms, you should convert the client
systems in question into NIS slave servers and force them to bind to
themselves.

30.4.6.Â Barring Some Users from Logging On

In our lab, there is a machine basie that is supposed to be a faculty only
workstation. We do not want to take this machine out of the NIS domain, yet the
passwd file on the master NIS server contains accounts for both faculty and
students. What can we do?

There is a way to bar specific users from logging on to a machine, even if they
are present in the NIS database. To do this, all you must do is add -username
with the correct number of colons like other entries to the end of the /etc/
master.passwd file on the client machine, where username is the username of the
user you wish to bar from logging in. The line with the blocked user must be
before the + line for allowing NIS users. This should preferably be done using
vipw, since vipw will sanity check your changes to /etc/master.passwd, as well
as automatically rebuild the password database when you finish editing. For
example, if we wanted to bar user bill from logging on to basie we would:

basie# vipw [add -bill::::::::: to the end, exit] vipw: rebuilding the
database... vipw: done basie# cat /etc/master.passwd root:
[password]:0:0::0:0:The super-user:/root:/bin/csh toor:[password]:0:0::0:0:The
other super-user:/root:/bin/sh daemon:*:1:1::0:0:Owner of many system
processes:/root:/sbin/nologin operator:*:2:5::0:0:System &:/:/sbin/nologin
bin:*:3:7::0:0:Binaries Commands and Source,,,:/:/sbin/nologin
tty:*:4:65533::0:0:Tty Sandbox:/:/sbin/nologin kmem:*:5:65533::0:0:KMem
Sandbox:/:/sbin/nologin games:*:7:13::0:0:Games pseudo-user:/usr/games:/sbin/
nologin news:*:8:8::0:0:News Subsystem:/:/sbin/nologin man:*:9:9::0:0:Mister
Man Pages:/usr/share/man:/sbin/nologin bind:*:53:53::0:0:Bind Sandbox:/:/sbin/
nologin uucp:*:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/
uucp/uucico xten:*:67:67::0:0:X-10 daemon:/usr/local/xten:/sbin/nologin
pop:*:68:6::0:0:Post Office Owner:/nonexistent:/sbin/nologin
nobody:*:65534:65534::0:0:Unprivileged user:/nonexistent:/sbin/nologin
-bill::::::::: +::::::::: basie#

30.4.7.Â Using Netgroups

Contributed by Udo Erdelhoff.

The method shown in the previous section works reasonably well if you need
special rules for a very small number of users and/or machines. On larger
networks, you will forget to bar some users from logging onto sensitive
machines, or you may even have to modify each machine separately, thus losing
the main benefit of NIS: centralized administration.

The NIS developers' solution for this problem is called netgroups. Their
purpose and semantics can be compared to the normal groups used by UNIXÂ® file
systems. The main differences are the lack of a numeric ID and the ability to
define a netgroup by including both user accounts and other netgroups.

Netgroups were developed to handle large, complex networks with hundreds of
users and machines. On one hand, this is a Good Thing if you are forced to deal
with such a situation. On the other hand, this complexity makes it almost
impossible to explain netgroups with really simple examples. The example used
in the remainder of this section demonstrates this problem.

Let us assume that your successful introduction of NIS in your laboratory
caught your superiors' interest. Your next job is to extend your NIS domain to
cover some of the other machines on campus. The two tables contain the names of
the new users and new machines as well as brief descriptions of them.

         User Name(s)                            Description
alpha, beta                    Normal employees of the IT department
charlie, delta                 The new apprentices of the IT department
echo, foxtrott, golf, ...      Ordinary employees
able, baker, ...               The current interns

   Machine Name(s)                           Description
war, death, famine,    Your most important servers. Only the IT employees are
pollution              allowed to log onto these machines.
pride, greed, envy,    Less important servers. All members of the IT department
wrath, lust, sloth     are allowed to login onto these machines.
one, two, three, four, Ordinary workstations. Only the real employees are
...                    allowed to use these machines.
trashcan               A very old machine without any critical data. Even the
                       intern is allowed to use this box.

If you tried to implement these restrictions by separately blocking each user,
you would have to add one -user line to each system's passwd for each user who
is not allowed to login onto that system. If you forget just one entry, you
could be in trouble. It may be feasible to do this correctly during the initial
setup, however you will eventually forget to add the lines for new users during
day-to-day operations. After all, Murphy was an optimist.

Handling this situation with netgroups offers several advantages. Each user
need not be handled separately; you assign a user to one or more netgroups and
allow or forbid logins for all members of the netgroup. If you add a new
machine, you will only have to define login restrictions for netgroups. If a
new user is added, you will only have to add the user to one or more netgroups.
Those changes are independent of each other: no more â  for each combination of
user and machine do...â   If your NIS setup is planned carefully, you will only
have to modify exactly one central configuration file to grant or deny access
to machines.

The first step is the initialization of the NIS map netgroup. FreeBSD's ypinit
(8) does not create this map by default, but its NIS implementation will
support it once it has been created. To create an empty map, simply type

ellington# vi /var/yp/netgroup

and start adding content. For our example, we need at least four netgroups: IT
employees, IT apprentices, normal employees and interns.

IT_EMP (,alpha,test-domain) (,beta,test-domain) IT_APP (,charlie,test-domain)
(,delta,test-domain) USERS (,echo,test-domain) (,foxtrott,test-domain) \
(,golf,test-domain) INTERNS (,able,test-domain) (,baker,test-domain)

IT_EMP, IT_APP etc. are the names of the netgroups. Each bracketed group adds
one or more user accounts to it. The three fields inside a group are:

 1. The name of the host(s) where the following items are valid. If you do not
    specify a hostname, the entry is valid on all hosts. If you do specify a
    hostname, you will enter a realm of darkness, horror and utter confusion.

 2. The name of the account that belongs to this netgroup.

 3. The NIS domain for the account. You can import accounts from other NIS
    domains into your netgroup if you are one of the unlucky fellows with more
    than one NIS domain.

Each of these fields can contain wildcards. See netgroup(5) for details.

Note:

Netgroup names longer than 8 characters should not be used, especially if you
have machines running other operating systems within your NIS domain. The names
are case sensitive; using capital letters for your netgroup names is an easy
way to distinguish between user, machine and netgroup names.

Some NIS clients (other than FreeBSD) cannot handle netgroups with a large
number of entries. For example, some older versions of SunOSâ ¢ start to cause
trouble if a netgroup contains more than 15 entries. You can circumvent this
limit by creating several sub-netgroups with 15 users or less and a real
netgroup that consists of the sub-netgroups:

BIGGRP1 (,joe1,domain) (,joe2,domain) (,joe3,domain) [...] BIGGRP2
(,joe16,domain) (,joe17,domain) [...] BIGGRP3 (,joe31,domain) (,joe32,domain)
BIGGROUP BIGGRP1 BIGGRP2 BIGGRP3

You can repeat this process if you need more than 225 users within a single
netgroup.

Activating and distributing your new NIS map is easy:

ellington# cd /var/yp ellington# make

This will generate the three NIS maps netgroup, netgroup.byhost and
netgroup.byuser. Use ypcat(1) to check if your new NIS maps are available:

ellington% ypcat -k netgroup ellington% ypcat -k netgroup.byhost ellington%
ypcat -k netgroup.byuser

The output of the first command should resemble the contents of /var/yp/
netgroup. The second command will not produce output if you have not specified
host-specific netgroups. The third command can be used to get the list of
netgroups for a user.

The client setup is quite simple. To configure the server war, you only have to
start vipw(8) and replace the line

+:::::::::

with

+@IT_EMP:::::::::

Now, only the data for the users defined in the netgroup IT_EMP is imported
into war's password database and only these users are allowed to login.

Unfortunately, this limitation also applies to the ~ function of the shell and
all routines converting between user names and numerical user IDs. In other
words, cd ~user will not work, ls -l will show the numerical ID instead of the
username and find . -user joe -print will fail with No such user. To fix this,
you will have to import all user entries without allowing them to login onto
your servers.

This can be achieved by adding another line to /etc/master.passwd. This line
should contain:

+:::::::::/sbin/nologin, meaning â  Import all entries but replace the shell
with /sbin/nologin in the imported entriesâ  . You can replace any field in the
passwd entry by placing a default value in your /etc/master.passwd.

Warning:

Make sure that the line +:::::::::/sbin/nologin is placed after
+@IT_EMP:::::::::. Otherwise, all user accounts imported from NIS will have /
sbin/nologin as their login shell.

After this change, you will only have to change one NIS map if a new employee
joins the IT department. You could use a similar approach for the less
important servers by replacing the old +::::::::: in their local version of /
etc/master.passwd with something like this:

+@IT_EMP::::::::: +@IT_APP::::::::: +:::::::::/sbin/nologin

The corresponding lines for the normal workstations could be:

+@IT_EMP::::::::: +@USERS::::::::: +:::::::::/sbin/nologin

And everything would be fine until there is a policy change a few weeks later:
The IT department starts hiring interns. The IT interns are allowed to use the
normal workstations and the less important servers; and the IT apprentices are
allowed to login onto the main servers. You add a new netgroup IT_INTERN, add
the new IT interns to this netgroup and start to change the configuration on
each and every machine... As the old saying goes: â  Errors in centralized
planning lead to global messâ  .

NIS' ability to create netgroups from other netgroups can be used to prevent
situations like these. One possibility is the creation of role-based netgroups.
For example, you could create a netgroup called BIGSRV to define the login
restrictions for the important servers, another netgroup called SMALLSRV for
the less important servers and a third netgroup called USERBOX for the normal
workstations. Each of these netgroups contains the netgroups that are allowed
to login onto these machines. The new entries for your NIS map netgroup should
look like this:

BIGSRV IT_EMP IT_APP SMALLSRV IT_EMP IT_APP ITINTERN USERBOX IT_EMP ITINTERN
USERS

This method of defining login restrictions works reasonably well if you can
define groups of machines with identical restrictions. Unfortunately, this is
the exception and not the rule. Most of the time, you will need the ability to
define login restrictions on a per-machine basis.

Machine-specific netgroup definitions are the other possibility to deal with
the policy change outlined above. In this scenario, the /etc/master.passwd of
each box contains two lines starting with â  +â  . The first of them adds a
netgroup with the accounts allowed to login onto this machine, the second one
adds all other accounts with /sbin/nologin as shell. It is a good idea to use
the â  ALL-CAPSâ   version of the machine name as the name of the netgroup. In
other words, the lines should look like this:

+@BOXNAME::::::::: +:::::::::/sbin/nologin

Once you have completed this task for all your machines, you will not have to
modify the local versions of /etc/master.passwd ever again. All further changes
can be handled by modifying the NIS map. Here is an example of a possible
netgroup map for this scenario with some additional goodies:

# Define groups of users first IT_EMP (,alpha,test-domain) (,beta,test-domain)
IT_APP (,charlie,test-domain) (,delta,test-domain) DEPT1 (,echo,test-domain)
(,foxtrott,test-domain) DEPT2 (,golf,test-domain) (,hotel,test-domain) DEPT3
(,india,test-domain) (,juliet,test-domain) ITINTERN (,kilo,test-domain)
(,lima,test-domain) D_INTERNS (,able,test-domain) (,baker,test-domain) # # Now,
define some groups based on roles USERS DEPT1 DEPT2 DEPT3 BIGSRV IT_EMP IT_APP
SMALLSRV IT_EMP IT_APP ITINTERN USERBOX IT_EMP ITINTERN USERS # # And a groups
for a special tasks # Allow echo and golf to access our anti-virus-machine
SECURITY IT_EMP (,echo,test-domain) (,golf,test-domain) # # machine-based
netgroups # Our main servers WAR BIGSRV FAMINE BIGSRV # User india needs access
to this server POLLUTION BIGSRV (,india,test-domain) # # This one is really
important and needs more access restrictions DEATH IT_EMP # # The
anti-virus-machine mentioned above ONE SECURITY # # Restrict a machine to a
single user TWO (,hotel,test-domain) # [...more groups to follow]

If you are using some kind of database to manage your user accounts, you should
be able to create the first part of the map with your database's report tools.
This way, new users will automatically have access to the boxes.

One last word of caution: It may not always be advisable to use machine-based
netgroups. If you are deploying a couple of dozen or even hundreds of identical
machines for student labs, you should use role-based netgroups instead of
machine-based netgroups to keep the size of the NIS map within reasonable
limits.

30.4.8.Â Important Things to Remember

There are still a couple of things that you will need to do differently now
that you are in an NIS environment.

  * Every time you wish to add a user to the lab, you must add it to the master
    NIS server only, and you must remember to rebuild the NIS maps. If you
    forget to do this, the new user will not be able to login anywhere except
    on the NIS master. For example, if we needed to add a new user jsmith to
    the lab, we would:

    # pw useradd jsmith # cd /var/yp # make test-domain

    You could also run adduser jsmith instead of pw useradd jsmith.

  * Keep the administration accounts out of the NIS maps. You do not want to be
    propagating administrative accounts and passwords to machines that will
    have users that should not have access to those accounts.

  * Keep the NIS master and slave secure, and minimize their downtime. If
    somebody either hacks or simply turns off these machines, they have
    effectively rendered many people without the ability to login to the lab.

    This is the chief weakness of any centralized administration system. If you
    do not protect your NIS servers, you will have a lot of angry users!

30.4.9.Â NIS v1 Compatibility

FreeBSD's ypserv has some support for serving NIS v1 clients. FreeBSD's NIS
implementation only uses the NIS v2 protocol, however other implementations
include support for the v1 protocol for backwards compatibility with older
systems. The ypbind daemons supplied with these systems will try to establish a
binding to an NIS v1 server even though they may never actually need it (and
they may persist in broadcasting in search of one even after they receive a
response from a v2 server). Note that while support for normal client calls is
provided, this version of ypserv does not handle v1 map transfer requests;
consequently, it cannot be used as a master or slave in conjunction with older
NIS servers that only support the v1 protocol. Fortunately, there probably are
not any such servers still in use today.

30.4.10.Â NIS Servers That Are Also NIS Clients

Care must be taken when running ypserv in a multi-server domain where the
server machines are also NIS clients. It is generally a good idea to force the
servers to bind to themselves rather than allowing them to broadcast bind
requests and possibly become bound to each other. Strange failure modes can
result if one server goes down and others are dependent upon it. Eventually all
the clients will time out and attempt to bind to other servers, but the delay
involved can be considerable and the failure mode is still present since the
servers might bind to each other all over again.

You can force a host to bind to a particular server by running ypbind with the
-S flag. If you do not want to do this manually each time you reboot your NIS
server, you can add the following lines to your /etc/rc.conf:

nis_client_enable="YES" # run client stuff as well nis_client_flags="-S NIS
domain,server"

See ypbind(8) for further information.

30.4.11.Â Password Formats

One of the most common issues that people run into when trying to implement NIS
is password format compatibility. If your NIS server is using DES encrypted
passwords, it will only support clients that are also using DES. For example,
if you have Solarisâ ¢ NIS clients in your network, then you will almost
certainly need to use DES encrypted passwords.

To check which format your servers and clients are using, look at /etc/
login.conf. If the host is configured to use DES encrypted passwords, then the
default class will contain an entry like this:

default:\ :passwd_format=des:\ :copyright=/etc/COPYRIGHT:\ [Further entries
elided]

Other possible values for the passwd_format capability include blf and md5 (for
Blowfish and MD5 encrypted passwords, respectively).

If you have made changes to /etc/login.conf, you will also need to rebuild the
login capability database, which is achieved by running the following command
as root:

# cap_mkdb /etc/login.conf

Note:

The format of passwords already in /etc/master.passwd will not be updated until
a user changes his password for the first time after the login capability
database is rebuilt.

Next, in order to ensure that passwords are encrypted with the format that you
have chosen, you should also check that the crypt_default in /etc/auth.conf
gives precedence to your chosen password format. To do this, place the format
that you have chosen first in the list. For example, when using DES encrypted
passwords, the entry would be:

crypt_default = des blf md5

Having followed the above steps on each of the FreeBSD based NIS servers and
clients, you can be sure that they all agree on which password format is used
within your network. If you have trouble authenticating on an NIS client, this
is a pretty good place to start looking for possible problems. Remember: if you
want to deploy an NIS server for a heterogeneous network, you will probably
have to use DES on all systems because it is the lowest common standard.

30.5.Â Automatic Network Configuration (DHCP)

Written by Greg Sutter.

30.5.1.Â What Is DHCP?

DHCP, the Dynamic Host Configuration Protocol, describes the means by which a
system can connect to a network and obtain the necessary information for
communication upon that network. FreeBSD uses the OpenBSD dhclient taken from
OpenBSDÂ 3.7. All information here regarding dhclient is for use with either of
the ISC or OpenBSD DHCP clients. The DHCP server is the one included in the ISC
distribution.

30.5.2.Â What This Section Covers

This section describes both the client-side components of the ISC and OpenBSD
DHCP client and server-side components of the ISC DHCP system. The client-side
program, dhclient, comes integrated within FreeBSD, and the server-side portion
is available from the net/isc-dhcp42-server port. The dhclient(8), dhcp-options
(5), and dhclient.conf(5) manual pages, in addition to the references below,
are useful resources.

30.5.3.Â How It Works

When dhclient, the DHCP client, is executed on the client machine, it begins
broadcasting requests for configuration information. By default, these requests
are on UDP port 68. The server replies on UDP 67, giving the client an IP
address and other relevant network information such as netmask, router, and DNS
servers. All of this information comes in the form of a DHCP â  leaseâ   and is
only valid for a certain time (configured by the DHCP server maintainer). In
this manner, stale IP addresses for clients no longer connected to the network
can be automatically reclaimed.

DHCP clients can obtain a great deal of information from the server. An
exhaustive list may be found in dhcp-options(5).

30.5.4.Â FreeBSD Integration

FreeBSD fully integrates the OpenBSD DHCP client, dhclient. DHCP client support
is provided within both the installer and the base system, obviating the need
for detailed knowledge of network configurations on any network that runs a
DHCP server.

DHCP is supported by sysinstall. When configuring a network interface within 
sysinstall, the second question asked is: â  Do you want to try DHCP
configuration of the interface?â  . Answering affirmatively will execute
dhclient, and if successful, will fill in the network configuration information
automatically.

There are two things you must do to have your system use DHCP upon startup:

  * Make sure that the bpf device is compiled into your kernel. To do this, add
    device bpf to your kernel configuration file, and rebuild the kernel. For
    more information about building kernels, see ChapterÂ 9, Configuring the
    FreeBSD Kernel.

    The bpf device is already part of the GENERIC kernel that is supplied with
    FreeBSD, so if you do not have a custom kernel, you should not need to
    create one in order to get DHCP working.

    Note:

    For those who are particularly security conscious, you should be warned
    that bpf is also the device that allows packet sniffers to work correctly
    (although they still have to be run as root). bpf is required to use DHCP,
    but if you are very sensitive about security, you probably should not add
    bpf to your kernel in the expectation that at some point in the future you
    will be using DHCP.

  * By default, DHCP configuration on FreeBSD runs in the background, or
    asynchronously. Other startup scripts continue to run while DHCP completes,
    speeding up system startup.

    Background DHCP works well when the DHCP server responds quickly to
    requests and the DHCP configuration process goes quickly. However, DHCP may
    take a long time to complete on some systems. If network services attempt
    to run before DHCP has completed, they will fail. Using DHCP in synchronous
    mode prevents the problem, pausing startup until DHCP configuration has
    completed.

    To connect to a DHCP server in the background while other startup continues
    (asynchronous mode), use the â  DHCPâ   value in /etc/rc.conf:

    ifconfig_fxp0="DHCP"

    To pause startup while DHCP completes, use synchronous mode with the â  
    SYNCDHCPâ   value:

    ifconfig_fxp0="SYNCDHCP"

    Note:

    Replace the fxp0 shown in these examples with the name of the interface to
    be dynamically configured, as described in SectionÂ 12.8, â  Setting Up
    Network Interface Cardsâ  .

    If you are using a different location for dhclient, or if you wish to pass
    additional flags to dhclient, also include (editing as necessary):

    dhclient_program="/sbin/dhclient" dhclient_flags=""

The DHCP server, dhcpd, is included as part of the net/isc-dhcp42-server port
in the ports collection. This port contains the ISC DHCP server and
documentation.

30.5.5.Â Files

  * /etc/dhclient.conf

    dhclient requires a configuration file, /etc/dhclient.conf. Typically the
    file contains only comments, the defaults being reasonably sane. This
    configuration file is described by the dhclient.conf(5) manual page.

  * /sbin/dhclient

    dhclient is statically linked and resides in /sbin. The dhclient(8) manual
    page gives more information about dhclient.

  * /sbin/dhclient-script

    dhclient-script is the FreeBSD-specific DHCP client configuration script.
    It is described in dhclient-script(8), but should not need any user
    modification to function properly.

  * /var/db/dhclient.leases.interface

    The DHCP client keeps a database of valid leases in this file, which is
    written as a log. dhclient.leases(5) gives a slightly longer description.

30.5.6.Â Further Reading

The DHCP protocol is fully described in RFC 2131. An informational resource has
also been set up at http://www.dhcp.org/.

30.5.7.Â Installing and Configuring a DHCP Server

30.5.7.1.Â What This Section Covers

This section provides information on how to configure a FreeBSD system to act
as a DHCP server using the ISC (Internet Systems Consortium) implementation of
the DHCP server.

The server is not provided as part of FreeBSD, and so you will need to install
the net/isc-dhcp42-server port to provide this service. See ChapterÂ 5, 
Installing Applications: Packages and Ports for more information on using the
Ports Collection.

30.5.7.2.Â DHCP Server Installation

In order to configure your FreeBSD system as a DHCP server, you will need to
ensure that the bpf(4) device is compiled into your kernel. To do this, add
device bpf to your kernel configuration file, and rebuild the kernel. For more
information about building kernels, see ChapterÂ 9, Configuring the FreeBSD
Kernel.

The bpf device is already part of the GENERIC kernel that is supplied with
FreeBSD, so you do not need to create a custom kernel in order to get DHCP
working.

Note:

Those who are particularly security conscious should note that bpf is also the
device that allows packet sniffers to work correctly (although such programs
still need privileged access). bpf is required to use DHCP, but if you are very
sensitive about security, you probably should not include bpf in your kernel
purely because you expect to use DHCP at some point in the future.

The next thing that you will need to do is edit the sample dhcpd.conf which was
installed by the net/isc-dhcp42-server port. By default, this will be /usr/
local/etc/dhcpd.conf.sample, and you should copy this to /usr/local/etc/
dhcpd.conf before proceeding to make changes.

30.5.7.3.Â Configuring the DHCP Server

dhcpd.conf is comprised of declarations regarding subnets and hosts, and is
perhaps most easily explained using an example :

option domain-name "example.com";1 option domain-name-servers 192.168.4.100;2
option subnet-mask 255.255.255.0;3 default-lease-time 3600;4 max-lease-time
86400;5 ddns-update-style none;6 subnet 192.168.4.0 netmask 255.255.255.0 {
range 192.168.4.129 192.168.4.254;7 option routers 192.168.4.1;8 } host
mailhost { hardware ethernet 02:03:04:05:06:07;9 fixed-address
mailhost.example.com;10 }

1    This option specifies the domain that will be provided to clients as the
     default search domain. See resolv.conf(5) for more information on what
     this means.

2    This option specifies a comma separated list of DNS servers that the
     client should use.

3    The netmask that will be provided to clients.

4    A client may request a specific length of time that a lease will be valid.
     Otherwise the server will assign a lease with this expiry value (in
     seconds).

5    This is the maximum length of time that the server will lease for. Should
     a client request a longer lease, a lease will be issued, although it will
     only be valid for max-lease-time seconds.

6    This option specifies whether the DHCP server should attempt to update DNS
     when a lease is accepted or released. In the ISC implementation, this
     option is required.

7    This denotes which IP addresses should be used in the pool reserved for
     allocating to clients. IP addresses between, and including, the ones
     stated are handed out to clients.

8    Declares the default gateway that will be provided to clients.

9    The hardware MAC address of a host (so that the DHCP server can recognize
     a host when it makes a request).

10   Specifies that the host should always be given the same IP address. Note
     that using a hostname is correct here, since the DHCP server will resolve
     the hostname itself before returning the lease information.

Once you have finished writing your dhcpd.conf, you should enable the DHCP
server in /etc/rc.conf, i.e., by adding:

dhcpd_enable="YES" dhcpd_ifaces="dc0"

Replace the dc0 interface name with the interface (or interfaces, separated by
whitespace) that your DHCP server should listen on for DHCP client requests.

Then, you can proceed to start the server by issuing the following command:

# service isc-dhcpd start

Should you need to make changes to the configuration of your server in the
future, it is important to note that sending a SIGHUP signal to dhcpd does not
result in the configuration being reloaded, as it does with most daemons. You
will need to send a SIGTERM signal to stop the process, and then restart it
using the command above.

30.5.7.4.Â Files

  * /usr/local/sbin/dhcpd

    dhcpd is statically linked and resides in /usr/local/sbin. The dhcpd(8)
    manual page installed with the port gives more information about dhcpd.

  * /usr/local/etc/dhcpd.conf

    dhcpd requires a configuration file, /usr/local/etc/dhcpd.conf before it
    will start providing service to clients. This file needs to contain all the
    information that should be provided to clients that are being serviced,
    along with information regarding the operation of the server. This
    configuration file is described by the dhcpd.conf(5) manual page installed
    by the port.

  * /var/db/dhcpd.leases

    The DHCP server keeps a database of leases it has issued in this file,
    which is written as a log. The manual page dhcpd.leases(5), installed by
    the port gives a slightly longer description.

  * /usr/local/sbin/dhcrelay

    dhcrelay is used in advanced environments where one DHCP server forwards a
    request from a client to another DHCP server on a separate network. If you
    require this functionality, then install the net/isc-dhcp42-relay port. The
    dhcrelay(8) manual page provided with the port contains more detail.

30.6.Â Domain Name System (DNS)

Contributed by Chern Lee, Tom Rhodes and Daniel Gerzo.

30.6.1.Â Overview

FreeBSD utilizes, by default, a version of BIND (Berkeley Internet Name
Domain), which is the most common implementation of the DNS protocol. DNS is
the protocol through which names are mapped to IP addresses, and vice versa.
For example, a query for www.FreeBSD.org will receive a reply with the IP
address of The FreeBSD Project's web server, whereas, a query for
ftp.FreeBSD.org will return the IP address of the corresponding FTP machine.
Likewise, the opposite can happen. A query for an IP address can resolve its
hostname. It is not necessary to run a name server to perform DNS lookups on a
system.

FreeBSD currently comes with BIND9 DNS server software by default. Our
installation provides enhanced security features, a new file system layout and
automated chroot(8) configuration.

DNS is coordinated across the Internet through a somewhat complex system of
authoritative root, Top Level Domain (TLD), and other smaller-scale name
servers which host and cache individual domain information.

Currently, BIND is maintained by the Internet Systems Consortium https://
www.isc.org/.

30.6.2.Â Terminology

To understand this document, some terms related to DNS must be understood.

  Term                                 Definition
Forward  Mapping of hostnames to IP addresses.
DNS
Origin   Refers to the domain covered in a particular zone file.
named,   Common names for the BIND name server package within FreeBSD.
BIND
Resolver A system process through which a machine queries a name server for
         zone information.
Reverse  Mapping of IP addresses to hostnames.
DNS
Root     The beginning of the Internet zone hierarchy. All zones fall under the
zone     root zone, similar to how all files in a file system fall under the
         root directory.
Zone     An individual domain, subdomain, or portion of the DNS administered by
         the same authority.

Examples of zones:

  * . is how the root zone is usually referred to in documentation.

  * org. is a Top Level Domain (TLD) under the root zone.

  * example.org. is a zone under the org. TLD.

  * 1.168.192.in-addr.arpa is a zone referencing all IP addresses which fall
    under the 192.168.1.* IP address space.

As one can see, the more specific part of a hostname appears to its left. For
example, example.org. is more specific than org., as org. is more specific than
the root zone. The layout of each part of a hostname is much like a file
system: the /dev directory falls within the root, and so on.

30.6.3.Â Reasons to Run a Name Server

Name servers generally come in two forms: authoritative name servers, and
caching (also known as resolving) name servers.

An authoritative name server is needed when:

  * One wants to serve DNS information to the world, replying authoritatively
    to queries.

  * A domain, such as example.org, is registered and IP addresses need to be
    assigned to hostnames under it.

  * An IP address block requires reverse DNS entries (IP to hostname).

  * A backup or second name server, called a slave, will reply to queries.

A caching name server is needed when:

  * A local DNS server may cache and respond more quickly than querying an
    outside name server.

When one queries for www.FreeBSD.org, the resolver usually queries the uplink 
ISP's name server, and retrieves the reply. With a local, caching DNS server,
the query only has to be made once to the outside world by the caching DNS
server. Additional queries will not have to go outside the local network, since
the information is cached locally.

30.6.4.Â How It Works

In FreeBSD, the BIND daemon is called named.

          File                                 Description
named(8)                  The BIND daemon.
rndc(8)                   Name server control utility.
/etc/namedb               Directory where BIND zone information resides.
/etc/namedb/named.conf    Configuration file of the daemon.

Depending on how a given zone is configured on the server, the files related to
that zone can be found in the master, slave, or dynamic subdirectories of the /
etc/namedb directory. These files contain the DNS information that will be
given out by the name server in response to queries.

30.6.5.Â Starting BIND

Since BIND is installed by default, configuring it is relatively simple.

The default named configuration is that of a basic resolving name server,
running in a chroot(8) environment, and restricted to listening on the local
IPv4 loopback address (127.0.0.1). To start the server one time with this
configuration, use the following command:

# service named onestart

To ensure the named daemon is started at boot each time, put the following line
into the /etc/rc.conf:

named_enable="YES"

There are obviously many configuration options for /etc/namedb/named.conf that
are beyond the scope of this document. However, if you are interested in the
startup options for named on FreeBSD, take a look at the named_* flags in /etc/
defaults/rc.conf and consult the rc.conf(5) manual page. The SectionÂ 12.7, â  
Using rc(8) Under FreeBSDâ   section is also a good read.

30.6.6.Â Configuration Files

Configuration files for named currently reside in /etc/namedb directory and
will need modification before use unless all that is needed is a simple
resolver. This is where most of the configuration will be performed.

30.6.6.1.Â /etc/namedb/named.conf

// $FreeBSD$ // // Refer to the named.conf(5) and named(8) man pages, and the
documentation // in /usr/share/doc/bind9 for more details. // // If you are
going to set up an authoritative server, make sure you // understand the hairy
details of how DNS works. Even with // simple mistakes, you can break
connectivity for affected parties, // or cause huge amounts of useless Internet
traffic. options { // All file and path names are relative to the chroot
directory, // if any, and should be fully qualified. directory "/etc/namedb/
working"; pid-file "/var/run/named/pid"; dump-file "/var/dump/named_dump.db";
statistics-file "/var/stats/named.stats"; // If named is being used only as a
local resolver, this is a safe default. // For named to be accessible to the
network, comment this option, specify // the proper IP address, or delete this
option. listen-on { 127.0.0.1; }; // If you have IPv6 enabled on this system,
uncomment this option for // use as a local resolver. To give access to the
network, specify // an IPv6 address, or the keyword "any". // listen-on-v6 {
::1; }; // These zones are already covered by the empty zones listed below. //
If you remove the related empty zones below, comment these lines out.
disable-empty-zone "255.255.255.255.IN-ADDR.ARPA"; disable-empty-zone
"0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.ARPA";
disable-empty-zone
"1.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.0.IP6.ARPA"; //
If you've got a DNS server around at your upstream provider, enter // its IP
address here, and enable the line below. This will make you // benefit from its
cache, thus reduce overall DNS traffic in the Internet. /* forwarders {
127.0.0.1; }; */ // If the 'forwarders' clause is not empty the default is to
'forward first' // which will fall back to sending a query from your local
server if the name // servers in 'forwarders' do not have the answer.
Alternatively you can // force your name server to never initiate queries of
its own by enabling the // following line: // forward only; // If you wish to
have forwarding configured automatically based on // the entries in /etc/
resolv.conf, uncomment the following line and // set named_auto_forward=yes in
/etc/rc.conf. You can also enable // named_auto_forward_only (the effect of
which is described above). // include "/etc/namedb/auto_forward.conf";

Just as the comment says, to benefit from an uplink's cache, forwarders can be
enabled here. Under normal circumstances, a name server will recursively query
the Internet looking at certain name servers until it finds the answer it is
looking for. Having this enabled will have it query the uplink's name server
(or name server provided) first, taking advantage of its cache. If the uplink
name server in question is a heavily trafficked, fast name server, enabling
this may be worthwhile.

Warning:

127.0.0.1 will not work here. Change this IP address to a name server at your
uplink.

/* Modern versions of BIND use a random UDP port for each outgoing query by
default in order to dramatically reduce the possibility of cache poisoning. All
users are strongly encouraged to utilize this feature, and to configure their
firewalls to accommodate it. AS A LAST RESORT in order to get around a
restrictive firewall policy you can try enabling the option below. Use of this
option will significantly reduce your ability to withstand cache poisoning
attacks, and should be avoided if at all possible. Replace NNNNN in the example
with a number between 49160 and 65530. */ // query-source address * port NNNNN;
}; // If you enable a local name server, don't forget to enter 127.0.0.1 //
first in your /etc/resolv.conf so this server will be queried. // Also, make
sure to enable it in /etc/rc.conf. // The traditional root hints mechanism. Use
this, OR the slave zones below. zone "." { type hint; file "/etc/namedb/
named.root"; }; /* Slaving the following zones from the root name servers has
some significant advantages: 1. Faster local resolution for your users 2. No
spurious traffic will be sent from your network to the roots 3. Greater
resilience to any potential root server failure/DDoS On the other hand, this
method requires more monitoring than the hints file to be sure that an
unexpected failure mode has not incapacitated your server. Name servers that
are serving a lot of clients will benefit more from this approach than
individual hosts. Use with caution. To use this mechanism, uncomment the
entries below, and comment the hint zone above. As documented at http://
dns.icann.org/services/axfr/ these zones: "." (the root), ARPA, IN-ADDR.ARPA,
IP6.ARPA, and ROOT-SERVERS.NET are available for AXFR from these servers on
IPv4 and IPv6: xfr.lax.dns.icann.org, xfr.cjr.dns.icann.org */ /* zone "." {
type slave; file "/etc/namedb/slave/root.slave"; masters { 192.5.5.241; //
F.ROOT-SERVERS.NET. }; notify no; }; zone "arpa" { type slave; file "/etc/
namedb/slave/arpa.slave"; masters { 192.5.5.241; // F.ROOT-SERVERS.NET. };
notify no; }; */ /* Serving the following zones locally will prevent any
queries for these zones leaving your network and going to the root name
servers. This has two significant advantages: 1. Faster local resolution for
your users 2. No spurious traffic will be sent from your network to the roots *
/ // RFCs 1912 and 5735 (and BCP 32 for localhost) zone "localhost" { type
master; file "/etc/namedb/master/localhost-forward.db"; }; zone
"127.in-addr.arpa" { type master; file "/etc/namedb/master/
localhost-reverse.db"; }; zone "255.in-addr.arpa" { type master; file "/etc/
namedb/master/empty.db"; }; // RFC 1912-style zone for IPv6 localhost address
zone "0.ip6.arpa" { type master; file "/etc/namedb/master/
localhost-reverse.db"; }; // "This" Network (RFCs 1912 and 5735) zone
"0.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; }; //
Private Use Networks (RFCs 1918 and 5735) zone "10.in-addr.arpa" { type master;
file "/etc/namedb/master/empty.db"; }; zone "16.172.in-addr.arpa" { type
master; file "/etc/namedb/master/empty.db"; }; zone "17.172.in-addr.arpa" {
type master; file "/etc/namedb/master/empty.db"; }; zone "18.172.in-addr.arpa"
{ type master; file "/etc/namedb/master/empty.db"; }; zone
"19.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "20.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db";
}; zone "21.172.in-addr.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "22.172.in-addr.arpa" { type master; file "/etc/namedb/
master/empty.db"; }; zone "23.172.in-addr.arpa" { type master; file "/etc/
namedb/master/empty.db"; }; zone "24.172.in-addr.arpa" { type master; file "/
etc/namedb/master/empty.db"; }; zone "25.172.in-addr.arpa" { type master; file
"/etc/namedb/master/empty.db"; }; zone "26.172.in-addr.arpa" { type master;
file "/etc/namedb/master/empty.db"; }; zone "27.172.in-addr.arpa" { type
master; file "/etc/namedb/master/empty.db"; }; zone "28.172.in-addr.arpa" {
type master; file "/etc/namedb/master/empty.db"; }; zone "29.172.in-addr.arpa"
{ type master; file "/etc/namedb/master/empty.db"; }; zone
"30.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "31.172.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db";
}; zone "168.192.in-addr.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; // Link-local/APIPA (RFCs 3927 and 5735) zone
"254.169.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; }; //
IETF protocol assignments (RFCs 5735 and 5736) zone "0.0.192.in-addr.arpa" {
type master; file "/etc/namedb/master/empty.db"; }; // TEST-NET-[1-3] for
Documentation (RFCs 5735 and 5737) zone "2.0.192.in-addr.arpa" { type master;
file "/etc/namedb/master/empty.db"; }; zone "100.51.198.in-addr.arpa" { type
master; file "/etc/namedb/master/empty.db"; }; zone "113.0.203.in-addr.arpa" {
type master; file "/etc/namedb/master/empty.db"; }; // IPv6 Range for
Documentation (RFC 3849) zone "8.b.d.0.1.0.0.2.ip6.arpa" { type master; file "/
etc/namedb/master/empty.db"; }; // Domain Names for Documentation and Testing
(BCP 32) zone "test" { type master; file "/etc/namedb/master/empty.db"; }; zone
"example" { type master; file "/etc/namedb/master/empty.db"; }; zone "invalid"
{ type master; file "/etc/namedb/master/empty.db"; }; zone "example.com" { type
master; file "/etc/namedb/master/empty.db"; }; zone "example.net" { type
master; file "/etc/namedb/master/empty.db"; }; zone "example.org" { type
master; file "/etc/namedb/master/empty.db"; }; // Router Benchmark Testing
(RFCs 2544 and 5735) zone "18.198.in-addr.arpa" { type master; file "/etc/
namedb/master/empty.db"; }; zone "19.198.in-addr.arpa" { type master; file "/
etc/namedb/master/empty.db"; }; // IANA Reserved - Old Class E Space (RFC 5735)
zone "240.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "241.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "242.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "243.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "244.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "245.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "246.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "247.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "248.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "249.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "250.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "251.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "252.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "253.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; };
zone "254.in-addr.arpa" { type master; file "/etc/namedb/master/empty.db"; }; /
/ IPv6 Unassigned Addresses (RFC 4291) zone "1.ip6.arpa" { type master; file "/
etc/namedb/master/empty.db"; }; zone "3.ip6.arpa" { type master; file "/etc/
namedb/master/empty.db"; }; zone "4.ip6.arpa" { type master; file "/etc/namedb/
master/empty.db"; }; zone "5.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "6.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "7.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "8.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "9.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "a.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "b.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "c.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "d.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "e.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "0.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "1.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "2.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "3.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "4.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "5.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "6.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "7.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "8.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "9.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "a.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "b.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "0.e.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "1.e.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "2.e.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "3.e.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "4.e.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "5.e.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "6.e.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; zone "7.e.f.ip6.arpa" { type master; file "/etc/namedb/master/
empty.db"; }; // IPv6 ULA (RFC 4193) zone "c.f.ip6.arpa" { type master; file "/
etc/namedb/master/empty.db"; }; zone "d.f.ip6.arpa" { type master; file "/etc/
namedb/master/empty.db"; }; // IPv6 Link Local (RFC 4291) zone "8.e.f.ip6.arpa"
{ type master; file "/etc/namedb/master/empty.db"; }; zone "9.e.f.ip6.arpa" {
type master; file "/etc/namedb/master/empty.db"; }; zone "a.e.f.ip6.arpa" {
type master; file "/etc/namedb/master/empty.db"; }; zone "b.e.f.ip6.arpa" {
type master; file "/etc/namedb/master/empty.db"; }; // IPv6 Deprecated
Site-Local Addresses (RFC 3879) zone "c.e.f.ip6.arpa" { type master; file "/etc
/namedb/master/empty.db"; }; zone "d.e.f.ip6.arpa" { type master; file "/etc/
namedb/master/empty.db"; }; zone "e.e.f.ip6.arpa" { type master; file "/etc/
namedb/master/empty.db"; }; zone "f.e.f.ip6.arpa" { type master; file "/etc/
namedb/master/empty.db"; }; // IP6.INT is Deprecated (RFC 4159) zone "ip6.int"
{ type master; file "/etc/namedb/master/empty.db"; }; // NB: Do not use the IP
addresses below, they are faked, and only // serve demonstration/documentation
purposes! // // Example slave zone config entries. It can be convenient to
become // a slave at least for the zone your own domain is in. Ask // your
network administrator for the IP address of the responsible // master name
server. // // Do not forget to include the reverse lookup zone! // This is
named after the first bytes of the IP address, in reverse // order, with
".IN-ADDR.ARPA" appended, or ".IP6.ARPA" for IPv6. // // Before starting to set
up a master zone, make sure you fully // understand how DNS and BIND work.
There are sometimes // non-obvious pitfalls. Setting up a slave zone is usually
simpler. // // NB: Don't blindly enable the examples below. :-) Use actual
names // and addresses instead. /* An example dynamic zone key "exampleorgkey"
{ algorithm hmac-md5; secret "sf87HJqjkqh8ac87a02lla=="; }; zone "example.org"
{ type master; allow-update { key "exampleorgkey"; }; file "/etc/namedb/dynamic
/example.org"; }; */ /* Example of a slave reverse zone zone
"1.168.192.in-addr.arpa" { type slave; file "/etc/namedb/slave/
1.168.192.in-addr.arpa"; masters { 192.168.1.1; }; }; */

In named.conf, these are examples of slave entries for a forward and reverse
zone.

For each new zone served, a new zone entry must be added to named.conf.

For example, the simplest zone entry for example.org can look like:

zone "example.org" { type master; file "master/example.org"; };

The zone is a master, as indicated by the type statement, holding its zone
information in /etc/namedb/master/example.org indicated by the file statement.

zone "example.org" { type slave; file "slave/example.org"; };

In the slave case, the zone information is transferred from the master name
server for the particular zone, and saved in the file specified. If and when
the master server dies or is unreachable, the slave name server will have the
transferred zone information and will be able to serve it.

30.6.6.2.Â Zone Files

An example master zone file for example.org (existing within /etc/namedb/master
/example.org) is as follows:

$TTL 3600 ; 1 hour default TTL example.org. IN SOA ns1.example.org.
admin.example.org. ( 2006051501 ; Serial 10800 ; Refresh 3600 ; Retry 604800 ;
Expire 300 ; Negative Response TTL ) ; DNS Servers IN NS ns1.example.org. IN NS
ns2.example.org. ; MX Records IN MX 10 mx.example.org. IN MX 20
mail.example.org. IN A 192.168.1.1 ; Machine Names localhost IN A 127.0.0.1 ns1
IN A 192.168.1.2 ns2 IN A 192.168.1.3 mx IN A 192.168.1.4 mail IN A 192.168.1.5
; Aliases www IN CNAME example.org.

Note that every hostname ending in a â  .â   is an exact hostname, whereas
everything without a trailing â  .â   is relative to the origin. For example,
ns1 is translated into ns1.example.org.

The format of a zone file follows:

recordname IN recordtype value

The most commonly used DNS records:

SOA

    start of zone authority

NS

    an authoritative name server

A

    a host address

CNAME

    the canonical name for an alias

MX

    mail exchanger

PTR

    a domain name pointer (used in reverse DNS)

example.org. IN SOA ns1.example.org. admin.example.org. ( 2006051501 ; Serial
10800 ; Refresh after 3 hours 3600 ; Retry after 1 hour 604800 ; Expire after 1
week 300 ) ; Negative Response TTL

example.org.

    the domain name, also the origin for this zone file.

ns1.example.org.

    the primary/authoritative name server for this zone.

admin.example.org.

    the responsible person for this zone, email address with â  @â   replaced.
    (&lt;admin@example.org&gt; becomes admin.example.org)

2006051501

    the serial number of the file. This must be incremented each time the zone
    file is modified. Nowadays, many admins prefer a yyyymmddrr format for the
    serial number. 2006051501 would mean last modified 05/15/2006, the latter
    01 being the first time the zone file has been modified this day. The
    serial number is important as it alerts slave name servers for a zone when
    it is updated.

IN NS ns1.example.org.

This is an NS entry. Every name server that is going to reply authoritatively
for the zone must have one of these entries.

localhost IN A 127.0.0.1 ns1 IN A 192.168.1.2 ns2 IN A 192.168.1.3 mx IN A
192.168.1.4 mail IN A 192.168.1.5

The A record indicates machine names. As seen above, ns1.example.org would
resolve to 192.168.1.2.

IN A 192.168.1.1

This line assigns IP address 192.168.1.1 to the current origin, in this case
example.org.

www IN CNAME @

The canonical name record is usually used for giving aliases to a machine. In
the example, www is aliased to the â  masterâ   machine whose name happens to
be the same as the domain name example.org (192.168.1.1). CNAMEs can never be
used together with another kind of record for the same hostname.

IN MX 10 mail.example.org.

The MX record indicates which mail servers are responsible for handling
incoming mail for the zone. mail.example.org is the hostname of a mail server,
and 10 is the priority of that mail server.

One can have several mail servers, with priorities of 10, 20 and so on. A mail
server attempting to deliver to example.org would first try the highest
priority MX (the record with the lowest priority number), then the second
highest, etc, until the mail can be properly delivered.

For in-addr.arpa zone files (reverse DNS), the same format is used, except with
PTR entries instead of A or CNAME.

$TTL 3600 1.168.192.in-addr.arpa. IN SOA ns1.example.org. admin.example.org. (
2006051501 ; Serial 10800 ; Refresh 3600 ; Retry 604800 ; Expire 300 ) ;
Negative Response TTL IN NS ns1.example.org. IN NS ns2.example.org. 1 IN PTR
example.org. 2 IN PTR ns1.example.org. 3 IN PTR ns2.example.org. 4 IN PTR
mx.example.org. 5 IN PTR mail.example.org.

This file gives the proper IP address to hostname mappings for the above
fictitious domain.

It is worth noting that all names on the right side of a PTR record need to be
fully qualified (i.e., end in a â  .â  ).

30.6.7.Â Caching Name Server

A caching name server is a name server whose primary role is to resolve
recursive queries. It simply asks queries of its own, and remembers the answers
for later use.

30.6.8.Â DNSSEC

Domain Name System Security Extensions, or DNSSEC for short, is a suite of
specifications to protect resolving name servers from forged DNS data, such as
spoofed DNS records. By using digital signatures, a resolver can verify the
integrity of the record. Note that DNSSEC only provides integrity via digitally
signing the Resource Records (RRs). It provides neither confidentiality nor
protection against false end-user assumptions. This means that it cannot
protect against people going to example.net instead of example.com. The only
thing DNSSEC does is authenticate that the data has not been compromised in
transit. The security of DNS is an important step in securing the Internet in
general. For more in-depth details of how DNSSEC works, the relevant RFCs are a
good place to start. See the list in SectionÂ 30.6.10, â  Further Readingâ  .

The following sections will demonstrate how to enable DNSSEC for an
authoritative DNS server and a recursive (or caching) DNS server running BIND
9. While all versions of BIND 9 support DNSSEC, it is necessary to have at
least version 9.6.2 in order to be able to use the signed root zone when
validating DNS queries. This is because earlier versions lack the required
algorithms to enable validation using the root zone key. It is strongly
recommended to use the latest version of BIND 9.7 or later to take advantage of
automatic key updating for the root key, as well as other features to
automatically keep zones signed and signatures up to date. Where configurations
differ between 9.6.2 and 9.7 and later, differences will be pointed out.

30.6.8.1.Â Recursive DNS Server Configuration

Enabling DNSSEC validation of queries performed by a recursive DNS server
requires a few changes to named.conf. Before making these changes the root zone
key, or trust anchor, must be acquired. Currently the root zone key is not
available in a file format BIND understands, so it has to be manually converted
into the proper format. The key itself can be obtained by querying the root
zone for it using dig. By running

% dig +multi +noall +answer DNSKEY . &gt; root.dnskey

the key will end up in root.dnskey. The contents should look something like
this:

. 93910 IN DNSKEY 257 3 8 ( AwEAAagAIKlVZrpC6Ia7gEzahOR+9W29euxhJhVVLOyQ
bSEW0O8gcCjFFVQUTf6v58fLjwBd0YI0EzrAcQqBGCzh /
RStIoO8g0NfnfL2MTJRkxoXbfDaUeVPQuYEhg37NZWA JQ9VnMVDxP/VHL496M/QZxkjf5/
Efucp2gaDX6RS6CXp oY68LsvPVjR0ZSwzz1apAzvN9dlzEheX7ICJBBtuA6G3
LQpzW5hOA2hzCTMjJPJ8LbqF6dsV6DoBQzgul0sGIcGO
Yl7OyQdXfZ57relSQageu+ipAdTTJ25AsRTAoub8ONGc
LmqrAmRLKBP1dfwhYB4N7knNnulqQxA+Uk1ihz0= ) ; key id = 19036 . 93910 IN DNSKEY
256 3 8 ( AwEAAcaGQEA+OJmOzfzVfoYN249JId7gx+OZMbxy69Hf
UyuGBbRN0+HuTOpBxxBCkNOL+EJB9qJxt+0FEY6ZUVjE g58sRr4ZQ6Iu6b1xTBKgc193zUARk4mmQ/
PPGxn7Cn5V EGJ/1h6dNaiXuRHwR+7oWh7DnzkIJChcTqlFrXDW3tjt ) ; key id = 34525

Do not be alarmed if the obtained keys differ from this example. They might
have changed since these instructions were last updated. This output actually
contains two keys. The first key in the listing, with the value 257 after the
DNSKEY record type, is the one needed. This value indicates that this is a
Secure Entry Point (SEP), commonly known as a Key Signing Key (KSK). The second
key, with value 256, is a subordinate key, commonly called a Zone Signing Key (
ZSK). More on the different key types later in SectionÂ 30.6.8.2, â  
Authoritative DNS Server Configurationâ  .

Now the key must be verified and formatted so that BIND can use it. To verify
the key, generate a DS RR set. Create a file containing these RRs with

% dnssec-dsfromkey -f root-dnskey . &gt; root.ds

These records use SHA-1 and SHA-256 respectively, and should look similar to
the following example, where the longer is using SHA-256.

. IN DS 19036 8 1 B256BD09DC8DD59F0E0F0D8541B8328DD986DF6E . IN DS 19036 8 2
49AAC11D7B6F6446702E54A1607371607A1A41855200FD2CE1CDDE32F24E8FB5

The SHA-256 RR can now be compared to the digest in https://data.iana.org/
root-anchors/root-anchors.xml. To be absolutely sure that the key has not been
tampered with the data in the XML file can be verified using the PGP signature
in https://data.iana.org/root-anchors/root-anchors.asc.

Next, the key must be formatted properly. This differs a little between BIND
versions 9.6.2 and 9.7 and later. In version 9.7 support was added to
automatically track changes to the key and update it as necessary. This is done
using managed-keys as seen in the example below. When using the older version,
the key is added using a trusted-keys statement and updates must be done
manually. For BIND 9.6.2 the format should look like:

trusted-keys { "." 257 3 8
"AwEAAagAIKlVZrpC6Ia7gEzahOR+9W29euxhJhVVLOyQbSEW0O8gcCjF
FVQUTf6v58fLjwBd0YI0EzrAcQqBGCzh/RStIoO8g0NfnfL2MTJRkxoX
bfDaUeVPQuYEhg37NZWAJQ9VnMVDxP/VHL496M/QZxkjf5/Efucp2gaD
X6RS6CXpoY68LsvPVjR0ZSwzz1apAzvN9dlzEheX7ICJBBtuA6G3LQpz
W5hOA2hzCTMjJPJ8LbqF6dsV6DoBQzgul0sGIcGOYl7OyQdXfZ57relS
Qageu+ipAdTTJ25AsRTAoub8ONGcLmqrAmRLKBP1dfwhYB4N7knNnulq QxA+Uk1ihz0="; };

For 9.7 the format will instead be:

managed-keys { "." initial-key 257 3 8
"AwEAAagAIKlVZrpC6Ia7gEzahOR+9W29euxhJhVVLOyQbSEW0O8gcCjF
FVQUTf6v58fLjwBd0YI0EzrAcQqBGCzh/RStIoO8g0NfnfL2MTJRkxoX
bfDaUeVPQuYEhg37NZWAJQ9VnMVDxP/VHL496M/QZxkjf5/Efucp2gaD
X6RS6CXpoY68LsvPVjR0ZSwzz1apAzvN9dlzEheX7ICJBBtuA6G3LQpz
W5hOA2hzCTMjJPJ8LbqF6dsV6DoBQzgul0sGIcGOYl7OyQdXfZ57relS
Qageu+ipAdTTJ25AsRTAoub8ONGcLmqrAmRLKBP1dfwhYB4N7knNnulq QxA+Uk1ihz0="; };

The root key can now be added to named.conf either directly or by including a
file containing the key. After these steps, configure BIND to do DNSSEC
validation on queries by editing named.conf and adding the following to the
options directive:

dnssec-enable yes; dnssec-validation yes;

To verify that it is actually working use dig to make a query for a signed zone
using the resolver just configured. A successful reply will contain the AD flag
to indicate the data was authenticated. Running a query such as

% dig @resolver +dnssec se ds

should return the DS RR for the .se zone. In the flags: section the AD flag
should be set, as seen in:

... ;; flags: qr rd ra ad; QUERY: 1, ANSWER: 3, AUTHORITY: 0, ADDITIONAL: 1 ...

The resolver is now capable of authenticating DNS queries.

30.6.8.2.Â Authoritative DNS Server Configuration

In order to get an authoritative name server to serve a DNSSEC signed zone a
little more work is required. A zone is signed using cryptographic keys which
must be generated. It is possible to use only one key for this. The preferred
method however is to have a strong well-protected Key Signing Key (KSK) that is
not rotated very often and a Zone Signing Key (ZSK) that is rotated more
frequently. Information on recommended operational practices can be found in
RFC 4641: DNSSEC Operational Practices. Practices regarding the root zone can
be found in DNSSEC Practice Statement for the Root Zone KSK operator and DNSSEC
Practice Statement for the Root Zone ZSK operator. The KSK is used to build a
chain of authority to the data in need of validation and as such is also called
a Secure Entry Point (SEP) key. A message digest of this key, called a
Delegation Signer (DS) record, must be published in the parent zone to
establish the trust chain. How this is accomplished depends on the parent zone
owner. The ZSK is used to sign the zone, and only needs to be published there.

To enable DNSSEC for the example.com zone depicted in previous examples, the
first step is to use dnssec-keygen to generate the KSK and ZSK key pair. This
key pair can utilize different cryptographic algorithms. It is recommended to
use RSA/SHA256 for the keys and 2048 bits key length should be enough. To
generate the KSK for example.com, run

% dnssec-keygen -f KSK -a RSASHA256 -b 2048 -n ZONE example.com

and to generate the ZSK, run

% dnssec-keygen -a RSASHA256 -b 2048 -n ZONE example.com

dnssec-keygen outputs two files, the public and the private keys in files named
similar to Kexample.com.+005+nnnnn.key (public) and
Kexample.com.+005+nnnnn.private (private). The nnnnn part of the file name is a
five digit key ID. Keep track of which key ID belongs to which key. This is
especially important when having more than one key in a zone. It is also
possible to rename the keys. For each KSK file do:

% mv Kexample.com.+005+nnnnn.key Kexample.com.+005+nnnnn.KSK.key % mv
Kexample.com.+005+nnnnn.private Kexample.com.+005+nnnnn.KSK.private

For the ZSK files, substitute KSK for ZSK as necessary. The files can now be
included in the zone file, using the $include statement. It should look
something like this:

$include Kexample.com.+005+nnnnn.KSK.key ; KSK $include
Kexample.com.+005+nnnnn.ZSK.key ; ZSK

Finally, sign the zone and tell BIND to use the signed zone file. To sign a
zone dnssec-signzone is used. The command to sign the zone example.com, located
in example.com.db would look similar to

% dnssec-signzone -o example.com -k Kexample.com.+005+nnnnn.KSK example.com.db
Kexample.com.+005+nnnnn.ZSK.key

The key supplied to the -k argument is the KSK and the other key file is the 
ZSK that should be used in the signing. It is possible to supply more than one 
KSK and ZSK, which will result in the zone being signed with all supplied keys.
This can be needed to supply zone data signed using more than one algorithm.
The output of dnssec-signzone is a zone file with all RRs signed. This output
will end up in a file with the extension .signed, such as
example.com.db.signed. The DS records will also be written to a separate file
dsset-example.com. To use this signed zone just modify the zone directive in
named.conf to use example.com.db.signed. By default, the signatures are only
valid 30 days, meaning that the zone needs to be resigned in about 15 days to
be sure that resolvers are not caching records with stale signatures. It is
possible to make a script and a cron job to do this. See relevant manuals for
details.

Be sure to keep private keys confidential, as with all cryptographic keys. When
changing a key it is best to include the new key into the zone, while still
signing with the old one, and then move over to using the new key to sign.
After these steps are done the old key can be removed from the zone. Failure to
do this might render the DNS data unavailable for a time, until the new key has
propagated through the DNS hierarchy. For more information on key rollovers and
other DNSSEC operational issues, see RFC 4641: DNSSEC Operational practices.

30.6.8.3.Â Automation Using BIND 9.7 or Later

Beginning with BIND version 9.7 a new feature called Smart Signing was
introduced. This feature aims to make the key management and signing process
simpler by automating parts of the task. By putting the keys into a directory
called a key repository, and using the new option auto-dnssec, it is possible
to create a dynamic zone which will be resigned as needed. To update this zone
use nsupdate with the new option -l. rndc has also grown the ability to sign
zones with keys in the key repository, using the option sign. To tell BIND to
use this automatic signing and zone updating for example.com, add the following
to named.conf:

zone example.com { type master; key-directory "/etc/named/keys"; update-policy
local; auto-dnssec maintain; file "/etc/named/dynamic/example.com.zone"; };

After making these changes, generate keys for the zone as explained in
SectionÂ 30.6.8.2, â  Authoritative DNS Server Configurationâ  , put those keys
in the key repository given as the argument to the key-directory in the zone
configuration and the zone will be signed automatically. Updates to a zone
configured this way must be done using nsupdate, which will take care of
re-signing the zone with the new data added. For further details, see
SectionÂ 30.6.10, â  Further Readingâ   and the BIND documentation.

30.6.9.Â Security

Although BIND is the most common implementation of DNS, there is always the
issue of security. Possible and exploitable security holes are sometimes found.

While FreeBSD automatically drops named into a chroot(8) environment; there are
several other security mechanisms in place which could help to lure off
possible DNS service attacks.

It is always good idea to read CERT's security advisories and to subscribe to
the FreeBSD security notifications mailing list to stay up to date with the
current Internet and FreeBSD security issues.

Tip:

If a problem arises, keeping sources up to date and having a fresh build of 
named may help.

30.6.10.Â Further Reading

BIND/named manual pages: rndc(8) named(8) named.conf(5) nsupdate(1)
dnssec-signzone(8) dnssec-keygen(8)

  * Official ISC BIND Page

  * Official ISC BIND Forum

  * O'Reilly DNS and BIND 5th Edition

  * Root DNSSEC

  * DNSSEC Trust Anchor Publication for the Root Zone

  * RFC1034 - Domain Names - Concepts and Facilities

  * RFC1035 - Domain Names - Implementation and Specification

  * RFC4033 - DNS Security Introduction and Requirements

  * RFC4034 - Resource Records for the DNS Security Extensions

  * RFC4035 - Protocol Modifications for the DNS Security Extensions

  * RFC4641 - DNSSEC Operational Practices

  * RFC 5011 - Automated Updates of DNS Security (DNSSEC Trust Anchors

30.7.Â Apache HTTP Server

Contributed by Murray Stokely.

30.7.1.Â Overview

FreeBSD is used to run some of the busiest web sites in the world. The majority
of web servers on the Internet are using the Apache HTTP Server. Apache
software packages should be included on your FreeBSD installation media. If you
did not install Apache when you first installed FreeBSD, then you can install
it from the www/apache22 port.

Once Apache has been installed successfully, it must be configured.

Note:

This section covers version 2.2.X of the Apache HTTP Server as that is the most
widely used version for FreeBSD. For more detailed information beyond the scope
of this document about ApacheÂ 2.X, please see http://httpd.apache.org/.

30.7.2.Â Configuration

The main Apache HTTP Server configuration file is installed as /usr/local/etc/
apache22/httpd.conf on FreeBSD. This file is a typical UNIXÂ® text
configuration file with comment lines beginning with the # character. A
comprehensive description of all possible configuration options is outside the
scope of this book, so only the most frequently modified directives will be
described here.

ServerRoot "/usr/local"

    This specifies the default directory hierarchy for the Apache installation.
    Binaries are stored in the bin and sbin subdirectories of the server root,
    and configuration files are stored in etc/apache.

ServerAdmin you@your.address

    The address to which problems with the server should be emailed. This
    address appears on some server-generated pages, such as error documents.

ServerName www.example.com

    ServerName allows you to set a host name which is sent back to clients for
    your server if it is different than the one that the host is configured
    with (i.e., use www instead of the host's real name).

DocumentRoot "/usr/local/www/apache22/data"

    DocumentRoot: The directory out of which you will serve your documents. By
    default, all requests are taken from this directory, but symbolic links and
    aliases may be used to point to other locations.

It is always a good idea to make backup copies of your Apache configuration
file before making changes. Once you are satisfied with your initial
configuration you are ready to start running Apache.

30.7.3.Â Running Apache

The www/apache22 port installs an rc(8) script to aid in starting, stopping,
and restarting Apache, which can be found in /usr/local/etc/rc.d/.

To launch Apache at system startup, add the following line to /etc/rc.conf:

apache22_enable="YES"

If Apache should be started with non-default options, the following line may be
added to /etc/rc.conf:

apache22_flags=""

The Apache configuration can be tested for errors before starting the httpd
daemon for the first time, or after making subsequent configuration changes
while httpd is running. This can be done by the rc(8) script directly, or by
the service(8) utility by issuing one of the following commands:

# service apache22 configtest

Note:

It is important to note that the configtest is not an rc(8) standard, and
should not be expected to work for all rc(8) startup scripts.

If Apache does not report configuration errors, the ApacheÂ httpd can be
started with service(8):

# service apache22 start

The httpd service can be tested by entering http://localhost in a web browser,
replacing localhost with the fully-qualified domain name of the machine running
httpd, if it is not the local machine. The default web page that is displayed
is /usr/local/www/apache22/data/index.html.

30.7.4.Â Virtual Hosting

Apache supports two different types of Virtual Hosting. The first method is
Name-based Virtual Hosting. Name-based virtual hosting uses the clients HTTP/
1.1 headers to figure out the hostname. This allows many different domains to
share the same IP address.

To setup Apache to use Name-based Virtual Hosting add an entry like the
following to your httpd.conf:

NameVirtualHost *

If your webserver was named www.domain.tld and you wanted to setup a virtual
domain for www.someotherdomain.tld then you would add the following entries to
httpd.conf:

&lt;VirtualHost *&gt; ServerName www.domain.tld DocumentRoot /www/domain.tld &lt;/
VirtualHost&gt; &lt;VirtualHost *&gt; ServerName www.someotherdomain.tld DocumentRoot /
www/someotherdomain.tld &lt;/VirtualHost&gt;

Replace the addresses with the addresses you want to use and the path to the
documents with what you are using.

For more information about setting up virtual hosts, please consult the
official Apache documentation at: http://httpd.apache.org/docs/vhosts/.

30.7.5.Â Apache Modules

There are many different Apache modules available to add functionality to the
basic server. The FreeBSD Ports Collection provides an easy way to install 
Apache together with some of the more popular add-on modules.

30.7.5.1.Â mod_ssl

The mod_ssl module uses the OpenSSL library to provide strong cryptography via
the Secure Sockets Layer (SSL v2/v3) and Transport Layer Security (TLS v1)
protocols. This module provides everything necessary to request a signed
certificate from a trusted certificate signing authority so that you can run a
secure web server on FreeBSD.

The mod_ssl module is built by default, but can be enabled by specifying
-DWITH_SSL at compile time.

30.7.5.2.Â Language Bindings

There are Apache modules for most major scripting languages. These modules
typically make it possible to write Apache modules entirely in a scripting
language. They are also often used as a persistent interpreter embedded into
the server that avoids the overhead of starting an external interpreter and the
startup-time penalty for dynamic websites, as described in the next section.

30.7.6.Â Dynamic Websites

In the last decade, more businesses have turned to the Internet in order to
enhance their revenue and increase exposure. This has also increased the need
for interactive web content. While some companies, such as MicrosoftÂ®, have
introduced solutions into their proprietary products, the open source community
answered the call. Modern options for dynamic web content include Django, Ruby
on Rails, mod_perl2, and mod_php.

30.7.6.1.Â Django

Django is a BSD licensed framework designed to allow developers to write high
performance, elegant web applications quickly. It provides an object-relational
mapper so that data types are developed as Python objects, and a rich dynamic
database-access API is provided for those objects without the developer ever
having to write SQL. It also provides an extensible template system so that the
logic of the application is separated from the HTML presentation.

Django depends on mod_python, Apache, and an SQL database engine of your
choice. The FreeBSD Port will install all of these pre-requisites for you with
the appropriate flags.

ExampleÂ 30.3.Â Installing Django with Apache2, mod_python3, and PostgreSQL
# cd /usr/ports/www/py-django; make all install clean -DWITH_MOD_PYTHON3
-DWITH_POSTGRESQL


Once Django and these pre-requisites are installed, you will need to create a
Django project directory and then configure Apache to use the embedded Python
interpreter to call your application for specific URLs on your site.

ExampleÂ 30.4.Â Apache Configuration for Django/mod_python

You will need to add a line to the apache httpd.conf file to configure Apache
to pass requests for certain URLs to your web application:

&lt;Location "/"&gt; SetHandler python-program PythonPath "['/dir/to/your/django/
packages/'] + sys.path" PythonHandler django.core.handlers.modpython SetEnv
DJANGO_SETTINGS_MODULE mysite.settings PythonAutoReload On PythonDebug On &lt;/
Location&gt;


30.7.6.2.Â Ruby on Rails

Ruby on Rails is another open source web framework that provides a full
development stack and is optimized to make web developers more productive and
capable of writing powerful applications quickly. It can be installed easily
from the ports system.

# cd /usr/ports/www/rubygem-rails; make all install clean

30.7.6.3.Â mod_perl2

The Apache/Perl integration project brings together the full power of the Perl
programming language and the Apache HTTP Server. With the mod_perl2 module it
is possible to write Apache modules entirely in Perl. In addition, the
persistent interpreter embedded in the server avoids the overhead of starting
an external interpreter and the penalty of Perl start-up time.

mod_perl2 is available in the www/mod_perl2 port.

30.7.6.4.Â mod_php

Written by Tom Rhodes.

PHP, also known as â  PHP: Hypertext Preprocessorâ   is a general-purpose
scripting language that is especially suited for Web development. Capable of
being embedded into HTML its syntax draws upon C, Javaâ ¢, and Perl with the
intention of allowing web developers to write dynamically generated webpages
quickly.

To gain support for PHP5 for the Apache web server, begin by installing the
lang/php5 port.

If the lang/php5 port is being installed for the first time, available OPTIONS
will be displayed automatically. If a menu is not displayed, i.e., because the
lang/php5 port has been installed some time in the past, it is always possible
to bring the options dialog up again by running:

# make config

in the port directory.

In the options dialog, check the APACHE option to build mod_php5 as a loadable
module for the Apache web server.

Note:

A lot of sites are still using PHP4 for various reasons (i.e., compatibility
issues or already deployed web applications). If the mod_php4 is needed instead
of mod_php5, then please use the lang/php4 port. The lang/php4 port supports
many of the configuration and build-time options of the lang/php5 port.

This will install and configure the modules required to support dynamic PHP
applications. Check to ensure the following sections have been added to /usr/
local/etc/apache22/httpd.conf:

LoadModule php5_module libexec/apache/libphp5.so
AddModule mod_php5.c &lt;IfModule mod_php5.c&gt; DirectoryIndex index.php index.html
&lt;/IfModule&gt; &lt;IfModule mod_php5.c&gt; AddType application/x-httpd-php .php AddType
application/x-httpd-php-source .phps &lt;/IfModule&gt;

Once completed, a simple call to the apachectl command for a graceful restart
is needed to load the PHP module:

# apachectl graceful

For future upgrades of PHP, the make config command will not be required; the
selected OPTIONS are saved automatically by the FreeBSD Ports framework.

The PHP support in FreeBSD is extremely modular so the base install is very
limited. It is very easy to add support using the lang/php5-extensions port.
This port provides a menu driven interface to PHP extension installation.
Alternatively, individual extensions can be installed using the appropriate
port.

For instance, to add support for the MySQL database server to PHP5, simply
install the port databases/php5-mysql.

After installing an extension, the Apache server must be reloaded to pick up
the new configuration changes:

# apachectl graceful

30.8.Â File Transfer Protocol (FTP)

Contributed by Murray Stokely.

30.8.1.Â Overview

The File Transfer Protocol (FTP) provides users with a simple way to transfer
files to and from an FTP server. FreeBSD includes FTP server software, ftpd, in
the base system. This makes setting up and administering an FTP server on
FreeBSD very straightforward.

30.8.2.Â Configuration

The most important configuration step is deciding which accounts will be
allowed access to the FTP server. A normal FreeBSD system has a number of
system accounts used for various daemons, but unknown users should not be
allowed to log in with these accounts. The /etc/ftpusers file is a list of
users disallowed any FTP access. By default, it includes the aforementioned
system accounts, but it is possible to add specific users here that should not
be allowed access to FTP.

You may want to restrict the access of some users without preventing them
completely from using FTP. This can be accomplished with the /etc/ftpchroot
file. This file lists users and groups subject to FTP access restrictions. The
ftpchroot(5) manual page has all of the details so it will not be described in
detail here.

If you would like to enable anonymous FTP access to your server, then you must
create a user named ftp on your FreeBSD system. Users will then be able to log
on to your FTP server with a username of ftp or anonymous and with any password
(by convention an email address for the user should be used as the password).
The FTP server will call chroot(2) when an anonymous user logs in, to restrict
access to only the home directory of the ftp user.

There are two text files that specify welcome messages to be displayed to FTP
clients. The contents of the file /etc/ftpwelcome will be displayed to users
before they reach the login prompt. After a successful login, the contents of
the file /etc/ftpmotd will be displayed. Note that the path to this file is
relative to the login environment, so the file ~ftp/etc/ftpmotd would be
displayed for anonymous users.

Once the FTP server has been configured properly, it must be enabled in /etc/
inetd.conf. All that is required here is to remove the comment symbol â  #â  
from in front of the existing ftpd line :

ftp stream tcp nowait root /usr/libexec/ftpd ftpd -l

As explained in ExampleÂ 30.1, â  Reloading the inetd Configuration Fileâ  ,
the inetd configuration must be reloaded after this configuration file is
changed. Please refer to SectionÂ 30.2.2, â  Settingsâ   for details on
enabling inetd on your system.

Alternatively, ftpd can also be started as a stand-alone server. In this case,
it is sufficient to set the appropriate variable in /etc/rc.conf:

ftpd_enable="YES"

After setting the above variable, the stand-alone server will be started at the
next reboot, or it can be started manually by executing the following command
as root:

# service ftpd start

You can now log on to your FTP server by typing:

% ftp localhost

30.8.3.Â Maintaining

The ftpd daemon uses syslog(3) to log messages. By default, the system log
daemon will put messages related to FTP in the /var/log/xferlog file. The
location of the FTP log can be modified by changing the following line in /etc/
syslog.conf:

ftp.info /var/log/xferlog

Be aware of the potential problems involved with running an anonymous FTP
server. In particular, you should think twice about allowing anonymous users to
upload files. You may find that your FTP site becomes a forum for the trade of
unlicensed commercial software or worse. If you do need to allow anonymous FTP
uploads, then you should set up the permissions so that these files can not be
read by other anonymous users until they have been reviewed.

30.9.Â File and Print Services for MicrosoftÂ®Â WindowsÂ® Clients (Samba)

Contributed by Murray Stokely.

30.9.1.Â Overview

Samba is a popular open source software package that provides file and print
services for MicrosoftÂ®Â WindowsÂ® clients. Such clients can connect to and
use FreeBSD filespace as if it was a local disk drive, or FreeBSD printers as
if they were local printers.

Samba software packages should be included on your FreeBSD installation media.
If you did not install Samba when you first installed FreeBSD, then you can
install it from the net/samba34 port or package.

30.9.2.Â Configuration

A default Samba configuration file is installed as /usr/local/share/examples/
samba34/smb.conf.default. This file must be copied to /usr/local/etc/smb.conf
and customized before Samba can be used.

The smb.conf file contains runtime configuration information for Samba, such as
definitions of the printers and â  file system sharesâ   that you would like to
share with WindowsÂ® clients. The Samba package includes a web based tool
called swat which provides a simple way of configuring the smb.conf file.

30.9.2.1.Â Using the Samba Web Administration Tool (SWAT)

The Samba Web Administration Tool (SWAT) runs as a daemon from inetd.
Therefore, inetd must be enabled as shown in SectionÂ 30.2, â  The inetd â  
Super-Serverâ  â  , and the following line in /etc/inetd.conf should be
uncommented before swat can be used to configure Samba:

swat stream tcp nowait/400 root /usr/local/sbin/swat swat

As explained in ExampleÂ 30.1, â  Reloading the inetd Configuration Fileâ  ,
the inetd configuration must be reloaded after this configuration file is
changed.

Once swat has been enabled in inetd.conf, you can use a browser to connect to
http://localhost:901. You will first have to log on with the system root
account.

Once you have successfully logged on to the main Samba configuration page, you
can browse the system documentation, or begin by clicking on the Globals tab.
The Globals section corresponds to the variables that are set in the [global]
section of /usr/local/etc/smb.conf.

30.9.2.2.Â Global Settings

Whether you are using swat or editing /usr/local/etc/smb.conf directly, the
first directives you are likely to encounter when configuring Samba are:

workgroup

    NT Domain-Name or Workgroup-Name for the computers that will be accessing
    this server.

netbios name

    This sets the NetBIOS name by which a Samba server is known. By default it
    is the same as the first component of the host's DNS name.

server string

    This sets the string that will be displayed with the net view command and
    some other networking tools that seek to display descriptive text about the
    server.

30.9.2.3.Â Security Settings

Two of the most important settings in /usr/local/etc/smb.conf are the security
model chosen, and the backend password format for client users. The following
directives control these options:

security

    The two most common options here are security = share and security = user.
    If your clients use usernames that are the same as their usernames on your
    FreeBSD machine then you will want to use user level security. This is the
    default security policy and it requires clients to first log on before they
    can access shared resources.

    In share level security, client do not need to log onto the server with a
    valid username and password before attempting to connect to a shared
    resource. This was the default security model for older versions of Samba.

passdb backend
   
    Samba has several different backend authentication models. You can
    authenticate clients with LDAP, NIS+, a SQL database, or a modified
    password file. The default authentication method is smbpasswd, and that is
    all that will be covered here.

Assuming that the default smbpasswd backend is used, the /usr/local/etc/samba/
smbpasswd file must be created to allow Samba to authenticate clients. If you
would like to give your UNIXÂ® user accounts access from WindowsÂ® clients, use
the following command:

# smbpasswd -a username

Note:

The recommended backend is now tdbsam, and the following command should be used
to add user accounts:

# pdbedit -a -u username

Please see the Official Samba HOWTO for additional information about
configuration options. With the basics outlined here, you should have
everything you need to start running Samba.

30.9.3.Â Starting Samba

The net/samba34 port adds a new startup script, which can be used to control 
Samba. To enable this script, so that it can be used for example to start, stop
or restart Samba, add the following line to the /etc/rc.conf file:

samba_enable="YES"

Or, for fine grain control:

nmbd_enable="YES"
smbd_enable="YES"

Note:

This will also configure Samba to automatically start at system boot time.

It is possible then to start Samba at any time by typing:

# service samba start Starting SAMBA: removing stale tdbs : Starting nmbd.
Starting smbd.

Please refer to SectionÂ 12.7, â  Using rc(8) Under FreeBSDâ   for more
information about using rc scripts.

Samba actually consists of three separate daemons. You should see that both the
nmbd and smbd daemons are started by the samba script. If you enabled winbind
name resolution services in smb.conf, then you will also see that the winbindd
daemon is started.

You can stop Samba at any time by typing :

# service samba stop

Samba is a complex software suite with functionality that allows broad
integration with MicrosoftÂ®Â WindowsÂ® networks. For more information about
functionality beyond the basic installation described here, please see http://
www.samba.org.

30.10.Â Clock Synchronization with NTP

Contributed by Tom Hukins.

30.10.1.Â Overview

Over time, a computer's clock is prone to drift. The Network Time Protocol
(NTP) is one way to ensure your clock stays accurate.

Many Internet services rely on, or greatly benefit from, computers' clocks
being accurate. For example, a web server may receive requests to send a file
if it has been modified since a certain time. In a local area network
environment, it is essential that computers sharing files from the same file
server have synchronized clocks so that file timestamps stay consistent.
Services such as cron(8) also rely on an accurate system clock to run commands
at the specified times.

FreeBSD ships with the ntpd(8) NTP server which can be used to query other NTP
servers to set the clock on your machine or provide time services to others.

30.10.2.Â Choosing Appropriate NTP Servers

In order to synchronize your clock, you will need to find one or more NTP
servers to use. Your network administrator or ISP may have set up an NTP server
for this purposeâ  check their documentation to see if this is the case. There
is an online list of publicly accessible NTP servers which you can use to find
an NTP server near to you. Make sure you are aware of the policy for any
servers you choose, and ask for permission if required.

Choosing several unconnected NTP servers is a good idea in case one of the
servers you are using becomes unreachable or its clock is unreliable. ntpd(8)
uses the responses it receives from other servers intelligentlyâ  it will favor
unreliable servers less than reliable ones.

30.10.3.Â Configuring Your Machine

30.10.3.1.Â Basic Configuration

If you only wish to synchronize your clock when the machine boots up, you can
use ntpdate(8). This may be appropriate for some desktop machines which are
frequently rebooted and only require infrequent synchronization, but most
machines should run ntpd(8).

Using ntpdate(8) at boot time is also a good idea for machines that run ntpd(8)
. The ntpd(8) program changes the clock gradually, whereas ntpdate(8) sets the
clock, no matter how great the difference between a machine's current clock
setting and the correct time.

To enable ntpdate(8) at boot time, add ntpdate_enable="YES" to /etc/rc.conf.
You will also need to specify all servers you wish to synchronize with and any
flags to be passed to ntpdate(8) in ntpdate_flags.

30.10.3.2.Â General Configuration

NTP is configured by the /etc/ntp.conf file in the format described in ntp.conf
(5). Here is a simple example:

server ntplocal.example.com prefer server timeserver.example.org server
ntp2a.example.net driftfile /var/db/ntp.drift

The server option specifies which servers are to be used, with one server
listed on each line. If a server is specified with the prefer argument, as with
ntplocal.example.com, that server is preferred over other servers. A response
from a preferred server will be discarded if it differs significantly from
other servers' responses, otherwise it will be used without any consideration
to other responses. The prefer argument is normally used for NTP servers that
are known to be highly accurate, such as those with special time monitoring
hardware.

The driftfile option specifies which file is used to store the system clock's
frequency offset. The ntpd(8) program uses this to automatically compensate for
the clock's natural drift, allowing it to maintain a reasonably correct setting
even if it is cut off from all external time sources for a period of time.

The driftfile option specifies which file is used to store information about
previous responses from the NTP servers you are using. This file contains
internal information for NTP. It should not be modified by any other process.

30.10.3.3.Â Controlling Access to Your Server

By default, your NTP server will be accessible to all hosts on the Internet.
The restrict option in /etc/ntp.conf allows you to control which machines can
access your server.

If you want to deny all machines from accessing your NTP server, add the
following line to /etc/ntp.conf:

restrict default ignore

Note:

This will also prevent access from your server to any servers listed in your
local configuration. If you need to synchronise your NTP server with an
external NTP server you should allow the specific server. See the ntp.conf(5)
manual for more information.

If you only want to allow machines within your own network to synchronize their
clocks with your server, but ensure they are not allowed to configure the
server or used as peers to synchronize against, add

restrict 192.168.1.0 mask 255.255.255.0 nomodify notrap

instead, where 192.168.1.0 is an IP address on your network and 255.255.255.0
is your network's netmask.

/etc/ntp.conf can contain multiple restrict options. For more details, see the
Access Control Support subsection of ntp.conf(5).

30.10.4.Â Running the NTP Server

To ensure the NTP server is started at boot time, add the line ntpd_enable=
"YES" to /etc/rc.conf. If you wish to pass additional flags to ntpd(8), edit
the ntpd_flags parameter in /etc/rc.conf.

To start the server without rebooting your machine, run ntpd being sure to
specify any additional parameters from ntpd_flags in /etc/rc.conf. For example:

# ntpd -p /var/run/ntpd.pid

30.10.5.Â Using ntpd with a Temporary Internet Connection

The ntpd(8) program does not need a permanent connection to the Internet to
function properly. However, if you have a temporary connection that is
configured to dial out on demand, it is a good idea to prevent NTP traffic from
triggering a dial out or keeping the connection alive. If you are using user
PPP, you can use filter directives in /etc/ppp/ppp.conf. For example:

set filter dial 0 deny udp src eq 123 # Prevent NTP traffic from initiating
dial out set filter dial 1 permit 0 0 set filter alive 0 deny udp src eq 123 #
Prevent incoming NTP traffic from keeping the connection open set filter alive
1 deny udp dst eq 123 # Prevent outgoing NTP traffic from keeping the
connection open set filter alive 2 permit 0/0 0/0

For more details see the PACKET FILTERING section in ppp(8) and the examples in
/usr/share/examples/ppp/.

Note:

Some Internet access providers block low-numbered ports, preventing NTP from
functioning since replies never reach your machine.

30.10.6.Â Further Information

Documentation for the NTP server can be found in /usr/share/doc/ntp/ in HTML
format.

30.11.Â Remote Host Logging with syslogd

Contributed by Tom Rhodes.

Interacting with system logs is a crucial aspect of both security and system
administration. Monitoring the log files of multiple hosts can get very
unwieldy when these hosts are distributed across medium or large networks, or
when they are parts of various different types of networks. In these cases,
configuring remote logging may make the whole process a lot more comfortable.

Centralized logging to a specific logging host can reduce some of the
administrative burden of log file administration. Log file aggregation, merging
and rotation can be configured in one location, using the native tools of
FreeBSD, such as syslogd(8) and newsyslog(8). In the following example
configuration, host A, named logserv.example.com, will collect logging
information for the local network. Host B, named logclient.example.com will
pass logging information to the server system. In live configurations, both
hosts require proper forward and reverse DNS or entries in /etc/hosts.
Otherwise, data will be rejected by the server.

30.11.1.Â Log Server Configuration

Log servers are machines configured to accept logging information from remote
hosts. In most cases this is to ease configuration, in other cases it may just
be a better administration move. Regardless of reason, there are a few
requirements before continuing.

A properly configured logging server has met the following minimal
requirements:

  * The firewall ruleset allows for UDP to be passed on port 514 on both the
    client and server;

  * syslogd has been configured to accept remote messages from client machines;

  * The syslogd server and all client machines must have valid entries for both
    forward and reverse DNS, or be properly configured in /etc/hosts.

To configure the log server, the client must be listed in /etc/syslog.conf, and
the logging facility must be specified:

+logclient.example.com *.* /var/log/logclient.log

Note:

More information on various supported and available facilities may be found in
the syslog.conf(5) manual page.

Once added, all facility messages will be logged to the file specified
previously, /var/log/logclient.log.

The server machine must also have the following listing placed inside /etc/
rc.conf:

syslogd_enable="YES" syslogd_flags="-a logclient.example.com -v -v"

The first option will enable the syslogd daemon on boot up, and the second
option allows data from the specified client to be accepted on this server. The
latter part, using -v -v, will increase the verbosity of logged messages. This
is extremely useful for tweaking facilities as administrators are able to see
what type of messages are being logged under which facility.

Multiple -a options may be specified to allow logging from multiple clients. IP
addresses and whole netblocks may also be specified, see the syslog(3) manual
page for a full list of possible options.

Finally, the log file should be created. The method used does not matter, but
touch(1) works great for situations such as this:

# touch /var/log/logclient.log

At this point, the syslogd daemon should be restarted and verified:

# service syslogd restart # pgrep syslog

If a PID is returned, the server has been restarted successfully, and client
configuration may begin. If the server has not restarted, consult the /var/log/
messages log for any output.

30.11.2.Â Log Client Configuration

A logging client is a machine which sends log information to a logging server
in addition to keeping local copies.

Similar to log servers, clients must also meet a few minimum requirements:

  * syslogd(8) must be configured to send messages of specific types to a log
    server, which must accept them;

  * The firewall must allow UDP packets through on port 514;

  * Both forward and reverse DNS must be configured or have proper entries in
    the /etc/hosts.

Client configuration is a bit more relaxed when compared to that of the
servers. The client machine must have the following listing placed inside /etc/
rc.conf:

syslogd_enable="YES" syslogd_flags="-s -v -v"

As before, these entries will enable the syslogd daemon on boot up, and
increases the verbosity of logged messages. The -s option prevents logs from
being accepted by this client from other hosts.

Facilities describe the system part for which a message is generated. For an
example, ftp and ipfw are both facilities. When log messages are generated for
those two services, they will normally include those two utilities in any log
messages. Facilities are accompanied with a priority or level, which is used to
mark how important a log message is. The most common will be the warning and
info. Please refer to the syslog(3) manual page for a full list of available
facilities and priorities.

The logging server must be defined in the client's /etc/syslog.conf. In this
instance, the @ symbol is used to send logging data to a remote server and
would look similar to the following entry:

*.* @logserv.example.com

Once added, syslogd must be restarted for the changes to take effect:

# service syslogd restart

To test that log messages are being sent across the network, use logger(1) on
the client to send a message to syslogd:

# logger "Test message from logclient"

This message should now exist both in /var/log/messages on the client, and /var
/log/logclient.log on the log server.

30.11.3.Â Debugging Log Servers

In certain cases, debugging may be required if messages are not being received
on the log server. There are several reasons this may occur; however, the most
common two are network connection issues and DNS issues. To test these cases,
ensure both hosts are able to reach one another using the hostname specified in
/etc/rc.conf. If this appears to be working properly, an alternation to the
syslogd_flags option in /etc/rc.conf will be required.

In the following example, /var/log/logclient.log is empty, and the /var/log/
messages files indicate no reason for the failure. To increase debugging
output, change the syslogd_flags option to look like the following example, and
issue a restart:

syslogd_flags="-d -a logclien.example.com -v -v"
# service syslogd restart

Debugging data similar to the following will flash on the screen immediately
after the restart:

logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted logmsg: pri 6, flags 4, from logserv.example.com, msg
syslogd: kernel boot file is /boot/kernel/kernel Logging to FILE /var/log/
messages syslogd: kernel boot file is /boot/kernel/kernel cvthname
(192.168.1.10) validate: dgram from IP 192.168.1.10, port 514, name
logclient.example.com; rejected in rule 0 due to name mismatch.

It appears obvious the messages are being rejected due to a name mismatch.
After reviewing the configuration bit by bit, it appears a typo in the
following /etc/rc.conf line has an issue:

syslogd_flags="-d -a logclien.example.com -v -v"

The line should contain logclient, not logclien. After the proper alterations
are made, a restart is issued with expected results:

# service syslogd restart logmsg: pri 56, flags 4, from logserv.example.com,
msg syslogd: restart syslogd: restarted logmsg: pri 6, flags 4, from
logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel logmsg: pri 166, flags 17,
from logserv.example.com, msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com
syslogd: exiting on signal 2 cvthname(192.168.1.10) validate: dgram from IP
192.168.1.10, port 514, name logclient.example.com; accepted in rule 0. logmsg:
pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test
message 2 Logging to FILE /var/log/logclient.log Logging to FILE /var/log/
messages

At this point, the messages are being properly received and placed in the
correct file.

30.11.4.Â Security Considerations

As with any network service, security requirements should be considered before
implementing this configuration. At times, log files may contain sensitive data
about services enabled on the local host, user accounts, and configuration
data. Network data sent from the client to the server will not be encrypted nor
password protected. If a need for encryption exists, it might be possible to
use security/stunnel, which will transmit data over an encrypted tunnel.

Local security is also an issue. Log files are not encrypted during use or
after log rotation. Local users may access these files to gain additional
insight on system configuration. In those cases, setting proper permissions on
these files will be critical. The newsyslog(8) utility supports setting
permissions on newly created and rotated log files. Setting log files to mode
600 should prevent any unwanted snooping by local users.

ChapterÂ 31.Â Firewalls

Contributed by Joseph J. Barbish.
Converted to SGML and updated by Brad Davis.
Table of Contents

31.1. Introduction
31.2. Firewall Concepts
31.3. Firewall Packages
31.4. PF and ALTQ
31.5. The IPFILTER (IPF) Firewall
31.6. IPFW

31.1.Â Introduction

Firewalls make it possible to filter the incoming and outgoing traffic that
flows through a system. A firewall can use one or more sets of â  rulesâ   to
inspect network packets as they come in or go out of network connections and
either allows the traffic through or blocks it. The rules of a firewall can
inspect one or more characteristics of the packets such as the protocol type,
source or destination host address, and source or destination port.

Firewalls can enhance the security of a host or a network. They can be used to
do one or more of the following:

  * Protect and insulate the applications, services, and machines of an
    internal network from unwanted traffic from the public Internet.

  * Limit or disable access from hosts of the internal network to services of
    the public Internet.

  * Support network address translation (NAT), which allows an internal network
    to use private IP addresses and share a single connection to the public
    Internet using either a single IP address or a shared pool of automatically
    assigned public addresses.

After reading this chapter, you will know:

  * How to define packet filtering rules.

  * The differences between the firewalls built into FreeBSD.

  * How to use and configure the PF firewall.

  * How to use and configure the IPFILTER firewall.

  * How to use and configure the IPFW firewall.

Before reading this chapter, you should:

  * Understand basic FreeBSD and Internet concepts.

31.2.Â Firewall Concepts

A firewall ruleset can be either â  exclusiveâ   or â  inclusiveâ  . An
exclusive firewall allows all traffic through except for the traffic matching
the ruleset. An inclusive firewall does the reverse as it only allows traffic
matching the rules through and blocks everything else.

An inclusive firewall offers better control of the outgoing traffic, making it
a better choice for systems that offer services to the public Internet. It also
controls the type of traffic originating from the public Internet that can gain
access to a private network. All traffic that does not match the rules is
blocked and logged. Inclusive firewalls are generally safer than exclusive
firewalls because they significantly reduce the risk of allowing unwanted
traffic.

Note:

Unless noted otherwise, all configuration and example rulesets in this chapter
create inclusive firewall rulesets.

Security can be tightened further using a â  stateful firewallâ  . This type of
firewall keeps track of open connections and only allows traffic which either
matches an existing connection or opens a new, allowed connection. The
disadvantage of a stateful firewall is that it can be vulnerable to Denial of
Service (DoS) attacks if a lot of new connections are opened very fast. Most
firewalls use a combination of stateful and non-stateful behavior.

31.3.Â Firewall Packages

FreeBSD has three firewalls built into the base system: IPFILTER, also known as
IPF, IPFIREWALL, also known as IPFW, and PF). FreeBSD also provides two traffic
shapers for controlling bandwidth usage: altq(4) and dummynet(4). Dummynet has
traditionally been closely tied with IPFW, and ALTQ with PF. Each firewall uses
rules to control the access of packets to and from a FreeBSD system, although
they go about it in different ways and each has a different rule syntax.

FreeBSD provides multiple firewalls in order to meet the different requirements
and preferences for a wide variety of users. Each user should evaluate which
firewall best meets their needs.

Since all firewalls are based on inspecting the values of selected packet
control fields, the creator of the firewall ruleset must have an understanding
of how TCP/IP works, what the different values in the packet control fields
are, and how these values are used in a normal session conversation. For a good
introduction, refer to Daryl's TCP/IP Primer.

31.4.Â PF and ALTQ

Revised and updated by John Ferrell.

Since FreeBSDÂ 5.3, a ported version of OpenBSD's PF firewall has been included
as an integrated part of the base system. PF is a complete, full-featured
firewall that has optional support for ALTQ (Alternate Queuing), which provides
Quality of Service (QoS).

Since the OpenBSD Project maintains the definitive reference for PF in thePF
FAQ, this section of the Handbook focuses on PF as it pertains to FreeBSD,
while providing some general usage information.

More information about porting PF to FreeBSD can be found at http://
pf4freebsd.love2party.net/.

31.4.1.Â Using the PF Loadable Kernel Modules

In order to use PF, the PF kernel module must be first loaded. Add the
following line to /etc/rc.conf:

pf_enable="YES"

Then, run the startup script to load the module:

# service pf start

The PF module will not load if it cannot find the ruleset configuration file.
The default location is /etc/pf.conf. If the PF ruleset is located somewhere
else, add a line to /etc/rc.conf which specifies the full path to the file:

pf_rules="/path/to/pf.conf"

The sample pf.conf can be found in /usr/share/examples/pf/.

The PF module can also be loaded manually from the command line:

# kldload pf.ko

Logging support for PF is provided by pflog.ko which can be loaded by adding
the following line to /etc/rc.conf:

pflog_enable="YES"

Then, run the startup script to load the module:

# service pflog start

31.4.2.Â PF Kernel Options

While it is not necessary to compile PF support into the FreeBSD kernel, some
of PF's advanced features are not included in the loadable module, namely
pfsync(4), which is a pseudo-device that exposes certain changes to the state
table used by PF. It can be paired with carp(4) to create failover firewalls
using PF. More information on CARP can be found in of the Handbook.

The following PF kernel options can be found in /usr/src/sys/conf/NOTES:

device pf device pflog device pfsync

device pf enables PF support.

device pflog enables the optional pflog(4) pseudo network device which can be
used to log traffic to a bpf(4) descriptor. The pflogd(8) daemon can then be
used to store the logging information to disk.

device pfsync enables the optional pfsync(4) pseudo-network device that is used
to monitor â  state changesâ  .

31.4.3.Â Available rc.conf Options

The following rc.conf(5) statements can be used to configure PF and pflog(4) at
boot:

pf_enable="YES" # Enable PF (load module if required) pf_rules="/etc/pf.conf" #
rules definition file for pf pf_flags="" # additional flags for pfctl startup
pflog_enable="YES" # start pflogd(8) pflog_logfile="/var/log/pflog" # where
pflogd should store the logfile pflog_flags="" # additional flags for pflogd
startup

If there is a LAN behind the firewall and packets need to be forwarded for the
computers on the LAN, or NAT is required, add the following option:

gateway_enable="YES" # Enable as LAN gateway

31.4.4.Â Creating Filtering Rules

By default, PF reads its configuration rules from /etc/pf.conf and modifies,
drops, or passes packets according to the rules or definitions specified in
this file. The FreeBSD installation includes several sample files located in /
usr/share/examples/pf/. Refer to the PF FAQ for complete coverage of PF
rulesets.

Warning:

When reading the PF FAQ, keep in mind that different versions of FreeBSD
contain different versions of PF. Currently, FreeBSDÂ 8.X is using the same
version of PF as OpenBSDÂ 4.1. FreeBSDÂ 9.X and later is using the same version
of PF as OpenBSDÂ 4.5.

The FreeBSD packet filter mailing list is a good place to ask questions about
configuring and running the PF firewall. Do not forget to check the mailing
list archives before asking questions.

To control PF, use pfctl(8). Below are some useful options to this command.
Review pfctl(8) for a description of all available options:

        Command                                 Purpose
pfctl -e                Enable PF.
pfctl -d                Disable PF.
pfctl -F all -f /etc/   Flush all NAT, filter, state, and table rules and
pf.conf                 reload /etc/pf.conf.
pfctl -s [ rules | nat  Report on the filter rules, NAT rules, or state table.
state ]
pfctl -vnf /etc/pf.conf Check /etc/pf.conf for errors, but do not load ruleset.

31.4.5.Â Enabling ALTQ

ALTQ is only available by compiling its support into the FreeBSD kernel. ALTQ
is not supported by all network card drivers. Refer to altq(4) for a list of
drivers that are supported by the release of FreeBSD.

The following kernel options will enable ALTQ and add additional functionality:

options ALTQ options ALTQ_CBQ # Class Based Queuing (CBQ) options ALTQ_RED #
Random Early Detection (RED) options ALTQ_RIO # RED In/Out options ALTQ_HFSC #
Hierarchical Packet Scheduler (HFSC) options ALTQ_PRIQ # Priority Queuing
(PRIQ) options ALTQ_NOPCC # Required for SMP build

options ALTQ enables the ALTQ framework.

options ALTQ_CBQ enables Class Based Queuing (CBQ). CBQ can be used to divide a
connection's bandwidth into different classes or queues to prioritize traffic
based on filter rules.

options ALTQ_RED enables Random Early Detection (RED). RED is used to avoid
network congestion by measuring the length of the queue and comparing it to the
minimum and maximum thresholds for the queue. If the queue is over the maximum,
all new packets will be dropped. RED drops packets from different connections
randomly.

options ALTQ_RIO enables Random Early Detection In and Out.

options ALTQ_HFSC enables the Hierarchical Fair Service Curve Packet Scheduler 
HFSC. For more information, refer to http://www-2.cs.cmu.edu/~hzhang/HFSC/
main.html.

options ALTQ_PRIQ enables Priority Queuing (PRIQ). PRIQ will always pass
traffic that is in a higher queue first.

options ALTQ_NOPCC enables SMP support for ALTQ. This option is required on SMP
systems.

31.4.6.Â PF Rule Sets and Tools

Contributed by Peter N. M. Hansteen.

This section demonstrates some useful PF features and PF related tools in a
series of examples. A more thorough tutorial is available at http://
home.nuug.no/~peter/pf/.

Tip:

security/sudo is useful for running commands like pfctl that require elevated
privileges. It can be installed from the Ports Collection.

31.4.6.1.Â The Simplest Rule Set Ever

The simplest possible setup is for a single machine which will not run any
services, and which will talk to one network which may be the Internet. A
minimal /etc/pf.conf looks like this:

block in all pass out all keep state

Here we deny any incoming traffic, allow traffic we make ourselves to pass, and
retain state information on our connections. Keeping state information allows
return traffic for all connections we have initiated to pass back to us. This
rule set is used on machines that can be trusted. The rule set can be loaded
with

# pfctl -e ; pfctl -f /etc/pf.conf

31.4.6.2.Â Tighter and More Elegant

For a slightly more structured and complete setup, we start by denying
everything and then allowing only those things we know that we need ^[8]. This
gives us the opportunity to introduce two of the features which make PF such a
wonderful tool: lists and macros.

We will make some changes to /etc/pf.conf, starting with

block all

Then we back up a little. Macros need to be defined before use, so at the very
top of the file, we add:

tcp_services = "{ ssh, smtp, domain, www, pop3, auth, pop3s }" udp_services = "
{ domain }"

Now we have demonstrated several things at once - what macros look like, that
macros may be lists, and that PF understands rules using port names equally
well as it does port numbers. The names are the ones listed in /etc/services.
This gives us something to put in our rules, which we edit slightly to look
like this:

block all pass out proto tcp to any port $tcp_services keep state pass proto
udp to any port $udp_services keep state

At this point some of us will point out that UDP is stateless, but PF actually
manages to maintain state information despite this. Keeping state for a UDP
connection means that for example when you ask a name server about a domain
name, you will be able to receive its answer.

Since we have made changes to our pf.conf, we load the new rules:

# pfctl -f /etc/pf.conf

and the new rules are applied. If there are no syntax errors, pfctl will not
output any messages during the rule load. The -v flag will produce more verbose
pfctl output.

If there have been extensive changes to the rule set, the rules can be tested
before attempting to load them. The command to do this is

# pfctl -nf /etc/pf.conf

-n causes the rules to be interpreted only, but does not load them. This
provides an opportunity to correct any errors. Under any circumstances, the
last valid rule set loaded will be in force until PF is disabled or a new rule
set is loaded.

Use pfctl -v to Show the Parsed Rule Set:

Adding the -v to a pfctl ruleset load (even a dry run with -n) will display the
fully parsed rules exactly the way they will be loaded. This is extremely
useful when debugging rules.

31.4.6.3.Â A Simple Gateway with NAT

To most users, a single machine setup will be of limited interest, and at this
point we move on to more realistic or at least more common setups,
concentrating on a machine which is running PF and also acts as a gateway for
at least one other machine.

31.4.6.3.1.Â Gateways and the Pitfalls of in, out and on

In the single machine setup, life is relatively simple. Traffic created on it
should either pass out to the rest of the world or not, and the administrator
decides what to let in from elsewhere.

On a gateway, the perspective changes from â  me versus the network out thereâ 
  to â  I am the one who decides what to pass to or from all the networks I am
connected toâ  . The machine has at least two network interfaces, each
connected to a separate net.

It is very reasonable to think that for traffic to pass from the network
connected to xl1 to hosts on the network connected to xl0, a rule like this is
needed:

pass in on xl1 from xl1:network to xl0:network port $ports keep state

This rule keeps track of states as well.

However, one of the most common and most complained-about mistakes in firewall
configuration is not realizing that the â  toâ   keyword does not in itself
guarantee passage all the way there. The rule we just wrote only lets the
traffic pass in to the gateway on the internal interface. To let the packets
get a bit further, a matching rule is needed which says

pass out on xl0 from xl1:network to xl0:network port $ports keep state

These rules will work, but they will not necessarily achieve the desired
effect.

Rules this specific are rarely needed. For the basic gateway configurations we
will be dealing with here, a better rule says

pass from xl1:network to any port $ports keep state

This provides local net access to the Internet and leaves the detective work to
the antispoof and scrub code. They are both pretty good these days, and we will
get back to them later. For now we just accept the fact that for simple setups,
interface-bound rules with in/out rules tend to add more clutter than they are
worth to rule sets.

For a busy network admin, a readable rule set is a safer rule set.

For the remainder of this section, with some exceptions, we will keep the rules
as simple as possible for readability.

31.4.6.3.2.Â What is the Local Network, Anyway?

Above, we introduced the interface:network notation. That is a nice piece of
shorthand, but the rule set can be made even more readable and maintainable by
taking the macro use a tiny bit further.

For example, a $localnet macro could be defined as the network directly
attached to your internal interface ($xl1:network in the examples above).

Alternatively, the definition of $localnet could be changed to an IP address/
netmask notation to denote a network, such as 192.168.100.1/24 for a subnet of
private addresses.

If required, $localnet could even be defined as a list of networks. Whatever
the specific needs, a sensible $localnet definition and a typical pass rule of
the type

pass from $localnet to any port $ports keep state

could end up saving you a few headaches. We will stick to that convention from
here on.

31.4.6.3.3.Â Setting Up

We assume that the machine has acquired another network card or at any rate
there is a network connection from the local network, via PPP or other means.
We will not consider the specific interface configurations.

For the discussion and examples below, only the interface names will differ
between a PPP setup and an Ethernet one, and we will do our best to get rid of
the actual interface names as quickly as possible.

First, we need to turn on gatewaying in order to let the machine forward the
network traffic it receives on one interface to other networks via a separate
interface. Initially we will do this on the command line with sysctl(8), for
traditional IP version four.

# sysctl net.inet.ip.forwarding=1

If we need to forward IP version six traffic, the command is

# sysctl net.inet6.ip6.forwarding=1

In order for this to continue working after the computer has been restarted at
some time in the future, enter these settings into /etc/rc.conf:

gateway_enable="YES" #for ipv4 ipv6_gateway_enable="YES" #for ipv6

Use ifconfig -a, or ifconfig interface_name to find out if both of the
interfaces to be used are up and running.

If all traffic initiated by machines on the inside is to be allowed, /etc/
pf.conf could look roughly like this ^[9]:

ext_if = "xl0" # macro for external interface - use tun0 for PPPoE int_if =
"xl1" # macro for internal interface localnet = $int_if:network # ext_if IP
address could be dynamic, hence ($ext_if) nat on $ext_if from $localnet to any
-&gt; ($ext_if) block all pass from { lo0, $localnet } to any keep state

Note the use of macros to assign logical names to the network interfaces. Here
3Com cards are used, but this is the last time during this tutorial we will
find this of any interest whatsoever. In truly simple setups like this one, we
may not gain very much by using macros like these, but once the rule sets grow
somewhat larger, you will learn to appreciate the readability this provides.

Also note the nat rule. This is where we handle the network address translation
from the non-routable address inside the local net to the sole official address
we assume has been assigned.

The parentheses surrounding the last part of the nat rule ($ext_if) are there
to compensate for the possibility that the IP address of the external interface
may be dynamically assigned. This detail will ensure that network traffic runs
without serious interruptions even if the external IP address changes.

On the other hand, this rule set probably allows more traffic to pass out of
the network than actually desired. One reasonable setup could contain the macro

client_out = "{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \ https,
cvspserver, 2628, 5999, 8000, 8080 }"

and the main pass rule

pass inet proto tcp from $localnet to any port $client_out \ flags S/SA keep
state

This may be a somewhat peculiar selection of ports, but it is based on a real
life example. Individual needs probably differ at least in some specifics, but
this should cover at least some of the more useful services.

In addition, we have a few other pass rules. We will be returning to some of
the more interesting ones rather soon. One pass rule which is useful to those
of us who want the ability to administer our machines from elsewhere is

pass in inet proto tcp to port ssh

or for that matter

pass in inet proto tcp to $ext_if port ssh

whichever is preferred. Lastly we need to make the name service work for our
clients:

udp_services = "{ domain, ntp }"

This is supplemented with a rule which passes the traffic we want through our
firewall:

pass quick inet proto { tcp, udp } to any port $udp_services keep state

Note the quick keyword in this rule. We have started writing rule sets which
consist of several rules, and it is time to take a look at the relationships
between the rules in a rule set. The rules are evaluated from top to bottom, in
the sequence they are written in the configuration file. For each packet or
connection evaluated by PF, the last matching rule in the rule set is the one
which is applied. The quick keyword offers an escape from the ordinary
sequence. When a packet matches a quick rule, the packet is treated according
to the present rule. The rule processing stops without considering any further
rules which might have matched the packet. This is very useful when a few
isolated exceptions to the general rules are needed.

This rule also takes care of NTP, which is used for time synchronization. One
thing common to both protocols is that they may under certain circumstances
communicate alternately over TCP and UDP.

31.4.6.4.Â That Sad Old FTP Thing

The short list of real life TCP ports above contained, among other things, FTP.
FTP is a sad old thing and a problem child, emphatically so for anyone trying
to combine FTP and firewalls. FTP is an old and weird protocol, with a lot to
not like. The most common points against it are

  * Passwords are transferred in the clear

  * The protocol demands the use of at least two TCP connections (control and
    data) on separate ports

  * When a session is established, data is communicated via ports selected at
    random

All of these points make for challenges security-wise, even before considering
any potential weaknesses in client or server software which may lead to
security issues. These things have tended to happen.

Under any circumstances, other more modern and more secure options for file
transfer exist, such as sftp(1) or scp(1), which feature both authentication
and data transfer via encrypted connections. Competent IT professionals should
have a preference for some other form of file transfer than FTP.

Regardless of our professionalism and preferences, we are all too aware that at
times we will need to handle things we would prefer not to. In the case of FTP
through firewalls, the main part of our handling consists of redirecting the
traffic to a small program which is written specifically for this purpose.

31.4.6.4.1.Â FTP Via Redirect: ftp-proxy

Enabling FTP transfers through your gateway is amazingly simple, thanks to the 
FTP proxy program (called ftp-proxy(8)) included in the base system on FreeBSD
and other systems which offer PF.

The FTP protocol being what it is, the proxy needs to dynamically insert rules
in your rule set. ftp-proxy(8) interacts with your configuration via a set of
anchors where the proxy inserts and deletes the rules it constructs to handle
your FTP traffic.

To enable ftp-proxy(8), add this line to /etc/rc.conf:

ftpproxy_flags=""

Starting the proxy manually by running /usr/sbin/ftp-proxy allows testing of
the PF configuration changes we are about to make.

For a basic configuration, only three elements need to be added to /etc/
pf.conf. First, the anchors:

nat-anchor "ftp-proxy/*" rdr-anchor "ftp-proxy/*"

The proxy will insert the rules it generates for the FTP sessions here. A pass
rule is needed to let FTP traffic in to the proxy.

Now for the actual redirection. Redirection rules and NAT rules fall into the
same rule class. These rules may be referenced directly by other rules, and
filtering rules may depend on these rules. Logically, rdr and nat rules need to
be defined before the filtering rules.

We insert our rdr rule immediately after the nat rule in /etc/pf.conf

rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021

In addition, the redirected traffic must be allowed to pass. We achieve this
with

pass out proto tcp from $proxy to any port ftp

where $proxy expands to the address the proxy daemon is bound to.

Save pf.conf, then load the new rules with

# pfctl -f /etc/pf.conf

At this point, users will probably begin noticing that FTP works before they
have been told.

This example covers a basic setup where the clients in the local net need to
contact FTP servers elsewhere. The basic configuration here should work well
with most combinations of FTP clients and servers. As shown in the man page,
the proxy's behavior can be changed in various ways by adding options to the
ftpproxy_flags= line. Some clients or servers may have specific quirks that
must be compensated for in the configuration, or there may be a need to
integrate the proxy in specific ways such as assigning FTP traffic to a
specific queue. For these and other finer points of ftp-proxy(8) configuration,
start by studying the man page.

For ways to run an FTP server protected by PF and ftp-proxy(8), look into
running a separate ftp-proxy in reverse mode (using -R), on a separate port
with its own redirecting pass rule.

31.4.6.5.Â Easing Troubleshooting

Making network troubleshooting friendly is a potentially large subject. At most
times, the debugging or troubleshooting friendliness of a TCP/IP network
depends on treatment of the Internet protocol which was designed specifically
with debugging in mind, the Internet Control Message Protocol, or ICMP as it is
usually abbreviated.

ICMP is the protocol for sending and receiving control messages between hosts
and gateways, mainly to provide feedback to a sender about any unusual or
difficult conditions enroute to the target host.

There is a lot of ICMP traffic which usually just happens in the background
while users are surfing the web, reading mail or transferring files. Routers
use ICMP to negotiate packet sizes and other transmission parameters in a
process often referred to as path MTU discovery.

Some admins refer to ICMP as either â  just evilâ  , or, if their understanding
runs a little deeper, â  a necessary evilâ  . The reason for this attitude is
purely historical. The reason can be found a few years back when it was
discovered that several operating systems contained code in their networking
stack which could make a machine running one of the affected systems crash and
fall over, or in some cases just do really strange things, with a sufficiently
large ICMP request.

One of the companies which was hit hard was Microsoft, and you can find rather
a lot of material on the â  ping of deathâ   bug by using your favorite search
engine. This all happened in the second half of the 1990s, and all modern
operating systems, at least the ones we can read, have thoroughly sanitized
their network code since then. At least that is what we are led to believe.

One of the early workarounds was to simply block either all ICMP traffic or at
least ICMP ECHO, which is what ping uses. Now these rule sets have been around
for roughly fifteen years, and the people who put them there are still scared.

31.4.6.5.1.Â Then, Do We Let it All Through?

The obvious question then becomes, if ICMP is such a good and useful thing,
should we not let it all through, all the time? The answer is â  It dependsâ  .

Letting diagnostic traffic pass unconditionally of course makes debugging
easier, but also makes it relatively easy for others to extract information
about your network. That means that a rule like

pass inet proto icmp from any to any

might not be optimal if the internal workings of the local network should be
cloaked in a bit of mystery. In all fairness it should also be said that some 
ICMP traffic might be found quite harmlessly riding piggyback on keep state
rules.

31.4.6.5.2.Â The Easy Way Out: the Buck Stops Here

The easiest solution could very well be to let all ICMP traffic from the local
net through and stop probes from elsewhere at the gateway:

pass inet proto icmp icmp-type $icmp_types from $localnet to any keep state
pass inet proto icmp icmp-type $icmp_types from any to $ext_if keep state

Stopping probes at the gateway might be an attractive option anyway, but let us
have a look at a few other options which will show some of PF's flexibility.

31.4.6.5.3.Â Letting ping Through

The rule set we have developed so far has one clear disadvantage: common
troubleshooting commands such as ping(8) and traceroute(8) will not work. That
may not matter too much to end users, and since it was ping which scared people
into filtering or blocking ICMP traffic in the first place, there are
apparently some people who feel we are better off without it. If you are in my
perceived target audience, you will be rather fond of having those
troubleshooting tools avalable. With a couple of small additions to the rule
set, they will be. ping(8) uses ICMP, and in order to keep our rule set tidy,
we start by defining another macro:

icmp_types = "echoreq"

and a rule which uses the definition,

pass inet proto icmp all icmp-type $icmp_types keep state

More or other types of ICMP packets may need to go through, and icmp_types can
be expanded to a list of those packet types that are allowed.

31.4.6.5.4.Â Helping traceroute(8)

traceroute(8) is another command which is quite useful when users claim that
the Internet is not working. By default, Unix traceroute uses UDP connections
according to a set formula based on destination. The rule below works with
traceroute on all unixes I've had access to, including GNU/Linux:

# allow out the default range for traceroute(8): # "base+nhops*nqueries-1"
(33434+64*3-1) pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt;
33626 keep state

Experience so far indicates that traceroute implementations on other operating
systems work roughly the same. Except, of course, on Microsoft Windows. On that
platform, TRACERT.EXE uses ICMP ECHO for this purpose. So to let Windows
traceroutes through, only the first rule is needed. Unix traceroute can be
instructed to use other protocols as well, and will behave remarkably like its
Microsoft counterpart if -I is used. Check the traceroute(8) man page (or its
source code, for that matter) for all the details.

Under any circumstances, this solution was lifted from an openbsd-misc post.
I've found that list, and the searchable list archives (accessible among other
places from http://marc.theaimsgroup.com/), to be a very valuable resource
whenever you need OpenBSD or PF related information.

31.4.6.5.5.Â Path MTU Discovery

Internet protocols are designed to be device independent, and one consequence
of device independence is that the optimal packet size for a given connection
cannot always be predicted reliably. The main constraint on packet size is
called the Maximum Transmission Unit, or MTU, which sets the upper limit on the
packet size for an interface. ifconfig(8) shows the MTU for the network
interfaces.

Modern TCP/IP implementations expect to be able to determine the right packet
size for a connection through a process which, simply put, involves sending
packets of varying sizes with the â  Do not fragmentâ   flag set, expecting an 
ICMP return packet indicating â  type 3, code 4â   when the upper limit has
been reached. Now do not dive for the RFCs right away. Type 3 means â  
destination unreachableâ  , while code 4 is short for â  fragmentation needed,
but the do-not-fragment flag is setâ  . So if connections to networks which may
have other MTUs than the local network seem sub-optimal, and there is no need
to be that specific, the list of ICMP types can be changed slightly to let the 
â  destination unreachableâ   packets through, too:

icmp_types = "{ echoreq, unreach }"

As we can see, this means we do not need to change the pass rule itself:

pass inet proto icmp all icmp-type $icmp_types keep state

PF allows filtering on all variations of ICMP types and codes. For those who
want to delve into what to pass (or not) of ICMP traffic, the list of possible
types and codes are documented in the icmp(4) and icmp6(4) man pages. The
background information is available in the RFCs ^[10].

31.4.6.6.Â Tables Make Life Easier

By this time it may appear that this gets awfully static and rigid. There will
after all be some kinds of data which are relevant to filtering and redirection
at a given time, but do not deserve to be put into a configuration file! Quite
right, and PF offers mechanisms for handling these situations as well. Tables
are one such feature, mainly useful as lists which can be manipulated without
needing to reload the entire rule set, and where fast lookups are desirable.
Table names are always enclosed in &lt; &gt;, like this:

table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }

Here, the network 192.168.2.0/24 is part of the table, except the address
192.168.2.5, which is excluded using the ! operator (logical NOT). It is also
possible to load tables from files where each item is on a separate line, such
as the file /etc/clients.

192.168.2.0/24 !192.168.2.5

which in turn is used to initialize the table in /etc/pf.conf:

table &lt;clients&gt; persist file /etc/clients

Then, for example, one of our earlier rules can be changed to read

pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep
state

to manage outgoing traffic from client computers. With this in hand, the
table's contents can be manipulated live, such as

# pfctl -t clients -T add 192.168.1/16

Note that this changes the in-memory copy of the table only, meaning that the
change will not survive a power failure or other reboot unless there are
arrangements to store the changes.

One might opt to maintain the on-disk copy of the table using a cron(8) job
which dumps the table content to disk at regular intervals, using a command
such as pfctl -t clients -T show &gt;/etc/clients. Alternatively, /etc/clients
could be edited, replacing the in-memory table contents with the file data:

# pfctl -t clients -T replace -f /etc/clients

For operations performed frequently, administrators will sooner or later end up
writing shell scripts for tasks such as inserting or removing items or
replacing table contents. The only real limitations lie in individual needs and
creativity.

31.4.6.7.Â Overload Tables

Those who run a Secure Shell login service which is accessible from the
Internet have probably seen something like this in the authentication logs:

Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31
port 40992 ssh2 Sep 26 03:12:34 skapet sshd[5279]: Failed password for root
from 200.72.41.31 port 40992 ssh2 Sep 26 03:12:35 skapet sshd[5279]: Received
disconnect from 200.72.41.31: 11: Bye Bye Sep 26 03:12:44 skapet sshd[29635]:
Invalid user admin from 200.72.41.31 Sep 26 03:12:44 skapet sshd[24703]:
input_userauth_request: invalid user admin Sep 26 03:12:44 skapet sshd[24703]:
Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2

And so on. This is what a brute force attack looks like. Essentially somebody,
or more likely, a cracked computer somewhere, is trying by brute force to find
a combination of user name and password which will let them into your system.

The simplest response would be to write a pf.conf rule which blocks all access.
This leads to another class of problems, including what to do in order to let
people with legitimate business on the system access it anyway. Some might
consider moving the service to another port, but then again, the ones flooding
on port 22 would probably be able to scan their way to port 22222 for a repeat
performance.

Since OpenBSD 3.7, and soon after in FreeBSD version 6.0, PF has offered a
slightly more elegant solution. Pass rules can be written so they maintain
certain limits on what connecting hosts can do. For good measure, violators can
be banished to a table of addresses which are denied some or all access. If
desired, it's even possible to drop all existing connections from machines
which overreach the limits. Here is how it is done:

First, set up the table. In the tables section, add

table &lt;bruteforce&gt; persist

Then somewhere fairly early in the rule set, add a rule to block the
bruteforcers:

block quick from &lt;bruteforce&gt;

And finally, the pass rule.

pass inet proto tcp from any to $localnet port $tcp_services \ flags S/SA keep
state \ (max-src-conn 100, max-src-conn-rate 15/5, \ overload &lt;bruteforce&gt;
flush global)

The first part here is identical to the main rule we constructed earlier. The
part in parentheses is the new stuff which will ease network load even further.

max-src-conn is the number of simultaneous connections allowed from one host.
In this example, it is set at 100. Other setups may want a slightly higher or
lower value.

max-src-conn-rate is the rate of new connections allowed from any single host,
here 15 connections per 5 seconds. Again, the administrator is the one to judge
what suits their setup.

overload &lt;bruteforce&gt; means that any host which exceeds these limits gets its
address added to the table bruteforce. Our rule set blocks all traffic from
addresses in the bruteforce table.

Finally, flush global says that when a host reaches the limit, that host's
connections will be terminated (flushed). The global part says that for good
measure, this applies to connections which match other pass rules too.

The effect is dramatic. From here on, bruteforcers more often than not will end
up with "Fatal: timeout before authentication" messages, getting nowhere.

Note:

These rules will not block slow bruteforcers, sometimes referred to as the Hail
Mary Cloud.

Once again, please keep in mind that this example rule is intended mainly as an
illustration. It is not unlikely that a particular network's needs are better
served by rather different rules or combinations of rules.

If, for example, a generous number of connections in general are wanted, but
the desire is to be a little more tight fisted when it comes to ssh, supplement
the rule above with something like the one below, early on in the rule set:

pass quick proto { tcp, udp } from any to any port ssh \ flags S/SA keep state
\ (max-src-conn 15, max-src-conn-rate 5/3, \ overload &lt;bruteforce&gt; flush
global)

It should be possible to find the set of parameters which is just right for
individual situations by reading the relevant man pages and the PF User Guide,
and perhaps a bit of experimentation.

It May Not be Necessary to Block All Overloaders:

It is probably worth noting at this point that the overload mechanism is a
general technique which does not have to apply exclusively to the ssh service,
and it is not always optimal to block all traffic from offenders entirely.

For example, an overload rule could be used to protect a mail service or a web
service, and the overload table could be used in a rule to assign offenders to
a queue with a minimal bandwidth allocation or, in the web case, to redirect to
a specific web page.

31.4.6.7.1.Â Expiring Table Entries with pfctl

At this point, we have tables which will be filled by our overload rules, and
since we could reasonably expect our gateways to have months of uptime, the
tables will grow incrementally, taking up more memory as time goes by.

Sometimes an IP address that was blocked last week due to a brute force attack
was in fact a dynamically assigned one, which is now assigned to a different
ISP customer who has a legitimate reason to try communicating with hosts in the
local network.

Situations like these were what caused Henning Brauer to add to pfctl the
ability to expire table entries not referenced in a specified number of seconds
(in OpenBSD 4.1). For example, the command

# pfctl -t bruteforce -T expire 86400

will remove &lt;bruteforce&gt; table entries which have not been referenced for 86400
seconds.

31.4.6.7.2.Â The expiretable Tool

Before pfctl acquired the ability to expire table entries, Henrik Gustafsson
had written expiretable, which removes table entries which have not been
accessed for a specified period of time.

One useful example is to use the expiretable program as a way of removing
outdated &lt;bruteforce&gt; table entries.

For example, let expiretable remove &lt;bruteforce&gt; table entries older than 24
hours by adding an entry containing the following to /etc/rc.local:

/usr/local/sbin/expiretable -v -d -t 24h bruteforce

expiretable is in the PortsÂ Collection on FreeBSD as security/expiretable.

31.4.6.8.Â Other PF Tools

Over time, a number of tools have been developed which interact with PF in
various ways.

31.4.6.8.1.Â The pftop Traffic Viewer

Can Erkin Acar's pftop makes it possible to keep an eye on what passes into and
out of the network. pftop is available through the ports system as sysutils/
pftop. The name is a strong hint at what it does - pftop shows a running
snapshot of traffic in a format which is strongly inspired by top(1).

31.4.6.8.2.Â The spamd Spam Deferral Daemon

Not to be confused with the spamd daemon which comes bundled with spamassassin,
the PF companion spamd was designed to run on a PF gateway to form part of the
outer defense against spam. spamd hooks into the PF configuration via a set of
redirections.

The main point underlying the spamd design is the fact that spammers send a
large number of messages, and the probability that you are the first person
receiving a particular message is incredibly small. In addition, spam is mainly
sent via a few spammer friendly networks and a large number of hijacked
machines. Both the individual messages and the machines will be reported to
blacklists fairly quickly, and this is the kind of data spamd can use to our
advantage with blacklists.

What spamd does to SMTP connections from addresses in the blacklist is to
present its banner and immediately switch to a mode where it answers SMTP
traffic one byte at the time. This technique, which is intended to waste as
much time as possible on the sending end while costing the receiver pretty much
nothing, is called tarpitting. The specific implementation with one byte SMTP
replies is often referred to as stuttering.

31.4.6.8.2.1.Â A Basic Blacklisting spamd

Here is the basic procedure for setting up spamd with automatically updated
blacklists:

 1. Install the mail/spamd/ port. In particular, be sure to read the package
    message and act upon what it says. Specifically, to use spamd's greylisting
    features, a file descriptor file system (see fdescfs(5)) must be mounted at
    /dev/fd/. Do this by adding the following line to /etc/fstab:

    fdescfs /dev/fd fdescfs rw 0 0

    Make sure the fdescfs code is in the kernel, either compiled in or by
    loading the module with kldload(8).

 2. Next, edit the rule set to include

    table &lt;spamd&gt; persist table &lt;spamd-white&gt; persist rdr pass on $ext_if inet
    proto tcp from &lt;spamd&gt; to \ { $ext_if, $localnet } port smtp -&gt; 127.0.0.1
    port 8025 rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \ {
    $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025

    The two tables &lt;spamd&gt; and &lt;spamd-white&gt; are essential. SMTP traffic from
    the addresses in the first table plus the ones which are not in the other
    table are redirected to a daemon listening at port 8025.

 3. The next step is to set up spamd's own configuration in /usr/local/etc/
    spamd.conf supplemented by rc.conf parameters.

    The supplied sample file offers quite a bit of explanation, and the man
    page offers additional information, but we will recap the essentials here.

    One of the first lines without a # comment sign at the start contains the
    block which defines the all list, which specifies the lists actually used:

    all:\ :traplist:whitelist:

    Here, all the desired black lists are added, separated by colons (:). To
    use whitelists to subtract addresses from the blacklist, add the name of
    the whitelist immediately after the name of each blacklist, i.e.,
    :blacklist:whitelist:.

    Next up is a blacklist definition:

    traplist:\ :black:\ :msg="SPAM. Your address %A has sent spam within the
    last 24 hours":\ :method=http:\ :file=www.openbsd.org/spamd/traplist.gz

    Following the name, the first data field specifies the list type, in this
    case black. The msg field contains the message to display to blacklisted
    senders during the SMTP dialogue. The method field specifies how
    spamd-setup fetches the list data, here http. The other options are
    fetching via ftp, from a file in a mounted file system or via exec of an
    external program. Finally the file field specifies the name of the file
    spamd expects to receive.

    The definition of a whitelist follows much the same pattern:

    whitelist:\ :white:\ :method=file:\ :file=/var/mail/whitelist.txt

    but omits the message parameters since a message is not needed.

    Choose Data Sources with Care:

    Using all the blacklists in the sample spamd.conf will end up blacklisting
    large blocks of the Internet, including several Asian nations.
    Administrators need to edit the file to end up with an optimal
    configuration. The administrator is the judge of which data sources to use,
    and using lists other than the ones suggested in the sample file is
    possible.

    Put the lines for spamd and any startup parameters desired in /etc/rc.conf,
    for example:

    spamd_flags="-v" # for normal use: "" and see spamd-setup(8)

    When done with editing the setup, reload the rule set, start spamd with the
    options desired using the /usr/local/etc/rc.d/obspamd script, and complete
    the configuration using spamd-setup. Finally, create a cron(8) job which
    calls spamd-setup to update the tables at reasonable intervals.

On a typical gateway in front of a mail server, hosts will start getting
trapped within a few seconds to several minutes.

31.4.6.8.2.2.Â Adding Greylisting to the spamd Setup

spamd also supports greylisting, which works by rejecting messages from unknown
hosts temporarily with 45n codes, letting messages from hosts which try again
within a reasonable time through. Traffic from well behaved hosts, that is,
senders which are set up to behave within the limits set up in the relevant
RFCs ^[11], will be let through.

Greylisting as a technique was presented in a 2003 paper by Evan Harris ^[12],
and a number of implementations followed over the next few months. OpenBSD's 
spamd acquired its ability to greylist in OpenBSD 3.5, which was released in
May 2004.

The most amazing thing about greylisting, apart from its simplicity, is that it
still works. Spammers and malware writers have been very slow to adapt.

The basic procedure for adding greylisting to your setup follows below.

 1. If not done already, make sure the file descriptor file system (see fdescfs
    (5)) is mounted at /dev/fd/. Do this by adding the following line to /etc/
    fstab:

    fdescfs /dev/fd fdescfs rw 0 0

    and make sure the fdescfs(5) code is in the kernel, either compiled in or
    by loading the module with kldload(8).

 2. To run spamd in greylisting mode, /etc/rc.conf must be changed slightly by
    adding

    spamd_grey="YES" # use spamd greylisting if YES

    Several greylisting related parameters can be fine-tuned with spamd's
    command line parameters and the corresponding /etc/rc.conf settings. Check
    the spamd man page to see what the parameters mean.

 3. To complete the greylisting setup, restart spamd using the /usr/local/etc/
    rc.d/obspamd script.

Behind the scenes, rarely mentioned and barely documented are two of spamd's
helpers, the spamdb database tool and the spamlogd whitelist updater, which
both perform essential functions for the greylisting feature. Of the two 
spamlogd works quietly in the background, while spamdb has been developed to
offer some interesting features.

Restart spamd to Enable Greylisting:

After following all steps in the tutorial exactly up to this point, spamlogd
has been started automatically already. However, if the initial spamd
configuration did not include greylisting, spamlogd may not have been started,
and there may be strange symptoms, such as greylists and whitelists not getting
updated properly.

Under normal circumstances, it should not be necessary to start spamlogd by
hand. Restarting spamd after enabling greylisting ensures spamlogd is loaded
and available too.

spamdb is the administrator's main interface to managing the black, grey and
white lists via the contents of the /var/db/spamdb database.

31.4.6.8.3.Â Network Hygiene: Blocking, Scrubbing and so On

Our gateway does not feel quite complete without a few more items in the
configuration which will make it behave a bit more sanely towards hosts on the
wide net and our local network.

31.4.6.8.3.1.Â block-policy

block-policy is an option which can be set in the options part of the ruleset,
which precedes the redirection and filtering rules. This option determines
which feedback, if any, PF will give to hosts which try to create connections
which are subsequently blocked. The option has two possible values, drop, which
drops blocked packets with no feedback, and return, which returns with status
codes such as Connection refused or similar.

The correct strategy for block policies has been the subject of rather a lot of
discussion. We choose to play nicely and instruct our firewall to issue
returns:

set block-policy return

31.4.6.8.3.2.Â scrub

In PF versions up to OpenBSD 4.5 inclusive, scrub is a keyword which enables
network packet normalization, causing fragmented packets to be assembled and
removing ambiguity. Enabling scrub provides a measure of protection against
certain kinds of attacks based on incorrect handling of packet fragments. A
number of supplementing options are available, but we choose the simplest form
which is suitable for most configurations.

scrub in all

Some services, such as NFS, require some specific fragment handling options.
This is extensively documented in the PF user guide and man pages provide all
the information you could need.

One fairly common example is this,

scrub in all fragment reassemble no-df max-mss 1440

meaning, we reassemble fragments, clear the â  do not fragmentâ   bit and set
the maximum segment size to 1440 bytes. Other variations are possible, and you
should be able to cater to various specific needs by consulting the man pages
and some experimentation.

31.4.6.8.3.3.Â antispoof

antispoof is a common special case of filtering and blocking. This mechanism
protects against activity from spoofed or forged IP addresses, mainly by
blocking packets appearing on interfaces and in directions which are logically
not possible.

We specify that we want to weed out spoofed traffic coming in from the rest of
the world and any spoofed packets which, however unlikely, were to originate in
our own network:

antispoof for $ext_if antispoof for $int_if

31.4.6.8.3.4.Â Handling Non-Routable Addresses from Elsewhere

Even with a properly configured gateway to handle network address translation
for your own network, you may find yourself in the unenviable position of
having to compensate for other people's misconfigurations.

One depressingly common class of misconfigurations is the kind which lets
traffic with non-routable addresses out to the Internet. Traffic from
non-routeable addresses have also played a part in several DOS attack
techniques, so it may be worth considering explicitly blocking traffic from
non-routeable addresses from entering your network.

One possible solution is the one outlined below, which for good measure also
blocks any attempt to initiate contact to non-routable addresses through the
gateway's external interface:

martians = "{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \ 10.0.0.0/8,
169.254.0.0/16, 192.0.2.0/24, \ 0.0.0.0/8, 240.0.0.0/4 }" block drop in quick
on $ext_if from $martians to any block drop out quick on $ext_if from any to
$martians

Here, the martians macro denotes the RFC 1918 addresses and a few other ranges
which are mandated by various RFCs not to be in circulation on the open
Internet. Traffic to and from such addresses is quietly dropped on the
gateway's external interface.

The specific details of how to implement this kind of protection will vary,
among other things according to your specific network configuration. Your
network design could for example dictate that you include or exclude other
address ranges than these.

This completes our simple NATing firewall for a small local network. A more
thorough tutorial is available at http://home.nuug.no/~peter/pf/, where you
will also find slides from related presentations.

31.5.Â The IPFILTER (IPF) Firewall

IPFILTER is a cross-platform, open source firewall which has been ported to
FreeBSD, NetBSD, OpenBSD, SunOSâ ¢, HP/UX, and Solarisâ ¢ operating systems.

IPFILTER is based on a kernel-side firewall and NAT mechanism that can be
controlled and monitored by userland interface programs. The firewall rules can
be set or deleted using ipf(8). The NAT rules can be set or deleted using ipnat
(8). Run-time statistics for the kernel parts of IPFILTER can be printed using
ipfstat(8). To log IPFILTER actions to the system log files, use ipmon(8).

IPF was originally written using a rule processing logic of â  the last
matching rule winsâ   and only used stateless rules. Over time, IPF has been
enhanced to include a â  quickâ   option and a stateful â  keep stateâ   option
which modernized the rules processing logic. IPF's official documentation
covers only the legacy rule coding parameters and rule file processing logic
and the modernized functions are only included as additional options.

The instructions contained in this section are based on using rules that
contain â  quickâ   and â  keep stateâ   as these provide the basic framework
for configuring an inclusive firewall ruleset.

For a detailed explanation of the legacy rules processing method, refer to
http://www.munk.me.uk/ipf/ipf-howto.html and http://coombs.anu.edu.au/~avalon/
ip-filter.html.

The IPF FAQ is at http://www.phildev.net/ipf/index.html.

A searchable archive of the IPFilter mailing list is available at http://
marc.theaimsgroup.com/?l=ipfilter.

31.5.1.Â Enabling IPF

IPF is included in the basic FreeBSD install as a kernel loadable module. The
system will dynamically load this module at boot time when ipfilter_enable=
"YES" is added to rc.conf. The module enables logging and default pass all. To
change the default to block all, add a block all rule at the end of the
ruleset.

31.5.2.Â Kernel Options

For users who prefer to statically compile IPF support into a custom kernel,
the following IPF option statements, listed in /usr/src/sys/conf/NOTES, are
available:

options IPFILTER options IPFILTER_LOG options IPFILTER_DEFAULT_BLOCK

options IPFILTER enables support for the â  IPFILTERâ   firewall.

options IPFILTER_LOG enables IPF logging using the ipl packet logging pseudoâ  
device for every rule that has the log keyword.

options IPFILTER_DEFAULT_BLOCK changes the default behavior so that any packet
not matching a firewall pass rule gets blocked.

These settings will take effect only after installing a kernel that has been
built with the above options set.

31.5.3.Â Available rc.conf Options

To activate IPF at boot time, the following statements need to be added to /etc
/rc.conf:

ipfilter_enable="YES" # Start ipf firewall ipfilter_rules="/etc/ipf.rules" #
loads rules definition text file ipmon_enable="YES" # Start IP monitor log
ipmon_flags="-Ds" # D = start as daemon # s = log to syslog # v = log tcp
window, ack, seq # n = map IP & port to names

If there is a LAN behind the firewall that uses the reserved private IP address
ranges, the following lines have to be added to enable NAT functionality:

gateway_enable="YES" # Enable as LAN gateway ipnat_enable="YES" # Start ipnat
function ipnat_rules="/etc/ipnat.rules" # rules definition file for ipnat

31.5.4.Â IPF

To load the ruleset file, use ipf(8). Custom rules are normally placed in a
file, and the following command can be used to replace the currently running
firewall rules:

# ipf -Fa -f /etc/ipf.rules

-Fa flushes all the internal rules tables.

-f specifies the file containing the rules to load.

This provides the ability to make changes to a custom rules file, run the above
IPF command, and thus update the running firewall with a fresh copy of the
rules without having to reboot the system. This method is convenient for
testing new rules as the procedure can be executed as many times as needed.

Refer to ipf(8) for details on the other flags available with this command.

ipf(8) expects the rules file to be a standard text file. It will not accept a
rules file written as a script with symbolic substitution.

There is a way to build IPF rules that utilize the power of script symbolic
substitution. For more information, see SectionÂ 31.5.9, â  Building the Rule
Script with Symbolic Substitutionâ  .

31.5.5.Â IPFSTAT

The default behavior of ipfstat(8) is to retrieve and display the totals of the
accumulated statistics gathered by applying the rules against packets going in
and out of the firewall since it was last started, or since the last time the
accumulators were reset to zero using ipf -Z.

Refer to ipfstat(8) for details.

The default ipfstat(8) output will look something like this:

input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0 output
packets: blocked 4200 passed 1284345 nomatch 14687 counted 0 input packets
logged: blocked 99286 passed 0 output packets logged: blocked 0 passed 0
packets logged: input 0 output 0 log failures: input 3898 output 0 fragment
state(in): kept 0 lost 0 fragment state(out): kept 0 lost 0 packet state(in):
kept 169364 lost 0 packet state(out): kept 431395 lost 0 ICMP replies: 0 TCP
RSTs sent: 0 Result cache hits(in): 1215208 (out): 1098963 IN Pullups
succeeded: 2 failed: 0 OUT Pullups succeeded: 0 failed: 0 Fastroute successes:
0 failures: 0 TCP cksum fails(in): 0 (out): 0 Packet log flags set: (0)

When supplied with either -i for inbound or -o for outbound, the command will
retrieve and display the appropriate list of filter rules currently installed
and in use by the kernel.

ipfstat -in displays the inbound internal rules table with rule numbers.

ipfstat -on displays the outbound internal rules table with rule numbers.

The output will look something like this:

@1 pass out on xl0 from any to any @2 block out on dc0 from any to any @3 pass
out quick on dc0 proto tcp/udp from any to any keep state

ipfstat -ih displays the inbound internal rules table, prefixing each rule with
a count of how many times the rule was matched.

ipfstat -oh displays the outbound internal rules table, prefixing each rule
with a count of how many times the rule was matched.

The output will look something like this:

2451423 pass out on xl0 from any to any 354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state

One of the most important options of ipfstat is -t which displays the state
table in a way similar to how top(1) shows the FreeBSD running process table.
When a firewall is under attack, this function provides the ability to identify
and see the attacking packets. The optional sub-flags give the ability to
select the destination or source IP, port, or protocol to be monitored in real
time. Refer to ipfstat(8) for details.

31.5.6.Â IPMON

In order for ipmon to work properly, the kernel option IPFILTER_LOG must be
turned on. This command has two different modes. Native mode is the default
mode when the command is used without -D.

Daemon mode provides a continuous system log file so that logging of past
events may be reviewed. FreeBSD has a built in facility to automatically rotate
system logs. This is why outputting the log information to syslogd(8) is better
than the default of outputting to a regular file. The default rc.conf
ipmon_flags statement uses -Ds:

ipmon_flags="-Ds" # D = start as daemon # s = log to syslog # v = log tcp
window, ack, seq # n = map IP & port to names

Logging provides the ability to review, after the fact, information such as
which packets were dropped, what addresses they came from and where they were
going. These can all provide a significant edge in tracking down attackers.

Even with the logging facility enabled, IPF will not generate any rule logging
by default. The firewall administrator decides which rules in the ruleset
should be logged and adds the log keyword to those rules. Normally, only deny
rules are logged.

It is customary to include a â  default deny everythingâ   rule with the log
keyword included as the last rule in the ruleset. This makes it possible to see
all the packets that did not match any of the rules in the ruleset.

31.5.7.Â IPMON Logging

syslogd(8) uses its own method for segregation of log data. It uses groupings
called â  facilityâ   and â  levelâ  . By default, IPMON in -Ds mode uses
local0 as the â  facilityâ   name. The following levels can be used to further
segregate the logged data:

LOG_INFO - packets logged using the "log" keyword as the action rather than
pass or block. LOG_NOTICE - packets logged which are also passed LOG_WARNING -
packets logged which are also blocked LOG_ERR - packets which have been logged
and which can be considered short

In order to setup IPFILTER to log all data to /var/log/ipfilter.log, first
create the empty file:

# touch /var/log/ipfilter.log

syslogd(8) is controlled by definition statements in /etc/syslog.conf. This
file offers considerable flexibility in how syslog will deal with system
messages issued by software applications like IPF.

To write all logged messages to the specified file, add the following statement
to /etc/syslog.conf:

local0.* /var/log/ipfilter.log

To activate the changes and instruct syslogd(8) to read the modified /etc/
syslog.conf, run service syslogd reload.

Do not forget to change /etc/newsyslog.conf to rotate the new log file.

31.5.8.Â The Format of Logged Messages

Messages generated by ipmon consist of data fields separated by white space.
Fields common to all messages are:

 1. The date of packet receipt.

 2. The time of packet receipt. This is in the form HH:MM:SS.F, for hours,
    minutes, seconds, and fractions of a second.

 3. The name of the interface that processed the packet.

 4. The group and rule number of the rule in the format @0:17.

These can be viewed with ipfstat -in.

 1. The action: p for passed, b for blocked, S for a short packet, n did not
    match any rules, and L for a log rule. The order of precedence in showing
    flags is: S, p, b, n, L. A capital P or B means that the packet has been
    logged due to a global logging setting, not a particular rule.

 2. The addresses written as three fields: the source address and port
    separated by a comma, the -&gt; symbol, and the destination address and port.
    For example: 209.53.17.22,80 -&gt; 198.73.220.17,1722.

 3. PR followed by the protocol name or number: for example, PR tcp.

 4. len followed by the header length and total length of the packet: for
    example, len 20 40.

If the packet is a TCP packet, there will be an additional field starting with
a hyphen followed by letters corresponding to any flags that were set. Refer to
ipf(5) for a list of letters and their flags.

If the packet is an ICMP packet, there will be two fields at the end: the first
always being â  ICMPâ   and the next being the ICMP message and sub-message
type, separated by a slash. For example: ICMP 3/3 for a port unreachable
message.

31.5.9.Â Building the Rule Script with Symbolic Substitution

Some experienced IPF users create a file containing the rules and code them in
a manner compatible with running them as a script with symbolic substitution.
The major benefit of doing this is that only the value associated with the
symbolic name needs to be changed, and when the script is run all the rules
containing the symbolic name will have the value substituted in the rules.
Being a script, symbolic substitution can be used to code frequently used
values and substitute them in multiple rules. This can be seen in the following
example.

The script syntax used here is compatible with the sh(1), csh(1), and tcsh(1)
shells.

Symbolic substitution fields are prefixed with a $.

Symbolic fields do not have the $ prefix.

The value to populate the symbolic field must be enclosed between double quotes
(").

Start the rule file with something like this:

############# Start of IPF rules script ######################## oif="dc0" #
name of the outbound interface odns="192.0.2.11" # ISP's DNS server IP address
myip="192.0.2.7" # my static IP address from ISP ks="keep state" fks="flags S
keep state" # You can choose between building /etc/ipf.rules file # from this
script or running this script "as is". # # Uncomment only one line and comment
out another. # # 1) This can be used for building /etc/ipf.rules: #cat &gt; /etc/
ipf.rules &lt;&lt; EOF # # 2) This can be used to run script "as is": /sbin/ipf -Fa
-f - &lt;&lt; EOF # Allow out access to my ISP's Domain name server. pass out quick
on $oif proto tcp from any to $odns port = 53 $fks pass out quick on $oif proto
udp from any to $odns port = 53 $ks # Allow out non-secure standard www
function pass out quick on $oif proto tcp from $myip to any port = 80 $fks #
Allow out secure www function https over TLS SSL pass out quick on $oif proto
tcp from $myip to any port = 443 $fks EOF ################## End of IPF rules
script ########################

The rules are not important in this example as it instead focuses on how the
symbolic substitution fields are populated. If this example was in a file named
/etc/ipf.rules.script, these rules could be reloaded by running:

# sh /etc/ipf.rules.script

There is one problem with using a rules file with embedded symbolics: IPF does
not understand symbolic substitution, and cannot read such scripts directly.

This script can be used in one of two ways:

  * Uncomment the line that begins with cat, and comment out the line that
    begins with /sbin/ipf. Place ipfilter_enable="YES" into /etc/rc.conf, and
    run the script once after each modification to create or update /etc/
    ipf.rules.

  * Disable IPFILTER in the system startup scripts by adding ipfilter_enable=
    "NO"to /etc/rc.conf.

    Then, add a script like the following to /usr/local/etc/rc.d/. The script
    should have an obvious name like ipf.loadrules.sh, where the .sh extension
    is mandatory.

    #!/bin/sh sh /etc/ipf.rules.script

    The permissions on this script file must be read, write, execute for owner
    root:

    # chmod 700 /usr/local/etc/rc.d/ipf.loadrules.sh

Now, when the system boots, the IPF rules will be loaded.

31.5.10.Â IPF Rulesets

A ruleset contains a group of IPF rules which pass or block packets based on
the values contained in the packet. The bi-directional exchange of packets
between hosts comprises a session conversation. The firewall ruleset processes
both the packets arriving from the public Internet, as well as the packets
produced by the system as a response to them. Each TCP/IP service is predefined
by its protocol and listening port. Packets destined for a specific service
originate from the source address using an unprivileged port and target the
specific service port on the destination address. All the above parameters can
be used as selection criteria to create rules which will pass or block
services.

Warning:

When working with the firewall rules, be very careful. Some configurations can
lock the administrator out of the server. To be on the safe side, consider
performing the initial firewall configuration from the local console rather
than doing it remotely over ssh.

31.5.11.Â Rule Syntax

The rule syntax presented here has been simplified to only address the modern
stateful rule context and â  first matching rule winsâ   logic. For the
complete legacy rule syntax, refer to ipf(8).

A # character is used to mark the start of a comment and may appear at the end
of a rule line or on its own line. Blank lines are ignored.

Rules contain keywords which must be written in a specific order from left to
right on the line. Keywords are identified in bold type. Some keywords have
sub-options which may be keywords themselves and also include more sub-options.
Each of the headings in the below syntax has a bold section header which
expands on the content.

ACTION IN-OUT OPTIONS SELECTION STATEFUL PROTO SRC_ADDR,DST_ADDR OBJECT
PORT_NUM TCP_FLAG STATEFUL

ACTION = block | pass

IN-OUT = in | out

OPTIONS = log | quick | on interface-name

SELECTION = proto value | source/destination IP | port = number | flags
flag-value

PROTO = tcp/udp | udp | tcp | icmp

SRC_ADD,DST_ADDR = all | from object to object

OBJECT = IP address | any

PORT_NUM = port number

TCP_FLAG = S

STATEFUL = keep state

31.5.11.1.Â ACTION

The action keyword indicates what to do with the packet if it matches the rest
of the filter rule. Each rule must have an action. The following actions are
recognized:

block indicates that the packet should be dropped if the selection parameters
match the packet.

pass indicates that the packet should exit the firewall if the selection
parameters match the packet.

31.5.11.2.Â IN-OUT

A mandatory requirement is that each filter rule explicitly state which side of
the I/O it is to be used on. The next keyword must be either in or out and one
or the other has to be included or the rule will not pass syntax checks.

in means this rule is being applied against an inbound packet which has just
been received on the interface facing the public Internet.

out means this rule is being applied against an outbound packet destined for
the interface facing the public Internet.

31.5.11.3.Â OPTIONS

Note:

These options must be used in the order shown here.

log indicates that the packet header will be written to the ipl(4) packet log
pseudo-device if the selection parameters match the packet.

quick indicates that if the selection parameters match the packet, this rule
will be the last rule checked, and no further processing of any following rules
will occur for this packet.

on indicates the interface name to be incorporated into the selection
parameters. Interface names are as displayed by ifconfig(8). Using this option,
the rule will only match if the packet is going through that interface in the
specified direction.

When a packet is logged, the headers of the packet are written to the ipl(4)
packet logging pseudo-device. Immediately following the log keyword, the
following qualifiers may be used in this order:

body indicates that the first 128 bytes of the packet contents will be logged
after the headers.

first. If the log keyword is being used in conjunction with a keep state
option, this option is recommended so that only the triggering packet is logged
and not every packet which matches the stateful connection.

31.5.11.4.Â SELECTION

The keywords described in this section are used to describe attributes of the
packet to be checked when determining whether or not rules match. There is a
keyword subject, and it has sub-option keywords, one of which has to be
selected. The following general-purpose attributes are provided for matching,
and must be used in this order:

31.5.11.5.Â PROTO

proto is the subject keyword which must include one of its corresponding
keyword sub-option values. The sub-option indicates a specific protocol to be
matched against.

tcp/udp | udp | tcp | icmp or any protocol names found in /etc/protocols are
recognized and may be used. The special protocol keyword tcp/udp may be used to
match either a TCP or a UDP packet, and has been added as a convenience to save
duplication of otherwise identical rules.

31.5.11.6.Â SRC_ADDR/DST_ADDR

The all keyword is equivalent to â  from any to anyâ   with no other match
parameters.

from | to src to dst: the from and to keywords are used to match against IP
addresses. Rules must specify both the source and destination parameters. any
is a special keyword that matches any IP address. Examples include: from any to
any, from 0.0.0.0/0 to any, from any to 0.0.0.0/0, from 0.0.0.0 to any, and
from any to 0.0.0.0.

There is no way to match ranges of IP addresses which do not express themselves
easily using the dotted numeric form / mask-length notation. The net-mgmt/
ipcalc port may be used to ease the calculation. Additional information is
available at the utility's web page: http://jodies.de/ipcalc.

31.5.11.7.Â PORT

If a port match is included, for either or both of source and destination, it
is only applied to TCP and UDP packets. When composing port comparisons, either
the service name from /etc/services or an integer port number may be used. When
the port appears as part of the from object, it matches the source port number.
When it appears as part of the to object, it matches the destination port
number. An example usage is from any to any port = 80

Single port comparisons may be done in a number of ways, using a number of
different comparison operators. Instead of the = shown in the example above,
the following operators may be used: !=, &lt;, &gt;, &lt;=, &gt;=, eq, ne, lt, gt, le, and
ge.

To specify port ranges, place the two port numbers between &lt;&gt; or &gt;&lt;

31.5.11.8.Â TCP_FLAG

Flags are only effective for TCP filtering. The letters represent one of the
possible flags that can be matched against the TCP packet header.

The modernized rules processing logic uses the flags S parameter to identify
the TCP session start request.

31.5.11.9.Â STATEFUL

keep state indicates that on a pass rule, any packets that match the rules
selection parameters should activate the stateful filtering facility.

31.5.12.Â Stateful Filtering

Stateful filtering treats traffic as a bi-directional exchange of packets
comprising a session. When activated, keep-state dynamically generates internal
rules for each anticipated packet being exchanged during the session. It has
sufficient matching capabilities to determine if a packet is valid for a
session. Any packets that do not properly fit the session template are
automatically rejected.

IPF stateful filtering will also allow ICMP packets related to an existing TCP
or UDP session. So, if an ICMP type 3 code 4 packet is a response in a session
started by a keep state rule, it will automatically be allowed. Any packet that
IPF can be certain is part of an active session, even if it is a different
protocol, will be allowed.

Packets destined to go out through the interface connected to the public
Internet are first checked against the dynamic state table. If the packet
matches the next expected packet comprising an active session conversation, it
exits the firewall and the state of the session conversation flow is updated in
the dynamic state table. Packets that do not belong to an already active
session, are checked against the outbound ruleset.

Packets coming in from the interface connected to the public Internet are first
checked against the dynamic state table. If the packet matches the next
expected packet comprising an active session, it exits the firewall and the
state of the session conversation flow is updated in the dynamic state table.
Packets that do not belong to an already active session, are checked against
the inbound ruleset.

When the session completes, it is removed from the dynamic state table.

Stateful filtering allows one to focus on blocking/passing new sessions. If the
new session is passed, all its subsequent packets are allowed automatically and
any impostor packets are automatically rejected. If a new session is blocked,
none of its subsequent packets are allowed. Stateful filtering provides
advanced matching abilities capable of defending against the flood of different
attack methods employed by attackers.

31.5.13.Â Inclusive Ruleset Example

The following ruleset is an example of an inclusive type of firewall which only
allows services matching pass rules and blocks all others by default. Network
firewalls intended to protect other machines should have at least two
interfaces, and are generally configured to trust the LAN and to not trust the
public Internet. Alternatively, a host based firewall might be configured to
protect only the system it is running on, and is appropriate for servers on an
untrusted network or a desktop system not protected by firewall on the network.

FreeBSD uses interface lo0 and IP address 127.0.0.1 for internal communication
within the operating system. The firewall rules must contain rules to allow
free movement of these internally used packets.

The interface which faces the public Internet is the one specified in the rules
that authorize and control access of the outbound and inbound connections.

In cases where one or more NICs are cabled to private network segments, those
interfaces may require rules to allow packets originating from those LAN
interfaces transit to each other or to the Internet.

The rules should be organized into three major sections: the trusted
interfaces, then the public interface outbound, and lastly, the public
untrusted interface inbound.

The rules in each of the public interface sections should have the most
frequently matched rules placed before less commonly matched rules, with the
last rule in the section blocking and logging all packets on that interface and
direction.

The outbound section in the following ruleset only contains pass rules which
uniquely identify the services that are authorized for public Internet access.
All the rules use quick, on, proto, port, and keep state. The proto tcp rules
include flag to identify the session start request as the triggering packet to
activate the stateful facility.

The inbound section blocks undesirable packets first, for two different
reasons. The first is that malicious packets may be partial matches for
legitimate traffic. These packets have to be discarded rather than allowed,
based on their partial matches against the allow rules. The second reason is
that known and uninteresting rejects may be blocked silently, rather than being
logged by the last rule in the section.

The ruleset should ensure that there is no response returned for any
undesirable traffic. Invalid packets should be silently dropped so that the
attacker has no knowledge if the packets reached the system. Rules that include
a log first option, will only log the event the first time they are triggered.
This option is included in the sample nmap OS fingerprint rule. The security/
nmap utility is commonly used by attackers who attempt to identify the
operating system of the server.

Any time there are logged messages on a rule with the log first option, ipfstat
-hio should be executed to evaluate how many times the rule has been matched. A
large number of matches usually indicates that the system is being flooded or
is under attack.

To lookup unknown port numbers, refer to /etc/services. Alternatively, visit
http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers and do a port
number lookup to find the purpose of a particular port number.

Check out this link for port numbers used by Trojans http://www.sans.org/
security-resources/idfaq/oddports.php.

The following ruleset creates an inclusive firewall ruleset which can be easily
customized by commenting out pass rules for services that should not be
authorized.

To avoid logging unwanted messages, add a block rule in the inbound section.

Change the dc0 interface name in every rule to the interface name that connects
the system to the public Internet.

The following statements were added to /etc/ipf.rules:

################################################################# # No
restrictions on Inside LAN Interface for private network # Not needed unless
you have LAN #################################################################
#pass out quick on xl0 all #pass in quick on xl0 all ##########################
####################################### # No restrictions on Loopback Interface
################################################################# pass in quick
on lo0 all pass out quick on lo0 all ##########################################
####################### # Interface facing Public Internet (Outbound Section) #
Match session start requests originating from behind the # firewall on the
private network # or from this gateway server destined for the public Internet.
################################################################# # Allow out
access to my ISP's Domain name server. # xxx must be the IP address of your
ISP's DNS. # Dup these lines if your ISP has more than one DNS server # Get the
IP addresses from /etc/resolv.conf file pass out quick on dc0 proto tcp from
any to xxx port = 53 flags S keep state pass out quick on dc0 proto udp from
any to xxx port = 53 keep state # Allow out access to my ISP's DHCP server for
cable or DSL networks. # This rule is not needed for 'user ppp' type connection
to the # public Internet, so you can delete this whole group. # Use the
following rule and check log for IP address. # Then put IP address in commented
out rule & delete first rule pass out log quick on dc0 proto udp from any to
any port = 67 keep state #pass out quick on dc0 proto udp from any to z.z.z.z
port = 67 keep state # Allow out non-secure standard www function pass out
quick on dc0 proto tcp from any to any port = 80 flags S keep state # Allow out
secure www function https over TLS SSL pass out quick on dc0 proto tcp from any
to any port = 443 flags S keep state # Allow out send & get email function pass
out quick on dc0 proto tcp from any to any port = 110 flags S keep state pass
out quick on dc0 proto tcp from any to any port = 25 flags S keep state # Allow
out Time pass out quick on dc0 proto tcp from any to any port = 37 flags S keep
state # Allow out nntp news pass out quick on dc0 proto tcp from any to any
port = 119 flags S keep state # Allow out gateway & LAN users' non-secure FTP (
both passive & active modes) # This function uses the IPNAT built in FTP proxy
function coded in # the nat rules file to make this single rule function
correctly. # If you want to use the pkg_add command to install application
packages # on your gateway system you need this rule. pass out quick on dc0
proto tcp from any to any port = 21 flags S keep state # Allow out ssh/sftp/scp
(telnet/rlogin/FTP replacements) # This function is using SSH (secure shell)
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state #
Allow out insecure Telnet pass out quick on dc0 proto tcp from any to any port
= 23 flags S keep state # Allow out FreeBSD CVSup pass out quick on dc0 proto
tcp from any to any port = 5999 flags S keep state # Allow out ping to public
Internet pass out quick on dc0 proto icmp from any to any icmp-type 8 keep
state # Allow out whois from LAN to public Internet pass out quick on dc0 proto
tcp from any to any port = 43 flags S keep state # Block and log only the first
occurrence of everything # else that's trying to get out. # This rule
implements the default block block out log first quick on dc0 all #############
#################################################### # Interface facing Public
Internet (Inbound Section) # Match packets originating from the public Internet
# destined for this gateway server or the private network. ####################
############################################# # Block all inbound traffic from
non-routable or reserved address spaces block in quick on dc0 from 192.168.0.0/
16 to any #RFC 1918 private IP block in quick on dc0 from 172.16.0.0/12 to any
#RFC 1918 private IP block in quick on dc0 from 10.0.0.0/8 to any #RFC 1918
private IP block in quick on dc0 from 127.0.0.0/8 to any #loopback block in
quick on dc0 from 0.0.0.0/8 to any #loopback block in quick on dc0 from
169.254.0.0/16 to any #DHCP auto-config block in quick on dc0 from 192.0.2.0/24
to any #reserved for docs block in quick on dc0 from 204.152.64.0/23 to any #
Sun cluster interconnect block in quick on dc0 from 224.0.0.0/3 to any #Class D
& E multicast ##### Block a bunch of different nasty things. ############ #
That I do not want to see in the log # Block frags block in quick on dc0 all
with frags # Block short tcp packets block in quick on dc0 proto tcp all with
short # block source routed packets block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr # Block nmap OS fingerprint attempts #
Log first occurrence of these so I can get their IP address block in log first
quick on dc0 proto tcp from any to any flags FUP # Block anything with special
options block in quick on dc0 all with ipopts # Block public pings block in
quick on dc0 proto icmp all icmp-type 8 # Block ident block in quick on dc0
proto tcp from any to any port = 113 # Block all Netbios service. 137=name, 138
=datagram, 139=session # Netbios is MS/Windows sharing services. # Block MS/
Windows hosts2 name server requests 81 block in log first quick on dc0 proto
tcp/udp from any to any port = 137 block in log first quick on dc0 proto tcp/
udp from any to any port = 138 block in log first quick on dc0 proto tcp/udp
from any to any port = 139 block in log first quick on dc0 proto tcp/udp from
any to any port = 81 # Allow traffic in from ISP's DHCP server. This rule must
contain # the IP address of your ISP's DHCP server as it is the only #
authorized source to send this packet type. Only necessary for # cable or DSL
configurations. This rule is not needed for # 'user ppp' type connection to the
public Internet. # This is the same IP address you captured and # used in the
outbound section. pass in quick on dc0 proto udp from z.z.z.z to any port = 68
keep state # Allow in standard www function because I have apache server pass
in quick on dc0 proto tcp from any to any port = 80 flags S keep state # Allow
in non-secure Telnet session from public Internet # labeled non-secure because
ID/PW passed over public Internet as clear text. # Delete this sample group if
you do not have telnet server enabled. #pass in quick on dc0 proto tcp from any
to any port = 23 flags S keep state # Allow in secure FTP, Telnet, and SCP from
public Internet # This function is using SSH (secure shell) pass in quick on
dc0 proto tcp from any to any port = 22 flags S keep state # Block and log only
first occurrence of all remaining traffic # coming into the firewall. The
logging of only the first # occurrence avoids filling up disk with Denial of
Service logs. # This rule implements the default block. block in log first
quick on dc0 all ################### End of rules file ########################
#############

31.5.14.Â NAT

NAT stands for Network Address Translation. In LinuxÂ®, NAT is called â  IP
Masqueradingâ  . The IPF NAT function enables the private LAN behind the
firewall to share a single ISP-assigned IP address, even if that address is
dynamically assigned. NAT allows each computer in the LAN to have Internet
access, without having to pay the ISP for multiple Internet accounts or IP
addresses.

NAT will automatically translate the private LAN IP address for each system on
the LAN to the single public IP address as packets exit the firewall bound for
the public Internet. It also performs the reverse translation for returning
packets.

According to RFC 1918, the following IP address ranges are reserved for private
networks which will never be routed directly to the public Internet, and
therefore are available for use with NAT:

  * 10.0.0.0/8.

  * 172.16.0.0/12.

  * 192.168.0.0/16.

31.5.15.Â IPNAT

NAT rules are loaded using ipnat. Typically, the NAT rules are stored in /etc/
ipnat.rules. See ipnat(8) for details.

When the file containing the NAT rules is edited after NAT has been started,
run ipnat with -CF to delete the internal in use NAT rules and flush the
contents of the translation table of all active entries.

To reload the NAT rules, issue a command like this:

# ipnat -CF -f /etc/ipnat.rules

To display some NAT statistics, use this command:

# ipnat -s

To list the NAT table's current mappings, use this command:

# ipnat -l

To turn verbose mode on and display information relating to rule processing and
active rules/table entries:

# ipnat -v

31.5.16.Â IPNAT Rules

NAT rules are flexible and can accomplish many different things to fit the
needs of commercial and home users.

The rule syntax presented here has been simplified to what is most commonly
used in a non-commercial environment. For a complete rule syntax description,
refer to ipnat(5).

The syntax for a NAT rule looks like this:

map IF LAN_IP_RANGE -&gt; PUBLIC_ADDRESS

The keyword map starts the rule.

Replace IF with the external interface.

The LAN_IP_RANGE is used by the internal clients use for IP Addressing.
Usually, this is something like 192.168.1.0/24.

The PUBLIC_ADDRESS can either be the static external IP address or the special
keyword 0/32 which uses the IP address assigned to IF.

31.5.17.Â How NAT Works

In IPF, when a packet arrives at the firewall from the LAN with a public
destination, it passes through the outbound filter rules. NAT gets its turn at
the packet and applies its rules top down, where the first matching rule wins. 
NAT tests each of its rules against the packet's interface name and source IP
address. When a packet's interface name matches a NAT rule, the packet's source
IP address in the private LAN is checked to see if it falls within the IP
address range specified to the left of the arrow symbol on the NAT rule. On a
match, the packet has its source IP address rewritten with the public IP
address obtained by the 0/32 keyword. NAT posts an entry in its internal NAT
table so when the packet returns from the public Internet it can be mapped back
to its original private IP address and then passed to the filter rules for
processing.

31.5.18.Â Enabling IPNAT

To enable IPNAT, add these statements to /etc/rc.conf.

To enable the machine to route traffic between interfaces:

gateway_enable="YES"

To start IPNAT automatically each time:

ipnat_enable="YES"

To specify where to load the IPNAT rules from:

ipnat_rules="/etc/ipnat.rules"

31.5.19.Â NAT for a Large LAN

For networks that have large numbers of systems on the LAN or networks with
more than a single LAN, the process of funneling all those private IP addresses
into a single public IP address becomes a resource problem that may cause
problems with the same port numbers being used many times across many
connections, causing collisions. There are two ways to relieve this resource
problem.

31.5.19.1.Â Assigning Ports to Use

A normal NAT rule would look like:

map dc0 192.168.1.0/24 -&gt; 0/32

In the above rule, the packet's source port is unchanged as the packet passes
through IPNAT. By adding the portmap keyword, IPNAT can be directed to only use
source ports in the specified range. For example, the following rule will tell
IPNAT to modify the source port to be within the range shown:

map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000

Additionally, the auto keyword tells IPNAT to determine which ports are
available for use:

map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto

31.5.19.2.Â Using a Pool of Public Addresses

In very large LANs there comes a point where there are just too many LAN
addresses to fit into a single public address. If a block of public IP
addresses is available, these addresses can be used as a â  poolâ  , and IPNAT
may pick one of the public IP addresses as packet addresses are mapped on their
way out.

For example, instead of mapping all packets through a single public IP address:

map dc0 192.168.1.0/24 -&gt; 204.134.75.1

A range of public IP addresses can be specified either with a netmask:

map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0

or using CIDR notation:

map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24

31.5.20.Â Port Redirection

A common practice is to have a web server, email server, database server, and
DNS server each segregated to a different system on the LAN. In this case, the
traffic from these servers still has to undergo NAT, but there has to be some
way to direct the inbound traffic to the correct server. For example, a web
server operating on LAN address 10.0.10.25 and using a single public IP address
of 20.20.20.5, would use this rule:

rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80

or:

rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80

For a LAN DNS server on a private address of 10.0.10.33 that needs to receive
public DNS requests:

rdr dc0 20.20.20.5/32 port 53 -&gt; 10.0.10.33 port 53 udp

31.5.21.Â FTP and NAT

FTP has two modes: active mode and passive mode. The difference is in how the
data channel is acquired. Passive mode is more secure as the data channel is
acquired by the ordinal ftp session requester. For a good explanation of FTP
and the different modes, see http://www.slacksite.com/other/ftp.html.

31.5.21.1.Â IPNAT Rules

IPNAT has a built in FTP proxy option which can be specified on the NAT map
rule. It can monitor all outbound packet traffic for FTP active or passive
start session requests and dynamically create temporary filter rules containing
the port number being used by the data channel. This eliminates the security
risk FTP normally exposes the firewall to as it no longer needs to open large
ranges of high order ports for FTP connections.

This rule will handle all the traffic for the internal LAN:

map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp

This rule handles the FTP traffic from the gateway:

map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp

This rule handles all non-FTP traffic from the internal LAN:

map dc0 10.0.10.0/29 -&gt; 0/32

The FTP map rules go before the NAT rule so that when a packet matches an FTP
rule, the FTP proxy creates temporary filter rules to let the FTP session
packets pass and undergo NAT. All LAN packets that are not FTP will not match
the FTP rules but will undergo NAT if they match the third rule.

31.5.21.2.Â IPNAT FTP Filter Rules

Only one filter rule is needed for FTP if the NAT FTP proxy is used.

Without the FTP proxy, the following three rules will be needed:

# Allow out LAN PC client FTP to public Internet # Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state #
Allow out passive mode data channel high order port numbers pass out quick on
rl0 proto tcp from any to any port &gt; 1024 flags S keep state # Active mode let
data channel in from FTP server pass in quick on rl0 proto tcp from any to any
port = 20 flags S keep state

31.6.Â IPFW

IPFW is a stateful firewall written for FreeBSD which also provides a traffic
shaper, packet scheduler, and in-kernel NAT.

FreeBSD provides a sample ruleset in /etc/rc.firewall. The sample ruleset
define several firewall types for common scenarios to assist novice users in
generating an appropriate ruleset. ipfw(8) provides a powerful syntax which
advanced users can use to craft customized rulesets that meet the security
requirements of a given environment.

IPFW is composed of several components: the kernel firewall filter rule
processor and its integrated packet accounting facility, the logging facility,
the divert rule which triggers NAT, the dummynet traffic shaper facilities, the
fwd rule forward facility, the bridge facility, and the ipstealth facility.
IPFW supports both IPv4 and IPv6.

31.6.1.Â Enabling IPFW

IPFW is included in the basic FreeBSD install as a run time loadable module.
The system will dynamically load the kernel module when rc.conf contains the
statement firewall_enable="YES". After rebooting the system, the following
white highlighted message is displayed on the screen as part of the boot
process:

ipfw2 initialized, divert disabled, rule-based forwarding disabled, default to
deny, logging disabled

The loadable module includes logging ability. To enable logging and set the
verbose logging limit, add these statements to /etc/sysctl.conf before
rebooting:

net.inet.ip.fw.verbose=1 net.inet.ip.fw.verbose_limit=5

31.6.2.Â Kernel Options

For those users who wish to statically compile kernel IPFW support, the
following options are available for the custom kernel configuration file:

options IPFIREWALL

This option enables IPFW as part of the kernel.

options IPFIREWALL_VERBOSE

This option enables logging of packets that pass through IPFW and have the log
keyword specified in the ruleset.

options IPFIREWALL_VERBOSE_LIMIT=5

This option limits the number of packets logged through syslogd(8), on a
per-entry basis. This option may be used in hostile environments, when firewall
activity logging is desired. This will close a possible denial of service
attack via syslog flooding.

options IPFIREWALL_DEFAULT_TO_ACCEPT

This option allows everything to pass through the firewall by default, which is
a good idea when the firewall is being set up for the first time.

options IPDIVERT

This option enables the use of NAT functionality.

Note:

The firewall will block all incoming and outgoing packets if either the
IPFIREWALL_DEFAULT_TO_ACCEPT kernel option or a rule to explicitly allow these
connections is missing.

31.6.3.Â /etc/rc.conf Options

Enables the firewall:

firewall_enable="YES"

To select one of the default firewall types provided by FreeBSD, select one by
reading /etc/rc.firewall and specify it in the following:

firewall_type="open"

Available values for this setting are:

  * open: passes all traffic.

  * client: protects only this machine.

  * simple: protects the whole network.

  * closed: entirely disables IP traffic except for the loopback interface.

  * UNKNOWN: disables the loading of firewall rules.

  * filename: absolute path of the file containing the firewall rules.

Two methods are available for loading custom ipfw rules. One is to set the
firewall_type variable to the absolute path of the file which contains the
firewall rules.

The other method is to set the firewall_script variable to the absolute path of
an executable script that includes ipfw commands. A ruleset script that blocks
all incoming and outgoing traffic would look like this:

#!/bin/sh ipfw -q flush ipfw add deny in ipfw add deny out

Note:

If firewall_type is set to either client or simple, modify the default rules
found in /etc/rc.firewall to fit the configuration of the system. The examples
used in this section assume that the firewall_script is set to /etc/ipfw.rules.

Enable logging:

firewall_logging="YES"

Warning:

firewall_logging sets the net.inet.ip.fw.verbose sysctl variable to the value
of 1. There is no rc.conf variable to set log limitations, but the desired
value can be set using sysctl or by adding the following variable and desired
value to /etc/sysctl.conf:

net.inet.ip.fw.verbose_limit=5

If the machine is acting as a gateway providing NAT using natd(8), refer to
SectionÂ 32.10, â  Network Address Translationâ   for information regarding the
required /etc/rc.conf options.

31.6.4.Â The IPFW Command

ipfw can be used to make manual, single rule additions or deletions to the
active firewall while it is running. The problem with using this method is that
all the changes are lost when the system reboots. It is recommended to instead
write all the rules in a file and to use that file to load the rules at boot
time and to replace the currently running firewall rules whenever that file
changes.

ipfw is a useful way to display the running firewall rules to the console
screen. The IPFW accounting facility dynamically creates a counter for each
rule that counts each packet that matches the rule. During the process of
testing a rule, listing the rule with its counter is one way to determine if
the rule is functioning as expected.

To list all the running rules in sequence:

# ipfw list

To list all the running rules with a time stamp of when the last time the rule
was matched:

# ipfw -t list

The next example lists accounting information and the packet count for matched
rules along with the rules themselves. The first column is the rule number,
followed by the number of matched packets and bytes, followed by the rule
itself.

# ipfw -a list

To list dynamic rules in addition to static rules:

# ipfw -d list

To also show the expired dynamic rules:

# ipfw -d -e list

To zero the counters:

# ipfw zero

To zero the counters for just the rule with number NUM:

# ipfw zero NUM

31.6.5.Â IPFW Rulesets

When a packet enters the IPFW firewall, it is compared against the first rule
in the ruleset and progresses one rule at a time, moving from top to bottom of
the set in ascending rule number sequence order. When the packet matches the
selection parameters of a rule, the rule's action field value is executed and
the search of the ruleset terminates for that packet. This is referred to as â 
 first match winsâ  . If the packet does not match any of the rules, it gets
caught by the mandatory IPFW default rule, number 65535, which denies all
packets and silently discards them. However, if the packet matches a rule that
contains the count, skipto, or tee keywords, the search continues. Refer to
ipfw(8) for details on how these keywords affect rule processing.

The examples in this section create an inclusive type firewall ruleset
containing the stateful keep state, limit, in, out and via options. For a
complete rule syntax description, refer to ipfw(8).

Warning:

Be careful when working with firewall rules, as it is easy to lock out even the
administrator.

31.6.5.1.Â Rule Syntax

This section describes the keywords which comprise an IPFW rule. Keywords must
be written in the following order. # is used to mark the start of a comment and
may appear at the end of a rule line or on its own line. Blank lines are
ignored.

CMD RULE_NUMBER ACTION LOGGING SELECTION STATEFUL

31.6.5.1.1.Â CMD

Each new rule has to be prefixed with add to add the rule to the internal
table.

31.6.5.1.2.Â RULE_NUMBER

Each rule is associated with a rule_number in the range of 1 to 65535.

31.6.5.1.3.Â ACTION

A rule can be associated with one of the following actions. The specified
action will be executed when the packet matches the selection criterion of the
rule.

allow | accept | pass | permit

These keywords are equivalent as they allow packets that match the rule to exit
the firewall rule processing. The search terminates at this rule.

check-state

Checks the packet against the dynamic rules table. If a match is found, execute
the action associated with the rule which generated this dynamic rule,
otherwise move to the next rule. A check-state rule does not have selection
criterion. If no check-state rule is present in the ruleset, the dynamic rules
table is checked at the first keep-state or limit rule.

deny | drop

Both words mean the same thing, which is to discard packets that match this
rule. The search terminates.

31.6.5.1.4.Â Logging

When a packet matches a rule with the log keyword, a message will be logged to
syslogd(8) with a facility name of SECURITY. Logging only occurs if the number
of packets logged for that particular rule does not exceed the logamount
parameter. If no logamount is specified, the limit is taken from the sysctl
value of net.inet.ip.fw.verbose_limit. In both cases, a value of zero removes
the logging limit. Once the limit is reached, logging can be re-enabled by
clearing the logging counter or the packet counter for that rule, using ipfw
reset log.

Note:

Logging is done after all other packet matching conditions have been met, and
before performing the final action on the packet. The administrator decides
which rules to enable logging on.

31.6.5.1.5.Â Selection

The keywords described in this section are used to describe attributes of the
packet to be checked when determining whether rules match the packet or not.
The following general-purpose attributes are provided for matching, and must be
used in this order:

udp | tcp | icmp

Any other protocol names found in /etc/protocols can be used. The value
specified is the protocol to be matched against. This is a mandatory keyword.

from src to dst

The from and to keywords are used to match against IP addresses. Rules must
specify both source and destination parameters. any is a special keyword that
matches any IP address. me is a special keyword that matches any IP address
configured on an interface in the FreeBSD system to represent the PC the
firewall is running on. Example usage includes from me to any, from any to me,
from 0.0.0.0/0 to any, from any to 0.0.0.0/0, from 0.0.0.0 to any. from any to
0.0.0.0, and from me to 0.0.0.0. IP addresses are specified in dotted IP
address format followed by the mask in CIDR notation, or as a single host in
dotted IP address format. This keyword is a mandatory requirement. The net-mgmt
/ipcalc port may be used to assist the mask calculation.

port number

For protocols which support port numbers, such as TCP and UDP, it is mandatory
to include the port number of the service that will be matched. Service names
from /etc/services may be used instead of numeric port values.

in | out

Matches incoming or outgoing packets. It is mandatory that one or the other is
included as part of the rule matching criterion.

via IF

Matches packets going through the interface specified by device name. The via
keyword causes the interface to always be checked as part of the match process.

setup

This mandatory keyword identifies the session start request for TCP packets.

keep-state

This is a mandatory keyword. Upon a match, the firewall will create a dynamic
rule, whose default behavior is to match bidirectional traffic between source
and destination IP/port using the same protocol.

limit {src-addr | src-port | dst-addr | dst-port}

The firewall will only allow N connections with the same set of parameters as
specified in the rule. One or more of source and destination addresses and
ports can be specified. limit and keep-state can not be used on the same rule
as they provide the same stateful function.

31.6.5.2.Â Stateful Rule Option

The check-state option is used to identify where in the IPFW ruleset the packet
is to be tested against the dynamic rules facility. On a match, the packet
exits the firewall to continue on its way and a new rule is dynamically created
for the next anticipated packet being exchanged during this session. On a no
match, the packet advances to the next rule in the ruleset for testing.

The dynamic rules facility is vulnerable to resource depletion from a SYN-flood
attack which would open a huge number of dynamic rules. To counter this type of
attack with IPFW, use limit. This keyword limits the number of simultaneous
sessions by checking that rule's source or destinations fields and using the
packet's IP address in a search of the open dynamic rules, counting the number
of times this rule and IP address combination occurred. If this count is
greater than the value specified by limit, the packet is discarded.

31.6.5.3.Â Logging Firewall Messages

Even with the logging facility enabled, IPFW will not generate any rule logging
on its own. The firewall administrator decides which rules in the ruleset will
be logged, and adds the log keyword to those rules. Normally only deny rules
are logged. It is customary to duplicate the â  ipfw default deny everythingâ  
rule with the log keyword included as the last rule in the ruleset. This way,
it is possible to see all the packets that did not match any of the rules in
the ruleset.

Logging is a two edged sword. If one is not careful, an over abundance of log
data or a DoS attack can fill the disk with log files. Log messages are not
only written to syslogd, but also are displayed on the root console screen and
soon become annoying.

The IPFIREWALL_VERBOSE_LIMIT=5 kernel option limits the number of consecutive
messages sent to syslogd(8), concerning the packet matching of a given rule.
When this option is enabled in the kernel, the number of consecutive messages
concerning a particular rule is capped at the number specified. There is
nothing to be gained from 200 identical log messages. With this option set to
five, five consecutive messages concerning a particular rule would be logged to
syslogd and the remainder identical consecutive messages would be counted and
posted to syslogd with a phrase like the following:

last message repeated 45 times

All logged packets messages are written by default to /var/log/security, which
is defined in /etc/syslog.conf.

31.6.5.4.Â Building a Rule Script

Most experienced IPFW users create a file containing the rules and code them in
a manner compatible with running them as a script. The major benefit of doing
this is the firewall rules can be refreshed in mass without the need of
rebooting the system to activate them. This method is convenient in testing new
rules as the procedure can be executed as many times as needed. Being a script,
symbolic substitution can be used for frequently used values to be substituted
into multiple rules.

This example script is compatible with the syntax used by the sh(1), csh(1),
and tcsh(1) shells. Symbolic substitution fields are prefixed with a dollar
sign ($). Symbolic fields do not have the $ prefix. The value to populate the
symbolic field must be enclosed in double quotes ("").

Start the rules file like this:

############### start of example ipfw rules script ############# # ipfw -q -f
flush # Delete all rules # Set defaults oif="tun0" # out interface odns=
"192.0.2.11" # ISP's DNS server IP address cmd="ipfw -q add " # build rule
prefix ks="keep-state" # just too lazy to key this each time $cmd 00500
check-state $cmd 00502 deny all from any to any frag $cmd 00501 deny tcp from
any to any established $cmd 00600 allow tcp from any to any 80 out via $oif
setup $ks $cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks $cmd
00611 allow udp from any to $odns 53 out via $oif $ks ################### End
of example ipfw rules script ############

The rules are not important as the focus of this example is how the symbolic
substitution fields are populated.

If the above example was in /etc/ipfw.rules, the rules could be reloaded by the
following command:

# sh /etc/ipfw.rules

/etc/ipfw.rules can be located anywhere and the file can have any name.

The same thing could be accomplished by running these commands by hand:

# ipfw -q -f flush # ipfw -q add check-state # ipfw -q add deny all from any to
any frag # ipfw -q add deny tcp from any to any established # ipfw -q add allow
tcp from any to any 80 out via tun0 setup keep-state # ipfw -q add allow tcp
from any to 192.0.2.11 53 out via tun0 setup keep-state # ipfw -q add 00611
allow udp from any to 192.0.2.11 53 out via tun0 keep-state

31.6.5.5.Â An Example Stateful Ruleset

The following sample ruleset is a complete inclusive type ruleset. Comment out
any pass rules for services that are not required. To avoid logging undesired
messages, add a deny rule in the inbound section. Change the dc0 in every rule
to the device name of the interface that connects the system to the Internet.

There is a noticeable pattern in the usage of these rules.

  * All statements that are a request to start a session to the Internet use
    keep-state.

  * All the authorized services that originate from the Internet use limit to
    prevent flooding.

  * All rules use in or out to clarify direction.

  * All rules use via interface-name to specify the interface the packet is
    traveling over.

The following rules go into /etc/ipfw.rules:

################ Start of IPFW rules file ############################### #
Flush out the list before we begin. ipfw -q -f flush # Set rules command prefix
cmd="ipfw -q add" pif="dc0" # public interface name of NIC # facing the public
Internet ################################################################# # No
restrictions on Inside LAN Interface for private network # Not needed unless
you have LAN. # Change xl0 to your LAN NIC interface name #####################
############################################ #$cmd 00005 allow all from any to
any via xl0 ################################################################# #
No restrictions on Loopback Interface #########################################
######################## $cmd 00010 allow all from any to any via lo0 #########
######################################################## # Allow the packet
through if it has previous been added to the # the "dynamic" rules table by a
allow keep-state statement. ###################################################
############## $cmd 00015 check-state #########################################
######################## # Interface facing Public Internet (Outbound Section)
# Interrogate session start requests originating from behind the # firewall on
the private network or from this gateway server # destined for the public
Internet. ################################################################# #
Allow out access to my ISP's Domain name server. # x.x.x.x must be the IP
address of your ISP.s DNS # Dup these lines if your ISP has more than one DNS
server # Get the IP addresses from /etc/resolv.conf file $cmd 00110 allow tcp
from any to x.x.x.x 53 out via $pif setup keep-state $cmd 00111 allow udp from
any to x.x.x.x 53 out via $pif keep-state # Allow out access to my ISP's DHCP
server for cable/DSL configurations. # This rule is not needed for .user ppp.
connection to the public Internet. # so you can delete this whole group. # Use
the following rule and check log for IP address. # Then put IP address in
commented out rule & delete first rule $cmd 00120 allow log udp from any to any
67 out via $pif keep-state #$cmd 00120 allow udp from any to x.x.x.x 67 out via
$pif keep-state # Allow out non-secure standard www function $cmd 00200 allow
tcp from any to any 80 out via $pif setup keep-state # Allow out secure www
function https over TLS SSL $cmd 00220 allow tcp from any to any 443 out via
$pif setup keep-state # Allow out send & get email function $cmd 00230 allow
tcp from any to any 25 out via $pif setup keep-state $cmd 00231 allow tcp from
any to any 110 out via $pif setup keep-state # Allow out FBSD (make install &
CVSUP) functions # Basically give user root "GOD" privileges. $cmd 00240 allow
tcp from me to any out via $pif setup keep-state uid root # Allow out ping $cmd
00250 allow icmp from any to any out via $pif keep-state # Allow out Time $cmd
00260 allow tcp from any to any 37 out via $pif setup keep-state # Allow out
nntp news (i.e., news groups) $cmd 00270 allow tcp from any to any 119 out via
$pif setup keep-state # Allow out secure FTP, Telnet, and SCP # This function
is using SSH (secure shell) $cmd 00280 allow tcp from any to any 22 out via
$pif setup keep-state # Allow out whois $cmd 00290 allow tcp from any to any 43
out via $pif setup keep-state # deny and log everything else that.s trying to
get out. # This rule enforces the block all by default logic. $cmd 00299 deny
log all from any to any out via $pif ##########################################
####################### # Interface facing Public Internet (Inbound Section) #
Check packets originating from the public Internet # destined for this gateway
server or the private network. ################################################
################# # Deny all inbound traffic from non-routable reserved address
spaces $cmd 00300 deny all from 192.168.0.0/16 to any in via $pif #RFC 1918
private IP $cmd 00301 deny all from 172.16.0.0/12 to any in via $pif #RFC 1918
private IP $cmd 00302 deny all from 10.0.0.0/8 to any in via $pif #RFC 1918
private IP $cmd 00303 deny all from 127.0.0.0/8 to any in via $pif #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif #loopback $cmd 00305 deny
all from 169.254.0.0/16 to any in via $pif #DHCP auto-config $cmd 00306 deny
all from 192.0.2.0/24 to any in via $pif #reserved for docs $cmd 00307 deny all
from 204.152.64.0/23 to any in via $pif #Sun cluster interconnect $cmd 00308
deny all from 224.0.0.0/3 to any in via $pif #Class D & E multicast # Deny
public pings $cmd 00310 deny icmp from any to any in via $pif # Deny ident $cmd
00315 deny tcp from any to any 113 in via $pif # Deny all Netbios service. 137=
name, 138=datagram, 139=session # Netbios is MS/Windows sharing services. #
Block MS/Windows hosts2 name server requests 81 $cmd 00320 deny tcp from any to
any 137 in via $pif $cmd 00321 deny tcp from any to any 138 in via $pif $cmd
00322 deny tcp from any to any 139 in via $pif $cmd 00323 deny tcp from any to
any 81 in via $pif # Deny any late arriving packets $cmd 00330 deny all from
any to any frag in via $pif # Deny ACK packets that did not match the dynamic
rule table $cmd 00332 deny tcp from any to any established in via $pif # Allow
traffic in from ISP's DHCP server. This rule must contain # the IP address of
your ISP.s DHCP server as it.s the only # authorized source to send this packet
type. # Only necessary for cable or DSL configurations. # This rule is not
needed for .user ppp. type connection to # the public Internet. This is the
same IP address you captured # and used in the outbound section. #$cmd 00360
allow udp from any to x.x.x.x 67 in via $pif keep-state # Allow in standard www
function because I have apache server $cmd 00400 allow tcp from any to me 80 in
via $pif setup limit src-addr 2 # Allow in secure FTP, Telnet, and SCP from
public Internet $cmd 00410 allow tcp from any to me 22 in via $pif setup limit
src-addr 2 # Allow in non-secure Telnet session from public Internet # labeled
non-secure because ID & PW are passed over public # Internet as clear text. #
Delete this sample group if you do not have telnet server enabled. $cmd 00420
allow tcp from any to me 23 in via $pif setup limit src-addr 2 # Reject & Log
all incoming connections from the outside $cmd 00499 deny log all from any to
any in via $pif # Everything else is denied by default # deny and log all
packets that fell through to see what they are $cmd 00999 deny log all from any
to any ################ End of IPFW rules file ###############################

31.6.5.6.Â An Example NAT and Stateful Ruleset

There are some additional configuration statements that need to be enabled to
activate the NAT function of IPFW. For a customized kernel, the kernel
configuration file needs option IPDIVERT added to the other IPFIREWALL options.

In addition to the normal IPFW options in /etc/rc.conf, the following are
needed:

natd_enable="YES" # Enable NATD function natd_interface="rl0" # interface name
of public Internet NIC natd_flags="-dynamic -m" # -m = preserve port numbers if
possible

Utilizing stateful rules with a divert natd rule complicates the ruleset logic.
The positioning of the check-state, and divert natd rules in the ruleset is
critical and a new action type is used, called skipto. When using skipto, it is
mandatory that each rule is numbered, so that the skipto rule knows which rule
to jump to.

The following is an uncommented example of a ruleset which explains the
sequence of the packet flow.

The processing flow starts with the first rule from the top of the ruleset and
progresses one rule at a time until the end is reached or the packet matches
and the packet is released out of the firewall. Take note of the location of
rule numbers 100 101, 450, 500, and 510. These rules control the translation of
the outbound and inbound packets so that their entries in the dynamic
keep-state table always register the private LAN IP address. All the allow and
deny rules specify the direction of the packet and the interface. All start
outbound session requests will skipto rule 500 to undergo NAT.

Consider a web browser which initializes a new HTTP session over port 80. When
the first outbound packet enters the firewall, it does not match rule 100
because it is headed out rather than in. It passes rule 101 because this is the
first packet, and it has not been posted to the dynamic keep-state table yet.
The packet finally matches rule 125 as it is outbound through the NIC facing
the Internet and has a source IP address as a private LAN IP address. On
matching this rule, two actions take place. keep-state adds this rule to the
dynamic keep-state rules table and the specified action is executed and posted
as part of the info in the dynamic table. In this case, the action is skipto
rule 500. Rule 500 NATs the packet IP address and sends it out to the Internet.
This packet makes its way to the destination web server, where a response
packet is generated and sent back. This new packet enters the top of the
ruleset. It matches rule 100 and has it destination IP address mapped back to
the corresponding LAN IP address. It then is processed by the check-state rule,
is found in the table as an existing session, and is released to the LAN. It
goes to the LAN system that sent it and a new packet is sent requesting another
segment of the data from the remote server. This time it matches the
check-state rule, its outbound entry is found, and the associated action,
skipto 500, is executed. The packet jumps to rule 500, gets NATed, and is
released to the Internet.

On the inbound side, everything coming in that is part of an existing session
is automatically handled by the check-state rule and the properly placed divert
natd rules. The ruleset only has to deny bad packets and allow only authorized
services. Consider a web server running on the firewall where web requests from
the Internet should have access to the local web site. An inbound start request
packet will match rule 100 and its IP address will be mapped to the LAN IP
address of the firewall. The packet is then matched against all the nasty
things that need to be checked and finally matches rule 425 where two actions
occur. The packet rule is posted to the dynamic keep-state table but this time,
any new session requests originating from that source IP address are limited to
2. This defends against DoS attacks against the service running on the
specified port number. The action is allow, so the packet is released to the
LAN. The packet generated as a response is recognized by the check-state as
belonging to an existing session. It is then sent to rule 500 for NATing and
released to the outbound interface.

Example Ruleset #1:

#!/bin/sh cmd="ipfw -q add" skip="skipto 500" pif=rl0 ks="keep-state" good_tcpo
="22,25,37,43,53,80,443,110,119" ipfw -q -f flush $cmd 002 allow all from any
to any via xl0 # exclude LAN traffic $cmd 003 allow all from any to any via lo0
# exclude loopback traffic $cmd 100 divert natd ip from any to any in via $pif
$cmd 101 check-state # Authorized outbound packets $cmd 120 $skip udp from any
to xx.168.240.2 53 out via $pif $ks $cmd 121 $skip udp from any to xx.168.240.5
53 out via $pif $ks $cmd 125 $skip tcp from any to any $good_tcpo out via $pif
setup $ks $cmd 130 $skip icmp from any to any out via $pif $ks $cmd 135 $skip
udp from any to any 123 out via $pif $ks # Deny all inbound traffic from
non-routable reserved address spaces $cmd 300 deny all from 192.168.0.0/16 to
any in via $pif #RFC 1918 private IP $cmd 301 deny all from 172.16.0.0/12 to
any in via $pif #RFC 1918 private IP $cmd 302 deny all from 10.0.0.0/8 to any
in via $pif #RFC 1918 private IP $cmd 303 deny all from 127.0.0.0/8 to any in
via $pif #loopback $cmd 304 deny all from 0.0.0.0/8 to any in via $pif #
loopback $cmd 305 deny all from 169.254.0.0/16 to any in via $pif #DHCP
auto-config $cmd 306 deny all from 192.0.2.0/24 to any in via $pif #reserved
for docs $cmd 307 deny all from 204.152.64.0/23 to any in via $pif #Sun cluster
$cmd 308 deny all from 224.0.0.0/3 to any in via $pif #Class D & E multicast #
Authorized inbound packets $cmd 400 allow udp from xx.70.207.54 to any 68 in
$ks $cmd 420 allow tcp from any to me 80 in via $pif setup limit src-addr 1
$cmd 450 deny log ip from any to any # This is skipto location for outbound
stateful rules $cmd 500 divert natd ip from any to any out via $pif $cmd 510
allow ip from any to any ######################## end of rules ################
##

The next example is functionally equivalent, but uses descriptive comments to
help the inexperienced IPFW rule writer to better understand what the rules are
doing.

Example Ruleset #2:

#!/bin/sh ################ Start of IPFW rules file ###########################
#### # Flush out the list before we begin. ipfw -q -f flush # Set rules command
prefix cmd="ipfw -q add" skip="skipto 800" pif="rl0" # public interface name of
NIC # facing the public Internet ##############################################
################### # No restrictions on Inside LAN Interface for private
network # Change xl0 to your LAN NIC interface name ###########################
###################################### $cmd 005 allow all from any to any via
xl0 ################################################################# # No
restrictions on Loopback Interface ############################################
##################### $cmd 010 allow all from any to any via lo0 ##############
################################################### # check if packet is
inbound and nat address if it is ##############################################
################### $cmd 014 divert natd ip from any to any in via $pif #######
########################################################## # Allow the packet
through if it has previous been added to the # the "dynamic" rules table by a
allow keep-state statement. ###################################################
############## $cmd 015 check-state ###########################################
###################### # Interface facing Public Internet (Outbound Section) #
Check session start requests originating from behind the # firewall on the
private network or from this gateway server # destined for the public Internet.
################################################################# # Allow out
access to my ISP's Domain name server. # x.x.x.x must be the IP address of your
ISP's DNS # Dup these lines if your ISP has more than one DNS server # Get the
IP addresses from /etc/resolv.conf file $cmd 020 $skip tcp from any to x.x.x.x
53 out via $pif setup keep-state # Allow out access to my ISP's DHCP server for
cable/DSL configurations. $cmd 030 $skip udp from any to x.x.x.x 67 out via
$pif keep-state # Allow out non-secure standard www function $cmd 040 $skip tcp
from any to any 80 out via $pif setup keep-state # Allow out secure www
function https over TLS SSL $cmd 050 $skip tcp from any to any 443 out via $pif
setup keep-state # Allow out send & get email function $cmd 060 $skip tcp from
any to any 25 out via $pif setup keep-state $cmd 061 $skip tcp from any to any
110 out via $pif setup keep-state # Allow out FreeBSD (make install & CVSUP)
functions # Basically give user root "GOD" privileges. $cmd 070 $skip tcp from
me to any out via $pif setup keep-state uid root # Allow out ping $cmd 080
$skip icmp from any to any out via $pif keep-state # Allow out Time $cmd 090
$skip tcp from any to any 37 out via $pif setup keep-state # Allow out nntp
news (i.e., news groups) $cmd 100 $skip tcp from any to any 119 out via $pif
setup keep-state # Allow out secure FTP, Telnet, and SCP # This function is
using SSH (secure shell) $cmd 110 $skip tcp from any to any 22 out via $pif
setup keep-state # Allow out whois $cmd 120 $skip tcp from any to any 43 out
via $pif setup keep-state # Allow ntp time server $cmd 130 $skip udp from any
to any 123 out via $pif keep-state ############################################
##################### # Interface facing Public Internet (Inbound Section) #
Check packets originating from the public Internet # destined for this gateway
server or the private network. ################################################
################# # Deny all inbound traffic from non-routable reserved address
spaces $cmd 300 deny all from 192.168.0.0/16 to any in via $pif #RFC 1918
private IP $cmd 301 deny all from 172.16.0.0/12 to any in via $pif #RFC 1918
private IP $cmd 302 deny all from 10.0.0.0/8 to any in via $pif #RFC 1918
private IP $cmd 303 deny all from 127.0.0.0/8 to any in via $pif #loopback $cmd
304 deny all from 0.0.0.0/8 to any in via $pif #loopback $cmd 305 deny all from
169.254.0.0/16 to any in via $pif #DHCP auto-config $cmd 306 deny all from
192.0.2.0/24 to any in via $pif #reserved for docs $cmd 307 deny all from
204.152.64.0/23 to any in via $pif #Sun cluster $cmd 308 deny all from
224.0.0.0/3 to any in via $pif #Class D & E multicast # Deny ident $cmd 315
deny tcp from any to any 113 in via $pif # Deny all Netbios service. 137=name,
138=datagram, 139=session # Netbios is MS/Windows sharing services. # Block MS/
Windows hosts2 name server requests 81 $cmd 320 deny tcp from any to any 137 in
via $pif $cmd 321 deny tcp from any to any 138 in via $pif $cmd 322 deny tcp
from any to any 139 in via $pif $cmd 323 deny tcp from any to any 81 in via
$pif # Deny any late arriving packets $cmd 330 deny all from any to any frag in
via $pif # Deny ACK packets that did not match the dynamic rule table $cmd 332
deny tcp from any to any established in via $pif # Allow traffic in from ISP's
DHCP server. This rule must contain # the IP address of your ISP's DHCP server
as it is the only # authorized source to send this packet type. # Only
necessary for cable or DSL configurations. # This rule is not needed for 'user
ppp' type connection to # the public Internet. This is the same IP address you
captured # and used in the outbound section. $cmd 360 allow udp from x.x.x.x to
any 68 in via $pif keep-state # Allow in standard www function because I have
Apache server $cmd 370 allow tcp from any to me 80 in via $pif setup limit
src-addr 2 # Allow in secure FTP, Telnet, and SCP from public Internet $cmd 380
allow tcp from any to me 22 in via $pif setup limit src-addr 2 # Allow in
non-secure Telnet session from public Internet # labeled non-secure because ID
& PW are passed over public # Internet as clear text. # Delete this sample
group if you do not have telnet server enabled. $cmd 390 allow tcp from any to
me 23 in via $pif setup limit src-addr 2 # Reject & Log all unauthorized
incoming connections from the public Internet $cmd 400 deny log all from any to
any in via $pif # Reject & Log all unauthorized out going connections to the
public Internet $cmd 450 deny log all from any to any out via $pif # This is
skipto location for outbound stateful rules $cmd 800 divert natd ip from any to
any out via $pif $cmd 801 allow ip from any to any # Everything else is denied
by default # deny and log all packets that fell through to see what they are
$cmd 999 deny log all from any to any ################ End of IPFW rules file #
##############################

------------

^[8] Why write the rule set to default deny? The short answer is, it gives
better control at the expense of some thinking. The point of packet filtering
is to take control, not to run catch-up with what the bad guys do. Marcus Ranum
has written a very entertaining and informative article about this, The Six
Dumbest Ideas in Computer Security, and it is well written too.

^[9] For dialup users, the external interface is the tun0 pseudo-device.
Broadband users such as ADSL subscribers tend to have an Ethernet interface to
play with, however for a significant subset of ADSL users, specifically those
using PPP over Ethernet (PPPoE), the correct external interface will be the
tun0 pseudo-device, not the physical Ethernet interface.

^[10] The main internet RFCs describing ICMP and some related techhiques are
RFC792, RFC950, RFC1191, RFC1256, RFC2521, rfc2765, while necessary updates for
ICMP for IPv6 are found in RFC1885, RFC2463, RFC2466. These documents are
available in a number of places on the net, such as the ietf.org and faqs.org
web sites.

^[11] The relevant RFCs are mainly RFC1123 and RFC2821.

^[12] The original Harris paper and a number of other useful articles and
resources can be found at the greylisting.org web site.

ChapterÂ 32.Â Advanced Networking

Table of Contents

32.1. Synopsis
32.2. Gateways and Routes
32.3. Wireless Networking
32.4. Bluetooth
32.5. Bridging
32.6. Link Aggregation and Failover
32.7. Diskless Operation
32.8. PXE Booting with an NFS Root File System
32.9. ISDN
32.10. Network Address Translation
32.11. IPv6
32.12. Asynchronous Transfer Mode (ATM)
32.13. Common Address Redundancy Protocol (CARP)

32.1.Â Synopsis

This chapter will cover a number of advanced networking topics.

After reading this chapter, you will know:

  * The basics of gateways and routes.

  * How to set up IEEEÂ® 802.11 and BluetoothÂ® devices.

  * How to make FreeBSD act as a bridge.

  * How to set up network booting on a diskless machine.

  * How to set up network PXE booting with an NFS root file system.

  * How to set up network address translation.

  * How to set up IPv6 on a FreeBSD machine.

  * How to configure ATM.

  * How to enable and utilize the features of CARP, the Common Address
    Redundancy Protocol in FreeBSD

Before reading this chapter, you should:

  * Understand the basics of the /etc/rc scripts.

  * Be familiar with basic network terminology.

  * Know how to configure and install a new FreeBSD kernel (ChapterÂ 9, 
    Configuring the FreeBSD Kernel).

  * Know how to install additional third-party software (ChapterÂ 5, Installing
    Applications: Packages and Ports).

32.2.Â Gateways and Routes

Contributed by Coranth Gryphon.

For one machine to be able to find another over a network, there must be a
mechanism in place to describe how to get from one to the other. This is called
routing. A â  routeâ   is a defined pair of addresses: a â  destinationâ   and
a â  gatewayâ  . The pair indicates that if you are trying to get to this 
destination, communicate through this gateway. There are three types of
destinations: individual hosts, subnets, and â  defaultâ  . The â  default
routeâ   is used if none of the other routes apply. We will talk a little bit
more about default routes later on. There are also three types of gateways:
individual hosts, interfaces (also called â  linksâ  ), and Ethernet hardware
addresses (MAC addresses).

32.2.1.Â An Example

To illustrate different aspects of routing, we will use the following example
from netstat:

% netstat -r Routing tables Destination Gateway Flags Refs Use Netif Expire
default outside-gw UGSc 37 418 ppp0 localhost localhost UH 0 181 lo0 test0
0:e0:b5:36:cf:4f UHLW 5 63288 ed0 77 10.20.30.255 link#1 UHLW 1 2421
example.com link#1 UC 0 0 host1 0:e0:a8:37:8:1e UHLW 3 4601 lo0 host2
0:e0:a8:37:8:1e UHLW 0 5 lo0 =&gt; host2.example.com link#1 UC 0 0 224 link#1 UC 0
0

The first two lines specify the default route (which we will cover in the next
section) and the localhost route.

The interface (Netif column) that this routing table specifies to use for
localhost is lo0, also known as the loopback device. This says to keep all
traffic for this destination internal, rather than sending it out over the LAN,
since it will only end up back where it started.

The next thing that stands out are the addresses beginning with 0:e0:. These
are Ethernet hardware addresses, which are also known as MAC addresses. FreeBSD
will automatically identify any hosts (test0 in the example) on the local
Ethernet and add a route for that host, directly to it over the Ethernet
interface, ed0. There is also a timeout (Expire column) associated with this
type of route, which is used if we fail to hear from the host in a specific
amount of time. When this happens, the route to this host will be automatically
deleted. These hosts are identified using a mechanism known as RIP (Routing
Information Protocol), which figures out routes to local hosts based upon a
shortest path determination.

FreeBSD will also add subnet routes for the local subnet (10.20.30.255 is the
broadcast address for the subnet 10.20.30, and example.com is the domain name
associated with that subnet). The designation link#1 refers to the first
Ethernet card in the machine. You will notice no additional interface is
specified for those.

Both of these groups (local network hosts and local subnets) have their routes
automatically configured by a daemon called routed. If this is not run, then
only routes which are statically defined (i.e., entered explicitly) will exist.

The host1 line refers to our host, which it knows by Ethernet address. Since we
are the sending host, FreeBSD knows to use the loopback interface (lo0) rather
than sending it out over the Ethernet interface.

The two host2 lines are an example of what happens when we use an ifconfig(8)
alias (see the section on Ethernet for reasons why we would do this). The =&gt;
symbol after the lo0 interface says that not only are we using the loopback
(since this address also refers to the local host), but specifically it is an
alias. Such routes only show up on the host that supports the alias; all other
hosts on the local network will simply have a link#1 line for such routes.

The final line (destination subnet 224) deals with multicasting, which will be
covered in another section.

Finally, various attributes of each route can be seen in the Flags column.
Below is a short table of some of these flags and their meanings:

U Up: The route is active.
H Host: The route destination is a single host.
G Gateway: Send anything for this destination on to this remote system, which
  will figure out from there where to send it.
S Static: This route was configured manually, not automatically generated by
  the system.
C Clone: Generates a new route based upon this route for machines we connect
  to. This type of route is normally used for local networks.
W WasCloned: Indicated a route that was auto-configured based upon a local area
  network (Clone) route.
L Link: Route involves references to Ethernet hardware.

32.2.2.Â Default Routes

When the local system needs to make a connection to a remote host, it checks
the routing table to determine if a known path exists. If the remote host falls
into a subnet that we know how to reach (Cloned routes), then the system checks
to see if it can connect along that interface.

If all known paths fail, the system has one last option: the â  defaultâ  
route. This route is a special type of gateway route (usually the only one
present in the system), and is always marked with a c in the flags field. For
hosts on a local area network, this gateway is set to whatever machine has a
direct connection to the outside world (whether via PPP link, DSL, cable modem,
T1, or another network interface).

If you are configuring the default route for a machine which itself is
functioning as the gateway to the outside world, then the default route will be
the gateway machine at your Internet Service Provider's (ISP) site.

Let us look at an example of default routes. This is a common configuration:

[net-routin]

The hosts Local1 and Local2 are at your site. Local1 is connected to an ISP via
a dial up PPP connection. This PPP server computer is connected through a local
area network to another gateway computer through an external interface to the
ISPs Internet feed.

The default routes for each of your machines will be:

     Host                   Default Gateway                    Interface
Local2          Local1                                  Ethernet
Local1          T1-GW                                   PPP

A common question is â  Why (or how) would we set the T1-GW to be the default
gateway for Local1, rather than the ISP server it is connected to?â  .

Remember, since the PPP interface is using an address on the ISP's local
network for your side of the connection, routes for any other machines on the
ISP's local network will be automatically generated. Hence, you will already
know how to reach the T1-GW machine, so there is no need for the intermediate
step of sending traffic to the ISP server.

It is common to use the address X.X.X.1 as the gateway address for your local
network. So (using the same example), if your local class-C address space was
10.20.30 and your ISP was using 10.9.9 then the default routes would be:

                      Host                               Default Route
Local2 (10.20.30.2)                              Local1 (10.20.30.1)
Local1 (10.20.30.1, 10.9.9.30)                   T1-GW (10.9.9.1)

The default route can be easily defined in /etc/rc.conf. In our example, on the
Local2 machine, we added the following line in /etc/rc.conf:

defaultrouter="10.20.30.1"

It is also possible to do it directly from the command line with the route(8)
command:

# route add default 10.20.30.1

For more information on manual manipulation of network routing tables, consult
the route(8) manual page.

32.2.3.Â Dual Homed Hosts

There is one other type of configuration that we should cover, and that is a
host that sits on two different networks. Technically, any machine functioning
as a gateway (in the example above, using a PPP connection) counts as a
dual-homed host. But the term is really only used to refer to a machine that
sits on two local-area networks.

In one case, the machine has two Ethernet cards, each having an address on the
separate subnets. Alternately, the machine may only have one Ethernet card, and
be using ifconfig(8) aliasing. The former is used if two physically separate
Ethernet networks are in use, the latter if there is one physical network
segment, but two logically separate subnets.

Either way, routing tables are set up so that each subnet knows that this
machine is the defined gateway (inbound route) to the other subnet. This
configuration, with the machine acting as a router between the two subnets, is
often used when we need to implement packet filtering or firewall security in
either or both directions.

If you want this machine to actually forward packets between the two
interfaces, you need to tell FreeBSD to enable this ability. See the next
section for more details on how to do this.

32.2.4.Â Building a Router

A network router is simply a system that forwards packets from one interface to
another. Internet standards and good engineering practice prevent the FreeBSD
Project from enabling this by default in FreeBSD. You can enable this feature
by changing the following variable to YES in rc.conf(5):

gateway_enable="YES" # Set to YES if this host will be a gateway

This option will set the sysctl(8) variable net.inet.ip.forwarding to 1. If you
should need to stop routing temporarily, you can reset this to 0 temporarily.

Your new router will need routes to know where to send the traffic. If your
network is simple enough you can use static routes. FreeBSD also comes with the
standard BSD routing daemon routed(8), which speaks RIP (both version 1 and
version 2) and IRDP. Support for BGP v4, OSPF v2, and other sophisticated
routing protocols is available with the net/zebra package. Commercial products
such as GateDÂ® are also available for more complex network routing solutions.

32.2.5.Â Setting Up Static Routes

Contributed by Al Hoang.

32.2.5.1.Â Manual Configuration

Let us assume we have a network as follows:

[static-rou]

In this scenario, RouterA is our FreeBSD machine that is acting as a router to
the rest of the Internet. It has a default route set to 10.0.0.1 which allows
it to connect with the outside world. We will assume that RouterB is already
configured properly and knows how to get wherever it needs to go. (This is
simple in this picture. Just add a default route on RouterB using 192.168.1.1
as the gateway.)

If we look at the routing table for RouterA we would see something like the
following:

% netstat -nr Routing tables Internet: Destination Gateway Flags Refs Use Netif
Expire default 10.0.0.1 UGS 0 49378 xl0 127.0.0.1 127.0.0.1 UH 0 6 lo0 10.0.0.0
/24 link#1 UC 0 0 xl0 192.168.1.0/24 link#2 UC 0 0 xl1

With the current routing table RouterA will not be able to reach our Internal
Net 2. It does not have a route for 192.168.2.0/24. One way to alleviate this
is to manually add the route. The following command would add the Internal Net
2 network to RouterA's routing table using 192.168.1.2 as the next hop:

# route add -net 192.168.2.0/24 192.168.1.2

Now RouterA can reach any hosts on the 192.168.2.0/24 network.

32.2.5.2.Â Persistent Configuration

The above example is perfect for configuring a static route on a running
system. However, one problem is that the routing information will not persist
if you reboot your FreeBSD machine. Additional static routes can be entered in
/etc/rc.conf:

# Add Internal Net 2 as a static route static_routes="internalnet2"
route_internalnet2="-net 192.168.2.0/24 192.168.1.2"

The static_routes configuration variable is a list of strings separated by a
space. Each string references to a route name. In our above example we only
have one string in static_routes. This string is internalnet2. We then add a
configuration variable called route_internalnet2 where we put all of the
configuration parameters we would give to the route(8) command. For our example
above we would have used the command:

# route add -net 192.168.2.0/24 192.168.1.2

so we need "-net 192.168.2.0/24 192.168.1.2".

As said above, we can have more than one string in static_routes. This allows
us to create multiple static routes. The following lines shows an example of
adding static routes for the 192.168.0.0/24 and 192.168.1.0/24 networks on an
imaginary router:

static_routes="net1 net2" route_net1="-net 192.168.0.0/24 192.168.0.1"
route_net2="-net 192.168.1.0/24 192.168.1.1"

32.2.6.Â Routing Propagation

We have already talked about how we define our routes to the outside world, but
not about how the outside world finds us.

We already know that routing tables can be set up so that all traffic for a
particular address space (in our examples, a class-C subnet) can be sent to a
particular host on that network, which will forward the packets inbound.

When you get an address space assigned to your site, your service provider will
set up their routing tables so that all traffic for your subnet will be sent
down your PPP link to your site. But how do sites across the country know to
send to your ISP?

There is a system (much like the distributed DNS information) that keeps track
of all assigned address-spaces, and defines their point of connection to the
Internet Backbone. The â  Backboneâ   are the main trunk lines that carry
Internet traffic across the country, and around the world. Each backbone
machine has a copy of a master set of tables, which direct traffic for a
particular network to a specific backbone carrier, and from there down the
chain of service providers until it reaches your network.

It is the task of your service provider to advertise to the backbone sites that
they are the point of connection (and thus the path inward) for your site. This
is known as route propagation.

32.2.7.Â Troubleshooting

Sometimes, there is a problem with routing propagation, and some sites are
unable to connect to you. Perhaps the most useful command for trying to figure
out where routing is breaking down is the traceroute(8) command. It is equally
useful if you cannot seem to make a connection to a remote machine (i.e., ping
(8) fails).

The traceroute(8) command is run with the name of the remote host you are
trying to connect to. It will show the gateway hosts along the path of the
attempt, eventually either reaching the target host, or terminating because of
a lack of connection.

For more information, see the manual page for traceroute(8).

32.2.8.Â Multicast Routing

FreeBSD supports both multicast applications and multicast routing natively.
Multicast applications do not require any special configuration of FreeBSD;
applications will generally run out of the box. Multicast routing requires that
support be compiled into the kernel:

options MROUTING

In addition, the multicast routing daemon, mrouted(8) must be configured to set
up tunnels and DVMRP via /etc/mrouted.conf. More details on multicast
configuration may be found in the manual page for mrouted(8).

Note:

The mrouted(8) multicast routing daemon implements the DVMRP multicast routing
protocol, which has largely been replaced by pim(4) in many multicast
installations. mrouted(8) and the related map-mbone(8) and mrinfo(8) utilities
are available in the FreeBSD PortsÂ Collection as net/mrouted.

32.3.Â Wireless Networking

Loader, Marc Fonvieille and Murray Stokely.

32.3.1.Â Wireless Networking Basics

Most wireless networks are based on the IEEEÂ® 802.11 standards. A basic
wireless network consists of multiple stations communicating with radios that
broadcast in either the 2.4GHz or 5GHz band (though this varies according to
the locale and is also changing to enable communication in the 2.3GHz and
4.9GHz ranges).

802.11 networks are organized in two ways: in infrastructure mode one station
acts as a master with all the other stations associating to it; the network is
known as a BSS and the master station is termed an access point (AP). In a BSS
all communication passes through the AP; even when one station wants to
communicate with another wireless station messages must go through the AP. In
the second form of network there is no master and stations communicate
directly. This form of network is termed an IBSS and is commonly known as an 
ad-hoc network.

802.11 networks were first deployed in the 2.4GHz band using protocols defined
by the IEEEÂ® 802.11 and 802.11b standard. These specifications include the
operating frequencies, MAC layer characteristics including framing and
transmission rates (communication can be done at various rates). Later the
802.11a standard defined operation in the 5GHz band, including different
signalling mechanisms and higher transmission rates. Still later the 802.11g
standard was defined to enable use of 802.11a signalling and transmission
mechanisms in the 2.4GHz band in such a way as to be backwards compatible with
802.11b networks.

Separate from the underlying transmission techniques 802.11 networks have a
variety of security mechanisms. The original 802.11 specifications defined a
simple security protocol called WEP. This protocol uses a fixed pre-shared key
and the RC4 cryptographic cipher to encode data transmitted on a network.
Stations must all agree on the fixed key in order to communicate. This scheme
was shown to be easily broken and is now rarely used except to discourage
transient users from joining networks. Current security practice is given by
the IEEEÂ® 802.11i specification that defines new cryptographic ciphers and an
additional protocol to authenticate stations to an access point and exchange
keys for doing data communication. Further, cryptographic keys are periodically
refreshed and there are mechanisms for detecting intrusion attempts (and for
countering intrusion attempts). Another security protocol specification
commonly used in wireless networks is termed WPA. This was a precursor to
802.11i defined by an industry group as an interim measure while waiting for
802.11i to be ratified. WPA specifies a subset of the requirements found in
802.11i and is designed for implementation on legacy hardware. Specifically WPA
requires only the TKIP cipher that is derived from the original WEP cipher.
802.11i permits use of TKIP but also requires support for a stronger cipher,
AES-CCM, for encrypting data. (The AES cipher was not required in WPA because
it was deemed too computationally costly to be implemented on legacy hardware.)

Other than the above protocol standards the other important standard to be
aware of is 802.11e. This defines protocols for deploying multi-media
applications such as streaming video and voice over IP (VoIP) in an 802.11
network. Like 802.11i, 802.11e also has a precursor specification termed WME
(later renamed WMM) that has been defined by an industry group as a subset of
802.11e that can be deployed now to enable multi-media applications while
waiting for the final ratification of 802.11e. The most important thing to know
about 802.11e and WME/WMM is that it enables prioritized traffic use of a
wireless network through Quality of Service (QoS) protocols and enhanced media
access protocols. Proper implementation of these protocols enable high speed
bursting of data and prioritized traffic flow.

FreeBSD supports networks that operate using 802.11a, 802.11b, and 802.11g. The
WPA and 802.11i security protocols are likewise supported (in conjunction with
any of 11a, 11b, and 11g) and QoS and traffic prioritization required by the
WME/WMM protocols are supported for a limited set of wireless devices.

32.3.2.Â Basic Setup

32.3.2.1.Â Kernel Configuration

To use wireless networking, you need a wireless networking card and to
configure the kernel with the appropriate wireless networking support. The
latter is separated into multiple modules so that you only need to configure
the software you are actually going to use.

The first thing you need is a wireless device. The most commonly used devices
are those that use parts made by Atheros. These devices are supported by the
ath(4) driver and require the following line to be added to /boot/loader.conf:

if_ath_load="YES"

The Atheros driver is split up into three separate pieces: the proper driver (
ath(4)), the hardware support layer that handles chip-specific functions (
ath_hal(4)), and an algorithm for selecting which of several possible rates for
transmitting frames (ath_rate_sample here). When this support is loaded as
kernel modules, these dependencies are automatically handled for you. If,
instead of an Atheros device, you had another device you would select the
module for that device; e.g.:

if_wi_load="YES"

for devices based on the Intersil Prism parts (wi(4) driver).

Note:

In the rest of this document, we will use an ath(4) device, the device name in
the examples must be changed according to your configuration. A list of
available wireless drivers and supported adapters can be found in the FreeBSD
Hardware Notes. Copies of these notes for various releases and architectures
are available on the Release Information page of the FreeBSD Web site. If a
native FreeBSD driver for your wireless device does not exist, it may be
possible to directly use the WindowsÂ® driver with the help of the NDIS driver
wrapper.

With that, you will need the modules that implement cryptographic support for
the security protocols you intend to use. These are intended to be dynamically
loaded on demand by the wlan(4) module but for now they must be manually
configured. The following modules are available: wlan_wep(4), wlan_ccmp(4) and
wlan_tkip(4). Both wlan_ccmp(4) and wlan_tkip(4) drivers are only needed if you
intend to use the WPA and/or 802.11i security protocols. If your network does
not use encryption, you will not need wlan_wep(4) support. To load these
modules at boot time, add the following lines to /boot/loader.conf:

wlan_wep_load="YES" wlan_ccmp_load="YES" wlan_tkip_load="YES"

With this information in the system bootstrap configuration file (i.e., /boot/
loader.conf), you have to reboot your FreeBSD box. If you do not want to reboot
your machine for the moment, you can load the modules by hand using kldload(8).

Note:

If you do not want to use modules, it is possible to compile these drivers into
the kernel by adding the following lines to your kernel configuration file:

device wlan # 802.11 support device wlan_wep # 802.11 WEP support device
wlan_ccmp # 802.11 CCMP support device wlan_tkip # 802.11 TKIP support device
wlan_amrr # AMRR transmit rate control algorithm device ath # Atheros pci/
cardbus NIC's device ath_hal # pci/cardbus chip support options
AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors device ath_rate_sample #
SampleRate tx rate control for ath

With this information in the kernel configuration file, recompile the kernel
and reboot your FreeBSD machine.

When the system is up, we could find some information about the wireless device
in the boot messages, like this:

ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: [ITHREAD] ath0: AR2413 mac 7.9 RF2413 phy 4.5

32.3.3.Â Infrastructure Mode

The infrastructure mode or BSS mode is the mode that is typically used. In this
mode, a number of wireless access points are connected to a wired network. Each
wireless network has its own name, this name is called the SSID of the network.
Wireless clients connect to the wireless access points.

32.3.3.1.Â FreeBSD Clients

32.3.3.1.1.Â How to Find Access Points

To scan for networks, use the ifconfig command. This request may take a few
moments to complete as it requires that the system switches to each available
wireless frequency and probes for available access points. Only the super-user
can initiate such a scan:

# ifconfig wlan0 create wlandev ath0 # ifconfig wlan0 up scan SSID/MESH ID
BSSID CHAN RATE S:N INT CAPS dlinkap 00:13:46:49:41:76 11 54M -90:96 100 EPS
WPA WME freebsdap 00:11:95:c3:0d:ac 1 54M -83:96 100 EPS WPA

Note:

You must mark the interface up before you can scan. Subsequent scan requests do
not require you to mark the interface up again.

The output of a scan request lists each BSS/IBSS network found. Beside the name
of the network, SSID, we find the BSSID which is the MAC address of the access
point. The CAPS field identifies the type of each network and the capabilities
of the stations operating there:

TableÂ 32.1.Â Station Capability Codes

Capability                               Meaning
   Code
E          Extended Service Set (ESS). Indicates that the station is part of an
           infrastructure network (in contrast to an IBSS/ad-hoc network).
I          IBSS/ad-hoc network. Indicates that the station is part of an ad-hoc
           network (in contrast to an ESS network).
           Privacy. Data confidentiality is required for all data frames
P          exchanged within the BSS. This means that this BSS requires the
           station to use cryptographic means such as WEP, TKIP or AES-CCMP to
           encrypt/decrypt data frames being exchanged with others.
           Short Preamble. Indicates that the network is using short preambles
S          (defined in 802.11b High Rate/DSSS PHY, short preamble utilizes a 56
           bit sync field in contrast to a 128 bit field used in long preamble
           mode).
s          Short slot time. Indicates that the 802.11g network is using a short
           slot time because there are no legacy (802.11b) stations present.


One can also display the current list of known networks with:

# ifconfig wlan0 list scan

This information may be updated automatically by the adapter or manually with a
scan request. Old data is automatically removed from the cache, so over time
this list may shrink unless more scans are done.

32.3.3.1.2.Â Basic Settings

This section provides a simple example of how to make the wireless network
adapter work in FreeBSD without encryption. After you are familiar with these
concepts, we strongly recommend using WPA to set up your wireless network.

There are three basic steps to configure a wireless network: selecting an
access point, authenticating your station, and configuring an IP address. The
following sections discuss each step.

32.3.3.1.2.1.Â Selecting an Access Point

Most of time it is sufficient to let the system choose an access point using
the builtin heuristics. This is the default behaviour when you mark an
interface up or otherwise configure an interface by listing it in /etc/rc.conf,
e.g.:

wlans_ath0="wlan0" ifconfig_wlan0="DHCP"

If there are multiple access points and you want to select a specific one, you
can select it by its SSID:

wlans_ath0="wlan0" ifconfig_wlan0="ssid your_ssid_here DHCP"

In an environment where there are multiple access points with the same SSID
(often done to simplify roaming) it may be necessary to associate to one
specific device. In this case you can also specify the BSSID of the access
point (you can also leave off the SSID):

wlans_ath0="wlan0" ifconfig_wlan0="ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx
DHCP"

There are other ways to constrain the choice of an access point such as
limiting the set of frequencies the system will scan on. This may be useful if
you have a multi-band wireless card as scanning all the possible channels can
be time-consuming. To limit operation to a specific band you can use the mode
parameter; e.g.:

wlans_ath0="wlan0" ifconfig_wlan0="mode 11g ssid your_ssid_here DHCP"

will force the card to operate in 802.11g which is defined only for 2.4GHz
frequencies so any 5GHz channels will not be considered. Other ways to do this
are the channel parameter, to lock operation to one specific frequency, and the
chanlist parameter, to specify a list of channels for scanning. More
information about these parameters can be found in the ifconfig(8) manual page.

32.3.3.1.2.2.Â Authentication

Once you have selected an access point your station needs to authenticate
before it can pass data. Authentication can happen in several ways. The most
common scheme used is termed open authentication and allows any station to join
the network and communicate. This is the authentication you should use for test
purpose the first time you set up a wireless network. Other schemes require
cryptographic handshakes be completed before data traffic can flow; either
using pre-shared keys or secrets, or more complex schemes that involve backend
services such as RADIUS. Most users will use open authentication which is the
default setting. Next most common setup is WPA-PSK, also known as WPA Personal,
which is described below.

Note:

If you have an AppleÂ® AirPortÂ® Extreme base station for an access point you
may need to configure shared-key authentication together with a WEP key. This
can be done in the /etc/rc.conf file or using the wpa_supplicant(8) program. If
you have a single AirPortÂ® base station you can setup access with something
like:

wlans_ath0="wlan0" ifconfig_wlan0="authmode shared wepmode on weptxkey 1 wepkey
01234567 DHCP"

In general shared key authentication is to be avoided because it uses the WEP
key material in a highly-constrained manner making it even easier to crack the
key. If WEP must be used (e.g., for compatibility with legacy devices) it is
better to use WEP with open authentication. More information regarding WEP can
be found in the SectionÂ 32.3.3.1.4, â  WEPâ  .

32.3.3.1.2.3.Â Getting an IP Address with DHCP

Once you have selected an access point and set the authentication parameters,
you will have to get an IP address to communicate. Most of time you will obtain
your wireless IP address via DHCP. To achieve that, edit /etc/rc.conf and add
DHCP to the configuration for your device as shown in various examples above:

wlans_ath0="wlan0" ifconfig_wlan0="DHCP"

At this point, you are ready to bring up the wireless interface:

# service netif start

Once the interface is running, use ifconfig to see the status of the interface
ath0:

# ifconfig wlan0 wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu
1500 ether 00:11:95:d5:43:62 inet 192.168.1.100 netmask 0xffffff00 broadcast
192.168.1.255 media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g status:
associated ssid dlinkap channel 11 (2462 Mhz 11g) bssid 00:13:46:49:41:76
country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7 scanvalid 60
bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS wme
burst

The status: associated means you are connected to the wireless network (to the
dlinkap network in our case). The bssid 00:13:46:49:41:76 part is the MAC
address of your access point; the authmode OPEN part informs you that the
communication is not encrypted.

32.3.3.1.2.4.Â Static IP Address

In the case you cannot obtain an IP address from a DHCP server, you can set a
fixed IP address. Replace the DHCP keyword shown above with the address
information. Be sure to retain any other parameters you have set up for
selecting an access point:

wlans_ath0="wlan0" ifconfig_wlan0="inet 192.168.1.100 netmask 255.255.255.0
ssid your_ssid_here"

32.3.3.1.3.Â WPA

WPA (Wi-Fi Protected Access) is a security protocol used together with 802.11
networks to address the lack of proper authentication and the weakness of WEP.
WPA leverages the 802.1X authentication protocol and uses one of several
ciphers instead of WEP for data integrity. The only cipher required by WPA is
TKIP (Temporary Key Integrity Protocol). TKIP is a cipher that extends the
basic RC4 cipher used by WEP by adding integrity checking, tamper detection,
and measures for responding to any detected intrusions. TKIP is designed to
work on legacy hardware with only software modification; it represents a
compromise that improves security but is still not entirely immune to attack.
WPA also specifies the AES-CCMP cipher as an alternative to TKIP and that is
preferred when possible; for this specification the term WPA2 (or RSN) is
commonly used.

WPA defines authentication and encryption protocols. Authentication is most
commonly done using one of two techniques: by 802.1X and a backend
authentication service such as RADIUS, or by a minimal handshake between the
station and the access point using a pre-shared secret. The former is commonly
termed WPA Enterprise with the latter known as WPA Personal. Since most people
will not set up a RADIUS backend server for their wireless network, WPA-PSK is
by far the most commonly encountered configuration for WPA.

The control of the wireless connection and the authentication (key negotiation
or authentication with a server) is done with the wpa_supplicant(8) utility.
This program requires a configuration file, /etc/wpa_supplicant.conf, to run.
More information regarding this file can be found in the wpa_supplicant.conf(5)
manual page.

32.3.3.1.3.1.Â WPA-PSK

WPA-PSK, also known as WPA-Personal, is based on a pre-shared key (PSK)
generated from a given password and that will be used as the master key in the
wireless network. This means every wireless user will share the same key.
WPA-PSK is intended for small networks where the use of an authentication
server is not possible or desired.

Warning:

Always use strong passwords that are sufficiently long and made from a rich
alphabet so they will not be guessed and/or attacked.

The first step is the configuration of the /etc/wpa_supplicant.conf file with
the SSID and the pre-shared key of your network:

network={ ssid="freebsdap" psk="freebsdmall" }

Then, in /etc/rc.conf, we indicate that the wireless device configuration will
be done with WPA and the IP address will be obtained with DHCP:

wlans_ath0="wlan0" ifconfig_wlan0="WPA DHCP"

Then we can bring up the interface:

# service netif start Starting wpa_supplicant. DHCPDISCOVER on wlan0 to
255.255.255.255 port 67 interval 5 DHCPDISCOVER on wlan0 to 255.255.255.255
port 67 interval 6 DHCPOFFER from 192.168.0.1 DHCPREQUEST on wlan0 to
255.255.255.255 port 67 DHCPACK from 192.168.0.1 bound to 192.168.0.254 --
renewal in 300 seconds. wlan0: flags=8843
&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether 00:11:95:d5:43:62 inet
192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255 media: IEEE 802.11
Wireless Ethernet OFDM/36Mbps mode 11g status: associated ssid freebsdap
channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac country US ecm authmode WPA2/
802.11i privacy ON deftxkey UNDEF AES-CCM 3:128-bit txpower 21.5 bmiss 7
scanvalid 450 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5
protmode CTS wme burst roaming MANUAL

Or you can try to configure it manually using the same /etc/wpa_supplicant.conf
above, and run:

# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf Trying to associate with
00:11:95:c3:0d:ac (SSID='freebsdap' freq=2412 MHz) Associated with
00:11:95:c3:0d:ac WPA: Key negotiation completed with 00:11:95:c3:0d:ac [PTK=
CCMP GTK=CCMP] CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed
(auth) [id=0 id_str=]

The next operation is the launch of the dhclient command to get the IP address
from the DHCP server:

# dhclient wlan0 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 DHCPACK from
192.168.0.1 bound to 192.168.0.254 -- renewal in 300 seconds. # ifconfig wlan0
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether
00:11:95:d5:43:62 inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g status: associated
ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac country US ecm
authmode WPA2/802.11i privacy ON deftxkey UNDEF AES-CCM 3:128-bit txpower 21.5
bmiss 7 scanvalid 450 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
roam:rate 5 protmode CTS wme burst roaming MANUAL

Note:

If /etc/rc.conf has an ifconfig_wlan0 entry with the DHCP string (like
ifconfig_wlan0="DHCP"), dhclient will be launched automatically after
wpa_supplicant associates with the access point.

If DHCP is not possible or desired, you can set a static IP address after
wpa_supplicant has authenticated the station:

# ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0 # ifconfig wlan0
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether
00:11:95:d5:43:62 inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g status: associated
ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac country US ecm
authmode WPA2/802.11i privacy ON deftxkey UNDEF AES-CCM 3:128-bit txpower 21.5
bmiss 7 scanvalid 450 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
roam:rate 5 protmode CTS wme burst roaming MANUAL

When DHCP is not used, you also have to manually set the default gateway and
the nameserver:

# route add default your_default_router # echo "nameserver your_DNS_server" &gt;&gt;
/etc/resolv.conf

32.3.3.1.3.2.Â WPA with EAP-TLS

The second way to use WPA is with an 802.1X backend authentication server. In
this case WPA is called WPA-Enterprise to differentiate it from the less secure
WPA-Personal with its pre-shared key. Authentication in WPA-Enterprise is based
on the Extensible Authentication Protocol (EAP).

EAP does not come with an encryption method. Instead, it was decided to embed
EAP inside an encrypted tunnel. There are many EAP authentication methods, but
EAP-TLS, EAP-TTLS, and EAP-PEAP are the most common.

EAP-TLS (EAP with Transport Layer Security) is a very well-supported
authentication protocol in the wireless world since it was the first EAP method
to be certified by the Wi-Fi alliance. EAP-TLS will require three certificates
to run: the CA certificate (installed on all machines), the server certificate
for your authentication server, and one client certificate for each wireless
client. In this EAP method, both authentication server and wireless client
authenticate each other in presenting their respective certificates, and they
verify that these certificates were signed by your organization's certificate
authority (CA).

As previously, the configuration is done via /etc/wpa_supplicant.conf:

network={ ssid="freebsdap" 1 proto=RSN 2 key_mgmt=WPA-EAP 3 eap=TLS 4 identity=
"loader" 5 ca_cert="/etc/certs/cacert.pem" 6 client_cert="/etc/certs/
clientcert.pem" 7 private_key="/etc/certs/clientkey.pem" 8 private_key_passwd=
"freebsdmallclient" 9 }

1    This field indicates the network name (SSID).

2    Here, we use RSN (IEEEÂ® 802.11i) protocol, i.e., WPA2.

3    The key_mgmt line refers to the key management protocol we use. In our
     case it is WPA using EAP authentication: WPA-EAP.

4    In this field, we mention the EAP method for our connection.

5    The identity field contains the identity string for EAP.

6    The ca_cert field indicates the pathname of the CA certificate file. This
     file is needed to verify the server certificate.

7    The client_cert line gives the pathname to the client certificate file.
     This certificate is unique to each wireless client of the network.

8    The private_key field is the pathname to the client certificate private
     key file.

9    The private_key_passwd field contains the passphrase for the private key.

Then add the following lines to /etc/rc.conf:

wlans_ath0="wlan0" ifconfig_wlan0="WPA DHCP"

The next step is to bring up the interface:

# service netif start Starting wpa_supplicant. DHCPREQUEST on wlan0 to
255.255.255.255 port 67 interval 7 DHCPREQUEST on wlan0 to 255.255.255.255 port
67 interval 15 DHCPACK from 192.168.0.20 bound to 192.168.0.254 -- renewal in
300 seconds. wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
ether 00:11:95:d5:43:62 inet 192.168.0.254 netmask 0xffffff00 broadcast
192.168.0.255 media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g status:
associated ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac
country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF AES-CCM
3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan bgscanintvl 300 bgscanidle
250 roam:rssi 7 roam:rate 5 protmode CTS wme burst roaming MANUAL

As previously shown, it is also possible to bring up the interface manually
with both wpa_supplicant and ifconfig commands.

32.3.3.1.3.3.Â WPA with EAP-TTLS

With EAP-TLS both the authentication server and the client need a certificate,
with EAP-TTLS (EAP-Tunneled Transport Layer Security) a client certificate is
optional. This method is close to what some secure web sites do , where the web
server can create a secure SSL tunnel even if the visitors do not have
client-side certificates. EAP-TTLS will use the encrypted TLS tunnel for safe
transport of the authentication data.

The configuration is done via the /etc/wpa_supplicant.conf file:

network={ ssid="freebsdap" proto=RSN key_mgmt=WPA-EAP eap=TTLS 1 identity=
"test" 2 password="test" 3 ca_cert="/etc/certs/cacert.pem" 4 phase2="auth=MD5" 
5 }

1    In this field, we mention the EAP method for our connection.

2    The identity field contains the identity string for EAP authentication
     inside the encrypted TLS tunnel.

3    The password field contains the passphrase for the EAP authentication.

4    The ca_cert field indicates the pathname of the CA certificate file. This
     file is needed to verify the server certificate.

5    In this field, we mention the authentication method used in the encrypted
     TLS tunnel. In our case, EAP with MD5-Challenge has been used. The â  
     inner authenticationâ   phase is often called â  phase2â  .

You also have to add the following lines to /etc/rc.conf:

wlans_ath0="wlan0" ifconfig_wlan0="WPA DHCP"

The next step is to bring up the interface:

# service netif start Starting wpa_supplicant. DHCPREQUEST on wlan0 to
255.255.255.255 port 67 interval 7 DHCPREQUEST on wlan0 to 255.255.255.255 port
67 interval 15 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20 bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether
00:11:95:d5:43:62 inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g status: associated ssid
freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac country US ecm
authmode WPA2/802.11i privacy ON deftxkey UNDEF AES-CCM 3:128-bit txpower 21.5
bmiss 7 scanvalid 450 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
roam:rate 5 protmode CTS wme burst roaming MANUAL

32.3.3.1.3.4.Â WPA with EAP-PEAP

Note:

PEAPv0/EAP-MSCHAPv2 is the most common PEAP method. In the rest of this
document, we will use the PEAP term to refer to that method.

PEAP (Protected EAP) has been designed as an alternative to EAP-TTLS, and is
the most used EAP standard after EAP-TLS. In other words, if you have a network
with mixed OSes, PEAP should be the most supported standard after EAP-TLS.

PEAP is similar to EAP-TTLS: it uses a server-side certificate to authenticate
clients by creating an encrypted TLS tunnel between the client and the
authentication server, which protects the ensuing exchange of authentication
information. In terms of security, the difference between EAP-TTLS and PEAP is
that PEAP authentication broadcasts the username in the clear, with only the
password sent in the encrypted TLS tunnel. EAP-TTLS will use the TLS tunnel for
both username and password.

We have to edit the /etc/wpa_supplicant.conf file and add the EAP-PEAP related
settings:

network={ ssid="freebsdap" proto=RSN key_mgmt=WPA-EAP eap=PEAP 1 identity=
"test" 2 password="test" 3 ca_cert="/etc/certs/cacert.pem" 4 phase1="peaplabel=
0" 5 phase2="auth=MSCHAPV2" 6 }

1    In this field, we mention the EAP method for our connection.

2    The identity field contains the identity string for EAP authentication
     inside the encrypted TLS tunnel.

3    The password field contains the passphrase for the EAP authentication.

4    The ca_cert field indicates the pathname of the CA certificate file. This
     file is needed to verify the server certificate.

5    This field contains the parameters for the first phase of authentication
     (the TLS tunnel). According to the authentication server used, you will
     have to specify a specific label for authentication. Most of the time, the
     label will be â  client EAP encryptionâ   which is set by using peaplabel=
     0. More information can be found in the wpa_supplicant.conf(5) manual
     page.

6    In this field, we mention the authentication protocol used in the
     encrypted TLS tunnel. In the case of PEAP, it is auth=MSCHAPV2.

The following must be added to /etc/rc.conf:

wlans_ath0="wlan0" ifconfig_wlan0="WPA DHCP"

Then we can bring up the interface:

# service netif start Starting wpa_supplicant. DHCPREQUEST on wlan0 to
255.255.255.255 port 67 interval 7 DHCPREQUEST on wlan0 to 255.255.255.255 port
67 interval 15 DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20 bound to 192.168.0.254 -- renewal in 300 seconds.
wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500 ether
00:11:95:d5:43:62 inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g status: associated ssid
freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac country US ecm
authmode WPA2/802.11i privacy ON deftxkey UNDEF AES-CCM 3:128-bit txpower 21.5
bmiss 7 scanvalid 450 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
roam:rate 5 protmode CTS wme burst roaming MANUAL

32.3.3.1.4.Â WEP

WEP (Wired Equivalent Privacy) is part of the original 802.11 standard. There
is no authentication mechanism, only a weak form of access control, and it is
easily cracked.

WEP can be set up with ifconfig:

# ifconfig wlan0 create wlandev ath0 # ifconfig wlan0 inet 192.168.1.100
netmask 255.255.255.0 \ ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012

  * The weptxkey means which WEP key will be used in the transmission. Here we
    used the third key. This must match the setting in the access point. If you
    do not have any idea of which key is used by the access point, try 1 (i.e.,
    the first key) for this value.

  * The wepkey selects one of the WEP keys. It should be in the format
    index:key. Key 1 is used by default; the index only needs to be set if we
    use a key other than the first key.

    Note:

    You must replace the 0x3456789012 with the key configured for use on the
    access point.

You are encouraged to read the ifconfig(8) manual page for further information.

The wpa_supplicant facility also can be used to configure your wireless
interface with WEP. The example above can be set up by adding the following
lines to /etc/wpa_supplicant.conf:

network={ ssid="my_net" key_mgmt=NONE wep_key3=3456789012 wep_tx_keyidx=3 }

Then:

# wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf Trying to associate with
00:13:46:49:41:76 (SSID='dlinkap' freq=2437 MHz) Associated with
00:13:46:49:41:76

32.3.4.Â Ad-hoc Mode

IBSS mode, also called ad-hoc mode, is designed for point to point connections.
For example, to establish an ad-hoc network between the machine A and the
machine B, we will just need to choose two IP addresses and a SSID.

On the box A:

# ifconfig wlan0 create wlandev ath0 wlanmode adhoc # ifconfig wlan0 inet
192.168.0.1 netmask 255.255.255.0 ssid freebsdap # ifconfig wlan0 wlan0: flags=
8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500 ether
00:11:95:c3:0d:ac inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt; status:
running ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac country
US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60 protmode CTS wme
burst

The adhoc parameter indicates the interface is running in the IBSS mode.

On B, we should be able to detect A:

# ifconfig wlan0 create wlandev ath0 wlanmode adhoc # ifconfig wlan0 up scan
SSID/MESH ID BSSID CHAN RATE S:N INT CAPS freebsdap 02:11:95:c3:0d:ac 2 54M
-64:-96 100 IS WME

The I in the output confirms the machine A is in ad-hoc mode. We just have to
configure B with a different IP address:

# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap #
ifconfig wlan0 wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric
0 mtu 1500 ether 00:11:95:d5:43:62 inet 192.168.0.2 netmask 0xffffff00
broadcast 192.168.0.255 media: IEEE 802.11 Wireless Ethernet autoselect mode
11g &lt;adhoc&gt; status: running ssid freebsdap channel 2 (2417 Mhz 11g) bssid
02:11:95:c3:0d:ac country US ecm authmode OPEN privacy OFF txpower 21.5
scanvalid 60 protmode CTS wme burst

Both A and B are now ready to exchange information.

32.3.5.Â FreeBSD Host Access Points

FreeBSD can act as an Access Point (AP) which eliminates the need to buy a
hardware AP or run an ad-hoc network. This can be particularly useful when your
FreeBSD machine is acting as a gateway to another network (e.g., the Internet).

32.3.5.1.Â Basic Settings

Before configuring your FreeBSD machine as an AP, the kernel must be configured
with the appropriate wireless networking support for your wireless card. You
also have to add support for the security protocols you intend to use. For more
details, see SectionÂ 32.3.2, â  Basic Setupâ  .

Note:

The use of the NDIS driver wrapper and the WindowsÂ® drivers do not currently
allow AP operation. Only native FreeBSD wireless drivers support AP mode.

Once wireless networking support is loaded, you can check if your wireless
device supports the host-based access point mode (also known as hostap mode):

# ifconfig wlan0 create wlandev ath0 # ifconfig wlan0 list caps drivercaps=
6f85edc1
&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
cryptocaps=1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;

This output displays the card capabilities; the HOSTAP word confirms this
wireless card can act as an Access Point. Various supported ciphers are also
mentioned: WEP, TKIP, AES, etc. This information is important to know what
security protocols can be used on the Access Point.

The wireless device can only be put into hostap mode during the creation of the
network pseudo-device, so a previously created device must be destroyed first:

# ifconfig wlan0 destroy

then regenerated with the correct option before setting the other parameters:

# ifconfig wlan0 create wlandev ath0 wlanmode hostap # ifconfig wlan0 inet
192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1

Use ifconfig again to see the status of the wlan0 interface:

# ifconfig wlan0 wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt;
metric 0 mtu 1500 ether 00:11:95:c3:0d:ac inet 192.168.0.1 netmask 0xffffff00
broadcast 192.168.0.255 media: IEEE 802.11 Wireless Ethernet autoselect mode
11g &lt;hostap&gt; status: running ssid freebsdap channel 1 (2412 Mhz 11g) bssid
00:11:95:c3:0d:ac country US ecm authmode OPEN privacy OFF txpower 21.5
scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs

The hostap parameter indicates the interface is running in the host-based
access point mode.

The interface configuration can be done automatically at boot time by adding
the following lines to /etc/rc.conf:

wlans_ath0="wlan0" create_args_wlan0="wlanmode hostap" ifconfig_wlan0="inet
192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1"

32.3.5.2.Â Host-based Access Point Without Authentication or Encryption

Although it is not recommended to run an AP without any authentication or
encryption, this is a simple way to check if your AP is working. This
configuration is also important for debugging client issues.

Once the AP configured as previously shown, it is possible from another
wireless machine to initiate a scan to find the AP:

# ifconfig wlan0 create wlandev ath0 # ifconfig wlan0 up scan SSID/MESH ID
BSSID CHAN RATE S:N INT CAPS freebsdap 00:11:95:c3:0d:ac 1 54M -66:-96 100 ES
WME

The client machine found the Access Point and can be associated with it:

# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap #
ifconfig wlan0 wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric
0 mtu 1500 ether 00:11:95:d5:43:62 inet 192.168.0.2 netmask 0xffffff00
broadcast 192.168.0.255 media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode
11g status: associated ssid freebsdap channel 1 (2412 Mhz 11g) bssid
00:11:95:c3:0d:ac country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5
protmode CTS wme burst

32.3.5.3.Â WPA Host-based Access Point

This section will focus on setting up FreeBSD Access Point using the WPA
security protocol. More details regarding WPA and the configuration of
WPA-based wireless clients can be found in the SectionÂ 32.3.3.1.3, â  WPAâ  .

The hostapd daemon is used to deal with client authentication and keys
management on the WPA enabled Access Point.

In the following, all the configuration operations will be performed on the
FreeBSD machine acting as AP. Once the AP is correctly working, hostapd should
be automatically enabled at boot with the following line in /etc/rc.conf:

hostapd_enable="YES"

Before trying to configure hostapd, be sure you have done the basic settings
introduced in the SectionÂ 32.3.5.1, â  Basic Settingsâ  .

32.3.5.3.1.Â WPA-PSK

WPA-PSK is intended for small networks where the use of an backend
authentication server is not possible or desired.

The configuration is done in the /etc/hostapd.conf file:

interface=wlan0 1 debug=1 2 ctrl_interface=/var/run/hostapd 3
ctrl_interface_group=wheel 4 ssid=freebsdap 5 wpa=1 6 wpa_passphrase=
freebsdmall 7 wpa_key_mgmt=WPA-PSK 8 wpa_pairwise=CCMP TKIP 9

1    This field indicates the wireless interface used for the Access Point.

2    This field sets the level of verbosity during the execution of hostapd. A
     value of 1 represents the minimal level.

3    The ctrl_interface field gives the pathname of the directory used by 
     hostapd to stores its domain socket files for the communication with
     external programs such as hostapd_cli(8). The default value is used here.

4    The ctrl_interface_group line sets the group (here, it is the wheel group)
     allowed to access to the control interface files.

5    This field sets the network name.

6    The wpa field enables WPA and specifies which WPA authentication protocol
     will be required. A value of 1 configures the AP for WPA-PSK.

7    The wpa_passphrase field contains the ASCII passphrase for the WPA
     authentication.

     Warning:

     Always use strong passwords that are sufficiently long and made from a
     rich alphabet so they will not be guessed and/or attacked.

8    The wpa_key_mgmt line refers to the key management protocol we use. In our
     case it is WPA-PSK.

9    The wpa_pairwise field indicates the set of accepted encryption algorithms
     by the Access Point. Here both TKIP (WPA) and CCMP (WPA2) ciphers are
     accepted. CCMP cipher is an alternative to TKIP and that is strongly
     preferred when possible; TKIP should be used solely for stations incapable
     of doing CCMP.

The next step is to start hostapd:

# service hostapd forcestart
# ifconfig wlan0 wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu
2290 inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255 inet6
fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4 ether 00:11:95:c3:0d:ac
media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt; status:
associated ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac authmode WPA2/
802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS
dtimperiod 1 bintval 100

The Access Point is running, the clients can now be associated with it, see
SectionÂ 32.3.3.1.3, â  WPAâ   for more details. It is possible to see the
stations associated with the AP using the ifconfig wlan0 list sta command.

32.3.5.4.Â WEP Host-based Access Point

It is not recommended to use WEP for setting up an Access Point since there is
no authentication mechanism and it is easily to be cracked. Some legacy
wireless cards only support WEP as security protocol, these cards will only
allow to set up AP without authentication or encryption or using the WEP
protocol.

The wireless device can now be put into hostap mode and configured with the
correct SSID and IP address:

# ifconfig wlan0 create wlandev ath0 wlanmode hostap # ifconfig wlan0 inet
192.168.0.1 netmask 255.255.255.0 \ ssid freebsdap wepmode on weptxkey 3 wepkey
3:0x3456789012 mode 11g

  * The weptxkey means which WEP key will be used in the transmission. Here we
    used the third key (note that the key numbering starts with 1). This
    parameter must be specified to really encrypt the data.

  * The wepkey means setting the selected WEP key. It should in the format
    index:key, if the index is not given, key 1 is set. That is to say we need
    to set the index if we use keys other than the first key.

Use again ifconfig to see the status of the wlan0 interface:

# ifconfig wlan0 wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt;
metric 0 mtu 1500 ether 00:11:95:c3:0d:ac inet 192.168.0.1 netmask 0xffffff00
broadcast 192.168.0.255 media: IEEE 802.11 Wireless Ethernet autoselect mode
11g &lt;hostap&gt; status: running ssid freebsdap channel 4 (2427 Mhz 11g) bssid
00:11:95:c3:0d:ac country US ecm authmode OPEN privacy ON deftxkey 3 wepkey
3:40-bit txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 -dfs

From another wireless machine, it is possible to initiate a scan to find the
AP:

# ifconfig wlan0 create wlandev ath0 # ifconfig wlan0 up scan SSID BSSID CHAN
RATE S:N INT CAPS freebsdap 00:11:95:c3:0d:ac 1 54M 22:1 100 EPS

The client machine found the Access Point and can be associated with it using
the correct parameters (key, etc.), see SectionÂ 32.3.3.1.4, â  WEPâ   for more
details.

32.3.6.Â Using Both Wired and Wireless Connection

Wired connection provides better performance and reliability, while wireless
connection provides flexibility and mobility, users of laptop computers usually
want to combine these together and roam seamlessly between the two.

On FreeBSD, it is possible to combine two or even more network interfaces
together in a â  failoverâ   fashion, that is, to use the most preferred and
available connection from a group of network interfaces, and have the operating
system switch automatically when the link state changes.

We will cover link aggregation and failover in SectionÂ 32.6, â  Link
Aggregation and Failoverâ   where an example for using both wired and wireless
connection is also provided at ExampleÂ 32.3, â  Failover Mode Between Wired
and Wireless Interfacesâ  .

32.3.7.Â Troubleshooting

If you are having trouble with wireless networking, there are a number of steps
you can take to help troubleshoot the problem.

  * If you do not see the access point listed when scanning be sure you have
    not configured your wireless device to a limited set of channels.

  * If you cannot associate to an access point verify the configuration of your
    station matches the one of the access point. This includes the
    authentication scheme and any security protocols. Simplify your
    configuration as much as possible. If you are using a security protocol
    such as WPA or WEP configure the access point for open authentication and
    no security to see if you can get traffic to pass.

  * Once you can associate to the access point diagnose any security
    configuration using simple tools like ping(8).

    The wpa_supplicant has much debugging support; try running it manually with
    the -dd option and look at the system logs.

  * There are also many lower-level debugging tools. You can enable debugging
    messages in the 802.11 protocol support layer using the wlandebug program
    found in /usr/src/tools/tools/net80211. For example:

    # wlandebug -i ath0 +scan+auth+debug+assoc net.wlan.0.debug: 0 =&gt; 0xc80000
    &lt;assoc,auth,scan&gt;

    can be used to enable console messages related to scanning for access
    points and doing the 802.11 protocol handshakes required to arrange
    communication.

    There are also many useful statistics maintained by the 802.11 layer; the
    wlanstats tool will dump this information. These statistics should identify
    all errors identified by the 802.11 layer. Beware however that some errors
    are identified in the device drivers that lie below the 802.11 layer so
    they may not show up. To diagnose device-specific problems you need to
    refer to the drivers' documentation.

If the above information does not help to clarify the problem, please submit a
problem report and include output from the above tools.

32.4.Â Bluetooth

Written by Pav Lucistnik.

32.4.1.Â Introduction

Bluetooth is a wireless technology for creating personal networks operating in
the 2.4 GHz unlicensed band, with a range of 10 meters. Networks are usually
formed ad-hoc from portable devices such as cellular phones, handhelds and
laptops. Unlike the other popular wireless technology, Wi-Fi, Bluetooth offers
higher level service profiles, e.g., FTP-like file servers, file pushing, voice
transport, serial line emulation, and more.

The Bluetooth stack in FreeBSD is implemented using the Netgraph framework (see
netgraph(4)). A broad variety of Bluetooth USB dongles is supported by the
ng_ubt(4) driver. The Broadcom BCM2033 chip based Bluetooth devices are
supported via the ubtbcmfw(4) and ng_ubt(4) drivers. The 3Com Bluetooth PC Card
3CRWB60-A is supported by the ng_bt3c(4) driver. Serial and UART based
Bluetooth devices are supported via sio(4), ng_h4(4) and hcseriald(8). This
section describes the use of the USB Bluetooth dongle.

32.4.2.Â Plugging in the Device

By default Bluetooth device drivers are available as kernel modules. Before
attaching a device, you will need to load the driver into the kernel:

# kldload ng_ubt

If the Bluetooth device is present in the system during system startup, load
the module from /boot/loader.conf:

ng_ubt_load="YES"

Plug in your USB dongle. The output similar to the following will appear on the
console (or in syslog):

ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2 ubt0: Interface 0
endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2 ubt0: Interface 1
(alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3, wMaxPacketSize=49,
nframes=6, buffer size=294

service(8) is used to start and stop the Bluetooth stack. It is a good idea to
stop the stack before unplugging the device, but it is not (usually) fatal.
When starting the stack, you will receive output similar to the following:

# service bluetooth start ubt0 BD_ADDR: 00:02:72:00:d4:1a Features: 0xff 0xff
0xf 00 00 00 00 00 &lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt; &lt;Timing
accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt; &lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel
quality&gt; &lt;SCO link&gt; &lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt; Max. ACL packet size:
192 bytes Number of ACL packets: 8 Max. SCO packet size: 64 bytes Number of SCO
packets: 8

32.4.3.Â Host Controller Interface (HCI)

Host Controller Interface (HCI) provides a command interface to the baseband
controller and link manager, and access to hardware status and control
registers. This interface provides a uniform method of accessing the Bluetooth
baseband capabilities. HCI layer on the Host exchanges data and commands with
the HCI firmware on the Bluetooth hardware. The Host Controller Transport Layer
(i.e., physical bus) driver provides both HCI layers with the ability to
exchange information with each other.

A single Netgraph node of type hci is created for a single Bluetooth device.
The HCI node is normally connected to the Bluetooth device driver node
(downstream) and the L2CAP node (upstream). All HCI operations must be
performed on the HCI node and not on the device driver node. Default name for
the HCI node is â  devicehciâ  . For more details refer to the ng_hci(4) manual
page.

One of the most common tasks is discovery of Bluetooth devices in RF proximity.
This operation is called inquiry. Inquiry and other HCI related operations are
done with the hccontrol(8) utility. The example below shows how to find out
which Bluetooth devices are in range. You should receive the list of devices in
a few seconds. Note that a remote device will only answer the inquiry if it put
into discoverable mode.

% hccontrol -n ubt0hci inquiry Inquiry result, num_responses=1 Inquiry result #
0 BD_ADDR: 00:80:37:29:19:a4 Page Scan Rep. Mode: 0x1 Page Scan Period Mode: 00
Page Scan Mode: 00 Class: 52:02:04 Clock offset: 0x78ef Inquiry complete.
Status: No error [00]

BD_ADDR is unique address of a Bluetooth device, similar to MAC addresses of a
network card. This address is needed for further communication with a device.
It is possible to assign human readable name to a BD_ADDR. The /etc/bluetooth/
hosts file contains information regarding the known Bluetooth hosts. The
following example shows how to obtain human readable name that was assigned to
the remote device:

% hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4 BD_ADDR:
00:80:37:29:19:a4 Name: Pav's T39

If you perform an inquiry on a remote Bluetooth device, it will find your
computer as â  your.host.name (ubt0)â  . The name assigned to the local device
can be changed at any time.

The Bluetooth system provides a point-to-point connection (only two Bluetooth
units involved), or a point-to-multipoint connection. In the
point-to-multipoint connection the connection is shared among several Bluetooth
devices. The following example shows how to obtain the list of active baseband
connections for the local device:

% hccontrol -n ubt0hci read_connection_list Remote BD_ADDR Handle Type Mode
Role Encrypt Pending Queue State 00:80:37:29:19:a4 41 ACL 0 MAST NONE 0 0 OPEN

A connection handle is useful when termination of the baseband connection is
required. Note, that it is normally not required to do it by hand. The stack
will automatically terminate inactive baseband connections.

# hccontrol -n ubt0hci disconnect 41 Connection handle: 41 Reason: Connection
terminated by local host [0x16]

Refer to hccontrol help for a complete listing of available HCI commands. Most
of the HCI commands do not require superuser privileges.

32.4.4.Â Logical Link Control and Adaptation Protocol (L2CAP)

Logical Link Control and Adaptation Protocol (L2CAP) provides
connection-oriented and connectionless data services to upper layer protocols
with protocol multiplexing capability and segmentation and reassembly
operation. L2CAP permits higher level protocols and applications to transmit
and receive L2CAP data packets up to 64 kilobytes in length.

L2CAP is based around the concept of channels. Channel is a logical connection
on top of baseband connection. Each channel is bound to a single protocol in a
many-to-one fashion. Multiple channels can be bound to the same protocol, but a
channel cannot be bound to multiple protocols. Each L2CAP packet received on a
channel is directed to the appropriate higher level protocol. Multiple channels
can share the same baseband connection.

A single Netgraph node of type l2cap is created for a single Bluetooth device.
The L2CAP node is normally connected to the Bluetooth HCI node (downstream) and
Bluetooth sockets nodes (upstream). Default name for the L2CAP node is â  
devicel2capâ  . For more details refer to the ng_l2cap(4) manual page.

A useful command is l2ping(8), which can be used to ping other devices. Some
Bluetooth implementations might not return all of the data sent to them, so 0
bytes in the following example is normal.

# l2ping -a 00:80:37:29:19:a4 0 bytes from 0:80:37:29:19:a4 seq_no=0 time=
48.633 ms result=0 0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result
=0 0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0 0 bytes from
0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0

The l2control(8) utility is used to perform various operations on L2CAP nodes.
This example shows how to obtain the list of logical connections (channels) and
the list of baseband connections for the local device:

% l2control -a 00:02:72:00:d4:1a read_channel_list L2CAP channels: Remote
BD_ADDR SCID/ DCID PSM IMTU/ OMTU State 00:07:e0:00:0b:ca 66/ 64 3 132/ 672
OPEN % l2control -a 00:02:72:00:d4:1a read_connection_list L2CAP connections:
Remote BD_ADDR Handle Flags Pending State 00:07:e0:00:0b:ca 41 O 0 OPEN

Another diagnostic tool is btsockstat(1). It does a job similar to as netstat
(1) does, but for Bluetooth network-related data structures. The example below
shows the same logical connection as l2control(8) above.

% btsockstat Active L2CAP sockets PCB Recv-Q Send-Q Local address/PSM Foreign
address CID State c2afe900 0 0 00:02:72:00:d4:1a/3 00:07:e0:00:0b:ca 66 OPEN
Active RFCOMM sessions L2PCB PCB Flag MTU Out-Q DLCs State c2afe900 c2b53380 1
127 0 Yes OPEN Active RFCOMM sockets PCB Recv-Q Send-Q Local address Foreign
address Chan DLCI State c2e8bc80 0 250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3 6
OPEN

32.4.5.Â RFCOMM Protocol

The RFCOMM protocol provides emulation of serial ports over the L2CAP protocol.
The protocol is based on the ETSI standard TS 07.10. RFCOMM is a simple
transport protocol, with additional provisions for emulating the 9 circuits of
RS-232 (EIATIA-232-E) serial ports. The RFCOMM protocol supports up to 60
simultaneous connections (RFCOMM channels) between two Bluetooth devices.

For the purposes of RFCOMM, a complete communication path involves two
applications running on different devices (the communication endpoints) with a
communication segment between them. RFCOMM is intended to cover applications
that make use of the serial ports of the devices in which they reside. The
communication segment is a Bluetooth link from one device to another (direct
connect).

RFCOMM is only concerned with the connection between the devices in the direct
connect case, or between the device and a modem in the network case. RFCOMM can
support other configurations, such as modules that communicate via Bluetooth
wireless technology on one side and provide a wired interface on the other
side.

In FreeBSD the RFCOMM protocol is implemented at the Bluetooth sockets layer.

32.4.6.Â Pairing of Devices

By default, Bluetooth communication is not authenticated, and any device can
talk to any other device. A Bluetooth device (for example, cellular phone) may
choose to require authentication to provide a particular service (for example,
Dial-Up service). Bluetooth authentication is normally done with PIN codes. A
PIN code is an ASCII string up to 16 characters in length. User is required to
enter the same PIN code on both devices. Once user has entered the PIN code,
both devices will generate a link key. After that the link key can be stored
either in the devices themselves or in a persistent storage. Next time both
devices will use previously generated link key. The described above procedure
is called pairing. Note that if the link key is lost by any device then pairing
must be repeated.

The hcsecd(8) daemon is responsible for handling of all Bluetooth
authentication requests. The default configuration file is /etc/bluetooth/
hcsecd.conf. An example section for a cellular phone with the PIN code
arbitrarily set to â  1234â   is shown below:

device { bdaddr 00:80:37:29:19:a4; name "Pav's T39"; key nokey; pin "1234"; }

There is no limitation on PIN codes (except length). Some devices (for example
Bluetooth headsets) may have a fixed PIN code built in. The -d switch forces
the hcsecd(8) daemon to stay in the foreground, so it is easy to see what is
happening. Set the remote device to receive pairing and initiate the Bluetooth
connection to the remote device. The remote device should say that pairing was
accepted, and request the PIN code. Enter the same PIN code as you have in
hcsecd.conf. Now your PC and the remote device are paired. Alternatively, you
can initiate pairing on the remote device.

The following line can be added to the /etc/rc.conf file to have hcsecd started
automatically on system start:

hcsecd_enable="YES"

The following is a sample of the hcsecd daemon output:

hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr
0:80:37:29:19:a4 hcsecd[16484]: Found matching entry, remote bdaddr
0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist hcsecd[16484]:
Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr
0:80:37:29:19:a4 hcsecd[16484]: Found matching entry, remote bdaddr
0:80:37:29:19:a4, name 'Pav's T39', PIN code exists hcsecd[16484]: Sending
PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4

32.4.7.Â Service Discovery Protocol (SDP)

The Service Discovery Protocol (SDP) provides the means for client applications
to discover the existence of services provided by server applications as well
as the attributes of those services. The attributes of a service include the
type or class of service offered and the mechanism or protocol information
needed to utilize the service.

SDP involves communication between a SDP server and a SDP client. The server
maintains a list of service records that describe the characteristics of
services associated with the server. Each service record contains information
about a single service. A client may retrieve information from a service record
maintained by the SDP server by issuing a SDP request. If the client, or an
application associated with the client, decides to use a service, it must open
a separate connection to the service provider in order to utilize the service.
SDP provides a mechanism for discovering services and their attributes, but it
does not provide a mechanism for utilizing those services.

Normally, a SDP client searches for services based on some desired
characteristics of the services. However, there are times when it is desirable
to discover which types of services are described by an SDP server's service
records without any a priori information about the services. This process of
looking for any offered services is called browsing.

The Bluetooth SDP server sdpd(8) and command line client sdpcontrol(8) are
included in the standard FreeBSD installation. The following example shows how
to perform a SDP browse query.

% sdpcontrol -a 00:01:03:fc:6e:ec browse Record Handle: 00000000 Service Class
ID List: Service Discovery Server (0x1000) Protocol Descriptor List: L2CAP
(0x0100) Protocol specific parameter #1: u/int/uuid16 1 Protocol specific
parameter #2: u/int/uuid16 1 Record Handle: 0x00000001 Service Class ID List:
Browse Group Descriptor (0x1001) Record Handle: 0x00000002 Service Class ID
List: LAN Access Using PPP (0x1102) Protocol Descriptor List: L2CAP (0x0100)
RFCOMM (0x0003) Protocol specific parameter #1: u/int8/bool 1 Bluetooth Profile
Descriptor List: LAN Access Using PPP (0x1102) ver. 1.0

... and so on. Note that each service has a list of attributes (RFCOMM channel
for example). Depending on the service you might need to make a note of some of
the attributes. Some Bluetooth implementations do not support service browsing
and may return an empty list. In this case it is possible to search for the
specific service. The example below shows how to search for the OBEX Object
Push (OPUSH) service:

% sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH

Offering services on FreeBSD to Bluetooth clients is done with the sdpd(8)
server. The following line can be added to the /etc/rc.conf file:

sdpd_enable="YES"

Then the sdpd daemon can be started with:

# service sdpd start

The local server application that wants to provide Bluetooth service to the
remote clients will register service with the local SDP daemon. The example of
such application is rfcomm_pppd(8). Once started it will register Bluetooth LAN
service with the local SDP daemon.

The list of services registered with the local SDP server can be obtained by
issuing SDP browse query via local control channel:

# sdpcontrol -l browse

32.4.8.Â Dial-Up Networking (DUN) and Network Access with PPP (LAN) Profiles

The Dial-Up Networking (DUN) profile is mostly used with modems and cellular
phones. The scenarios covered by this profile are the following:

  * use of a cellular phone or modem by a computer as a wireless modem for
    connecting to a dial-up Internet access server, or using other dial-up
    services;

  * use of a cellular phone or modem by a computer to receive data calls.

Network Access with PPP (LAN) profile can be used in the following situations:

  * LAN access for a single Bluetooth device;

  * LAN access for multiple Bluetooth devices;

  * PC to PC (using PPP networking over serial cable emulation).

In FreeBSD both profiles are implemented with ppp(8) and rfcomm_pppd(8) - a
wrapper that converts RFCOMM Bluetooth connection into something PPP can
operate with. Before any profile can be used, a new PPP label in the /etc/ppp/
ppp.conf must be created. Consult rfcomm_pppd(8) manual page for examples.

In the following example rfcomm_pppd(8) will be used to open RFCOMM connection
to remote device with BD_ADDR 00:80:37:29:19:a4 on DUN RFCOMM channel. The
actual RFCOMM channel number will be obtained from the remote device via SDP.
It is possible to specify RFCOMM channel by hand, and in this case rfcomm_pppd
(8) will not perform SDP query. Use sdpcontrol(8) to find out RFCOMM channel on
the remote device.

# rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup

In order to provide Network Access with PPP (LAN) service the sdpd(8) server
must be running. A new entry for LAN clients must be created in the /etc/ppp/
ppp.conf file. Consult rfcomm_pppd(8) manual page for examples. Finally, start
RFCOMM PPP server on valid RFCOMM channel number. The RFCOMM PPP server will
automatically register Bluetooth LAN service with the local SDP daemon. The
example below shows how to start RFCOMM PPP server.

# rfcomm_pppd -s -C 7 -l rfcomm-server

32.4.9.Â OBEX Object Push (OPUSH) Profile

OBEX is a widely used protocol for simple file transfers between mobile
devices. Its main use is in infrared communication, where it is used for
generic file transfers between notebooks or PDAs, and for sending business
cards or calendar entries between cellular phones and other devices with PIM
applications.

The OBEX server and client are implemented as a third-party package obexapp,
which is available as comms/obexapp port.

OBEX client is used to push and/or pull objects from the OBEX server. An object
can, for example, be a business card or an appointment. The OBEX client can
obtain RFCOMM channel number from the remote device via SDP. This can be done
by specifying service name instead of RFCOMM channel number. Supported service
names are: IrMC, FTRN and OPUSH. It is possible to specify RFCOMM channel as a
number. Below is an example of an OBEX session, where device information object
is pulled from the cellular phone, and a new object (business card) is pushed
into the phone's directory.

% obexapp -a 00:80:37:29:19:a4 -C IrMC obex&gt; get telecom/devinfo.txt
devinfo-t39.txt Success, response: OK, Success (0x20) obex&gt; put new.vcf
Success, response: OK, Success (0x20) obex&gt; di Success, response: OK, Success
(0x20)

In order to provide OBEX Object Push service, sdpd(8) server must be running. A
root folder, where all incoming objects will be stored, must be created. The
default path to the root folder is /var/spool/obex. Finally, start OBEX server
on valid RFCOMM channel number. The OBEX server will automatically register
OBEX Object Push service with the local SDP daemon. The example below shows how
to start OBEX server.

# obexapp -s -C 10

32.4.10.Â Serial Port Profile (SPP)

The Serial Port Profile (SPP) allows Bluetooth devices to perform RS232 (or
similar) serial cable emulation. The scenario covered by this profile deals
with legacy applications using Bluetooth as a cable replacement, through a
virtual serial port abstraction.

The rfcomm_sppd(1) utility implements the Serial Port profile. A pseudo tty is
used as a virtual serial port abstraction. The example below shows how to
connect to a remote device Serial Port service. Note that you do not have to
specify a RFCOMM channel - rfcomm_sppd(1) can obtain it from the remote device
via SDP. If you would like to override this, specify a RFCOMM channel on the
command line.

# rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6 rfcomm_sppd[94692]: Starting
on /dev/ttyp6...

Once connected, the pseudo tty can be used as serial port:

# cu -l ttyp6

32.4.11.Â Troubleshooting

32.4.11.1.Â A Remote Device Cannot Connect

Some older Bluetooth devices do not support role switching. By default, when
FreeBSD is accepting a new connection, it tries to perform a role switch and
become master. Devices, which do not support this will not be able to connect.
Note that role switching is performed when a new connection is being
established, so it is not possible to ask the remote device if it does support
role switching. There is a HCI option to disable role switching on the local
side:

# hccontrol -n ubt0hci write_node_role_switch 0

32.4.11.2.Â Something is Going Wrong, Can I See What Exactly is Happening?

Yes, you can. Use the third-party package hcidump, which is available as comms/
hcidump port. The hcidump utility is similar to tcpdump(1). It can be used to
display the content of the Bluetooth packets on the terminal and to dump the
Bluetooth packets to a file.

32.5.Â Bridging

Written by Andrew Thompson.

32.5.1.Â Introduction

It is sometimes useful to divide one physical network (such as an Ethernet
segment) into two separate network segments without having to create IP subnets
and use a router to connect the segments together. A device that connects two
networks together in this fashion is called a â  bridgeâ  . A FreeBSD system
with two network interface cards can act as a bridge.

The bridge works by learning the MAC layer addresses (Ethernet addresses) of
the devices on each of its network interfaces. It forwards traffic between two
networks only when its source and destination are on different networks.

In many respects, a bridge is like an Ethernet switch with very few ports.

32.5.2.Â Situations Where Bridging Is Appropriate

There are many common situations in which a bridge is used today.

32.5.2.1.Â Connecting Networks

The basic operation of a bridge is to join two or more network segments
together. There are many reasons to use a host based bridge over plain
networking equipment such as cabling constraints, firewalling or connecting
pseudo networks such as a Virtual Machine interface. A bridge can also connect
a wireless interface running in hostap mode to a wired network and act as an
access point.

32.5.2.2.Â Filtering/Traffic Shaping Firewall

A common situation is where firewall functionality is needed without routing or
network address translation (NAT).

An example is a small company that is connected via DSL or ISDN to their ISP.
They have a 13 globally-accessible IP addresses from their ISP and have 10 PCs
on their network. In this situation, using a router-based firewall is difficult
because of subnetting issues.

A bridge-based firewall can be configured and dropped into the path just
downstream of their DSL/ISDN router without any IP numbering issues.

32.5.2.3.Â Network Tap

A bridge can join two network segments and be used to inspect all Ethernet
frames that pass between them. This can either be from using bpf(4)/tcpdump(1)
on the bridge interface or by sending a copy of all frames out an additional
interface (span port).

32.5.2.4.Â Layer 2 VPN

Two Ethernet networks can be joined across an IP link by bridging the networks
to an EtherIP tunnel or a tap(4) based solution such as OpenVPN.

32.5.2.5.Â Layer 2 Redundancy

A network can be connected together with multiple links and use the Spanning
Tree Protocol to block redundant paths. For an Ethernet network to function
properly only one active path can exist between two devices, Spanning Tree will
detect loops and put the redundant links into a blocked state. Should one of
the active links fail then the protocol will calculate a different tree and
reenable one of the blocked paths to restore connectivity to all points in the
network.

32.5.3.Â Kernel Configuration

This section covers if_bridge(4) bridge implementation, a netgraph bridging
driver is also available, for more information see ng_bridge(4) manual page.

The bridge driver is a kernel module and will be automatically loaded by
ifconfig(8) when creating a bridge interface. It is possible to compile the
bridge in to the kernel by adding device if_bridge to your kernel configuration
file.

Packet filtering can be used with any firewall package that hooks in via the
pfil(9) framework. The firewall can be loaded as a module or compiled into the
kernel.

The bridge can be used as a traffic shaper with altq(4) or dummynet(4).

32.5.4.Â Enabling the Bridge

The bridge is created using interface cloning. To create a bridge use ifconfig
(8), if the bridge driver is not present in the kernel then it will be loaded
automatically.

# ifconfig bridge create bridge0 # ifconfig bridge0 bridge0: flags=8802
&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500 ether 96:3d:4b:f1:79:7a id
00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15 maxage 20 holdcnt 6
proto rstp maxaddr 100 timeout 1200 root id 00:00:00:00:00:00 priority 0 ifcost
0 port 0

A bridge interface is created and is automatically assigned a randomly
generated Ethernet address. The maxaddr and timeout parameters control how many
MAC addresses the bridge will keep in its forwarding table and how many seconds
before each entry is removed after it is last seen. The other parameters
control how Spanning Tree operates.

Add the member network interfaces to the bridge. For the bridge to forward
packets all member interfaces and the bridge need to be up:

# ifconfig bridge0 addm fxp0 addm fxp1 up # ifconfig fxp0 up # ifconfig fxp1 up

The bridge is now forwarding Ethernet frames between fxp0 and fxp1. The
equivalent configuration in /etc/rc.conf so the bridge is created at startup
is:

cloned_interfaces="bridge0" ifconfig_bridge0="addm fxp0 addm fxp1 up"
ifconfig_fxp0="up" ifconfig_fxp1="up"

If the bridge host needs an IP address then the correct place to set this is on
the bridge interface itself rather than one of the member interfaces. This can
be set statically or via DHCP:

# ifconfig bridge0 inet 192.168.0.1/24

It is also possible to assign an IPv6 address to a bridge interface.

32.5.5.Â Firewalling

When packet filtering is enabled, bridged packets will pass through the filter
inbound on the originating interface, on the bridge interface and outbound on
the appropriate interfaces. Either stage can be disabled. When direction of the
packet flow is important it is best to firewall on the member interfaces rather
than the bridge itself.

The bridge has several configurable settings for passing non-IP and ARP
packets, and layer2 firewalling with IPFW. See if_bridge(4) for more
information.

32.5.6.Â Spanning Tree

The bridge driver implements the Rapid Spanning Tree Protocol (RSTP or 802.1w)
with backwards compatibility with the legacy Spanning Tree Protocol (STP).
Spanning Tree is used to detect and remove loops in a network topology. RSTP
provides faster Spanning Tree convergence than legacy STP, the protocol will
exchange information with neighbouring switches to quickly transition to
forwarding without creating loops. FreeBSD supports RSTP and STP as operating
modes, with RSTP being the default mode.

Spanning Tree can be enabled on member interfaces using the stp command. For a
bridge with fxp0 and fxp1 as the current interfaces, enable STP with the
following:

# ifconfig bridge0 stp fxp0 stp fxp1 bridge0: flags=8843
&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500 ether
d6:cf:d5:a0:94:6d id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200 root id
00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0 member: fxp0 flags=1c7
&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt; port 3 priority 128 path cost
200000 proto rstp role designated state forwarding member: fxp1 flags=1c7
&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt; port 4 priority 128 path cost
200000 proto rstp role designated state forwarding

This bridge has a spanning tree ID of 00:01:02:4b:d4:50 and a priority of
32768. As the root id is the same it indicates that this is the root bridge for
the tree.

Another bridge on the network also has spanning tree enabled:

bridge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
ether 96:3d:4b:f1:79:7a id 00:13:d4:9a:06:7a priority 32768 hellotime 2
fwddelay 15 maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200 root id
00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4 member: fxp0 flags=1c7
&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt; port 4 priority 128 path cost
200000 proto rstp role root state forwarding member: fxp1 flags=1c7
&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt; port 5 priority 128 path cost
200000 proto rstp role designated state forwarding

The line root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4 shows
that the root bridge is 00:01:02:4b:d4:50 as above and has a path cost of
400000 from this bridge, the path to the root bridge is via port 4 which is
fxp0.

32.5.7.Â Advanced Bridging

32.5.7.1.Â Reconstruct Traffic Flows

The bridge supports monitor mode, where the packets are discarded after bpf(4)
processing, and are not processed or forwarded further. This can be used to
multiplex the input of two or more interfaces into a single bpf(4) stream. This
is useful for reconstructing the traffic for network taps that transmit the RX/
TX signals out through two separate interfaces.

To read the input from four network interfaces as one stream:

# ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up # tcpdump
-i bridge0

32.5.7.2.Â Span Ports

A copy of every Ethernet frame received by the bridge will be transmitted out a
designated span port. The number of span ports configured on a bridge is
unlimited, if an interface is designated as a span port then it may not also be
used as a regular bridge port. This is most useful for snooping a bridged
network passively on another host connected to one of the span ports of the
bridge.

To send a copy of all frames out the interface named fxp4:

# ifconfig bridge0 span fxp4

32.5.7.3.Â Private Interfaces

A private interface does not forward any traffic to any other port that is also
a private interface. The traffic is blocked unconditionally so no Ethernet
frames will be forwarded, including ARP. If traffic needs to be selectively
blocked then a firewall should be used instead.

32.5.7.4.Â Sticky Interfaces

If a bridge member interface is marked as sticky then dynamically learned
address entries are treated at static once entered into the forwarding cache.
Sticky entries are never aged out of the cache or replaced, even if the address
is seen on a different interface. This gives the benefit of static address
entries without the need to pre-populate the forwarding table, clients learnt
on a particular segment of the bridge can not roam to another segment.

Another example of using sticky addresses would be to combine the bridge with
VLANs to create a router where customer networks are isolated without wasting
IP address space. Consider that CustomerA is on vlan100 and CustomerB is on
vlan101. The bridge has the address 192.168.0.1 and is also an internet router.

# ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101 #
ifconfig bridge0 inet 192.168.0.1/24

Both clients see 192.168.0.1 as their default gateway and since the bridge
cache is sticky they can not spoof the MAC address of the other customer to
intercept their traffic.

Any communication between the VLANs can be blocked using private interfaces (or
a firewall):

# ifconfig bridge0 private vlan100 private vlan101

The customers are completely isolated from each other, the full /24 address
range can be allocated without subnetting.

32.5.7.5.Â Address Limits

The number of unique source MAC addresses behind an interface can be limited.
Once the limit is reached packets with unknown source addresses are dropped
until an existing host cache entry expires or is removed.

The following example sets the maximum number of Ethernet devices for CustomerA
on vlan100 to 10.

# ifconfig bridge0 ifmaxaddr vlan100 10

32.5.7.6.Â SNMP Monitoring

The bridge interface and STP parameters can be monitored via the SNMP daemon
which is included in the FreeBSD base system. The exported bridge MIBs conform
to the IETF standards so any SNMP client or monitoring package can be used to
retrieve the data.

On the bridge machine uncomment the begemotSnmpdModulePath."bridge" = "/usr/lib
/snmp_bridge.so" line from /etc/snmp.config and start the bsnmpd daemon. Other
configuration such as community names and access lists may need to be modified.
See bsnmpd(1) and snmp_bridge(3) for more information.

The following examples use the Net-SNMP software (net-mgmt/net-snmp) to query a
bridge, the net-mgmt/bsnmptools port can also be used. From the SNMP client
host add to $HOME/.snmp/snmp.conf the following lines to import the bridge MIB
definitions in to Net-SNMP:

mibdirs +/usr/share/snmp/mibs mibs
+BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB

To monitor a single bridge via the IETF BRIDGE-MIB (RFC4188) do

% snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59
centi-seconds BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50 ...
BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)
BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)
BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4
50 BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1
RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)

The dot1dStpTopChanges.0 value is two which means that the STP bridge topology
has changed twice, a topology change means that one or more links in the
network have changed or failed and a new tree has been calculated. The
dot1dStpTimeSinceTopologyChange.0 value will show when this happened.

To monitor multiple bridge interfaces one may use the private
BEGEMOT-BRIDGE-MIB:

% snmpwalk -v 2c -c public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge0" = STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName."bridge2" = STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge0" = STRING:
e:ce:3b:5a:9e:13 BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress."bridge2" =
STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge0" = INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts."bridge2" = INTEGER: 1 ...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge0" =
Timeticks: (116927) 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange."bridge2" =
Timeticks: (82773) 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge0" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges."bridge2" = Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge0" = Hex-STRING: 80
00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot."bridge2" = Hex-STRING: 80
00 00 50 8B B8 C6 A9

To change the bridge interface being monitored via the mib-2.dot1dBridge
subtree do:

% snmpset -v 2c -c private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2

32.6.Â Link Aggregation and Failover

Written by Andrew Thompson.

32.6.1.Â Introduction

The lagg(4) interface allows aggregation of multiple network interfaces as one
virtual interface for the purpose of providing fault-tolerance and high-speed
links.

32.6.2.Â Operating Modes

Failover

    Sends and receives traffic only through the master port. If the master port
    becomes unavailable, the next active port is used. The first interface
    added is the master port; any interfaces added after that are used as
    failover devices. If failover to a non-master port occurs, the original
    port will become master when it becomes available again.

CiscoÂ® Fast EtherChannelÂ®

    CiscoÂ® Fast EtherChannelÂ® (FEC), is a static setup and does not negotiate
    aggregation with the peer or exchange frames to monitor the link. If the
    switch supports LACP then that should be used instead.

    FEC balances outgoing traffic across the active ports based on hashed
    protocol header information and accepts incoming traffic from any active
    port. The hash includes the Ethernet source and destination address, and,
    if available, the VLAN tag, and the IPv4/IPv6 source and destination
    address.

LACP

    The IEEEÂ® 802.3ad Link Aggregation Control Protocol (LACP) and the Marker
    Protocol. LACP will negotiate a set of aggregable links with the peer in to
    one or more Link Aggregated Groups (LAG). Each LAG is composed of ports of
    the same speed, set to full-duplex operation. The traffic will be balanced
    across the ports in the LAG with the greatest total speed, in most cases
    there will only be one LAG which contains all ports. In the event of
    changes in physical connectivity, Link Aggregation will quickly converge to
    a new configuration.

    LACP balances outgoing traffic across the active ports based on hashed
    protocol header information and accepts incoming traffic from any active
    port. The hash includes the Ethernet source and destination address, and,
    if available, the VLAN tag, and the IPv4/IPv6 source and destination
    address.

Loadbalance

    This is an alias of FEC mode.

Round-robin

    Distributes outgoing traffic using a round-robin scheduler through all
    active ports and accepts incoming traffic from any active port. This mode
    violates Ethernet Frame ordering and should be used with caution.

32.6.3.Â Examples

ExampleÂ 32.1.Â LACP Aggregation with a CiscoÂ® Switch

This example connects two interfaces on a FreeBSD machine to the switch as a
single load balanced and fault tolerant link. More interfaces can be added to
increase throughput and fault tolerance. Since frame ordering is mandatory on
Ethernet links then any traffic between two stations always flows over the same
physical link limiting the maximum speed to that of one interface. The transmit
algorithm attempts to use as much information as it can to distinguish
different traffic flows and balance across the available interfaces.

On the CiscoÂ® switch add the FastEthernet0/1 and FastEthernet0/2 interfaces to
the channel-group 1:

interface FastEthernet0/1 channel-group 1 mode active channel-protocol lacp !
interface FastEthernet0/2 channel-group 1 mode active channel-protocol lacp

Create the lagg(4) interface using fxp0 and fxp1, and bring the interfaces up
with the IP Address of 10.0.0.3/24:

# ifconfig fxp0 up # ifconfig fxp1 up # ifconfig lagg0 create # ifconfig lagg0
up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24

View the interface status by running:

# ifconfig lagg0

Ports marked as ACTIVE are part of the active aggregation group that has been
negotiated with the remote switch and traffic will be transmitted and received.
Use the verbose output of ifconfig(8) to view the LAG identifiers.

lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
options=8&lt;VLAN_MTU&gt; ether 00:05:5d:71:8d:b8 media: Ethernet autoselect status:
active laggproto lacp laggport: fxp1 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
laggport: fxp0 flags=1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;

To see the port status on the switch, use show lacp neighbor:

switch# show lacp neighbor Flags: S - Device is requesting Slow LACPDUs F -
Device is requesting Fast LACPDUs A - Device is in Active mode P - Device is in
Passive mode Channel group 1 neighbors Partner's information: LACP port Oper
Port Port Port Flags Priority Dev ID Age Key Number State Fa0/1 SA 32768
0005.5d71.8db8 29s 0x146 0x3 0x3D Fa0/2 SA 32768 0005.5d71.8db8 29s 0x146 0x4
0x3D

For more detail use the show lacp neighbor detail command.

To retain this configuration across reboots, the following entries can be added
to /etc/rc.conf:

ifconfig_fxp0="up" ifconfig_fxp1="up" cloned_interfaces="lagg0" ifconfig_lagg0=
"laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24"

ExampleÂ 32.2.Â Failover Mode

Failover mode can be used to switch over to a secondary interface if the link
is lost on the master interface. Bring the underlying physical interfaces up.
Create the lagg(4) interface, using fxp0 as the master interface and fxp1 as
the secondary interface and assign an IP Address of 10.0.0.15/24:

# ifconfig fxp0 up # ifconfig fxp1 up # ifconfig lagg0 create # ifconfig lagg0
up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24

The interface will look something like this, the major differences will be the 
MAC address and the device names:

# ifconfig lagg0 lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt;
metric 0 mtu 1500 options=8&lt;VLAN_MTU&gt; ether 00:05:5d:71:8d:b8 inet 10.0.0.15
netmask 0xffffff00 broadcast 10.0.0.255 media: Ethernet autoselect status:
active laggproto failover laggport: fxp1 flags=0&lt;&gt; laggport: fxp0 flags=5
&lt;MASTER,ACTIVE&gt;

Traffic will be transmitted and received on fxp0. If the link is lost on fxp0
then fxp1 will become the active link. If the link is restored on the master
interface then it will once again become the active link.

To retain this configuration across reboots, the following entries can be added
to /etc/rc.conf:

ifconfig_fxp0="up" ifconfig_fxp1="up" cloned_interfaces="lagg0" ifconfig_lagg0=
"laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24"

ExampleÂ 32.3.Â Failover Mode Between Wired and Wireless Interfaces

For laptop users, it is usually desirable to make wireless as a secondary
interface, which is to be used when the wired connection is not available. With
lagg(4), it is possible to use one IP address, prefer the wired connection for
both performance and security reasons, while maintaining the ability to
transfer data over the wireless connection.

In this setup, we will need to override the underlying wireless interface's MAC
address to match the lagg(4)'s, which is inherited from the master interface
being used, the wired interface.

In this setup, we will treat the wired interface, bge0, as the master, and the
wireless interface, wlan0, as the failover interface. The wlan0 was created
from iwn0 which we will set up with the wired connection's MAC address. The
first step would be to obtain the MAC address from the wired interface:

# ifconfig bge0 bge0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric
0 mtu 1500 options=19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
ether 00:21:70:da:ae:37 inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64
scopeid 0x2 nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt; media:
Ethernet autoselect (1000baseT &lt;full-duplex&gt;) status: active

You can replace the bge0 to match your reality, and will get a different ether
line which is the MAC address of your wired interface. Now, we change the
underlying wireless interface, iwn0:

# ifconfig iwn0 ether 00:21:70:da:ae:37

Bring the wireless interface up, but do not set an IP address on it:

# ifconfig wlan0 create wlandev iwn0 ssid my_router up

Bring the bge0 interface up. Create the lagg(4) interface with bge0 as master,
and failover to wlan0 if necessary:

# ifconfig bge0 up # ifconfig lagg0 create # ifconfig lagg0 up laggproto
failover laggport bge0 laggport wlan0

The interface will look something like this, the major differences will be the 
MAC address and the device names:

# ifconfig lagg0 lagg0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt;
metric 0 mtu 1500 options=8&lt;VLAN_MTU&gt; ether 00:21:70:da:ae:37 media: Ethernet
autoselect status: active laggproto failover laggport: wlan0 flags=0&lt;&gt;
laggport: bge0 flags=5&lt;MASTER,ACTIVE&gt;

Then start the DHCP client to obtain an IP address:

# dhclient lagg0

To retain this configuration across reboots, the following entries can be added
to /etc/rc.conf:

ifconfig_bge0="up" ifconfig_iwn0="ether 00:21:70:da:ae:37" wlans_iwn0="wlan0"
ifconfig_wlan0="WPA" cloned_interfaces="lagg0" ifconfig_lagg0="laggproto
failover laggport bge0 laggport wlan0 DHCP"


32.7.Â Diskless Operation

Updated by Jean-FranÃ§ois DockÃšs.
Reorganized and enhanced by Alex Dupre.

A FreeBSD machine can boot over the network and operate without a local disk,
using file systems mounted from an NFS server. No system modification is
necessary, beyond standard configuration files. Such a system is relatively
easy to set up because all the necessary elements are readily available:

  * There are at least two possible methods to load the kernel over the
    network:

      o PXE: The IntelÂ® Preboot eXecution Environment system is a form of
        smart boot ROM built into some networking cards or motherboards. See
        pxeboot(8) for more details.

      o The Etherboot port (net/etherboot) produces ROM-able code to boot
        kernels over the network. The code can be either burnt into a boot PROM
        on a network card, or loaded from a local floppy (or hard) disk drive,
        or from a running MS-DOSÂ® system. Many network cards are supported.

  * A sample script (/usr/share/examples/diskless/clone_root) eases the
    creation and maintenance of the workstation's root file system on the
    server. The script will probably require a little customization but it will
    get you started very quickly.

  * Standard system startup files exist in /etc to detect and support a
    diskless system startup.

  * Swapping, if needed, can be done either to an NFS file or to a local disk.

There are many ways to set up diskless workstations. Many elements are
involved, and most can be customized to suit local taste. The following will
describe variations on the setup of a complete system, emphasizing simplicity
and compatibility with the standard FreeBSD startup scripts. The system
described has the following characteristics:

  * The diskless workstations use a shared read-only / file system, and a
    shared read-only /usr.

    The root file system is a copy of a standard FreeBSD root (typically the
    server's), with some configuration files overridden by ones specific to
    diskless operation or, possibly, to the workstation they belong to.

    The parts of the root which have to be writable are overlaid with md(4)
    file systems. Any changes will be lost when the system reboots.

  * The kernel is transferred and loaded either with Etherboot or PXE as some
    situations may mandate the use of either method.

Caution:

As described, this system is insecure. It should live in a protected area of a
network, and be untrusted by other hosts.

All the information in this section has been tested using FreeBSD
5.2.1-RELEASE.

32.7.1.Â Background Information

Setting up diskless workstations is both relatively straightforward and prone
to errors. These are sometimes difficult to diagnose for a number of reasons.
For example:

  * Compile time options may determine different behaviors at runtime.

  * Error messages are often cryptic or totally absent.

In this context, having some knowledge of the background mechanisms involved is
very useful to solve the problems that may arise.

Several operations need to be performed for a successful bootstrap:

  * The machine needs to obtain initial parameters such as its IP address,
    executable filename, server name, root path. This is done using the DHCP or
    BOOTP protocols. DHCP is a compatible extension of BOOTP, and uses the same
    port numbers and basic packet format.

    It is possible to configure a system to use only BOOTP. The bootpd(8)
    server program is included in the base FreeBSD system.

    However, DHCP has a number of advantages over BOOTP (nicer configuration
    files, possibility of using PXE, plus many others not directly related to
    diskless operation), and we will describe mainly a DHCP configuration, with
    equivalent examples using bootpd(8) when possible. The sample configuration
    will use the ISC DHCP software package (release 3.0.1.r12 was installed on
    the test server).

  * The machine needs to transfer one or several programs to local memory.
    Either TFTP or NFS are used. The choice between TFTP and NFS is a compile
    time option in several places. A common source of error is to specify
    filenames for the wrong protocol: TFTP typically transfers all files from a
    single directory on the server, and would expect filenames relative to this
    directory. NFS needs absolute file paths.

  * The possible intermediate bootstrap programs and the kernel need to be
    initialized and executed. There are several important variations in this
    area:

      o PXE will load pxeboot(8), which is a modified version of the FreeBSD
        third stage loader. The loader(8) will obtain most parameters necessary
        to system startup, and leave them in the kernel environment before
        transferring control. It is possible to use a GENERIC kernel in this
        case.

      o Etherboot, will directly load the kernel, with less preparation. You
        will need to build a kernel with specific options.

    PXE and Etherboot work equally well; however, because kernels normally let
    the loader(8) do more work for them, PXE is the preferred method.

    If your BIOS and network cards support PXE, you should probably use it.

  * Finally, the machine needs to access its file systems. NFS is used in all
    cases.

See also diskless(8) manual page.

32.7.2.Â Setup Instructions

32.7.2.1.Â Configuration Using ISC DHCP

The ISC DHCP server can answer both BOOTP and DHCP requests.

ISC DHCP 4.2 is not part of the base system. You will first need to install the
net/isc-dhcp42-server port or the corresponding package.

Once ISC DHCP is installed, it needs a configuration file to run (normally
named /usr/local/etc/dhcpd.conf). Here follows a commented example, where host
margaux uses Etherboot and host corbieres uses PXE:

default-lease-time 600; max-lease-time 7200; authoritative; option domain-name
"example.com"; option domain-name-servers 192.168.4.1; option routers
192.168.4.1; subnet 192.168.4.0 netmask 255.255.255.0 { use-host-decl-names on;
1 option subnet-mask 255.255.255.0; option broadcast-address 192.168.4.255;
host margaux { hardware ethernet 01:23:45:67:89:ab; fixed-address
margaux.example.com; next-server 192.168.4.4; 2 filename "/data/misc/
kernel.diskless"; 3 option root-path "192.168.4.4:/data/misc/diskless"; 4 }
host corbieres { hardware ethernet 00:02:b3:27:62:df; fixed-address
corbieres.example.com; next-server 192.168.4.4; filename "pxeboot"; option
root-path "192.168.4.4:/data/misc/diskless"; } }

1    This option tells dhcpd to send the value in the host declarations as the
     hostname for the diskless host. An alternate way would be to add an option
     host-name margaux inside the host declarations.

2    The next-server directive designates the TFTP or NFS server to use for
     loading loader or kernel file (the default is to use the same host as the 
     DHCP server).

3    The filename directive defines the file that Etherboot or PXE will load
     for the next execution step. It must be specified according to the
     transfer method used. Etherboot can be compiled to use NFS or TFTP. The
     FreeBSD port configures NFS by default. PXE uses TFTP, which is why a
     relative filename is used here (this may depend on the TFTP server
     configuration, but would be fairly typical). Also, PXE loads pxeboot, not
     the kernel. There are other interesting possibilities, like loading
     pxeboot from a FreeBSD CD-ROM /boot directory (as pxeboot(8) can load a
     GENERIC kernel, this makes it possible to use PXE to boot from a remote
     CD-ROM).

4    The root-path option defines the path to the root file system, in usual 
     NFS notation. When using PXE, it is possible to leave off the host's IP as
     long as you do not enable the kernel option BOOTP. The NFS server will
     then be the same as the TFTP one.

32.7.2.2.Â Configuration Using BOOTP

Here follows an equivalent bootpd configuration (reduced to one client). This
would be found in /etc/bootptab.

Please note that Etherboot must be compiled with the non-default option
NO_DHCP_SUPPORT in order to use BOOTP, and that PXE needs DHCP. The only
obvious advantage of bootpd is that it exists in the base system.

.def100:\ :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\ :sm=255.255.255.0:\ :ds=
192.168.4.1:\ :gw=192.168.4.1:\ :hd="/tftpboot":\ :bf="/kernel.diskless":\ :rp=
"192.168.4.4:/data/misc/diskless": margaux:ha=0123456789ab:tc=.def100

32.7.2.3.Â Preparing a Boot Program with Etherboot

Etherboot's Web site contains extensive documentation mainly intended for Linux
systems, but nonetheless containing useful information. The following will just
outline how you would use Etherboot on a FreeBSD system.

You must first install the net/etherboot package or port.

You can change the Etherboot configuration (i.e., to use TFTP instead of NFS)
by editing the Config file in the Etherboot source directory.

For our setup, we shall use a boot floppy. For other methods (PROM, or MS-DOSÂ®
program), please refer to the Etherboot documentation.

To make a boot floppy, insert a floppy in the drive on the machine where you
installed Etherboot, then change your current directory to the src directory in
the Etherboot tree and type:

# gmake bin32/devicetype.fd0

devicetype depends on the type of the Ethernet card in the diskless
workstation. Refer to the NIC file in the same directory to determine the right
devicetype.

32.7.2.4.Â Booting with PXE

By default, the pxeboot(8) loader loads the kernel via NFS. It can be compiled
to use TFTP instead by specifying the LOADER_TFTP_SUPPORT option in /etc/
make.conf. See the comments in /usr/share/examples/etc/make.conf for
instructions.

There are two other make.conf options which may be useful for setting up a
serial console diskless machine: BOOT_PXELDR_PROBE_KEYBOARD, and
BOOT_PXELDR_ALWAYS_SERIAL.

To use PXE when the machine starts, you will usually need to select the Boot
from network option in your BIOS setup, or type a function key during the PC
initialization.

32.7.2.5.Â Configuring the TFTP and NFS Servers

If you are using PXE or Etherboot configured to use TFTP, you need to enable 
tftpd on the file server:

 1. Create a directory from which tftpd will serve the files, e.g., /tftpboot.

 2. Add this line to your /etc/inetd.conf:

    tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /tftpboot

    Note:

    It appears that at least some PXE versions want the TCP version of TFTP. In
    this case, add a second line, replacing dgram udp with stream tcp.

 3. Tell inetd to reread its configuration file. The inetd_enable="YES" must be
    in the /etc/rc.conf file for this command to execute correctly:

    # service inetd restart

You can place the tftpboot directory anywhere on the server. Make sure that the
location is set in both inetd.conf and dhcpd.conf.

In all cases, you also need to enable NFS and export the appropriate file
system on the NFS server.

 1. Add this to /etc/rc.conf:

    nfs_server_enable="YES"
 2. Export the file system where the diskless root directory is located by
    adding the following to /etc/exports (adjust the volume mount point and
    replace margaux corbieres with the names of the diskless workstations):

    /data/misc -alldirs -ro margaux corbieres
 3. Tell mountd to reread its configuration file. If you actually needed to
    enable NFS in /etc/rc.conf at the first step, you probably want to reboot
    instead.

    # service mountd restart

32.7.2.6.Â Building a Diskless Kernel

If using Etherboot, you need to create a kernel configuration file for the
diskless client with the following options (in addition to the usual ones):

options BOOTP # Use BOOTP to obtain IP address/hostname options BOOTP_NFSROOT #
NFS mount root file system using BOOTP info

You may also want to use BOOTP_NFSV3, BOOT_COMPAT and BOOTP_WIRED_TO (refer to
NOTES).

These option names are historical and slightly misleading as they actually
enable indifferent use of DHCP and BOOTP inside the kernel (it is also possible
to force strict BOOTP or DHCP use).

Build the kernel (see ChapterÂ 9, Configuring the FreeBSD Kernel), and copy it
to the place specified in dhcpd.conf.

Note:

When using PXE, building a kernel with the above options is not strictly
necessary (though suggested). Enabling them will cause more DHCP requests to be
issued during kernel startup, with a small risk of inconsistency between the
new values and those retrieved by pxeboot(8) in some special cases. The
advantage of using them is that the host name will be set as a side effect.
Otherwise you will need to set the host name by another method, for example in
a client-specific rc.conf file.

Note:

In order to be loadable with Etherboot, a kernel needs to have the device hints
compiled in. You would typically set the following option in the configuration
file (see the NOTES configuration comments file):

hints "GENERIC.hints"

32.7.2.7.Â Preparing the Root Filesystem

You need to create a root file system for the diskless workstations, in the
location listed as root-path in dhcpd.conf.

32.7.2.7.1.Â Using make world to Populate Root

This method is quick and will install a complete virgin system (not only the
root file system) into DESTDIR. All you have to do is simply execute the
following script:

#!/bin/sh export DESTDIR=/data/misc/diskless mkdir -p ${DESTDIR} cd /usr/src;
make buildworld && make buildkernel make installworld && make installkernel cd
/usr/src/etc; make distribution

Once done, you may need to customize your /etc/rc.conf and /etc/fstab placed
into DESTDIR according to your needs.

32.7.2.8.Â Configuring Swap

If needed, a swap file located on the server can be accessed via NFS.

32.7.2.8.1.Â NFS Swap

The kernel does not support enabling NFS swap at boot time. Swap must be
enabled by the startup scripts, by mounting a writable file system and creating
and enabling a swap file. To create a swap file of appropriate size, you can do
like this:

# dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000

To enable it you have to add the following line to your rc.conf:

swapfile=/path/to/swapfile

32.7.2.9.Â Miscellaneous Issues

32.7.2.9.1.Â Running with a Read-only /usr

If the diskless workstation is configured to run X, you will have to adjust the
XDM configuration file, which puts the error log on /usr by default.

32.7.2.9.2.Â Using a Non-FreeBSD Server

When the server for the root file system is not running FreeBSD, you will have
to create the root file system on a FreeBSD machine, then copy it to its
destination, using tar or cpio.

In this situation, there are sometimes problems with the special files in /dev,
due to differing major/minor integer sizes. A solution to this problem is to
export a directory from the non-FreeBSD server, mount this directory onto a
FreeBSD machine, and use devfs(5) to allocate device nodes transparently for
the user.

32.8.Â PXE Booting with an NFS Root File System

Written by Craig Rodrigues.

The IntelÂ® Preboot eXecution Environment (PXE) allows booting the operating
system over the network. PXE support is usually provided in the BIOS of modern
motherboards, where it can be enabled in the BIOS settings which enable booting
from the network. A fully functioning PXE setup also requires properly
configured DHCP and TFTP servers.

When the host computer boots, it receives information over DHCP about where to
obtain the initial boot loader via TFTP. After the host computer receives this
information, it downloads the boot loader via TFTP, and then executes the boot
loader. This is documented in section 2.2.1 of the Preboot Execution
Environment (PXE) Specification. In FreeBSD, the boot loader retrieved during
the PXE process is /boot/pxeboot. After /boot/pxeboot executes, the FreeBSD
kernel is loaded, and the rest of the FreeBSD bootup sequence proceeds. Refer
to ChapterÂ 13, The FreeBSD Booting Process for more information about the
FreeBSD booting process.

32.8.1.Â Setting Up the chroot Environment for the NFS Root File System

 1. Choose a directory which will have a FreeBSD installation which will be NFS
    mountable. For example, a directory such as /b/tftpboot/FreeBSD/install can
    be used.

    # export NFSROOTDIR=/b/tftpboot/FreeBSD/install # mkdir -p ${NFSROOTDIR}
 2. Enable the NFS server by following the instructions in SectionÂ 30.3.2, â  
    Configuring NFSâ  .

 3. Export the directory via NFS by adding the following to /etc/exports:

    /b -ro -alldirs
 4. Restart the NFS server:

    # service nfsd restart
 5. Enable inetd(8) by following the steps outlined in SectionÂ 30.2.2, â  
    Settingsâ  .

 6. Add the following line to /etc/inetd.conf:

    tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot
 7. Restart inetd:

    # service inetd restart
 8. Rebuild the FreeBSD kernel and userland:

    # cd /usr/src # make buildworld # make buildkernel
 9. Install FreeBSD into the directory mounted over NFS:

    # make installworld DESTDIR=${NFSROOTDIR} # make installkernel DESTDIR=$
    {NFSROOTDIR} # make distribution DESTDIR=${NFSROOTDIR}
10. Test that the TFTP server works and can download the boot loader which will
    be obtained via PXE:

    # tftp localhost tftp&gt; get FreeBSD/install/boot/pxeboot Received 264951
    bytes in 0.1 seconds
11. Edit ${NFSROOTDIR}/etc/fstab and create an entry to mount the root file
    system over NFS:

    # Device Mountpoint FSType Options Dump Pass myhost.example.com:/b/tftpboot
    /FreeBSD/install / nfs ro 0 0

    Replace myhost.example.com with the hostname or IP address of your NFS
    server. In this example, the root file system is mounted "read-only" in
    order to prevent NFS clients from potentially deleting the contents of the
    root file system.

12. Set the root password in the chroot(8) environment.

    # chroot ${NFSROOTDIR} # passwd

    This will set the root password for client machines which are PXE booting.

13. Enable ssh root logins for client machines which are PXE booting by editing
    ${NFSROOTDIR}/etc/ssh/sshd_config and enabling the PermitRootLogin option.
    This is documented in sshd_config(5).

14. Perform other customizations of the chroot(8) environment in ${NFSROOTDIR}.
    These customizations could include things like adding packages with pkg_add
    (1), editing the password file with vipw(8), or editing amd.conf(5) maps
    for automounting. For example:

    # chroot ${NFSROOTDIR} # pkg_add -r bash

32.8.2.Â Configuring Memory File Systems Used by /etc/rc.initdiskless

If you boot from an NFS root volume, /etc/rc detects that you booted over NFS
and runs the /etc/rc.initdiskless script. Read the comments in this script to
understand what is going on. We need to make /etc and /var memory backed file
systems because these directories need to be writable, but the NFS root
directory is read-only.

# chroot ${NFSROOTDIR} # mkdir -p conf/base # tar -c -v -f conf/base/
etc.cpio.gz --format cpio --gzip etc # tar -c -v -f conf/base/var.cpio.gz
--format cpio --gzip var

When the system boots, memory file systems for /etc and /var will be created
and mounted, and the contents of the cpio.gz files will be copied into them.

32.8.3.Â Setting up the DHCP Server

PXE requires a TFTP server and a DHCP server to be set up. The DHCP server does
not necessarily need to be the same machine as the TFTP server, but it needs to
be accessible in your network.

 1. Install the DHCP server by following the instructions documented at
    SectionÂ 30.5.7, â  Installing and Configuring a DHCP Serverâ  . Make sure
    that /etc/rc.conf and /usr/local/etc/dhcpd.conf are correctly configured.

 2. In /usr/local/etc/dhcpd.conf, configure the next-server, filename, and
    option root-path settings, to specify your TFTP server IP address, the path
    to /boot/pxeboot in TFTP, and the path to the NFS root file system. Here is
    a sample dhcpd.conf setup:

    subnet 192.168.0.0 netmask 255.255.255.0 { range 192.168.0.2 192.168.0.3 ;
    option subnet-mask 255.255.255.0 ; option routers 192.168.0.1 ; option
    broadcast-address 192.168.0.255 ; option domain-name-server 192.168.35.35,
    192.168.35.36 ; option domain-name "example.com"; # IP address of TFTP
    server next-server 192.168.0.1 ; # path of boot loader obtained # via tftp
    filename "FreeBSD/install/boot/pxeboot" ; # pxeboot boot loader will try to
    NFS mount this directory for root FS option root-path "192.168.0.1:/b/
    tftpboot/FreeBSD/install/" ; }

32.8.4.Â Configuring the PXE Client and Debugging Connection Problems

 1. When the client machine boots up, enter the BIOS configuration menu.
    Configure the BIOS to boot from the network. If all your previous
    configuration steps are correct, then everything should "just work".

 2. Use the net/wireshark port to debug the network traffic involved during the
    PXE booting process, which is illustrated in the diagram below. In
    SectionÂ 32.8.3, â  Setting up the DHCP Serverâ  , an example configuration
    is shown where the DHCP, TFTP, and NFS servers are actually on the same
    machine. However, these severs can be on separate machines.

    FigureÂ 32.1.Â PXE Booting Process with NFS Root Mount
    PXE Booting Process with NFS Root Mount

    1    Client broadcasts DHCPDISCOVER.

    2    DHCP server responds with IP address, next-server, filename, and
         root-path.

    3    Client sends TFTP request to next-server asking to retrieve filename.

    4    TFTP server responds and sends filename to client.

    5    Client executes filename which is pxeboot(8). pxeboot(8) loads the
         kernel. When the kernel executes, the root filesystem specified by
         root-path is mounted over NFS.


 3. Make sure that the pxeboot file can be retrieved by TFTP. On your TFTP
    server, look in /var/log/xferlog to ensure that the pxeboot file is being
    retrieved from the correct location. To test the configuration from
    dhcpd.conf above:

    # tftp 192.168.0.1 tftp&gt; get FreeBSD/install/boot/pxeboot Received 264951
    bytes in 0.1 seconds

    Read tftpd(8) and tftp(1). The BUGS sections in these pages document some
    limitations with TFTP.

 4. Make sure that the root file system can be mounted via NFS. To test
    configuration from dhcpd.conf above:

    # mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt
 5. Read the code in src/sys/boot/i386/libi386/pxe.c to understand how the
    pxeboot loader sets variables like boot.nfsroot.server and
    boot.nfsroot.path. These variables are then used in the NFS diskless root
    mount code in src/sys/nfsclient/nfs_diskless.c.

 6. Read pxeboot(8) and loader(8).

32.9.Â ISDN

A good resource for information on ISDN technology and hardware is Dan Kegel's
ISDN Page.

A quick simple road map to ISDN follows:

  * If you live in Europe you might want to investigate the ISDN card section.

  * If you are planning to use ISDN primarily to connect to the Internet with
    an Internet Provider on a dial-up non-dedicated basis, you might look into
    Terminal Adapters. This will give you the most flexibility, with the fewest
    problems, if you change providers.

  * If you are connecting two LANs together, or connecting to the Internet with
    a dedicated ISDN connection, you might consider the stand alone router/
    bridge option.

Cost is a significant factor in determining what solution you will choose. The
following options are listed from least expensive to most expensive.

32.9.1.Â ISDN Cards

Contributed by Hellmuth Michaelis.

FreeBSD's ISDN implementation supports only the DSS1/Q.931 (or Euro-ISDN)
standard using passive cards. Some active cards are supported where the
firmware also supports other signaling protocols; this also includes the first
supported Primary Rate (PRI) ISDN card.

The isdn4bsd software allows you to connect to other ISDN routers using either
IP over raw HDLC or by using synchronous PPP: either by using kernel PPP with
isppp, a modified sppp(4) driver, or by using userland ppp(8). By using
userland ppp(8), channel bonding of two or more ISDN B-channels is possible. A
telephone answering machine application is also available as well as many
utilities such as a software 300 Baud modem.

Some growing number of PC ISDN cards are supported under FreeBSD and the
reports show that it is successfully used all over Europe and in many other
parts of the world.

The passive ISDN cards supported are mostly the ones with the Infineon
(formerly Siemens) ISAC/HSCX/IPAC ISDN chipsets, but also ISDN cards with chips
from Cologne Chip (ISA bus only), PCI cards with Winbond W6692 chips, some
cards with the Tiger300/320/ISAC chipset combinations and some vendor specific
chipset based cards such as the AVM Fritz!Card PCI V.1.0 and the AVM Fritz!Card
PnP.

Currently the active supported ISDN cards are the AVM B1 (ISA and PCI) BRI
cards and the AVM T1 PCI PRI cards.

For documentation on isdn4bsd, have a look at the homepage of isdn4bsd which
also has pointers to hints, erratas and much more documentation such as the
isdn4bsd handbook.

In case you are interested in adding support for a different ISDN protocol, a
currently unsupported ISDN PC card or otherwise enhancing isdn4bsd, please get
in touch with Hellmuth Michaelis &lt;hm@FreeBSD.org&gt;.

For questions regarding the installation, configuration and troubleshooting 
isdn4bsd, a freebsd-isdn mailing list is available.

32.9.2.Â ISDN Terminal Adapters

Terminal adapters (TA), are to ISDN what modems are to regular phone lines.

Most TA's use the standard Hayes modem AT command set, and can be used as a
drop in replacement for a modem.

A TA will operate basically the same as a modem except connection and
throughput speeds will be much faster than your old modem. You will need to
configure PPP exactly the same as for a modem setup. Make sure you set your
serial speed as high as possible.

The main advantage of using a TA to connect to an Internet Provider is that you
can do Dynamic PPP. As IP address space becomes more and more scarce, most
providers are not willing to provide you with a static IP any more. Most
stand-alone routers are not able to accommodate dynamic IP allocation.

TA's completely rely on the PPP daemon that you are running for their features
and stability of connection. This allows you to upgrade easily from using a
modem to ISDN on a FreeBSD machine, if you already have PPP set up. However, at
the same time any problems you experienced with the PPP program and are going
to persist.

If you want maximum stability, use the kernel PPP option, not the userland PPP.

The following TA's are known to work with FreeBSD:

  * Motorola BitSurfer and Bitsurfer Pro

  * Adtran

Most other TA's will probably work as well, TA vendors try to make sure their
product can accept most of the standard modem AT command set.

The real problem with external TA's is that, like modems, you need a good
serial card in your computer.

You should read the FreeBSD Serial Hardware tutorial for a detailed
understanding of serial devices, and the differences between asynchronous and
synchronous serial ports.

A TA running off a standard PC serial port (asynchronous) limits you to
115.2Â Kbs, even though you have a 128Â Kbs connection. To fully utilize the
128Â Kbs that ISDN is capable of, you must move the TA to a synchronous serial
card.

Do not be fooled into buying an internal TA and thinking you have avoided the
synchronous/asynchronous issue. Internal TA's simply have a standard PC serial
port chip built into them. All this will do is save you having to buy another
serial cable and find another empty electrical socket.

A synchronous card with a TA is at least as fast as a stand-alone router, and
with a simple 386 FreeBSD box driving it, probably more flexible.

The choice of synchronous card/TA versus stand-alone router is largely a
religious issue. There has been some discussion of this in the mailing lists.
We suggest you search the archives for the complete discussion.

32.9.3.Â Stand-alone ISDN Bridges/Routers

ISDN bridges or routers are not at all specific to FreeBSD or any other
operating system. For a more complete description of routing and bridging
technology, please refer to a networking reference book.

In the context of this section, the terms router and bridge will be used
interchangeably.

As the cost of low end ISDN routers/bridges comes down, it will likely become a
more and more popular choice. An ISDN router is a small box that plugs directly
into your local Ethernet network, and manages its own connection to the other
bridge/router. It has built in software to communicate via PPP and other
popular protocols.

A router will allow you much faster throughput than a standard TA, since it
will be using a full synchronous ISDN connection.

The main problem with ISDN routers and bridges is that interoperability between
manufacturers can still be a problem. If you are planning to connect to an
Internet provider, you should discuss your needs with them.

If you are planning to connect two LAN segments together, such as your home LAN
to the office LAN, this is the simplest lowest maintenance solution. Since you
are buying the equipment for both sides of the connection you can be assured
that the link will work.

For example to connect a home computer or branch office network to a head
office network the following setup could be used:

ExampleÂ 32.4.Â Branch Office or Home Network

Network uses a bus based topology with 10 base 2 Ethernet (â  thinnetâ  ).
Connect router to network cable with AUI/10BT transceiver, if necessary.

10 Base 2 Ethernet

If your home/branch office is only one computer you can use a twisted pair
crossover cable to connect to the stand-alone router directly.


ExampleÂ 32.5.Â Head Office or Other LAN

Network uses a star topology with 10 base T Ethernet (â  Twisted Pairâ  ).

ISDN Network Diagram


One large advantage of most routers/bridges is that they allow you to have 2 
separate independent PPP connections to 2 separate sites at the same time. This
is not supported on most TA's, except for specific (usually expensive) models
that have two serial ports. Do not confuse this with channel bonding, MPP, etc.

This can be a very useful feature if, for example, you have an dedicated ISDN
connection at your office and would like to tap into it, but do not want to get
another ISDN line at work. A router at the office location can manage a
dedicated B channel connection (64Â Kbps) to the Internet and use the other B
channel for a separate data connection. The second B channel can be used for
dial-in, dial-out or dynamically bonding (MPP, etc.) with the first B channel
for more bandwidth.

An Ethernet bridge will also allow you to transmit more than just IP traffic.
You can also send IPX/SPX or whatever other protocols you use.

32.10.Â Network Address Translation

Contributed by Chern Lee.

32.10.1.Â Overview

FreeBSD's Network Address Translation daemon, commonly known as natd(8) is a
daemon that accepts incoming raw IP packets, changes the source to the local
machine and re-injects these packets back into the outgoing IP packet stream.
natd(8) does this by changing the source IP address and port such that when
data is received back, it is able to determine the original location of the
data and forward it back to its original requester.

The most common use of NAT is to perform what is commonly known as Internet
Connection Sharing.

32.10.2.Â Setup

Due to the diminishing IP space in IPv4, and the increased number of users on
high-speed consumer lines such as cable or DSL, people are increasingly in need
of an Internet Connection Sharing solution. The ability to connect several
computers online through one connection and IP address makes natd(8) a
reasonable choice.

Most commonly, a user has a machine connected to a cable or DSL line with one
IP address and wishes to use this one connected computer to provide Internet
access to several more over a LAN.

To do this, the FreeBSD machine on the Internet must act as a gateway. This
gateway machine must have two NICsâ  one for connecting to the Internet router,
the other connecting to a LAN. All the machines on the LAN are connected
through a hub or switch.

Note:

There are many ways to get a LAN connected to the Internet through a FreeBSD
gateway. This example will only cover a gateway with at least two NICs.

Network Layout

A setup like this is commonly used to share an Internet connection. One of the 
LAN machines is connected to the Internet. The rest of the machines access the
Internet through that â  gatewayâ   machine.

32.10.3.Â Boot Loader Configuration

The kernel features for network address translation with natd(8) are not
enabled in the GENERIC kernel, but they can be preloaded at boot time, by
adding a couple of options to /boot/loader.conf:

ipfw_load="YES" ipdivert_load="YES"

Additionally, the net.inet.ip.fw.default_to_accept tunable option may be set to
1:

net.inet.ip.fw.default_to_accept="1"

Note:

It is a very good idea to set this option during the first attempts to setup a
firewall and NAT gateway. This way the default policy of ipfw(8) will be allow
ip from any to any instead of the less permissive deny ip from any to any, and
it will be slightly more difficult to get locked out of the system right after
a reboot.

32.10.4.Â Kernel Configuration

When modules are not an option or if it is preferrable to build all the
required features into the running kernel, the following options must be in the
kernel configuration file:

options IPFIREWALL options IPDIVERT

Additionally, at choice, the following may also be suitable:

options IPFIREWALL_DEFAULT_TO_ACCEPT options IPFIREWALL_VERBOSE

32.10.5.Â System Startup Configuration

To enable firewall and NAT support at boot time, the following must be in /etc/
rc.conf:

gateway_enable="YES" 1 firewall_enable="YES" 2 firewall_type="OPEN" 3
natd_enable="YES" natd_interface="fxp0" 4 natd_flags="" 5

1    Sets up the machine to act as a gateway. Running sysctl
     net.inet.ip.forwarding=1 would have the same effect.

2    Enables the firewall rules in /etc/rc.firewall at boot.

3    This specifies a predefined firewall ruleset that allows anything in. See
     /etc/rc.firewall for additional types.

4    Indicates which interface to forward packets through (the interface
     connected to the Internet).

5    Any additional configuration options passed to natd(8) on boot.

Having the previous options defined in /etc/rc.conf would run natd -interface
fxp0 at boot. This can also be run manually.

Note:

It is also possible to use a configuration file for natd(8) when there are too
many options to pass. In this case, the configuration file must be defined by
adding the following line to /etc/rc.conf:

natd_flags="-f /etc/natd.conf"

The /etc/natd.conf file will contain a list of configuration options, one per
line. For example the next section case would use the following file:

redirect_port tcp 192.168.0.2:6667 6667 redirect_port tcp 192.168.0.3:80 80

For more information about the configuration file, consult the natd(8) manual
page about the -f option.

Each machine and interface behind the LAN should be assigned IP address numbers
in the private network space as defined by RFC 1918 and have a default gateway
of the natd machine's internal IP address.

For example, client A and B behind the LAN have IP addresses of 192.168.0.2 and
192.168.0.3, while the natd machine's LAN interface has an IP address of
192.168.0.1. Client A and B's default gateway must be set to that of the natd
machine, 192.168.0.1. The natd machine's external, or Internet interface does
not require any special modification for natd(8) to work.

32.10.6.Â Port Redirection

The drawback with natd(8) is that the LAN clients are not accessible from the
Internet. Clients on the LAN can make outgoing connections to the world but
cannot receive incoming ones. This presents a problem if trying to run Internet
services on one of the LAN client machines. A simple way around this is to
redirect selected Internet ports on the natd machine to a LAN client.

For example, an IRC server runs on client A, and a web server runs on client B.
For this to work properly, connections received on ports 6667 (IRC) and 80
(web) must be redirected to the respective machines.

The -redirect_port must be passed to natd(8) with the proper options. The
syntax is as follows:

-redirect_port proto targetIP:targetPORT[-targetPORT] [aliasIP:]aliasPORT
[-aliasPORT] [remoteIP[:remotePORT[-remotePORT]]]

In the above example, the argument should be:

-redirect_port tcp 192.168.0.2:6667 6667 -redirect_port tcp 192.168.0.3:80 80

This will redirect the proper tcp ports to the LAN client machines.

The -redirect_port argument can be used to indicate port ranges over individual
ports. For example, tcp 192.168.0.2:2000-3000 2000-3000 would redirect all
connections received on ports 2000 to 3000 to ports 2000 to 3000 on client A.

These options can be used when directly running natd(8), placed within the
natd_flags="" option in /etc/rc.conf, or passed via a configuration file.

For further configuration options, consult natd(8)

32.10.7.Â Address Redirection

Address redirection is useful if several IP addresses are available, yet they
must be on one machine. With this, natd(8) can assign each LAN client its own
external IP address. natd(8) then rewrites outgoing packets from the LAN
clients with the proper external IP address and redirects all traffic incoming
on that particular IP address back to the specific LAN client. This is also
known as static NAT. For example, the IP addresses 128.1.1.1, 128.1.1.2, and
128.1.1.3 belong to the natd gateway machine. 128.1.1.1 can be used as the natd
gateway machine's external IP address, while 128.1.1.2 and 128.1.1.3 are
forwarded back to LAN clients A and B.

The -redirect_address syntax is as follows:

-redirect_address localIP publicIP

localIP    The internal IP address of the LAN client.
publicIP   The external IP address corresponding to the LAN client.

In the example, this argument would read:

-redirect_address 192.168.0.2 128.1.1.2 -redirect_address 192.168.0.3 128.1.1.3

Like -redirect_port, these arguments are also placed within the natd_flags=""
option of /etc/rc.conf, or passed via a configuration file. With address
redirection, there is no need for port redirection since all data received on a
particular IP address is redirected.

The external IP addresses on the natd machine must be active and aliased to the
external interface. Look at rc.conf(5) to do so.

32.11.Â IPv6

Originally Written by Aaron Kaplan.
Restructured and Added by Tom Rhodes.
Extended by Brad Davis.

IPv6 (also known as IPng â  IP next generationâ  ) is the new version of the
well known IP protocol (also known as IPv4). Like the other current *BSD
systems, FreeBSD includes the KAME IPv6 reference implementation. So your
FreeBSD system comes with all you will need to experiment with IPv6. This
section focuses on getting IPv6 configured and running.

In the early 1990s, people became aware of the rapidly diminishing address
space of IPv4. Given the expansion rate of the Internet there were two major
concerns:

  * Running out of addresses. Today this is not so much of a concern any more,
    since RFC1918 private address space (10.0.0.0/8, 172.16.0.0/12, and
    192.168.0.0/16) and Network Address Translation (NAT) are being employed.

  * Router table entries were getting too large. This is still a concern today.

IPv6 deals with these and many other issues:

  * 128 bit address space. In other words theoretically there are
    340,282,366,920,938,463,463,374,607,431,768,211,456 addresses available.
    This means there are approximately 6.67 * 10^27 IPv6 addresses per square
    meter on our planet.

  * Routers will only store network aggregation addresses in their routing
    tables thus reducing the average space of a routing table to 8192 entries.

There are also lots of other useful features of IPv6 such as:

  * Address autoconfiguration (RFC2462)

  * Anycast addresses (â  one-out-of manyâ  )

  * Mandatory multicast addresses

  * IPsec (IP security)

  * Simplified header structure

  * Mobile IP

  * IPv6-to-IPv4 transition mechanisms

For more information see:

  * KAME.net

32.11.1.Â Background on IPv6 Addresses

There are different types of IPv6 addresses: Unicast, Anycast and Multicast.

Unicast addresses are the well known addresses. A packet sent to a unicast
address arrives exactly at the interface belonging to the address.

Anycast addresses are syntactically indistinguishable from unicast addresses
but they address a group of interfaces. The packet destined for an anycast
address will arrive at the nearest (in router metric) interface. Anycast
addresses may only be used by routers.

Multicast addresses identify a group of interfaces. A packet destined for a
multicast address will arrive at all interfaces belonging to the multicast
group.

Note:

The IPv4 broadcast address (usually xxx.xxx.xxx.255) is expressed by multicast
addresses in IPv6.

TableÂ 32.2.Â Reserved IPv6 Addresses

  IPv6 address   Prefixlength Description                 Notes
                    (Bits)
::               128 bits     unspecified cf. 0.0.0.0 in IPv4
::1              128 bits     loopback    cf. 127.0.0.1 in IPv4
                              address
                              embedded    The lower 32 bits are the IPv4
::00:xx:xx:xx:xx 96 bits      IPv4        address. Also called â  IPv4
                                          compatible IPv6 addressâ  
                              IPv4 mapped The lower 32 bits are the IPv4
::ff:xx:xx:xx:xx 96 bits      IPv6        address. For hosts which do not
                              address     support IPv6.
fe80:: - feb::   10 bits      link-local  cf. loopback address in IPv4
fec0:: - fef::   10 bits      site-local  Â 
ff::             8 bits       multicast   Â 
                              global      All global unicast addresses are
001 (base 2)     3 bits       unicast     assigned from this pool. The first 3
                                          bits are â  001â  .


32.11.2.Â Reading IPv6 Addresses

The canonical form is represented as: x:x:x:x:x:x:x:x, each â  xâ   being a 16
Bit hex value. For example FEBC:A574:382B:23C1:AA49:4592:4EFE:9982

Often an address will have long substrings of all zeros therefore one such
substring per address can be abbreviated by â  ::â  . Also up to three leading 
â  0â  s per hexquad can be omitted. For example fe80::1 corresponds to the
canonical form fe80:0000:0000:0000:0000:0000:0000:0001.

A third form is to write the last 32 Bit part in the well known (decimal) IPv4
style with dots â  .â   as separators. For example 2002::10.0.0.1 corresponds
to the (hexadecimal) canonical representation
2002:0000:0000:0000:0000:0000:0a00:0001 which in turn is equivalent to writing
2002::a00:1.

By now the reader should be able to understand the following:

# ifconfig
rl0: flags=8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; mtu 1500 inet
10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255 inet6
fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1 ether 00:00:21:03:08:e1
media: Ethernet autoselect (100baseTX ) status: active

fe80::200:21ff:fe03:8e1%rl0 is an auto configured link-local address. It is
generated from the MAC address as part of the auto configuration.

For further information on the structure of IPv6 addresses see RFC3513.

32.11.3.Â Getting Connected

Currently there are four ways to connect to other IPv6 hosts and networks:

  * Contact your Internet Service Provider to see if they offer IPv6 yet.

  * SixXS offers tunnels with end-points all around the globe.

  * Tunnel via 6-to-4 (RFC3068)

  * Use the net/freenet6 port if you are on a dial-up connection.

32.11.4.Â DNS in the IPv6 World

There used to be two types of DNS records for IPv6. The IETF has declared A6
records obsolete. AAAA records are the standard now.

Using AAAA records is straightforward. Assign your hostname to the new IPv6
address you just received by adding:

MYHOSTNAME AAAA MYIPv6ADDR

To your primary zone DNS file. In case you do not serve your own DNS zones ask
your DNS provider. Current versions of bind (version 8.3 and 9) and dns/djbdns
(with the IPv6 patch) support AAAA records.

32.11.5.Â Applying the Needed Changes to /etc/rc.conf

32.11.5.1.Â IPv6 Client Settings

These settings will help you configure a machine that will be on your LAN and
act as a client, not a router. To have rtsol(8) autoconfigure your interface on
boot on FreeBSDÂ 9.x and later, add:

ipv6_prefer="YES"

to rc.conf.

For FreeBSDÂ 8.x and earlier, add:

ipv6_enable="YES"

To statically assign an IP address such as
2001:471:1f11:251:290:27ff:fee0:2093, to your fxp0 interface, add the following
for FreeBSDÂ 9.x:

ifconfig_fxp0_ipv6="inet6 2001:471:1f11:251:290:27ff:fee0:2093 prefixlen 64"

Note:

Be sure to change prefixlen 64 to the appropriate value for the subnet within
which the computer is networked.

For FreeBSDÂ 8x and earlier, add:

ipv6_ifconfig_fxp0="2001:471:1f11:251:290:27ff:fee0:2093"

To assign a default router of 2001:471:1f11:251::1 add the following to /etc/
rc.conf:

ipv6_defaultrouter="2001:471:1f11:251::1"

32.11.5.2.Â IPv6 Router/Gateway Settings

This will help you take the directions that your tunnel provider has given you
and convert it into settings that will persist through reboots. To restore your
tunnel on startup use something like the following in /etc/rc.conf:

List the Generic Tunneling interfaces that will be configured, for example
gif0:

gif_interfaces="gif0"

To configure the interface with a local endpoint of MY_IPv4_ADDR to a remote
endpoint of REMOTE_IPv4_ADDR:

gifconfig_gif0="MY_IPv4_ADDR REMOTE_IPv4_ADDR"

To apply the IPv6 address you have been assigned for use as your IPv6 tunnel
endpoint, add the following for FreeBSDÂ 9.x and later:

ifconfig_gif0_ipv6="inet6 MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR"

For FreeBSDÂ 8.x and earlier, add:

ipv6_ifconfig_gif0="MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR"

Then all you have to do is set the default route for IPv6. This is the other
side of the IPv6 tunnel:

ipv6_defaultrouter="MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR"

32.11.5.3.Â IPv6 Tunnel Settings

If the server is to route IPv6 between the rest of your network and the world,
the following /etc/rc.conf setting will also be needed:

ipv6_gateway_enable="YES"

32.11.6.Â Router Advertisement and Host Auto Configuration

This section will help you setup rtadvd(8) to advertise the IPv6 default route.

To enable rtadvd(8) you will need the following in your /etc/rc.conf:

rtadvd_enable="YES"

It is important that you specify the interface on which to do IPv6 router
solicitation. For example to tell rtadvd(8) to use fxp0:

rtadvd_interfaces="fxp0"

Now we must create the configuration file, /etc/rtadvd.conf. Here is an
example:

fxp0:\ :addrs#1:addr="2001:471:1f11:246::":prefixlen#64:tc=ether:

Replace fxp0 with the interface you are going to be using.

Next, replace 2001:471:1f11:246:: with the prefix of your allocation.

If you are dedicated a /64 subnet you will not need to change anything else.
Otherwise, you will need to change the prefixlen# to the correct value.

32.12.Â Asynchronous Transfer Mode (ATM)

Contributed by Harti Brandt.

32.12.1.Â Configuring Classical IP over ATM (PVCs)

Classical IP over ATM (CLIP) is the simplest method to use Asynchronous
Transfer Mode (ATM) with IP. It can be used with switched connections (SVCs)
and with permanent connections (PVCs). This section describes how to set up a
network based on PVCs.

32.12.1.1.Â Fully Meshed Configurations

The first method to set up a CLIP with PVCs is to connect each machine to each
other machine in the network via a dedicated PVC. While this is simple to
configure it tends to become impractical for a larger number of machines. The
example supposes that we have four machines in the network, each connected to
the ATM network with an ATM adapter card. The first step is the planning of the
IP addresses and the ATM connections between the machines. We use the
following:

         Host                                 IP Address
hostA                  192.168.173.1
hostB                  192.168.173.2
hostC                  192.168.173.3
hostD                  192.168.173.4

To build a fully meshed net we need one ATM connection between each pair of
machines:

               Machines                             VPI.VCI couple
hostA - hostB                          0.100
hostA - hostC                          0.101
hostA - hostD                          0.102
hostB - hostC                          0.103
hostB - hostD                          0.104
hostC - hostD                          0.105

The VPI and VCI values at each end of the connection may of course differ, but
for simplicity we assume that they are the same. Next we need to configure the
ATM interfaces on each host:

hostA# ifconfig hatm0 192.168.173.1 up hostB# ifconfig hatm0 192.168.173.2 up
hostC# ifconfig hatm0 192.168.173.3 up hostD# ifconfig hatm0 192.168.173.4 up

assuming that the ATM interface is hatm0 on all hosts. Now the PVCs need to be
configured on hostA (we assume that they are already configured on the ATM
switches, you need to consult the manual for the switch on how to do this).

hostA# atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr hostA#
atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr hostA# atmconfig natm
add 192.168.173.4 hatm0 0 102 llc/snap ubr hostB# atmconfig natm add
192.168.173.1 hatm0 0 100 llc/snap ubr hostB# atmconfig natm add 192.168.173.3
hatm0 0 103 llc/snap ubr hostB# atmconfig natm add 192.168.173.4 hatm0 0 104
llc/snap ubr hostC# atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr
hostC# atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr hostC#
atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr hostD# atmconfig natm
add 192.168.173.1 hatm0 0 102 llc/snap ubr hostD# atmconfig natm add
192.168.173.2 hatm0 0 104 llc/snap ubr hostD# atmconfig natm add 192.168.173.3
hatm0 0 105 llc/snap ubr

Of course other traffic contracts than UBR can be used given the ATM adapter
supports those. In this case the name of the traffic contract is followed by
the parameters of the traffic. Help for the atmconfig(8) tool can be obtained
with:

# atmconfig help natm add

or in the atmconfig(8) manual page.

The same configuration can also be done via /etc/rc.conf. For hostA this would
look like:

network_interfaces="lo0 hatm0" ifconfig_hatm0="inet 192.168.173.1 up"
natm_static_routes="hostB hostC hostD" route_hostB="192.168.173.2 hatm0 0 100
llc/snap ubr" route_hostC="192.168.173.3 hatm0 0 101 llc/snap ubr" route_hostD=
"192.168.173.4 hatm0 0 102 llc/snap ubr"

The current state of all CLIP routes can be obtained with:

hostA# atmconfig natm show

32.13.Â Common Address Redundancy Protocol (CARP)

Contributed by Tom Rhodes.

The Common Address Redundancy Protocol, or CARP allows multiple hosts to share
the same IP address. In some configurations, this may be used for availability
or load balancing. Hosts may use separate IP addresses as well, as in the
example provided here.

To enable support for CARP, the FreeBSD kernel must be rebuilt as described in
ChapterÂ 9, Configuring the FreeBSD Kernel with the following option:

device carp

Alternatively, the if_carp.ko module can be loaded at boot time. Add the
following line to the /boot/loader.conf:

if_carp_load="YES"

CARP functionality should now be available and may be tuned via several sysctl 
OIDs:

             OID                                 Description
net.inet.carp.allow            Accept incoming CARP packets. Enabled by
                               default.
                               This option downs all of the CARP interfaces on
net.inet.carp.preempt          the host when one of them goes down. Disabled by
                               default
                               A value of 0 disables any logging. A Value of 1
net.inet.carp.log              enables logging of bad CARP packets. Values
                               greater than 1 enables logging of state changes
                               for the CARP interfaces. The default value is 1.
net.inet.carp.arpbalance       Balance local network traffic using ARP.
                               Disabled by default.
                               A read only OID showing the status of preemption
                               suppression. Preemption can be suppressed if
net.inet.carp.suppress_preempt link on an interface is down. A value of 0,
                               means that preemption is not suppressed. Every
                               problem increments this OID.

The CARP devices themselves may be created via the ifconfig command:

# ifconfig carp0 create

In a real environment, these interfaces will need unique identification numbers
known as a VHID. This VHID or Virtual Host Identification will be used to
distinguish the host on the network.

32.13.1.Â Using CARP for Server Availability (CARP)

One use of CARP, as noted above, is for server availability. This example will
provide failover support for three hosts, all with unique IP addresses and
providing the same web content. These machines will act in conjunction with a
Round Robin DNS configuration. The failover machine will have two additional 
CARP interfaces, one for each of the content server's IPs. When a failure
occurs, the failover server should pick up the failed machine's IP address.
This means the failure should go completely unnoticed to the user. The failover
server requires identical content and services as the other content servers it
is expected to pick up load for.

The two machines should be configured identically other than their issued
hostnames and VHIDs. This example calls these machines hosta.example.org and
hostb.example.org respectively. First, the required lines for a CARP
configuration have to be added to rc.conf. For hosta.example.org, the rc.conf
file should contain the following lines:

hostname="hosta.example.org" ifconfig_fxp0="inet 192.168.1.3 netmask
255.255.255.0" cloned_interfaces="carp0" ifconfig_carp0="vhid 1 pass testpass
192.168.1.50/24"

On hostb.example.org the following lines should be in rc.conf:

hostname="hostb.example.org" ifconfig_fxp0="inet 192.168.1.4 netmask
255.255.255.0" cloned_interfaces="carp0" ifconfig_carp0="vhid 2 pass testpass
192.168.1.51/24"

Note:

It is very important that the passwords, specified by the pass option to
ifconfig, are identical. The carp devices will only listen to and accept
advertisements from machines with the correct password. The VHID must also be
different for each machine.

The third machine, provider.example.org, should be prepared so that it may
handle failover from either host. This machine will require two carp devices,
one to handle each host. The appropriate rc.conf configuration lines will be
similar to the following:

hostname="provider.example.org" ifconfig_fxp0="inet 192.168.1.5 netmask
255.255.255.0" cloned_interfaces="carp0 carp1" ifconfig_carp0="vhid 1 advskew
100 pass testpass 192.168.1.50/24" ifconfig_carp1="vhid 2 advskew 100 pass
testpass 192.168.1.51/24"

Having the two carp devices will allow provider.example.org to notice and pick
up the IP address of either machine should it stop responding.

Note:

The default FreeBSD kernel may have preemption enabled. If so,
provider.example.org may not relinquish the IP address back to the original
content server. In this case, an administrator may have to manually force the
IP back to the master. The following command should be issued on
provider.example.org:

# ifconfig carp0 down && ifconfig carp0 up

This should be done on the carp interface which corresponds to the correct
host.

At this point, CARP should be completely enabled and available for testing. For
testing, either networking has to be restarted or the machines need to be
rebooted.

More information is always available in the carp(4) manual page.

PartÂ V.Â Appendices

Table of Contents

A. Obtaining FreeBSD

    A.1. CDROM and DVD Publishers
    A.2. FTP Sites
    A.3. Anonymous CVS (Deprecated)
    A.4. Using CTM
    A.5. Using Subversion
    A.6. Subversion Mirror Sites
    A.7. Using CVSup (Deprecated)
    A.8. CVS Tags
    A.9. rsync Sites

B. Bibliography

    B.1. Books & Magazines Specific to FreeBSD
    B.2. Users' Guides
    B.3. Administrators' Guides
    B.4. Programmers' Guides
    B.5. Operating System Internals
    B.6. Security Reference
    B.7. Hardware Reference
    B.8. UNIXÂ® History
    B.9. Magazines and Journals

C. Resources on the Internet

    C.1. Mailing Lists
    C.2. Usenet Newsgroups
    C.3. World Wide Web Servers
    C.4. Email Addresses

D. PGP Keys

    D.1. Officers
    D.2. Core Team Members
    D.3. Developers
    D.4. Other Cluster Account Holders

AppendixÂ A.Â Obtaining FreeBSD

Table of Contents

A.1. CDROM and DVD Publishers
A.2. FTP Sites
A.3. Anonymous CVS (Deprecated)
A.4. Using CTM
A.5. Using Subversion
A.6. Subversion Mirror Sites
A.7. Using CVSup (Deprecated)
A.8. CVS Tags
A.9. rsync Sites

A.1.Â CDROM and DVD Publishers

A.1.1.Â CD and DVD Sets

FreeBSD CD and DVD sets are available from many online retailers:

  * 
    Â Â Â Â FreeBSDÂ Mall,Â Inc.
    Â Â Â Â 2420Â SandÂ CreekÂ RdÂ C-1Â #347
    Â Â Â Â Brentwood,
    Â Â Â Â CA
    Â Â Â Â 94513
    Â Â Â Â USA
    Â Â Â Â Phone:Â +1Â 925Â 240-6652
    Â Â Â Â Fax:Â +1Â 925Â 674-0821
    Â Â Â Â Email:Â &lt;info@freebsdmall.com&gt;
    Â Â Â Â WWW:Â http://www.freebsdmall.com/
    Â Â 

  * 
    Â Â Â Â Dr.Â HinnerÂ EDV
    Â Â Â Â Kochelseestr.Â 11
    Â Â Â Â D-81371Â MÃŒnchen
    Â Â Â Â Germany
    Â Â Â Â Phone:Â (0177)Â 428Â 419Â 0
    Â Â Â Â WWW:Â http://www.hinner.de/linux/freebsd.html
    Â Â 

  * 
    Â Â Â Â LinuxÂ DistroÂ UK
    Â Â Â Â 42Â WharfedaleÂ Road
    Â Â Â Â Margate
    Â Â Â Â CT9Â 2TB
    Â Â Â Â UnitedÂ Kingdom
    Â Â Â Â WWW:Â https://linux-distro.co.uk/
    Â Â 

  * 
    Â Â Â Â TheÂ LinuxÂ Emporium
    Â Â Â Â TheÂ TechnoÂ Centre,Â PumaÂ Way
    Â Â Â Â Parkside
    Â Â Â Â CV1Â 2TT
    Â Â Â Â UnitedÂ Kingdom
    Â Â Â Â Phone:Â +44Â (0)247Â 615Â 8121
    Â Â Â Â Fax:Â +44Â 1491Â 837016
    Â Â Â Â WWW:Â http://www.linuxemporium.co.uk/products/bsd/
    Â Â 

  * 
    Â Â Â Â LinuxCenter.Ru
    Â Â Â Â GalernayaÂ Street,Â 55
    Â Â Â Â Saint-Petersburg
    Â Â Â Â 190000
    Â Â Â Â Russia
    Â Â Â Â Phone:Â +7-812-3125208
    Â Â Â Â Email:Â &lt;info@linuxcenter.ru&gt;
    Â Â Â Â WWW:Â http://linuxcenter.ru/shop/freebsd
    Â Â 

A.2.Â FTP Sites

The official sources for FreeBSD are available via anonymous FTP from a
worldwide set of mirror sites. The site ftp://ftp.FreeBSD.org/pub/FreeBSD/ is
well connected and allows a large number of connections to it, but you are
probably better off finding a â  closerâ   mirror site (especially if you
decide to set up some sort of mirror site).

Additionally, FreeBSD is available via anonymous FTP from the following mirror
sites. If you choose to obtain FreeBSD via anonymous FTP, please try to use a
site near you. The mirror sites listed as â  Primary Mirror Sitesâ   typically
have the entire FreeBSD archive (all the currently available versions for each
of the architectures) but you will probably have faster download times from a
site that is in your country or region. The regional sites carry the most
recent versions for the most popular architecture(s) but might not carry the
entire FreeBSD archive. All sites provide access via anonymous FTP but some
sites also provide access via other methods. The access methods available for
each site are provided in parentheses after the hostname.

Central Servers, Primary Mirror Sites, Armenia, Australia, Austria, Brazil,
Canada, China, Czech Republic, Denmark, Estonia, Finland, France, Germany,
Greece, Hong Kong, Iceland, Ireland, Israel, Italy, Japan, Korea, Latvia,
Lithuania, Netherlands, New Zealand, Norway, Poland, Portugal, Romania, Russia,
Saudi Arabia, Slovak Republic, Slovenia, South Africa, Spain, Sweden,
Switzerland, Taiwan, Turkey, Ukraine, United Kingdom, USA.

(as of UTC)

Central Servers
      * ftp://ftp.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6)

Primary Mirror Sites

    In case of problems, please contact the hostmaster &lt;
    mirror-admin@FreeBSD.org&gt; for this domain.

      * ftp://ftp1.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp3.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6)

      * ftp://ftp5.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp6.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp7.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp8.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp9.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp10.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6)

      * ftp://ftp11.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp12.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp13.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp14.FreeBSD.org/pub/FreeBSD/ (ftp / http)

Armenia

    In case of problems, please contact the hostmaster &lt;
    hostmaster@am.FreeBSD.org&gt; for this domain.

      * ftp://ftp1.am.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

Australia

    In case of problems, please contact the hostmaster &lt;
    hostmaster@au.FreeBSD.org&gt; for this domain.

      * ftp://ftp.au.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.au.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp3.au.FreeBSD.org/pub/FreeBSD/ (ftp)

Austria

    In case of problems, please contact the hostmaster &lt;
    hostmaster@at.FreeBSD.org&gt; for this domain.

      * ftp://ftp.at.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6)

Brazil

    In case of problems, please contact the hostmaster &lt;
    hostmaster@br.FreeBSD.org&gt; for this domain.

      * ftp://ftp.br.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp2.br.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp3.br.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

      * ftp://ftp4.br.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp5.br.FreeBSD.org

      * ftp://ftp6.br.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp7.br.FreeBSD.org/pub/FreeBSD/ (ftp)

Canada

    In case of problems, please contact the hostmaster &lt;
    hostmaster@ca.FreeBSD.org&gt; for this domain.

      * ftp://ftp.ca.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.ca.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp3.ca.FreeBSD.org/pub/FreeBSD/ (ftp)

China

    In case of problems, please contact the hostmaster &lt;
    hostmaster@cn.FreeBSD.org&gt; for this domain.

      * ftp://ftp.cn.FreeBSD.org/pub/FreeBSD/ (ftp)

Czech Republic

    In case of problems, please contact the hostmaster &lt;
    hostmaster@cz.FreeBSD.org&gt; for this domain.

      * ftp://ftp.cz.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6 /
        rsync / rsyncv6)

      * ftp://ftp2.cz.FreeBSD.org/pub/FreeBSD/ (ftp / http)

Denmark

    In case of problems, please contact the hostmaster &lt;
    hostmaster@dk.FreeBSD.org&gt; for this domain.

      * ftp://ftp.dk.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6)

Estonia

    In case of problems, please contact the hostmaster &lt;
    hostmaster@ee.FreeBSD.org&gt; for this domain.

      * ftp://ftp.ee.FreeBSD.org/pub/FreeBSD/ (ftp)

Finland

    In case of problems, please contact the hostmaster &lt;
    hostmaster@fi.FreeBSD.org&gt; for this domain.

      * ftp://ftp.fi.FreeBSD.org/pub/FreeBSD/ (ftp)

France

    In case of problems, please contact the hostmaster &lt;
    hostmaster@fr.FreeBSD.org&gt; for this domain.

      * ftp://ftp.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp1.fr.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp2.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.fr.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6 /
        rsync / rsyncv6)

      * ftp://ftp5.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

      * ftp://ftp7.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp8.fr.FreeBSD.org/pub/FreeBSD/ (ftp)

Germany

    In case of problems, please contact the hostmaster &lt;
    de-bsd-hubs@de.FreeBSD.org&gt; for this domain.

      * ftp://ftp.de.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp1.de.FreeBSD.org/freebsd/ (ftp / http / rsync)

      * ftp://ftp2.de.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp3.de.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.de.FreeBSD.org/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp5.de.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp6.de.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp7.de.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp8.de.FreeBSD.org/pub/FreeBSD/ (ftp)

Greece

    In case of problems, please contact the hostmaster &lt;
    hostmaster@gr.FreeBSD.org&gt; for this domain.

      * ftp://ftp.gr.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD/ (ftp)

Hong Kong
      * ftp://ftp.hk.FreeBSD.org/pub/FreeBSD/ (ftp)

Iceland

    In case of problems, please contact the hostmaster &lt;
    hostmaster@is.FreeBSD.org&gt; for this domain.

      * ftp://ftp.is.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

Ireland

    In case of problems, please contact the hostmaster &lt;
    hostmaster@ie.FreeBSD.org&gt; for this domain.

      * ftp://ftp.ie.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.ie.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp3.ie.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

Israel

    In case of problems, please contact the hostmaster &lt;
    hostmaster@il.FreeBSD.org&gt; for this domain.

      * ftp://ftp.il.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6)

Italy

    In case of problems, please contact the hostmaster &lt;
    hostmaster@it.FreeBSD.org&gt; for this domain.

      * ftp://ftp.it.FreeBSD.org/pub/FreeBSD/ (ftp)

Japan

    In case of problems, please contact the hostmaster &lt;
    hostmaster@jp.FreeBSD.org&gt; for this domain.

      * ftp://ftp.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp3.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp5.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp7.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp8.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp9.jp.FreeBSD.org/pub/FreeBSD/ (ftp)

Korea

    In case of problems, please contact the hostmaster &lt;
    hostmaster@kr.FreeBSD.org&gt; for this domain.

      * ftp://ftp.kr.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

      * ftp://ftp2.kr.FreeBSD.org/pub/FreeBSD/ (ftp / http)

Latvia

    In case of problems, please contact the hostmaster &lt;
    hostmaster@lv.FreeBSD.org&gt; for this domain.

      * ftp://ftp.lv.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp2.lv.FreeBSD.org/pub/FreeBSD/ (ftp)

Lithuania

    In case of problems, please contact the hostmaster &lt;
    hostmaster@lt.FreeBSD.org&gt; for this domain.

      * ftp://ftp.lt.FreeBSD.org/pub/FreeBSD/ (ftp / http)

Netherlands

    In case of problems, please contact the hostmaster &lt;
    hostmaster@nl.FreeBSD.org&gt; for this domain.

      * ftp://ftp.nl.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD/ (ftp)

New Zealand
      * ftp://ftp.nz.FreeBSD.org/pub/FreeBSD/ (ftp / http)

Norway

    In case of problems, please contact the hostmaster &lt;
    hostmaster@no.FreeBSD.org&gt; for this domain.

      * ftp://ftp.no.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

      * ftp://ftp3.no.FreeBSD.org/pub/FreeBSD/ (ftp)

Poland

    In case of problems, please contact the hostmaster &lt;
    hostmaster@pl.FreeBSD.org&gt; for this domain.

      * ftp://ftp.pl.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.pl.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6 /
        rsync / rsyncv6)

Portugal

    In case of problems, please contact the hostmaster &lt;
    hostmaster@pt.FreeBSD.org&gt; for this domain.

      * ftp://ftp.pt.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.pt.FreeBSD.org/pub/freebsd/ (ftp)

      * ftp://ftp4.pt.FreeBSD.org/pub/ISO/FreeBSD/ (ftp)

Romania

    In case of problems, please contact the hostmaster &lt;
    hostmaster@ro.FreeBSD.org&gt; for this domain.

      * ftp://ftp.ro.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp1.ro.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6)

Russia

    In case of problems, please contact the hostmaster &lt;
    hostmaster@ru.FreeBSD.org&gt; for this domain.

      * ftp://ftp.ru.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp3.ru.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.ru.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp5.ru.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp6.ru.FreeBSD.org/pub/FreeBSD/ (ftp)

Saudi Arabia

    In case of problems, please contact the hostmaster &lt;ftpadmin@isu.net.sa&gt;
    for this domain.

      * ftp://ftp.isu.net.sa/pub/ftp.freebsd.org/ (ftp)

Slovak Republic

    In case of problems, please contact the hostmaster &lt;
    hostmaster@sk.FreeBSD.org&gt; for this domain.

      * ftp://ftp.sk.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6 /
        rsync / rsyncv6)

      * ftp://ftp2.sk.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6)

Slovenia

    In case of problems, please contact the hostmaster &lt;
    hostmaster@si.FreeBSD.org&gt; for this domain.

      * ftp://ftp.si.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.si.FreeBSD.org/pub/FreeBSD/ (ftp)

South Africa

    In case of problems, please contact the hostmaster &lt;
    hostmaster@za.FreeBSD.org&gt; for this domain.

      * ftp://ftp.za.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.za.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp3.za.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.za.FreeBSD.org/pub/FreeBSD/ (ftp)

Spain

    In case of problems, please contact the hostmaster &lt;
    hostmaster@es.FreeBSD.org&gt; for this domain.

      * ftp://ftp.es.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp2.es.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp3.es.FreeBSD.org/pub/FreeBSD/ (ftp)

Sweden

    In case of problems, please contact the hostmaster &lt;
    hostmaster@se.FreeBSD.org&gt; for this domain.

      * ftp://ftp.se.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.se.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

      * ftp://ftp3.se.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.se.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6 /
        rsync / rsyncv6)

      * ftp://ftp5.se.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp6.se.FreeBSD.org/pub/FreeBSD (ftp / http)

Switzerland

    In case of problems, please contact the hostmaster &lt;
    hostmaster@ch.FreeBSD.org&gt; for this domain.

      * ftp://ftp.ch.FreeBSD.org/pub/FreeBSD/ (ftp / http)

Taiwan

    In case of problems, please contact the hostmaster &lt;
    hostmaster@tw.FreeBSD.org&gt; for this domain.

      * ftp://ftp.tw.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / rsync / rsyncv6)

      * ftp://ftp2.tw.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6 /
        rsync / rsyncv6)

      * ftp://ftp3.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp6.tw.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp7.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp8.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp9.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp10.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp11.tw.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp12.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp13.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp14.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp15.tw.FreeBSD.org/pub/FreeBSD/ (ftp)

Turkey
      * ftp://ftp.tr.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp2.tr.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

Ukraine
      * ftp://ftp.ua.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp2.ua.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp7.ua.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp8.ua.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp11.ua.FreeBSD.org/pub/FreeBSD/ (ftp)

United Kingdom

    In case of problems, please contact the hostmaster &lt;
    hostmaster@uk.FreeBSD.org&gt; for this domain.

      * ftp://ftp.uk.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp3.uk.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.uk.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp5.uk.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp6.uk.FreeBSD.org/pub/FreeBSD/ (ftp)

USA

    In case of problems, please contact the hostmaster &lt;
    hostmaster@us.FreeBSD.org&gt; for this domain.

      * ftp://ftp1.us.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp2.us.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp3.us.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp4.us.FreeBSD.org/pub/FreeBSD/ (ftp / ftpv6 / http / httpv6)

      * ftp://ftp5.us.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

      * ftp://ftp6.us.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp7.us.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp8.us.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp9.us.FreeBSD.org

      * ftp://ftp10.us.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp11.us.FreeBSD.org/pub/FreeBSD/ (ftp)

      * ftp://ftp12.us.FreeBSD.org/pub/FreeBSD/ (ftp / rsync)

      * ftp://ftp13.us.FreeBSD.org/pub/FreeBSD/ (ftp / http / rsync)

      * ftp://ftp14.us.FreeBSD.org/pub/FreeBSD/ (ftp / http)

      * ftp://ftp15.us.FreeBSD.org/pub/FreeBSD/ (ftp)

A.3.Â Anonymous CVS (Deprecated)

A.3.1.Â Warning

Warning:

CVS has been deprecated by the project, and its use is not recommended.
Subversion should be used instead.

A.4.Â Using CTM

CTM is a method for keeping a remote directory tree in sync with a central one.
It has been developed for usage with FreeBSD's source trees, though other
people may find it useful for other purposes as time goes by. Little, if any,
documentation currently exists at this time on the process of creating deltas,
so contact the ctm-users mailing list for more information and if you wish to
use CTM for other things.

A.4.1.Â Why Should I Use CTM?

CTM will give you a local copy of the FreeBSD source trees. There are a number
of â  flavorsâ   of the tree available. Whether you wish to track the entire
CVS tree or just one of the branches, CTM can provide you the information. If
you are an active developer on FreeBSD, but have lousy or non-existent TCP/IP
connectivity, or simply wish to have the changes automatically sent to you, CTM
was made for you. You will need to obtain up to three deltas per day for the
most active branches. However, you should consider having them sent by
automatic email. The sizes of the updates are always kept as small as possible.
This is typically less than 5K, with an occasional (one in ten) being 10-50K
and every now and then a large 100K+ or more coming around.

You will also need to make yourself aware of the various caveats related to
working directly from the development sources rather than a pre-packaged
release. This is particularly true if you choose the â  currentâ   sources. It
is recommended that you read Staying current with FreeBSD.

A.4.2.Â What Do I Need to Use CTM?

You will need two things: The CTM program, and the initial deltas to feed it
(to get up to â  currentâ   levels).

The CTM program has been part of FreeBSD ever since version 2.0 was released,
and lives in /usr/src/usr.sbin/ctm if you have a copy of the source available.

The â  deltasâ   you feed CTM can be had two ways, FTP or email. If you have
general FTP access to the Internet then the following FTP sites support access
to CTM:

ftp://ftp.FreeBSD.org/pub/FreeBSD/CTM/

or see section mirrors.

FTP the relevant directory and fetch the README file, starting from there.

If you wish to get your deltas via email:

Subscribe to one of the CTM distribution lists. ctm-src-cur supports the entire
Subversion tree. ctm-src-cur supports the head of the development branch.
ctm-src-9 supports the 9.X release branch, etc.. (If you do not know how to
subscribe yourself to a list, click on the list name above or go to http://
lists.FreeBSD.org/mailman/listinfo and click on the list that you wish to
subscribe to. The list page should contain all of the necessary subscription
instructions.)

When you begin receiving your CTM updates in the mail, you may use the
ctm_rmail program to unpack and apply them. You can actually use the ctm_rmail
program directly from a entry in /etc/aliases if you want to have the process
run in a fully automated fashion. Check the ctm_rmail manual page for more
details.

Note:

No matter what method you use to get the CTM deltas, you should subscribe to
the ctm-announce mailing list. In the future, this will be the only place where
announcements concerning the operations of the CTM system will be posted. Click
on the list name above and follow the instructions to subscribe to the list.

A.4.3.Â Using CTM for the First Time

Before you can start using CTM deltas, you will need to get to a starting point
for the deltas produced subsequently to it.

First you should determine what you already have. Everyone can start from an â 
 emptyâ   directory. You must use an initial â  Emptyâ   delta to start off
your CTM supported tree. At some point it is intended that one of these â  
startedâ   deltas be distributed on the CD for your convenience, however, this
does not currently happen.

Since the trees are many tens of megabytes, you should prefer to start from
something already at hand. If you have a -RELEASE CD, you can copy or extract
an initial source from it. This will save a significant transfer of data.

You can recognize these â  starterâ   deltas by the X appended to the number
(src-cur.3210XEmpty.gz for instance). The designation following the X
corresponds to the origin of your initial â  seedâ  . Empty is an empty
directory. As a rule a base transition from Empty is produced every 100 deltas.
By the way, they are large! 70 to 80 Megabytes of gzip'd data is common for the
XEmpty deltas.

Once you have picked a base delta to start from, you will also need all deltas
with higher numbers following it.

A.4.4.Â Using CTM in Your Daily Life

To apply the deltas, simply say:

# cd /where/ever/you/want/the/stuff # ctm -v -v /where/you/store/your/deltas/
src-xxx.*

CTM understands deltas which have been put through gzip, so you do not need to
gunzip them first, this saves disk space.

Unless it feels very secure about the entire process, CTM will not touch your
tree. To verify a delta you can also use the -c flag and CTM will not actually
touch your tree; it will merely verify the integrity of the delta and see if it
would apply cleanly to your current tree.

There are other options to CTM as well, see the manual pages or look in the
sources for more information.

That is really all there is to it. Every time you get a new delta, just run it
through CTM to keep your sources up to date.

Do not remove the deltas if they are hard to download again. You just might
want to keep them around in case something bad happens. Even if you only have
floppy disks, consider using fdwrite to make a copy.

A.4.5.Â Keeping Your Local Changes

As a developer one would like to experiment with and change files in the source
tree. CTM supports local modifications in a limited way: before checking for
the presence of a file foo, it first looks for foo.ctm. If this file exists, 
CTM will operate on it instead of foo.

This behavior gives us a simple way to maintain local changes: simply copy the
files you plan to modify to the corresponding file names with a .ctm suffix.
Then you can freely hack the code, while CTM keeps the .ctm file up-to-date.

A.4.6.Â Other Interesting CTM Options

A.4.6.1.Â Finding Out Exactly What Would Be Touched by an Update

You can determine the list of changes that CTM will make on your source
repository using the -l option to CTM.

This is useful if you would like to keep logs of the changes, pre- or post-
process the modified files in any manner, or just are feeling a tad paranoid.

A.4.6.2.Â Making Backups Before Updating

Sometimes you may want to backup all the files that would be changed by a CTM
update.

Specifying the -B backup-file option causes CTM to backup all files that would
be touched by a given CTM delta to backup-file.

A.4.6.3.Â Restricting the Files Touched by an Update

Sometimes you would be interested in restricting the scope of a given CTM
update, or may be interested in extracting just a few files from a sequence of
deltas.

You can control the list of files that CTM would operate on by specifying
filtering regular expressions using the -e and -x options.

For example, to extract an up-to-date copy of lib/libc/Makefile from your
collection of saved CTM deltas, run the commands:

# cd /where/ever/you/want/to/extract/it/ # ctm -e '^lib/libc/Makefile' ~ctm/
src-xxx.*

For every file specified in a CTM delta, the -e and -x options are applied in
the order given on the command line. The file is processed by CTM only if it is
marked as eligible after all the -e and -x options are applied to it.

A.4.7.Â Future Plans for CTM

Tons of them:

  * Use some kind of authentication into the CTM system, so as to allow
    detection of spoofed CTM updates.

  * Clean up the options to CTM, they became confusing and counter intuitive.

A.4.8.Â Miscellaneous Stuff

There is a sequence of deltas for the ports collection too, but interest has
not been all that high yet.

A.4.9.Â CTM Mirrors

CTM/FreeBSD is available via anonymous FTP from the following mirror sites. If
you choose to obtain CTM via anonymous FTP, please try to use a site near you.

In case of problems, please contact the ctm-users mailing list.

California, Bay Area, official source
      * ftp://ftp.FreeBSD.org/pub/FreeBSD/development/CTM/

South Africa, backup server for old deltas
      * ftp://ftp.za.FreeBSD.org/pub/FreeBSD/CTM/

Taiwan/R.O.C.
      * ftp://ctm.tw.FreeBSD.org/pub/FreeBSD/development/CTM/

      * ftp://ctm2.tw.FreeBSD.org/pub/FreeBSD/development/CTM/

      * ftp://ctm3.tw.FreeBSD.org/pub/FreeBSD/development/CTM/

If you did not find a mirror near to you or the mirror is incomplete, try to
use a search engine such as alltheweb.

A.5.Â Using Subversion

A.5.1.Â Introduction

As of July 2012, FreeBSD uses Subversion (svn) as the primary version control
system for storing all of FreeBSD's source code, documentation, and the Ports
Collection.

Note:

Subversion is generally a developer tool. Most users should use FreeBSD Update
to update the FreeBSD base system, and Portsnap to update the FreeBSD Ports
Collection.

In Subversion, URLs are used to designate a repository, taking the form of
protocol://hostname/path. Mirrors may support different protocols as specified
below. The first component of the path is the FreeBSD repository to access.
There are three different repositories, base for the FreeBSD base system source
code, ports for the Ports Collection, and doc for documentation. For example,
the URL svn://svn0.us-east.FreeBSD.org/ports/head/ specifies the main branch of
the ports repository on the svn0.us-east.FreeBSD.org mirror, using the svn
protocol.

A.5.2.Â Installation

Subversion must be installed before it can be used to check out the contents of
any of the repositories. If a copy of the ports tree is already present, one
can install Subversion like this:

# cd /usr/ports/devel/subversion # make install clean

If the ports tree is not available, Subversion can be installed as a package:

# pkg_add -r subversion

If pkgng is being used to manage packages, Subversion can be installed with it
instead:

# pkg install devel/subversion

A.5.3.Â Running Subversion

The svn command is used to fetch a clean copy of the sources into a local
directory. The files in this directory are called a local working copy.

Warning:

If the local directory already exists but was not created by svn, rename or
delete it before the checkout. Checkout over an existing non-svn directory can
cause conflicts between the existing files and those brought in from the
repository.

A checkout from a given repository is performed with a command like this:

# svn checkout svn-mirror/repository/branch lwcdir

where:

  * svn-mirror is a URL for one of the Subversion mirror sites.

  * repository is one of the Project repositories, i.e., base, ports, or doc.

  * branch depends on the repository used. ports and doc are mostly updated in
    the head branch, while base maintains the latest version of -CURRENT under
    head and the respective latest versions of the -STABLE branches under
    stable/8 (for 8.x) and stable/9 (9.x).

  * lwcdir is the target directory where the contents of the specified branch
    should be placed. This is usually /usr/ports for ports, /usr/src for base,
    and /usr/doc for doc.

This example checks out the Ports Collection from the western US repository
using the HTTPS protocol, placing the local working copy in /usr/ports. If /usr
/ports is already present but was not created by svn, remember to rename or
delete it before the checkout.

# svn checkout https://svn0.us-west.FreeBSD.org/ports/head /usr/ports

Because the initial checkout has to download the full branch of the remote
repository, it can take a while. Please be patient.

After the initial checkout, the local working copy can be updated by running:

# svn update lwcdir

To update /usr/ports created in the example above, use:

# svn update /usr/ports

The update is much quicker than a checkout, only transferring files that have
changed.

An alternate way of updating the local working copy after checkout is provided
by the Makefile in the /usr/ports, /usr/src, and /usr/doc directories. Set
SVN_UPDATE and use the update target. For example, to update /usr/src:

# cd /usr/src # make update SVN_UPDATE=yes

A.5.4.Â For More Information

For other information about using Subversion, please see the â  Subversion Book
â  , titled Version Control with Subversion, or the Subversion Documentation.

A.6.Â Subversion Mirror Sites

All mirrors carry all repositories.

The master FreeBSD Subversion server, svn.FreeBSD.org, is publicly accessible,
read-only. That may change in the future, so users are encouraged to use one of
the official mirrors. To view the FreeBSD Subversion repositories through a
browser, use http://svnweb.FreeBSD.org/.

Note:

The FreeBSD svn mirror network is still in its early days, and will likely
change. Do not count on this list of mirrors being static. In particular, the
SSL certificates of the servers will likely change at some point.

+---------------------------------------------------------------------------------------------------------+
|          Name          |Protocols| Location |                      SSL fingerprint                      |
|------------------------+---------+----------+-----------------------------------------------------------|
|svn0.us-west.FreeBSD.org|svn, http|USA,      |SHA1                                                       |
|                        |, https  |California|79:35:8F:CA:6D:34:D9:30:44:D1:00:AF:33:4D:E6:11:44:4D:15:EC|
|------------------------+---------+----------+-----------------------------------------------------------|
|svn0.us-east.FreeBSD.org|svn, http|USA, New  |SHA1                                                       |
|                        |, https  |Jersey    |06:D1:23:DE:5E:7A:F7:2B:7A:7E:74:95:5F:54:8D:5C:B0:D6:2E:8F|
+---------------------------------------------------------------------------------------------------------+

HTTPS is the preferred protocol, providing protection against another computer
pretending to be the FreeBSD mirror (commonly known as a â  man in the middleâ 
  attack) or otherwise trying to send bad content to the end user.

On the first connection to an HTTPS mirror, the user will be asked to verify
the server fingerprint:

Error validating server certificate for 'https://svn0.us-west.freebsd.org:443':
- The certificate is not issued by a trusted authority. Use the fingerprint to
validate the certificate manually! Certificate information: - Hostname:
svnmir.ysv.FreeBSD.org - Valid: from Fri, 24 Aug 2012 22:04:04 GMT until Sat,
24 Aug 2013 22:04:04 GMT - Issuer: clusteradm, FreeBSD.org, CA, US -
Fingerprint: 79:35:8f:ca:6d:34:d9:30:44:d1:00:af:33:4d:e6:11:44:4d:15:ec (R)
eject, accept (t)emporarily or accept (p)ermanently?

Compare the fingerprint shown to those listed in the table above. If the
fingerprint matches, the server security certificate can be accepted
temporarily or permanently. A temporary certificate will expire after a single
session with the server, and the verification step will be repeated on the next
connection. Accepting the certificate permanently will store the authentication
credentials in ~/.subversion/auth/ and the user will not be asked to verify the
fingerprint again until the certificate expires.

If HTTPS cannot be used due to firewall or other problems, SVN is the next
choice, with slightly faster transfers. When neither can be used, use HTTP.

A.7.Â Using CVSup (Deprecated)

A.7.1.Â Introduction

Warning:

cvsup has been deprecated by the project, and its use is not recommended. 
Subversion should be used instead.

CVSup is a software package for distributing and updating source trees from a
master CVS repository on a remote server host. The FreeBSD sources are
maintained in a CVS repository on a central development machine in California.
With CVSup, FreeBSD users can easily keep their own source trees up to date.

CVSup uses the so-called pull model of updating. Under the pull model, each
client asks the server for updates, if and when they are wanted. The server
waits passively for update requests from its clients. Thus all updates are
instigated by the client. The server never sends unsolicited updates. Users
must either run the CVSup client manually to get an update, or they must set up
a cron job to run it automatically on a regular basis.

The term CVSup, capitalized just so, refers to the entire software package. Its
main components are the client cvsup which runs on each user's machine, and the
server cvsupd which runs at each of the FreeBSD mirror sites.

Note:

The csup utility is a rewrite of the CVSup software in C. Its biggest advantage
is, that it is faster and does not depend on the Modula-3 language, thus you do
not need to install it as a requirement. Moreover you can use it
out-of-the-box, since it is included in the base system. If you decided to use 
csup, just skip the steps on the installation of CVSup and substitute the
references of CVSup with csup while following the remainder of this article.

A.7.2.Â Installation

The easiest way to install CVSup is to use the precompiled net/cvsup package
from the FreeBSD packages collection. If you prefer to build CVSup from source,
you can use the net/cvsup port instead. But be forewarned: the net/cvsup port
depends on the Modula-3 system, which takes a substantial amount of time and
disk space to download and build.

Note:

If you are going to be using CVSup on a machine which will not have Xorg
installed, such as a server, be sure to use the port which does not include the
CVSup GUI, net/cvsup-without-gui.

A.7.3.Â CVSup Configuration

CVSup's operation is controlled by a configuration file called the supfile.
There are some sample supfiles in the directory /usr/share/examples/cvsup/.

The information in a supfile answers the following questions for CVSup:

  * Which files do you want to receive?

  * Which versions of them do you want?

  * Where do you want to get them from?

  * Where do you want to put them on your own machine?

  * Where do you want to put your status files?

In the following sections, we will construct a typical supfile by answering
each of these questions in turn. First, we describe the overall structure of a
supfile.

A supfile is a text file. Comments begin with # and extend to the end of the
line. Lines that are blank and lines that contain only comments are ignored.

Each remaining line describes a set of files that the user wishes to receive.
The line begins with the name of a â  collectionâ  , a logical grouping of
files defined by the server. The name of the collection tells the server which
files you want. After the collection name come zero or more fields, separated
by white space. These fields answer the questions listed above. There are two
types of fields: flag fields and value fields. A flag field consists of a
keyword standing alone, e.g., delete or compress. A value field also begins
with a keyword, but the keyword is followed without intervening white space by
= and a second word. For example, release=cvs is a value field.

A supfile typically specifies more than one collection to receive. One way to
structure a supfile is to specify all of the relevant fields explicitly for
each collection. However, that tends to make the supfile lines quite long, and
it is inconvenient because most fields are the same for all of the collections
in a supfile. CVSup provides a defaulting mechanism to avoid these problems.
Lines beginning with the special pseudo-collection name *default can be used to
set flags and values which will be used as defaults for the subsequent
collections in the supfile. A default value can be overridden for an individual
collection, by specifying a different value with the collection itself.
Defaults can also be changed or augmented in mid-supfile by additional *default
lines.

With this background, we will now proceed to construct a supfile for receiving
and updating the main source tree of FreeBSD-CURRENT.

  * Which files do you want to receive?

    The files available via CVSup are organized into named groups called â  
    collectionsâ  . The collections that are available are described in the
    following section. In this example, we wish to receive the entire main
    source tree for the FreeBSD system. There is a single large collection
    src-all which will give us all of that. As a first step toward constructing
    our supfile, we simply list the collections, one per line (in this case,
    only one line):

    src-all
  * Which version(s) of them do you want?

    With CVSup, you can receive virtually any version of the sources that ever
    existed. That is possible because the cvsupd server works directly from the
    CVS repository, which contains all of the versions. You specify which one
    of them you want using the tag= and date= value fields.

    Warning:

    Be very careful to specify any tag= fields correctly. Some tags are valid
    only for certain collections of files. If you specify an incorrect or
    misspelled tag, CVSup will delete files which you probably do not want
    deleted. In particular, use only tag=. for the ports-* collections.

    The tag= field names a symbolic tag in the repository. There are two kinds
    of tags, revision tags and branch tags. A revision tag refers to a specific
    revision. Its meaning stays the same from day to day. A branch tag, on the
    other hand, refers to the latest revision on a given line of development,
    at any given time. Because a branch tag does not refer to a specific
    revision, it may mean something different tomorrow than it means today.

    SectionÂ A.8, â  CVS Tagsâ   contains branch tags that users might be
    interested in. When specifying a tag in CVSup's configuration file, it must
    be preceded with tag= (RELENG_8 will become tag=RELENG_8). Keep in mind
    that only the tag=. is relevant for the Ports Collection.

    Warning:

    Be very careful to type the tag name exactly as shown. CVSup cannot
    distinguish between valid and invalid tags. If you misspell the tag, CVSup
    will behave as though you had specified a valid tag which happens to refer
    to no files at all. It will delete your existing sources in that case.

    When you specify a branch tag, you normally receive the latest versions of
    the files on that line of development. If you wish to receive some past
    version, you can do so by specifying a date with the date= value field. The
    cvsup(1) manual page explains how to do that.

    For our example, we wish to receive FreeBSD-CURRENT. We add this line at
    the beginning of our supfile:

    *default tag=.

    There is an important special case that comes into play if you specify
    neither a tag= field nor a date= field. In that case, you receive the
    actual RCS files directly from the server's CVS repository, rather than
    receiving a particular version. Developers generally prefer this mode of
    operation. By maintaining a copy of the repository itself on their systems,
    they gain the ability to browse the revision histories and examine past
    versions of files. This gain is achieved at a large cost in terms of disk
    space, however.

  * Where do you want to get them from?

    We use the host= field to tell cvsup where to obtain its updates. Any of
    the CVSup mirror sites will do, though you should try to select one that is
    close to you in cyberspace. In this example we will use a fictional FreeBSD
    distribution site, cvsup99.FreeBSD.org:

    *default host=cvsup99.FreeBSD.org

    You will need to change the host to one that actually exists before running
    CVSup. On any particular run of cvsup, you can override the host setting on
    the command line, with -h hostname.

  * Where do you want to put them on your own machine?

    The prefix= field tells cvsup where to put the files it receives. In this
    example, we will put the source files directly into our main source tree, /
    usr/src. The src directory is already implicit in the collections we have
    chosen to receive, so this is the correct specification:

    *default prefix=/usr
  * Where should cvsup maintain its status files?

    The CVSup client maintains certain status files in what is called the â  
    baseâ   directory. These files help CVSup to work more efficiently, by
    keeping track of which updates you have already received. We will use the
    standard base directory, /var/db:

    *default base=/var/db

    If your base directory does not already exist, now would be a good time to
    create it. The cvsup client will refuse to run if the base directory does
    not exist.

  * Miscellaneous supfile settings:

    There is one more line of boiler plate that normally needs to be present in
    the supfile:

    *default release=cvs delete use-rel-suffix compress

    release=cvs indicates that the server should get its information out of the
    main FreeBSD CVS repository. This is virtually always the case, but there
    are other possibilities which are beyond the scope of this discussion.

    delete gives CVSup permission to delete files. You should always specify
    this, so that CVSup can keep your source tree fully up-to-date. CVSup is
    careful to delete only those files for which it is responsible. Any extra
    files you happen to have will be left strictly alone.

    use-rel-suffix is ... arcane. If you really want to know about it, see the
    cvsup(1) manual page. Otherwise, just specify it and do not worry about it.

    compress enables the use of gzip-style compression on the communication
    channel. If your network link is T1 speed or faster, you probably should
    not use compression. Otherwise, it helps substantially.

  * Putting it all together:

    Here is the entire supfile for our example:

    *default tag=. *default host=cvsup99.FreeBSD.org *default prefix=/usr
    *default base=/var/db *default release=cvs delete use-rel-suffix compress
    src-all

A.7.3.1.Â The refuse File

As mentioned above, CVSup uses a pull method. Basically, this means that you
connect to the CVSup server, and it says, â  Here is what you can download from
me...â  , and your client responds â  OK, I will take this, this, this, and
this.â   In the default configuration, the CVSup client will take every file
associated with the collection and tag you chose in the configuration file. In
order to download a partial tree, use the refuse file.

The refuse file tells CVSup that it should not take every single file from a
collection; in other words, it tells the client to refuse certain files from
the server. The refuse file can be found (or, if you do not yet have one,
should be placed) in base/sup/. base is defined in your supfile; our defined
base is /var/db, which means that by default the refuse file is /var/db/sup/
refuse.

The refuse file has a very simple format; it simply contains the names of files
or directories that you do not wish to download. For example:

bin/ usr.bin/

Users who are on slow links or pay by the minute for their Internet connection
will be able to save time as they will no longer need to download files that
they will never use. For more information on refuse files and other neat
features of CVSup, please view its manual page.

A.7.4.Â Running CVSup

You are now ready to try an update. The command line for doing this is quite
simple:

# cvsup supfile

where supfile is of course the name of the supfile you have just created.
Assuming you are running under X11, cvsup will display a GUI window with some
buttons to do the usual things. Press the go button, and watch it run.

Since you are updating your actual /usr/src tree in this example, you will need
to run the program as root so that cvsup has the permissions it needs to update
your files. Having just created your configuration file, and having never used
this program before, that might understandably make you nervous. There is an
easy way to do a trial run without touching your precious files. Just create an
empty directory somewhere convenient, and name it as an extra argument on the
command line:

# mkdir /var/tmp/dest # cvsup supfile /var/tmp/dest

The directory you specify will be used as the destination directory for all
file updates. CVSup will examine your usual files in /usr/src, but it will not
modify or delete any of them. Any file updates will instead land in /var/tmp/
dest/usr/src. CVSup will also leave its base directory status files untouched
when run this way. The new versions of those files will be written into the
specified directory. As long as you have read access to /usr/src, you do not
even need to be root to perform this kind of trial run.

If you are not running X11 or if you just do not like GUIs, you should add a
couple of options to the command line when you run cvsup:

# cvsup -g -L 2 supfile

The -g tells CVSup not to use its GUI. This is automatic if you are not running
X11, but otherwise you have to specify it.

The -L 2 tells CVSup to print out the details of all the file updates it is
doing. There are three levels of verbosity, from -L 0 to -L 2. The default is
0, which means total silence except for error messages.

There are plenty of other options available. For a brief list of them, type
cvsup -H. For more detailed descriptions, see the manual page.

Once you are satisfied with the way updates are working, you can arrange for
regular runs of CVSup using cron(8). Obviously, you should not let CVSup use
its GUI when running it from cron(8).

A.7.5.Â CVSup File Collections

The file collections available via CVSup are organized hierarchically. There
are a few large collections, and they are divided into smaller sub-collections.
Receiving a large collection is equivalent to receiving each of its
sub-collections. The hierarchical relationships among collections are reflected
by the use of indentation in the list below.

The most commonly used collection is src-all.

cvs-all release=cvs

    The main FreeBSD CVS repository, including the cryptography code.

    distrib release=cvs

        Files related to the distribution and mirroring of FreeBSD.

    projects-all release=cvs

        Sources for the FreeBSD projects repository.

    src-all release=cvs

        The main FreeBSD sources, including the cryptography code.

        src-base release=cvs

            Miscellaneous files at the top of /usr/src.

        src-bin release=cvs

            User utilities that may be needed in single-user mode (/usr/src/
            bin).

        src-cddl release=cvs

            Utilities and libraries covered by the CDDL license (/usr/src/
            cddl).

        src-contrib release=cvs

            Utilities and libraries from outside the FreeBSD project, used
            relatively unmodified (/usr/src/contrib).

        src-crypto release=cvs

            Cryptography utilities and libraries from outside the FreeBSD
            project, used relatively unmodified (/usr/src/crypto).

        src-eBones release=cvs

            Kerberos and DES (/usr/src/eBones). Not used in current releases of
            FreeBSD.

        src-etc release=cvs

            System configuration files (/usr/src/etc).

        src-games release=cvs

            Games (/usr/src/games).

        src-gnu release=cvs

            Utilities covered by the GNU Public License (/usr/src/gnu).

        src-include release=cvs

            Header files (/usr/src/include).

        src-kerberos5 release=cvs

            Kerberos5 security package (/usr/src/kerberos5).

        src-kerberosIV release=cvs

            KerberosIV security package (/usr/src/kerberosIV).

        src-lib release=cvs

            Libraries (/usr/src/lib).

        src-libexec release=cvs

            System programs normally executed by other programs (/usr/src/
            libexec).

        src-release release=cvs

            Files required to produce a FreeBSD release (/usr/src/release).

        src-rescue release=cvs

            Statically linked programs for emergency recovery; see rescue(8) (/
            usr/src/rescue).

        src-sbin release=cvs

            System utilities for single-user mode (/usr/src/sbin).

        src-secure release=cvs

            Cryptographic libraries and commands (/usr/src/secure).

        src-share release=cvs

            Files that can be shared across multiple systems (/usr/src/share).

        src-sys release=cvs

            The kernel (/usr/src/sys).

        src-sys-crypto release=cvs

            Kernel cryptography code (/usr/src/sys/crypto).

        src-tools release=cvs

            Various tools for the maintenance of FreeBSD (/usr/src/tools).

        src-usrbin release=cvs

            User utilities (/usr/src/usr.bin).

        src-usrsbin release=cvs

            System utilities (/usr/src/usr.sbin).

distrib release=self

    The CVSup server's own configuration files. Used by CVSup mirror sites.

gnats release=current

    The GNATS bug-tracking database.

mail-archive release=current

    FreeBSD mailing list archive.

A.7.6.Â For More Information

For the CVSup FAQ and other information about CVSup, see The CVSup Home Page.

Most FreeBSD-related discussion of CVSup takes place on the FreeBSD technical
discussions mailing list. New versions of the software are announced there, as
well as on the FreeBSD announcements mailing list.

For questions or bug reports about CVSup take a look at the CVSup FAQ.

A.7.7.Â CVSup Sites

CVSup servers for FreeBSD are running at the following sites:

Central Servers, Primary Mirror Sites, Armenia, Australia, Austria, Brazil,
Canada, China, Costa Rica, Czech Republic, Denmark, Estonia, Finland, France,
Germany, Greece, Iceland, Ireland, Israel, Italy, Japan, Korea, Kuwait,
Kyrgyzstan, Latvia, Lithuania, Netherlands, New Zealand, Norway, Philippines,
Poland, Portugal, Romania, Russia, San Marino, Slovak Republic, Slovenia, South
Africa, Spain, Sweden, Switzerland, Taiwan, Thailand, Turkey, Ukraine, United
Kingdom, USA.

(as of UTC)

Central Servers
      * cvsup.FreeBSD.org

Primary Mirror Sites
      * cvsup1.FreeBSD.org

      * cvsup2.FreeBSD.org

      * cvsup3.FreeBSD.org

      * cvsup4.FreeBSD.org

      * cvsup5.FreeBSD.org

      * cvsup6.FreeBSD.org

      * cvsup7.FreeBSD.org

      * cvsup8.FreeBSD.org

      * cvsup9.FreeBSD.org

      * cvsup10.FreeBSD.org

      * cvsup11.FreeBSD.org

      * cvsup12.FreeBSD.org

      * cvsup13.FreeBSD.org

      * cvsup14.FreeBSD.org

      * cvsup15.FreeBSD.org

      * cvsup16.FreeBSD.org

      * cvsup18.FreeBSD.org

Armenia
      * cvsup1.am.FreeBSD.org

Australia
      * cvsup.au.FreeBSD.org

Austria
      * cvsup.at.FreeBSD.org

Brazil
      * cvsup.br.FreeBSD.org

      * cvsup2.br.FreeBSD.org

      * cvsup3.br.FreeBSD.org

      * cvsup4.br.FreeBSD.org

      * cvsup5.br.FreeBSD.org

Canada
      * cvsup1.ca.FreeBSD.org

China
      * cvsup.cn.FreeBSD.org

      * cvsup2.cn.FreeBSD.org

Costa Rica
      * cvsup1.cr.FreeBSD.org

Czech Republic
      * cvsup.cz.FreeBSD.org

Denmark
      * cvsup.dk.FreeBSD.org

      * cvsup2.dk.FreeBSD.org

Estonia
      * cvsup.ee.FreeBSD.org

Finland
      * cvsup.fi.FreeBSD.org

      * cvsup2.fi.FreeBSD.org

France
      * cvsup.fr.FreeBSD.org

      * cvsup1.fr.FreeBSD.org

      * cvsup2.fr.FreeBSD.org

      * cvsup3.fr.FreeBSD.org

      * cvsup4.fr.FreeBSD.org

      * cvsup5.fr.FreeBSD.org

      * cvsup8.fr.FreeBSD.org

Germany
      * cvsup.de.FreeBSD.org

      * cvsup2.de.FreeBSD.org

      * cvsup3.de.FreeBSD.org

      * cvsup4.de.FreeBSD.org

      * cvsup5.de.FreeBSD.org

      * cvsup6.de.FreeBSD.org

      * cvsup7.de.FreeBSD.org

      * cvsup8.de.FreeBSD.org

Greece
      * cvsup.gr.FreeBSD.org

      * cvsup2.gr.FreeBSD.org

Iceland
      * cvsup.is.FreeBSD.org

Ireland
      * cvsup.ie.FreeBSD.org

      * cvsup2.ie.FreeBSD.org

Israel
      * cvsup.il.FreeBSD.org

Italy
      * cvsup.it.FreeBSD.org

Japan
      * cvsup.jp.FreeBSD.org

      * cvsup2.jp.FreeBSD.org

      * cvsup3.jp.FreeBSD.org

      * cvsup4.jp.FreeBSD.org

      * cvsup5.jp.FreeBSD.org

      * cvsup6.jp.FreeBSD.org

Korea
      * cvsup.kr.FreeBSD.org

      * cvsup2.kr.FreeBSD.org

      * cvsup3.kr.FreeBSD.org

Kuwait
      * cvsup1.kw.FreeBSD.org

Kyrgyzstan
      * cvsup.kg.FreeBSD.org

Latvia
      * cvsup.lv.FreeBSD.org

      * cvsup2.lv.FreeBSD.org

Lithuania
      * cvsup.lt.FreeBSD.org

      * cvsup2.lt.FreeBSD.org

      * cvsup3.lt.FreeBSD.org

Netherlands
      * cvsup.nl.FreeBSD.org

      * cvsup2.nl.FreeBSD.org

      * cvsup3.nl.FreeBSD.org

New Zealand
      * cvsup.nz.FreeBSD.org

Norway
      * cvsup.no.FreeBSD.org

Philippines
      * cvsup1.ph.FreeBSD.org

Poland
      * cvsup.pl.FreeBSD.org

      * cvsup2.pl.FreeBSD.org

      * cvsup3.pl.FreeBSD.org

Portugal
      * cvsup.pt.FreeBSD.org

      * cvsup2.pt.FreeBSD.org

      * cvsup3.pt.FreeBSD.org

Romania
      * cvsup.ro.FreeBSD.org

      * cvsup1.ro.FreeBSD.org

      * cvsup2.ro.FreeBSD.org

      * cvsup3.ro.FreeBSD.org

Russia
      * cvsup.ru.FreeBSD.org

      * cvsup2.ru.FreeBSD.org

      * cvsup3.ru.FreeBSD.org

      * cvsup4.ru.FreeBSD.org

      * cvsup5.ru.FreeBSD.org

      * cvsup6.ru.FreeBSD.org

      * cvsup7.ru.FreeBSD.org

San Marino
      * cvsup.sm.FreeBSD.org

Slovak Republic
      * cvsup.sk.FreeBSD.org

Slovenia
      * cvsup.si.FreeBSD.org

      * cvsup2.si.FreeBSD.org

South Africa
      * cvsup.za.FreeBSD.org

      * cvsup2.za.FreeBSD.org

Spain
      * cvsup.es.FreeBSD.org

      * cvsup2.es.FreeBSD.org

      * cvsup3.es.FreeBSD.org

Sweden
      * cvsup.se.FreeBSD.org

      * cvsup2.se.FreeBSD.org

Switzerland
      * cvsup.ch.FreeBSD.org

Taiwan
      * cvsup.tw.FreeBSD.org

      * cvsup3.tw.FreeBSD.org

      * cvsup4.tw.FreeBSD.org

      * cvsup5.tw.FreeBSD.org

      * cvsup6.tw.FreeBSD.org

      * cvsup7.tw.FreeBSD.org

      * cvsup8.tw.FreeBSD.org

      * cvsup9.tw.FreeBSD.org

      * cvsup10.tw.FreeBSD.org

      * cvsup11.tw.FreeBSD.org

      * cvsup12.tw.FreeBSD.org

      * cvsup13.tw.FreeBSD.org

      * cvsup14.tw.FreeBSD.org

Thailand
      * cvsup.th.FreeBSD.org

Turkey
      * cvsup.tr.FreeBSD.org

      * cvsup2.tr.FreeBSD.org

Ukraine
      * cvsup3.ua.FreeBSD.org

      * cvsup5.ua.FreeBSD.org

      * cvsup6.ua.FreeBSD.org

United Kingdom
      * cvsup.uk.FreeBSD.org

      * cvsup2.uk.FreeBSD.org

      * cvsup3.uk.FreeBSD.org

      * cvsup4.uk.FreeBSD.org

USA
      * cvsup1.us.FreeBSD.org

      * cvsup2.us.FreeBSD.org

      * cvsup3.us.FreeBSD.org

      * cvsup4.us.FreeBSD.org

      * cvsup5.us.FreeBSD.org

      * cvsup6.us.FreeBSD.org

      * cvsup7.us.FreeBSD.org

      * cvsup8.us.FreeBSD.org

      * cvsup9.us.FreeBSD.org

      * cvsup10.us.FreeBSD.org

      * cvsup11.us.FreeBSD.org

      * cvsup12.us.FreeBSD.org

      * cvsup13.us.FreeBSD.org

      * cvsup14.us.FreeBSD.org

      * cvsup15.us.FreeBSD.org

      * cvsup16.us.FreeBSD.org

      * cvsup18.us.FreeBSD.org

A.8.Â CVS Tags

Warning:

CVS has been deprecated by the project, and its use is not recommended. 
Subversion should be used instead.

When obtaining or updating sources using cvs or CVSup, a revision tag must be
specified. A revision tag refers to either a particular line of FreeBSD
development, or a specific point in time. The first type are called â  branch
tagsâ  , and the second type are called â  release tagsâ  .

A.8.1.Â Branch Tags

All of these, with the exception of HEAD (which is always a valid tag), only
apply to the src/ tree. The ports/, doc/, and www/ trees are not branched.

HEAD

    Symbolic name for the main line, or FreeBSD-CURRENT. Also the default when
    no revision is specified.

    In CVSup, this tag is represented by a . (not punctuation, but a literal .
    character).

    Note:

    In CVS, this is the default when no revision tag is specified. It is
    usually not a good idea to checkout or update to CURRENT sources on a
    STABLE machine, unless that is your intent.

RELENG_9

    The line of development for FreeBSD-9.X, also known as FreeBSD 9-STABLE

RELENG_9_1

    The release branch for FreeBSD-9.1, used only for security advisories and
    other critical fixes.

RELENG_9_0

    The release branch for FreeBSD-9.0, used only for security advisories and
    other critical fixes.

RELENG_8

    The line of development for FreeBSD-8.X, also known as FreeBSD 8-STABLE

RELENG_8_3

    The release branch for FreeBSD-8.3, used only for security advisories and
    other critical fixes.

RELENG_8_2

    The release branch for FreeBSD-8.2, used only for security advisories and
    other critical fixes.

RELENG_8_1

    The release branch for FreeBSD-8.1, used only for security advisories and
    other critical fixes.

RELENG_8_0

    The release branch for FreeBSD-8.0, used only for security advisories and
    other critical fixes.

RELENG_7

    The line of development for FreeBSD-7.X, also known as FreeBSD 7-STABLE

RELENG_7_4

    The release branch for FreeBSD-7.4, used only for security advisories and
    other critical fixes.

RELENG_7_3

    The release branch for FreeBSD-7.3, used only for security advisories and
    other critical fixes.

RELENG_7_2

    The release branch for FreeBSD-7.2, used only for security advisories and
    other critical fixes.

RELENG_7_1

    The release branch for FreeBSD-7.1, used only for security advisories and
    other critical fixes.

RELENG_7_0

    The release branch for FreeBSD-7.0, used only for security advisories and
    other critical fixes.

RELENG_6

    The line of development for FreeBSD-6.X, also known as FreeBSD 6-STABLE

RELENG_6_4

    The release branch for FreeBSD-6.4, used only for security advisories and
    other critical fixes.

RELENG_6_3

    The release branch for FreeBSD-6.3, used only for security advisories and
    other critical fixes.

RELENG_6_2

    The release branch for FreeBSD-6.2, used only for security advisories and
    other critical fixes.

RELENG_6_1

    The release branch for FreeBSD-6.1, used only for security advisories and
    other critical fixes.

RELENG_6_0

    The release branch for FreeBSD-6.0, used only for security advisories and
    other critical fixes.

RELENG_5

    The line of development for FreeBSD-5.X, also known as FreeBSD 5-STABLE.

RELENG_5_5

    The release branch for FreeBSD-5.5, used only for security advisories and
    other critical fixes.

RELENG_5_4

    The release branch for FreeBSD-5.4, used only for security advisories and
    other critical fixes.

RELENG_5_3

    The release branch for FreeBSD-5.3, used only for security advisories and
    other critical fixes.

RELENG_5_2

    The release branch for FreeBSD-5.2 and FreeBSD-5.2.1, used only for
    security advisories and other critical fixes.

RELENG_5_1

    The release branch for FreeBSD-5.1, used only for security advisories and
    other critical fixes.

RELENG_5_0

    The release branch for FreeBSD-5.0, used only for security advisories and
    other critical fixes.

RELENG_4

    The line of development for FreeBSD-4.X, also known as FreeBSD 4-STABLE.

RELENG_4_11

    The release branch for FreeBSD-4.11, used only for security advisories and
    other critical fixes.

RELENG_4_10

    The release branch for FreeBSD-4.10, used only for security advisories and
    other critical fixes.

RELENG_4_9

    The release branch for FreeBSD-4.9, used only for security advisories and
    other critical fixes.

RELENG_4_8

    The release branch for FreeBSD-4.8, used only for security advisories and
    other critical fixes.

RELENG_4_7

    The release branch for FreeBSD-4.7, used only for security advisories and
    other critical fixes.

RELENG_4_6

    The release branch for FreeBSD-4.6 and FreeBSD-4.6.2, used only for
    security advisories and other critical fixes.

RELENG_4_5

    The release branch for FreeBSD-4.5, used only for security advisories and
    other critical fixes.

RELENG_4_4

    The release branch for FreeBSD-4.4, used only for security advisories and
    other critical fixes.

RELENG_4_3

    The release branch for FreeBSD-4.3, used only for security advisories and
    other critical fixes.

RELENG_3

    The line of development for FreeBSD-3.X, also known as 3.X-STABLE.

RELENG_2_2

    The line of development for FreeBSD-2.2.X, also known as 2.2-STABLE. This
    branch is mostly obsolete.

A.8.2.Â Release Tags

These tags refer to a specific point in time when a particular version of
FreeBSD was released. The release engineering process is documented in more
detail by the Release Engineering Information and Release Process documents.
The src tree uses tag names that start with RELENG_ tags. The ports and doc
trees use tags whose names begin with RELEASE tags. Finally, the www tree is
not tagged with any special name for releases.

RELENG_9_1_0_RELEASE

    FreeBSD 9.1

RELENG_9_0_0_RELEASE

    FreeBSD 9.0

RELENG_8_3_0_RELEASE

    FreeBSD 8.3

RELENG_8_2_0_RELEASE

    FreeBSD 8.2

RELENG_8_1_0_RELEASE

    FreeBSD 8.1

RELENG_8_0_0_RELEASE

    FreeBSD 8.0

RELENG_7_4_0_RELEASE

    FreeBSD 7.4

RELENG_7_3_0_RELEASE

    FreeBSD 7.3

RELENG_7_2_0_RELEASE

    FreeBSD 7.2

RELENG_7_1_0_RELEASE

    FreeBSD 7.1

RELENG_7_0_0_RELEASE

    FreeBSD 7.0

RELENG_6_4_0_RELEASE

    FreeBSD 6.4

RELENG_6_3_0_RELEASE

    FreeBSD 6.3

RELENG_6_2_0_RELEASE

    FreeBSD 6.2

RELENG_6_1_0_RELEASE

    FreeBSD 6.1

RELENG_6_0_0_RELEASE

    FreeBSD 6.0

RELENG_5_5_0_RELEASE

    FreeBSD 5.5

RELENG_5_4_0_RELEASE

    FreeBSD 5.4

RELENG_4_11_0_RELEASE

    FreeBSD 4.11

RELENG_5_3_0_RELEASE

    FreeBSD 5.3

RELENG_4_10_0_RELEASE

    FreeBSD 4.10

RELENG_5_2_1_RELEASE

    FreeBSD 5.2.1

RELENG_5_2_0_RELEASE

    FreeBSD 5.2

RELENG_4_9_0_RELEASE

    FreeBSD 4.9

RELENG_5_1_0_RELEASE

    FreeBSD 5.1

RELENG_4_8_0_RELEASE

    FreeBSD 4.8

RELENG_5_0_0_RELEASE

    FreeBSD 5.0

RELENG_4_7_0_RELEASE

    FreeBSD 4.7

RELENG_4_6_2_RELEASE

    FreeBSD 4.6.2

RELENG_4_6_1_RELEASE

    FreeBSD 4.6.1

RELENG_4_6_0_RELEASE

    FreeBSD 4.6

RELENG_4_5_0_RELEASE

    FreeBSD 4.5

RELENG_4_4_0_RELEASE

    FreeBSD 4.4

RELENG_4_3_0_RELEASE

    FreeBSD 4.3

RELENG_4_2_0_RELEASE

    FreeBSD 4.2

RELENG_4_1_1_RELEASE

    FreeBSD 4.1.1

RELENG_4_1_0_RELEASE

    FreeBSD 4.1

RELENG_4_0_0_RELEASE

    FreeBSD 4.0

RELENG_3_5_0_RELEASE

    FreeBSD-3.5

RELENG_3_4_0_RELEASE

    FreeBSD-3.4

RELENG_3_3_0_RELEASE

    FreeBSD-3.3

RELENG_3_2_0_RELEASE

    FreeBSD-3.2

RELENG_3_1_0_RELEASE

    FreeBSD-3.1

RELENG_3_0_0_RELEASE

    FreeBSD-3.0

RELENG_2_2_8_RELEASE

    FreeBSD-2.2.8

RELENG_2_2_7_RELEASE

    FreeBSD-2.2.7

RELENG_2_2_6_RELEASE

    FreeBSD-2.2.6

RELENG_2_2_5_RELEASE

    FreeBSD-2.2.5

RELENG_2_2_2_RELEASE

    FreeBSD-2.2.2

RELENG_2_2_1_RELEASE

    FreeBSD-2.2.1

RELENG_2_2_0_RELEASE

    FreeBSD-2.2.0

A.9.Â rsync Sites

The following sites make FreeBSD available through the rsync protocol. The 
rsync utility works in much the same way as the rcp(1) command, but has more
options and uses the rsync remote-update protocol which transfers only the
differences between two sets of files, thus greatly speeding up the
synchronization over the network. This is most useful if you are a mirror site
for the FreeBSD FTP server, or the CVS repository. The rsync suite is available
for many operating systems, on FreeBSD, see the net/rsync port or use the
package.

Czech Republic

    rsync://ftp.cz.FreeBSD.org/

    Available collections:

      * ftp: A partial mirror of the FreeBSD FTP server.

      * FreeBSD: A full mirror of the FreeBSD FTP server.

Netherlands

    rsync://ftp.nl.FreeBSD.org/

    Available collections:

      * FreeBSD: A full mirror of the FreeBSD FTP server.

Russia

    rsync://ftp.mtu.ru/

    Available collections:

      * FreeBSD: A full mirror of the FreeBSD FTP server.

      * FreeBSD-gnats: The GNATS bug-tracking database.

      * FreeBSD-Archive: The mirror of FreeBSD Archive FTP server.

Sweden

    rsync://ftp4.se.freebsd.org/

    Available collections:

      * FreeBSD: A full mirror of the FreeBSD FTP server.

Taiwan

    rsync://ftp.tw.FreeBSD.org/

    rsync://ftp2.tw.FreeBSD.org/

    rsync://ftp6.tw.FreeBSD.org/

    Available collections:

      * FreeBSD: A full mirror of the FreeBSD FTP server.

United Kingdom

    rsync://rsync.mirrorservice.org/

    Available collections:

      * ftp.freebsd.org: A full mirror of the FreeBSD FTP server.

United States of America

    rsync://ftp-master.FreeBSD.org/

    This server may only be used by FreeBSD primary mirror sites.

    Available collections:

      * FreeBSD: The master archive of the FreeBSD FTP server.

      * acl: The FreeBSD master ACL list.

    rsync://ftp13.FreeBSD.org/

    Available collections:

      * FreeBSD: A full mirror of the FreeBSD FTP server.

AppendixÂ B.Â Bibliography

Table of Contents

B.1. Books & Magazines Specific to FreeBSD
B.2. Users' Guides
B.3. Administrators' Guides
B.4. Programmers' Guides
B.5. Operating System Internals
B.6. Security Reference
B.7. Hardware Reference
B.8. UNIXÂ® History
B.9. Magazines and Journals

While the manual pages provide the definitive reference for individual pieces
of the FreeBSD operating system, they are notorious for not illustrating how to
put the pieces together to make the whole operating system run smoothly. For
this, there is no substitute for a good book on UNIXÂ® system administration
and a good users' manual.

B.1.Â Books & Magazines Specific to FreeBSD

International books & Magazines:

  * Using FreeBSD (in Traditional Chinese), published by Drmaster, 1997. ISBN
    9-578-39435-7.

  * FreeBSD Unleashed (Simplified Chinese translation), published by China
    Machine Press. ISBN 7-111-10201-0.

  * FreeBSD From Scratch Second Edition (in Simplified Chinese), published by
    China Machine Press. ISBN 7-111-10286-X.

  * FreeBSD Handbook Second Edition (Simplified Chinese translation), published
    by Posts & Telecom Press. ISBN 7-115-10541-3.

  * FreeBSD & Windows (in Simplified Chinese), published by China Railway
    Publishing House. ISBN 7-113-03845-X

  * FreeBSD Internet Services HOWTO (in Simplified Chinese), published by China
    Railway Publishing House. ISBN 7-113-03423-3

  * FreeBSD (in Japanese), published by CUTT. ISBN 4-906391-22-2 C3055 P2400E.

  * Complete Introduction to FreeBSD (in Japanese), published by Shoeisha Co.,
    Ltd. ISBN 4-88135-473-6 P3600E.

  * Personal UNIX Starter Kit FreeBSD (in Japanese), published by ASCII. ISBN
    4-7561-1733-3 P3000E.

  * FreeBSD Handbook (Japanese translation), published by ASCII. ISBN
    4-7561-1580-2 P3800E.

  * FreeBSD mit Methode (in German), published by Computer und Literatur Verlag
    /Vertrieb Hanser, 1998. ISBN 3-932311-31-0.

  * FreeBSD de Luxe (in German), published by Verlag Modere Industrie, 2003.
    ISBN 3-8266-1343-0.

  * FreeBSD Install and Utilization Manual (in Japanese), published by Mainichi
    Communications Inc., 1998. ISBN 4-8399-0112-0.

  * Onno W Purbo, Dodi Maryanto, Syahrial Hubbany, Widjil Widodo Building
    Internet Server with FreeBSD (in Indonesia Language), published by Elex
    Media Komputindo.

  * Absolute BSD: The Ultimate Guide to FreeBSD (Traditional Chinese
    translation), published by GrandTech Press, 2003. ISBN 986-7944-92-5.

  * The FreeBSD 6.0 Book (in Traditional Chinese), published by Drmaster, 2006.
    ISBN 9-575-27878-X.

English language books & Magazines:

  * Absolute FreeBSD, 2nd Edition: The Complete Guide to FreeBSD, published by
    No Starch Press, 2007. ISBN: 978-1-59327-151-0

  * The Complete FreeBSD, published by O'Reilly, 2003. ISBN: 0596005164

  * The FreeBSD Corporate Networker's Guide, published by Addison-Wesley, 2000.
    ISBN: 0201704811

  * FreeBSD: An Open-Source Operating System for Your Personal Computer,
    published by The Bit Tree Press, 2001. ISBN: 0971204500

  * Teach Yourself FreeBSD in 24 Hours, published by Sams, 2002. ISBN:
    0672324245

  * FreeBSD 6 Unleashed, published by Sams, 2006. ISBN: 0672328755

  * FreeBSD: The Complete Reference, published by McGrawHill, 2003. ISBN:
    0072224096

  * BSD Magazine, published by Software Press Sp. z o.o. SK. ISSN 1898-9144

B.2.Â Users' Guides

  * Ohio State University has written a UNIX Introductory Course which is
    available online in HTML and PostScript format.

    An Italian translation of this document is available as part of the FreeBSD
    Italian Documentation Project.

  * Jpman Project, Japan FreeBSD Users Group. FreeBSD User's Reference Manual
    (Japanese translation). Mainichi Communications Inc., 1998.
    ISBN4-8399-0088-4 P3800E.

  * Edinburgh University has written an Online Guide for newcomers to the UNIX
    environment.

B.3.Â Administrators' Guides

  * Jpman Project, Japan FreeBSD Users Group. FreeBSD System Administrator's
    Manual (Japanese translation). Mainichi Communications Inc., 1998.
    ISBN4-8399-0109-0 P3300E.

  * Dreyfus, Emmanuel. Cahiers de l'Admin: BSD 2nd Ed. (in French), Eyrolles,
    2004. ISBN 2-212-11463-X

B.4.Â Programmers' Guides

  * Computer Systems Research Group, UC Berkeley. 4.4BSD Programmer's Reference
    Manual. O'Reilly & Associates, Inc., 1994. ISBN 1-56592-078-3

  * Computer Systems Research Group, UC Berkeley. 4.4BSD Programmer's
    Supplementary Documents. O'Reilly & Associates, Inc., 1994. ISBN
    1-56592-079-1

  * Harbison, Samuel P. and Steele, Guy L. Jr. C: A Reference Manual. 4th ed.
    Prentice Hall, 1995. ISBN 0-13-326224-3

  * Kernighan, Brian and Dennis M. Ritchie. The C Programming Language. 2nd Ed.
    PTR Prentice Hall, 1988. ISBN 0-13-110362-8

  * Lehey, Greg. Porting UNIX Software. O'Reilly & Associates, Inc., 1995. ISBN
    1-56592-126-7

  * Plauger, P. J. The Standard C Library. Prentice Hall, 1992. ISBN
    0-13-131509-9

  * Spinellis, Diomidis. Code Reading: The Open Source Perspective.
    Addison-Wesley, 2003. ISBN 0-201-79940-5

  * Spinellis, Diomidis. Code Quality: The Open Source Perspective.
    Addison-Wesley, 2006. ISBN 0-321-16607-8

  * Stevens, W. Richard and Stephen A. Rago. Advanced Programming in the UNIX
    Environment. 2nd Ed. Reading, Mass. : Addison-Wesley, 2005. ISBN
    0-201-43307-9

  * Stevens, W. Richard. UNIX Network Programming. 2nd Ed, PTR Prentice Hall,
    1998. ISBN 0-13-490012-X

B.5.Â Operating System Internals

  * Andleigh, Prabhat K. UNIX System Architecture. Prentice-Hall, Inc., 1990.
    ISBN 0-13-949843-5

  * Jolitz, William. â  Porting UNIX to the 386â  . Dr. Dobb's Journal. January
    1991-July 1992.

  * Leffler, Samuel J., Marshall Kirk McKusick, Michael J Karels and John
    Quarterman The Design and Implementation of the 4.3BSD UNIX Operating
    System. Reading, Mass. : Addison-Wesley, 1989. ISBN 0-201-06196-1

  * Leffler, Samuel J., Marshall Kirk McKusick, The Design and Implementation
    of the 4.3BSD UNIX Operating System: Answer Book. Reading, Mass. :
    Addison-Wesley, 1991. ISBN 0-201-54629-9

  * McKusick, Marshall Kirk, Keith Bostic, Michael J Karels, and John
    Quarterman. The Design and Implementation of the 4.4BSD Operating System.
    Reading, Mass. : Addison-Wesley, 1996. ISBN 0-201-54979-4

    (Chapter 2 of this book is available online as part of the FreeBSD
    Documentation Project.)

  * Marshall Kirk McKusick, George V. Neville-Neil The Design and
    Implementation of the FreeBSD Operating System. Boston, Mass. :
    Addison-Wesley, 2004. ISBN 0-201-70245-2

  * Stevens, W. Richard. TCP/IP Illustrated, Volume 1: The Protocols. Reading,
    Mass. : Addison-Wesley, 1996. ISBN 0-201-63346-9

  * Schimmel, Curt. Unix Systems for Modern Architectures. Reading, Mass. :
    Addison-Wesley, 1994. ISBN 0-201-63338-8

  * Stevens, W. Richard. TCP/IP Illustrated, Volume 3: TCP for Transactions,
    HTTP, NNTP and the UNIX Domain Protocols. Reading, Mass. : Addison-Wesley,
    1996. ISBN 0-201-63495-3

  * Vahalia, Uresh. UNIX Internals -- The New Frontiers. Prentice Hall, 1996.
    ISBN 0-13-101908-2

  * Wright, Gary R. and W. Richard Stevens. TCP/IP Illustrated, Volume 2: The
    Implementation. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-63354-X

B.6.Â Security Reference

  * Cheswick, William R. and Steven M. Bellovin. Firewalls and Internet
    Security: Repelling the Wily Hacker. Reading, Mass. : Addison-Wesley, 1995.
    ISBN 0-201-63357-4

  * Garfinkel, Simson. PGP Pretty Good Privacy O'Reilly & Associates, Inc.,
    1995. ISBN 1-56592-098-8

B.7.Â Hardware Reference

  * Anderson, Don and Tom Shanley. Pentium Processor System Architecture. 2nd
    Ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-40992-5

  * Ferraro, Richard F. Programmer's Guide to the EGA, VGA, and Super VGA Cards
    . 3rd ed. Reading, Mass. : Addison-Wesley, 1995. ISBN 0-201-62490-7

  * Intel Corporation publishes documentation on their CPUs, chipsets and
    standards on their developer web site, usually as PDF files.

  * Shanley, Tom. 80486 System Architecture. 3rd ed. Reading, Mass. :
    Addison-Wesley, 1995. ISBN 0-201-40994-1

  * Shanley, Tom. ISA System Architecture. 3rd ed. Reading, Mass. :
    Addison-Wesley, 1995. ISBN 0-201-40996-8

  * Shanley, Tom. PCI System Architecture. 4th ed. Reading, Mass. :
    Addison-Wesley, 1999. ISBN 0-201-30974-2

  * Van Gilluwe, Frank. The Undocumented PC, 2nd Ed. Reading, Mass:
    Addison-Wesley Pub. Co., 1996. ISBN 0-201-47950-8

  * Messmer, Hans-Peter. The Indispensable PC Hardware Book, 4th Ed. Reading,
    Mass : Addison-Wesley Pub. Co., 2002. ISBN 0-201-59616-4

B.8.Â UNIXÂ® History

  * Lion, John Lion's Commentary on UNIX, 6th Ed. With Source Code. ITP Media
    Group, 1996. ISBN 1573980137

  * Raymond, Eric S. The New Hacker's Dictionary, 3rd edition. MIT Press, 1996.
    ISBN 0-262-68092-0. Also known as the Jargon File

  * Salus, Peter H. A quarter century of UNIX. Addison-Wesley Publishing
    Company, Inc., 1994. ISBN 0-201-54777-5

  * Simon Garfinkel, Daniel Weise, Steven Strassmann. The UNIX-HATERS Handbook.
    IDG Books Worldwide, Inc., 1994. ISBN 1-56884-203-1. Out of print, but
    available online.

  * Don Libes, Sandy Ressler Life with UNIX â   special edition. Prentice-Hall,
    Inc., 1989. ISBN 0-13-536657-7

  * The BSD family tree. http://www.FreeBSD.org/cgi/cvsweb.cgi/src/share/misc/
    bsd-family-tree or /usr/share/misc/bsd-family-tree on a FreeBSD machine.

  * Networked Computer Science Technical Reports Library. http://www.ncstrl.org
    /

  * Old BSD releases from the Computer Systems Research group (CSRG). http://
    www.mckusick.com/csrg/: The 4CD set covers all BSD versions from 1BSD to
    4.4BSD and 4.4BSD-Lite2 (but not 2.11BSD, unfortunately). The last disk
    also holds the final sources plus the SCCS files.

B.9.Â Magazines and Journals

  * The C/C++ Users Journal. R&D Publications Inc. ISSN 1075-2838

  * Sys Admin â   The Journal for UNIX System Administrators Miller Freeman,
    Inc., ISSN 1061-2688

  * freeX â   Das Magazin fÃŒr Linux - BSD - UNIX (in German) Computer- und
    Literaturverlag GmbH, ISSN 1436-7033

AppendixÂ C.Â Resources on the Internet

Table of Contents

C.1. Mailing Lists
C.2. Usenet Newsgroups
C.3. World Wide Web Servers
C.4. Email Addresses

The rapid pace of FreeBSD progress makes print media impractical as a means of
following the latest developments. Electronic resources are the best, if not
often the only, way to stay informed of the latest advances. Since FreeBSD is a
volunteer effort, the user community itself also generally serves as a â  
technical support departmentâ   of sorts, with electronic mail, web forums, and
USENET news being the most effective way of reaching that community.

The most important points of contact with the FreeBSD user community are
outlined below. If you are aware of other resources not mentioned here, please
send them to the FreeBSD documentation project mailing list so that they may
also be included.

C.1.Â Mailing Lists

The mailing lists are the most direct way of addressing questions or opening a
technical discussion to a concentrated FreeBSD audience. There are a wide
variety of lists on a number of different FreeBSD topics. Addressing your
questions to the most appropriate mailing list will invariably assure a faster
and more accurate response.

The charters for the various lists are given at the bottom of this document. 
Please read the charter before joining or sending mail to any list. Most of our
list subscribers now receive many hundreds of FreeBSD related messages every
day, and by setting down charters and rules for proper use we are striving to
keep the signal-to-noise ratio of the lists high. To do less would see the
mailing lists ultimately fail as an effective communications medium for the
project.

Note:

If you wish to test your ability to send to FreeBSD lists, send a test message
to freebsd-test. Please do not send test messages to any other list.

When in doubt about what list to post a question to, see How to get best
results from the FreeBSD-questions mailing list.

Before posting to any list, please learn about how to best use the mailing
lists, such as how to help avoid frequently-repeated discussions, by reading
the Mailing List Frequently Asked Questions (FAQ) document.

Archives are kept for all of the mailing lists and can be searched using the
FreeBSD World Wide Web server. The keyword searchable archive offers an
excellent way of finding answers to frequently asked questions and should be
consulted before posting a question. Note that this also means that messages
sent to FreeBSD mailing lists are archived in perpetuity. When protecting
privacy is a concern, consider using a disposable secondary email address and
posting only public information.

C.1.1.Â List Summary

General lists: The following are general lists which anyone is free (and
encouraged) to join:

             List                                  Purpose
freebsd-advocacy               FreeBSD Evangelism
freebsd-announce               Important events and project milestones
                               (moderated)
freebsd-arch                   Architecture and design discussions
                               Discussions pertaining to the maintenance of the
freebsd-bugbusters             FreeBSD problem report database and related
                               tools
freebsd-bugs                   Bug reports
freebsd-chat                   Non-technical items related to the FreeBSD
                               community
freebsd-chromium               FreeBSD-specific Chromium issues
freebsd-current                Discussion concerning the use of FreeBSD-CURRENT
freebsd-isp                    Issues for Internet Service Providers using
                               FreeBSD
freebsd-jobs                   FreeBSD employment and consulting opportunities
freebsd-questions              User questions and technical support
freebsd-security-notifications Security notifications (moderated)
freebsd-stable                 Discussion concerning the use of FreeBSD-STABLE
freebsd-test                   Where to send your test messages instead of one
                               of the actual lists

Technical lists: The following lists are for technical discussion. You should
read the charter for each list carefully before joining or sending mail to one
as there are firm guidelines for their use and content.

         List                                  Purpose
freebsd-acpi           ACPI and power management development
freebsd-afs            Porting AFS to FreeBSD
freebsd-aic7xxx        Developing drivers for the AdaptecÂ® AIC 7xxx
freebsd-amd64          Porting FreeBSD to AMD64 systems (moderated)
freebsd-apache         Discussion about Apache related ports
freebsd-arm            Porting FreeBSD to ARMÂ® processors
freebsd-atm            Using ATM networking with FreeBSD
freebsd-bluetooth      Using BluetoothÂ® technology in FreeBSD
freebsd-cluster        Using FreeBSD in a clustered environment
freebsd-cvsweb         CVSweb maintenance
freebsd-database       Discussing database use and development under FreeBSD
freebsd-desktop        Using and improving FreeBSD on the desktop
freebsd-doc            Creating FreeBSD related documents
freebsd-drivers        Writing device drivers for FreeBSD
freebsd-dtrace         Using and working on DTrace in FreeBSD
freebsd-eclipse        FreeBSD users of Eclipse IDE, tools, rich client
                       applications and ports.
freebsd-embedded       Using FreeBSD in embedded applications
freebsd-eol            Peer support of FreeBSD-related software that is no
                       longer supported by the FreeBSD project.
freebsd-emulation      Emulation of other systems such as Linux/MS-DOSÂ®/
                       WindowsÂ®
freebsd-firewire       FreeBSD FireWireÂ® (iLink, IEEE 1394) technical
                       discussion
freebsd-fs             File systems
freebsd-gecko          Gecko Rendering Engine issues
freebsd-geom           GEOM-specific discussions and implementations
freebsd-gnome          Porting GNOME and GNOME applications
freebsd-hackers        General technical discussion
freebsd-hardware       General discussion of hardware for running FreeBSD
freebsd-i18n           FreeBSD Internationalization
freebsd-ia32           FreeBSD on the IA-32 (IntelÂ® x86) platform
freebsd-ia64           Porting FreeBSD to IntelÂ®'s upcoming IA64 systems
freebsd-infiniband     Infiniband on FreeBSD
freebsd-ipfw           Technical discussion concerning the redesign of the IP
                       firewall code
freebsd-isdn           ISDN developers
freebsd-jail           Discussion about the jail(8) facility
freebsd-java           Javaâ ¢ developers and people porting JDKâ ¢s to FreeBSD
freebsd-kde            Porting KDE and KDE applications
freebsd-lfs            Porting LFS to FreeBSD
freebsd-mips           Porting FreeBSD to MIPSÂ®
freebsd-mobile         Discussions about mobile computing
freebsd-mono           Mono and C# applications on FreeBSD
freebsd-mozilla        Porting Mozilla to FreeBSD
freebsd-multimedia     Multimedia applications
freebsd-new-bus        Technical discussions about bus architecture
freebsd-net            Networking discussion and TCP/IP source code
freebsd-numerics       Discussions of high quality implementation of libm
                       functions
freebsd-office         Office applications on FreeBSD
freebsd-performance    Performance tuning questions for high performance/load
                       installations
freebsd-perl           Maintenance of a number of Perl-related ports
freebsd-pf             Discussion and questions about the packet filter
                       firewall system
freebsd-platforms      Concerning ports to non IntelÂ® architecture platforms
freebsd-ports          Discussion of the Ports Collection
freebsd-ports-announce Important news and instructions about the Ports
                       Collection (moderated)
freebsd-ports-bugs     Discussion of the ports bugs/PRs
freebsd-ppc            Porting FreeBSD to the PowerPCÂ®
freebsd-proliant       Technical discussion of FreeBSD on HP ProLiant server
                       platforms
freebsd-python         FreeBSD-specific Python issues
freebsd-rc             Discussion related to the rc.d system and its
                       development
freebsd-realtime       Development of realtime extensions to FreeBSD
freebsd-ruby           FreeBSD-specific Ruby discussions
freebsd-scsi           The SCSI subsystem
freebsd-security       Security issues affecting FreeBSD
freebsd-small          Using FreeBSD in embedded applications (obsolete; use
                       freebsd-embedded instead)
freebsd-snapshots      FreeBSD Development Snapshot Announcements
freebsd-sparc64        Porting FreeBSD to SPARCÂ® based systems
freebsd-standards      FreeBSD's conformance to the C99 and the POSIXÂ®
                       standards
freebsd-sysinstall     sysinstall(8) development
freebsd-tcltk          FreeBSD-specific Tcl/Tk discussions
freebsd-testing        Testing on FreeBSD
freebsd-tex            Porting TeX and its applications to FreeBSD
freebsd-threads        Threading in FreeBSD
freebsd-tilera         Porting FreeBSD to the Tilera family of CPUs
freebsd-tokenring      Support Token Ring in FreeBSD
freebsd-toolchain      Maintenance of FreeBSD's integrated toolchain
freebsd-usb            Discussing FreeBSD support for USB
freebsd-virtualization Discussion of various virtualization techniques
                       supported by FreeBSD
freebsd-vuxml          Discussion on VuXML infrastructure
freebsd-x11            Maintenance and support of X11 on FreeBSD
freebsd-xen            Discussion of the FreeBSD port to Xenâ ¢ â  
                       implementation and usage
freebsd-xfce           XFCE for FreeBSD â   porting and maintaining
freebsd-zope           Zope for FreeBSD â   porting and maintaining

Limited lists: The following lists are for more specialized (and demanding)
audiences and are probably not of interest to the general public. It is also a
good idea to establish a presence in the technical lists before joining one of
these limited lists so that you will understand the communications etiquette
involved.

       List                                   Purpose
freebsd-hubs        People running mirror sites (infrastructural support)
freebsd-user-groups User group coordination
freebsd-wip-status  FreeBSD Work-In-Progress Status
freebsd-wireless    Discussions of 802.11 stack, tools, device driver
                    development

Digest lists: All of the above lists are available in a digest format. Once
subscribed to a list, you can change your digest options in your account
options section.

SVN lists: The following lists are for people interested in seeing the log
messages for changes to various areas of the source tree. They are Read-Only
lists and should not have mail sent to them.

        List          Source            Area Description (source for)
                       area
svn-doc-all          /usr/doc All changes to the doc Subversion repository
                              (except for user, projects and translations)
svn-doc-head         /usr/doc All changes to the â  headâ   branch of the doc
                              Subversion repository
                     /usr/doc All changes to the projects area of the doc
svn-doc-projects     /        Subversion repository
                     projects
                              All changes to the administrative scripts, hooks,
svn-doc-svnadmin     /usr/doc and other configuration data of the doc
                              Subversion repository
svn-ports-all        /usr/    All changes to the ports Subversion repository
                     ports
svn-ports-head       /usr/    All changes to the â  headâ   branch of the ports
                     ports    Subversion repository
                     /usr/    All changes to the administrative scripts, hooks,
svn-ports-svnadmin   ports    and other configuration data of the ports
                              Subversion repository
svn-src-all          /usr/src All changes to the src Subversion repository
                              (except for user and projects)
                              All changes to the â  headâ   branch of the src
svn-src-head         /usr/src Subversion repository (the FreeBSD-CURRENT
                              branch)
svn-src-projects     /usr/    All changes to the projects area of the src
                     projects Subversion repository
svn-src-release      /usr/src All changes to the releases area of the src
                              Subversion repository
                              All changes to the releng branches of the src
svn-src-releng       /usr/src Subversion repository (the securityÂ / release
                              engineering branches)
svn-src-stable       /usr/src All changes to the all stable branches of the src
                              Subversion repository
svn-src-stable-6     /usr/src All changes to the stable/6 branch of the src
                              Subversion repository
svn-src-stable-7     /usr/src All changes to the stable/7 branch of the src
                              Subversion repository
svn-src-stable-8     /usr/src All changes to the stable/8 branch of the src
                              Subversion repository
svn-src-stable-9     /usr/src All changes to the stable/9 branch of the src
                              Subversion repository
svn-src-stable-other /usr/src All changes to the older stable branches of the
                              src Subversion repository
                              All changes to the administrative scripts, hooks,
svn-src-svnadmin     /usr/src and other configuration data of the src
                              Subversion repository
svn-src-user         /usr/src All changes to the experimental user area of the
                              src Subversion repository
svn-src-vendor       /usr/src All changes to the vendor work area of the src
                              Subversion repository

C.1.2.Â How to Subscribe

To subscribe to a list, click on the list name above or go to http://
lists.FreeBSD.org/mailman/listinfo and click on the list that you are
interested in. The list page should contain all of the necessary subscription
instructions.

To actually post to a given list, send mail to &lt;listname@FreeBSD.org&gt;. It will
then be redistributed to mailing list members world-wide.

To unsubscribe yourself from a list, click on the URL found at the bottom of
every email received from the list. It is also possible to send an email to &lt;
listname-unsubscribe@FreeBSD.org&gt; to unsubscribe yourself.

Again, we would like to request that you keep discussion in the technical
mailing lists on a technical track. If you are only interested in important
announcements then it is suggested that you join the FreeBSD announcements
mailing list, which is intended only for infrequent traffic.

C.1.3.Â List Charters

All FreeBSD mailing lists have certain basic rules which must be adhered to by
anyone using them. Failure to comply with these guidelines will result in two
(2) written warnings from the FreeBSD Postmaster &lt;postmaster@FreeBSD.org&gt;,
after which, on a third offense, the poster will removed from all FreeBSD
mailing lists and filtered from further posting to them. We regret that such
rules and measures are necessary at all, but today's Internet is a pretty harsh
environment, it would seem, and many fail to appreciate just how fragile some
of its mechanisms are.

Rules of the road:

  * The topic of any posting should adhere to the basic charter of the list it
    is posted to, e.g., if the list is about technical issues then your posting
    should contain technical discussion. Ongoing irrelevant chatter or flaming
    only detracts from the value of the mailing list for everyone on it and
    will not be tolerated. For free-form discussion on no particular topic, the
    FreeBSD chat mailing list is freely available and should be used instead.

  * No posting should be made to more than 2 mailing lists, and only to 2 when
    a clear and obvious need to post to both lists exists. For most lists,
    there is already a great deal of subscriber overlap and except for the most
    esoteric mixes (say â  -stable & -scsiâ  ), there really is no reason to
    post to more than one list at a time. If a message is sent to you in such a
    way that multiple mailing lists appear on the Cc line then the Cc line
    should also be trimmed before sending it out again. You are still
    responsible for your own cross-postings, no matter who the originator might
    have been.

  * Personal attacks and profanity (in the context of an argument) are not
    allowed, and that includes users and developers alike. Gross breaches of
    netiquette, like excerpting or reposting private mail when permission to do
    so was not and would not be forthcoming, are frowned upon but not
    specifically enforced. However, there are also very few cases where such
    content would fit within the charter of a list and it would therefore
    probably rate a warning (or ban) on that basis alone.

  * Advertising of non-FreeBSD related products or services is strictly
    prohibited and will result in an immediate ban if it is clear that the
    offender is advertising by spam.

Individual list charters:

freebsd-acpi

    ACPI and power management development

freebsd-afs

    Andrew File System

    This list is for discussion on porting and using AFS from CMU/Transarc

freebsd-announce

    Important events / milestones

    This is the mailing list for people interested only in occasional
    announcements of significant FreeBSD events. This includes announcements
    about snapshots and other releases. It contains announcements of new
    FreeBSD capabilities. It may contain calls for volunteers etc. This is a
    low volume, strictly moderated mailing list.

freebsd-arch

    Architecture and design discussions

    This list is for discussion of the FreeBSD architecture. Messages will
    mostly be kept strictly technical in nature. Examples of suitable topics
    are:

      * How to re-vamp the build system to have several customized builds
        running at the same time.

      * What needs to be fixed with VFS to make Heidemann layers work.

      * How do we change the device driver interface to be able to use the same
        drivers cleanly on many buses and architectures.

      * How to write a network driver.

freebsd-bluetooth

    BluetoothÂ® in FreeBSD

    This is the forum where FreeBSD's BluetoothÂ® users congregate. Design
    issues, implementation details, patches, bug reports, status reports,
    feature requests, and all matters related to BluetoothÂ® are fair game.

freebsd-bugbusters

    Coordination of the Problem Report handling effort

    The purpose of this list is to serve as a coordination and discussion forum
    for the Bugmeister, his Bugbusters, and any other parties who have a
    genuine interest in the PR database. This list is not for discussions about
    specific bugs, patches or PRs.

freebsd-bugs

    Bug reports

    This is the mailing list for reporting bugs in FreeBSD. Whenever possible,
    bugs should be submitted using the send-pr(1) command or the WEB interface
    to it.

freebsd-chat

    Non technical items related to the FreeBSD community

    This list contains the overflow from the other lists about non-technical,
    social information. It includes discussion about whether Jordan looks like
    a toon ferret or not, whether or not to type in capitals, who is drinking
    too much coffee, where the best beer is brewed, who is brewing beer in
    their basement, and so on. Occasional announcements of important events
    (such as upcoming parties, weddings, births, new jobs, etc) can be made to
    the technical lists, but the follow ups should be directed to this -chat
    list.

freebsd-chromium

    FreeBSD-specific Chromium issues

    This is a list for the discussion of Chromium support for FreeBSD. This is
    a technical list to discuss development and installation of Chromium.

freebsd-core

    FreeBSD core team

    This is an internal mailing list for use by the core members. Messages can
    be sent to it when a serious FreeBSD-related matter requires arbitration or
    high-level scrutiny.

freebsd-current

    Discussions about the use of FreeBSD-CURRENT

    This is the mailing list for users of FreeBSD-CURRENT. It includes warnings
    about new features coming out in -CURRENT that will affect the users, and
    instructions on steps that must be taken to remain -CURRENT. Anyone running
    â  CURRENTâ   must subscribe to this list. This is a technical mailing list
    for which strictly technical content is expected.

freebsd-cvsweb

    FreeBSD CVSweb Project

    Technical discussions about use, development and maintenance of
    FreeBSD-CVSweb.

freebsd-desktop

    Using and improving FreeBSD on the desktop

    This is a forum for discussion of FreeBSD on the desktop. It is primarily a
    place for desktop porters and users to discuss issues and improve FreeBSD's
    desktop support.

freebsd-doc

    Documentation project

    This mailing list is for the discussion of issues and projects related to
    the creation of documentation for FreeBSD. The members of this mailing list
    are collectively referred to as â  The FreeBSD Documentation Projectâ  . It
    is an open list; feel free to join and contribute!

freebsd-drivers

    Writing device drivers for FreeBSD

    This is a forum for technical discussions related to device drivers on
    FreeBSD. It is primarily a place for device driver writers to ask questions
    about how to write device drivers using the APIs in the FreeBSD kernel.

freebsd-dtrace

    Using and working on DTrace in FreeBSD

    DTrace is an integrated component of FreeBSD that provides a framework for
    understanding the kernel as well as user space programs at run time. The
    mailing list is an archived discussion for developers of the code as well
    as those using it.

freebsd-eclipse

    FreeBSD users of Eclipse IDE, tools, rich client applications and ports.

    The intention of this list is to provide mutual support for everything to
    do with choosing, installing, using, developing and maintaining the Eclipse
    IDE, tools, rich client applications on the FreeBSD platform and assisting
    with the porting of Eclipse IDE and plugins to the FreeBSD environment.

    The intention is also to facilitate exchange of information between the
    Eclipse community and the FreeBSD community to the mutual benefit of both.

    Although this list is focused primarily on the needs of Eclipse users it
    will also provide a forum for those who would like to develop FreeBSD
    specific applications using the Eclipse framework.

freebsd-embedded

    Using FreeBSD in embedded applications

    This list discusses topics related to using FreeBSD in embedded systems.
    This is a technical mailing list for which strictly technical content is
    expected. For the purpose of this list we define embedded systems as those
    computing devices which are not desktops and which usually serve a single
    purpose as opposed to being general computing environments. Examples
    include, but are not limited to, all kinds of phone handsets, network
    equipment such as routers, switches and PBXs, remote measuring equipment,
    PDAs, Point Of Sale systems, and so on.

freebsd-emulation

    Emulation of other systems such as Linux/MS-DOSÂ®/WindowsÂ®

    This is a forum for technical discussions related to running programs
    written for other operating systems on FreeBSD.

freebsd-eol

    Peer support of FreeBSD-related software that is no longer supported by the
    FreeBSD project.

    This list is for those interested in providing or making use of peer
    support of FreeBSD-related software for which the FreeBSD project no longer
    provides official support (e.g., in the form of security advisories and
    patches).

freebsd-firewire

    FireWireÂ® (iLink, IEEE 1394)

    This is a mailing list for discussion of the design and implementation of a
    FireWireÂ® (aka IEEE 1394 aka iLink) subsystem for FreeBSD. Relevant topics
    specifically include the standards, bus devices and their protocols,
    adapter boards/cards/chips sets, and the architecture and implementation of
    code for their proper support.

freebsd-fs

    File systems

    Discussions concerning FreeBSD file systems. This is a technical mailing
    list for which strictly technical content is expected.

freebsd-gecko

    Gecko Rendering Engine

    This is a forum about Gecko applications using FreeBSD.

    Discussion centers around Gecko Ports applications, their installation,
    their development and their support within FreeBSD.

freebsd-geom

    GEOM

    Discussions specific to GEOM and related implementations. This is a
    technical mailing list for which strictly technical content is expected.

freebsd-gnome

    GNOME

    Discussions concerning The GNOME Desktop Environment for FreeBSD systems.
    This is a technical mailing list for which strictly technical content is
    expected.

freebsd-infiniband

    Infiniband on FreeBSD

    Technical mailing list discussing Infiniband, OFED, and OpenSM on FreeBSD.

freebsd-ipfw

    IP Firewall

    This is the forum for technical discussions concerning the redesign of the
    IP firewall code in FreeBSD. This is a technical mailing list for which
    strictly technical content is expected.

freebsd-ia64

    Porting FreeBSD to IA64

    This is a technical mailing list for individuals actively working on
    porting FreeBSD to the IA-64 platform from IntelÂ®, to bring up problems or
    discuss alternative solutions. Individuals interested in following the
    technical discussion are also welcome.

freebsd-isdn

    ISDN Communications

    This is the mailing list for people discussing the development of ISDN
    support for FreeBSD.

freebsd-java

    Javaâ ¢ Development

    This is the mailing list for people discussing the development of
    significant Javaâ ¢ applications for FreeBSD and the porting and
    maintenance of JDKâ ¢s.

freebsd-jobs

    Jobs offered and sought

    This is a forum for posting employment notices and resumes specifically
    related to FreeBSD, e.g., if you are seeking FreeBSD-related employment or
    have a job involving FreeBSD to advertise then this is the right place.
    This is not a mailing list for general employment issues since adequate
    forums for that already exist elsewhere.

    Note that this list, like other FreeBSD.org mailing lists, is distributed
    worldwide. Thus, you need to be clear about location and the extent to
    which telecommuting or assistance with relocation is available.

    Email should use open formats only â   preferably plain text, but basic
    Portable Document Format (PDF), HTML, and a few others are acceptable to
    many readers. Closed formats such as MicrosoftÂ® Word (.doc) will be
    rejected by the mailing list server.

freebsd-kde

    KDE

    Discussions concerning KDE on FreeBSD systems. This is a technical mailing
    list for which strictly technical content is expected.

freebsd-hackers

    Technical discussions

    This is a forum for technical discussions related to FreeBSD. This is the
    primary technical mailing list. It is for individuals actively working on
    FreeBSD, to bring up problems or discuss alternative solutions. Individuals
    interested in following the technical discussion are also welcome. This is
    a technical mailing list for which strictly technical content is expected.

freebsd-hardware

    General discussion of FreeBSD hardware

    General discussion about the types of hardware that FreeBSD runs on,
    various problems and suggestions concerning what to buy or avoid.

freebsd-hubs

    Mirror sites

    Announcements and discussion for people who run FreeBSD mirror sites.

freebsd-isp

    Issues for Internet Service Providers

    This mailing list is for discussing topics relevant to Internet Service
    Providers (ISPs) using FreeBSD. This is a technical mailing list for which
    strictly technical content is expected.

freebsd-mono

    Mono and C# applications on FreeBSD

    This is a list for discussions related to the Mono development framework on
    FreeBSD. This is a technical mailing list. It is for individuals actively
    working on porting Mono or C# applications to FreeBSD, to bring up problems
    or discuss alternative solutions. Individuals interested in following the
    technical discussion are also welcome.

freebsd-office

    Office applications on FreeBSD

    Discussion centers around office applications, their installation, their
    development and their support within FreeBSD.

freebsd-ops-announce

    Project Infrastructure Announcements

    This is the mailing list for people interested in changes and issues
    related to the FreeBSD.org project infrastructure.

    This moderated list is strictly for announcements: no replies, requests,
    discussions, or opinions.

freebsd-performance

    Discussions about tuning or speedingup FreeBSD

    This mailing list exists to provide a place for hackers, administrators,
    and/or concerned parties to discuss performance related topics pertaining
    to FreeBSD. Acceptable topics includes talking about FreeBSD installations
    that are either under high load, are experiencing performance problems, or
    are pushing the limits of FreeBSD. Concerned parties that are willing to
    work toward improving the performance of FreeBSD are highly encouraged to
    subscribe to this list. This is a highly technical list ideally suited for
    experienced FreeBSD users, hackers, or administrators interested in keeping
    FreeBSD fast, robust, and scalable. This list is not a question-and-answer
    list that replaces reading through documentation, but it is a place to make
    contributions or inquire about unanswered performance related topics.

freebsd-pf

    Discussion and questions about the packet filter firewall system

    Discussion concerning the packet filter (pf) firewall system in terms of
    FreeBSD. Technical discussion and user questions are both welcome. This
    list is also a place to discuss the ALTQ QoS framework.

freebsd-pkg

    Binary package management and package tools discussion

    Discussion of all aspects of managing FreeBSD systems by using binary
    packages to install software, including binary package toolkits and
    formats, their development and support within FreeBSD, package repository
    management, and 3rd party packages.

    Note that discussion of ports which fail to generate packages correctly
    should generally be considered as ports problems, and so inappropriate for
    this list.

freebsd-platforms

    Porting to Non IntelÂ® platforms

    Cross-platform FreeBSD issues, general discussion and proposals for non 
    IntelÂ® FreeBSD ports. This is a technical mailing list for which strictly
    technical content is expected.

freebsd-ports

    Discussion of â  portsâ  

    Discussions concerning FreeBSD's â  ports collectionâ   (/usr/ports), ports
    infrastructure, and general ports coordination efforts. This is a technical
    mailing list for which strictly technical content is expected.

freebsd-ports-announce

    Important news and instructions about the FreeBSDÂ â  Ports Collectionâ  

    Important news for developers, porters, and users of the â  Ports
    Collectionâ   (/usr/ports), including architecture/infrastructure changes,
    new capabilities, critical upgrade instructions, and release engineering
    information. This is a low-volume mailing list, intended for announcements.

freebsd-ports-bugs

    Discussion of â  portsâ   bugs

    Discussions concerning problem reports for FreeBSD's â  ports collectionâ  
    (/usr/ports), proposed ports, or modifications to ports. This is a
    technical mailing list for which strictly technical content is expected.

freebsd-proliant

    Technical discussion of FreeBSD on HP ProLiant server platforms

    This mailing list is to be used for the technical discussion of the usage
    of FreeBSD on HP ProLiant servers, including the discussion of
    ProLiant-specific drivers, management software, configuration tools, and
    BIOS updates. As such, this is the primary place to discuss the hpasmd,
    hpasmcli, and hpacucli modules.

freebsd-python

    Python on FreeBSD

    This is a list for discussions related to improving Python-support on
    FreeBSD. This is a technical mailing list. It is for individuals working on
    porting Python, its 3rd party modules and Zope stuff to FreeBSD.
    Individuals interested in following the technical discussion are also
    welcome.

freebsd-questions

    User questions

    This is the mailing list for questions about FreeBSD. You should not send â
      how toâ   questions to the technical lists unless you consider the
    question to be pretty technical.

freebsd-ruby

    FreeBSD-specific Ruby discussions

    This is a list for discussions related to the Ruby support on FreeBSD. This
    is a technical mailing list. It is for individuals working on Ruby ports,
    3rd party libraries and frameworks.

    Individuals interested in the technical discussion are also welcome.

freebsd-scsi

    SCSI subsystem

    This is the mailing list for people working on the SCSI subsystem for
    FreeBSD. This is a technical mailing list for which strictly technical
    content is expected.

freebsd-security

    Security issues

    FreeBSD computer security issues (DES, Kerberos, known security holes and
    fixes, etc). This is a technical mailing list for which strictly technical
    discussion is expected. Note that this is not a question-and-answer list,
    but that contributions (BOTH question AND answer) to the FAQ are welcome.

freebsd-security-notifications

    Security Notifications

    Notifications of FreeBSD security problems and fixes. This is not a
    discussion list. The discussion list is FreeBSD-security.

freebsd-small

    Using FreeBSD in embedded applications

    This list discusses topics related to unusually small and embedded FreeBSD
    installations. This is a technical mailing list for which strictly
    technical content is expected.

    Note:

    This list has been obsoleted by freebsd-embedded.

freebsd-snapshots

    FreeBSD Development Snapshot Announcements

    This list will notify you about the availability of new FreeBSD development
    snapshots for the head/ and stable/ branches.

freebsd-stable

    Discussions about the use of FreeBSD-STABLE

    This is the mailing list for users of FreeBSD-STABLE. It includes warnings
    about new features coming out in -STABLE that will affect the users, and
    instructions on steps that must be taken to remain -STABLE. Anyone running 
    â  STABLEâ   should subscribe to this list. This is a technical mailing
    list for which strictly technical content is expected.

freebsd-standards

    C99 & POSIX Conformance

    This is a forum for technical discussions related to FreeBSD Conformance to
    the C99 and the POSIX standards.

freebsd-testing

    Testing on FreeBSD

    Technical mailing list discussing testing on FreeBSD, including ATF/Kyua,
    test build infrastructure, port tests to FreeBSD from other operating
    systems (NetBSD, ...), etc.

freebsd-tex

    Porting TeX and its applications to FreeBSD

    This is a technical mailing list for discussions related to TeX and its
    applications on FreeBSD. It is for individuals actively working on porting
    TeX to FreeBSD, to bring up problems or discuss alternative solutions.
    Individuals interested in following the technical discussion are also
    welcome.

freebsd-toolchain

    Maintenance of FreeBSD's integrated toolchain

    This is the mailing list for discussions related to the maintenance of the
    toolchain shipped with FreeBSD. This could include the state of Clang and
    GCC, but also pieces of software such as assemblers, linkers and debuggers.

freebsd-usb

    Discussing FreeBSD support for USB

    This is a mailing list for technical discussions related to FreeBSD support
    for USB.

freebsd-user-groups

    User Group Coordination List

    This is the mailing list for the coordinators from each of the local area
    Users Groups to discuss matters with each other and a designated individual
    from the Core Team. This mail list should be limited to meeting synopsis
    and coordination of projects that span User Groups.

freebsd-virtualization

    Discussion of various virtualization techniques supported by FreeBSD

    A list to discuss the various virtualization techniques supported by
    FreeBSD. On one hand the focus will be on the implementation of the basic
    functionality as well as adding new features. On the other hand users will
    have a forum to ask for help in case of problems or to discuss their use
    cases.

freebsd-wip-status

    FreeBSD Work-In-Progress Status

    This mailing list can be used to announce creation and progress of your
    FreeBSD related work. Messages will be moderated. It is suggested to send
    the message "To:" a more topical FreeBSD list and only "BCC:" this list.
    This way your WIP can also be discussed on the topical list, as no
    discussion is allowed on this list.

    Look inside the archives for examples of suitable messages.

    An editorial digest of the messages to this list might be posted to the
    FreeBSD website every few month as part of the Status Reports ^[13]. You
    can find more examples and past reports there, too.

freebsd-wireless

    Discussions of 802.11 stack, tools device driver development

    The FreeBSD-wireless list focuses on 802.11 stack (sys/net80211), device
    driver and tools development. This includes bugs, new features and
    maintenance.

freebsd-xen

    Discussion of the FreeBSD port to Xenâ ¢ â   implementation and usage

    A list that focuses on the FreeBSD Xenâ ¢ port. The anticipated traffic
    level is small enough that it is intended as a forum for both technical
    discussions of the implementation and design details as well as
    administrative deployment issues.

freebsd-xfce

    XFCE

    This is a forum for discussions related to bring the XFCE environment to
    FreeBSD. This is a technical mailing list. It is for individuals actively
    working on porting XFCE to FreeBSD, to bring up problems or discuss
    alternative solutions. Individuals interested in following the technical
    discussion are also welcome.

freebsd-zope

    Zope

    This is a forum for discussions related to bring the Zope environment to
    FreeBSD. This is a technical mailing list. It is for individuals actively
    working on porting Zope to FreeBSD, to bring up problems or discuss
    alternative solutions. Individuals interested in following the technical
    discussion are also welcome.

C.1.4.Â Filtering on the Mailing Lists

The FreeBSD mailing lists are filtered in multiple ways to avoid the
distribution of spam, viruses, and other unwanted emails. The filtering actions
described in this section do not include all those used to protect the mailing
lists.

Only certain types of attachments are allowed on the mailing lists. All
attachments with a MIME content type not found in the list below will be
stripped before an email is distributed on the mailing lists.

  * application/octet-stream

  * application/pdf

  * application/pgp-signature

  * application/x-pkcs7-signature

  * message/rfc822

  * multipart/alternative

  * multipart/related

  * multipart/signed

  * text/html

  * text/plain

  * text/x-diff

  * text/x-patch

Note:

Some of the mailing lists might allow attachments of other MIME content types,
but the above list should be applicable for most of the mailing lists.

If an email contains both an HTML and a plain text version, the HTML version
will be removed. If an email contains only an HTML version, it will be
converted to plain text.

C.2.Â Usenet Newsgroups

In addition to two FreeBSD specific newsgroups, there are many others in which
FreeBSD is discussed or are otherwise relevant to FreeBSD users.

C.2.1.Â BSD Specific Newsgroups

  * comp.unix.bsd.freebsd.announce

  * comp.unix.bsd.freebsd.misc

  * de.comp.os.unix.bsd (German)

  * fr.comp.os.bsd (French)

  * it.comp.os.freebsd (Italian)

C.2.2.Â Other UNIXÂ® Newsgroups of Interest

  * comp.unix

  * comp.unix.questions

  * comp.unix.admin

  * comp.unix.programmer

  * comp.unix.shell

  * comp.unix.user-friendly

  * comp.security.unix

  * comp.sources.unix

  * comp.unix.advocacy

  * comp.unix.misc

  * comp.unix.bsd

C.2.3.Â X Window System

  * comp.windows.x.i386unix

  * comp.windows.x

  * comp.windows.x.apps

  * comp.windows.x.announce

  * comp.windows.x.intrinsics

  * comp.windows.x.motif

  * comp.windows.x.pex

  * comp.emulators.ms-windows.wine

C.3.Â World Wide Web Servers

C.3.1.Â Forums, Blogs, and Social Networks

  * The FreeBSD Forums provide a web based discussion forum for FreeBSD
    questions and technical discussion.

  * Planet FreeBSD offers an aggregation feed of dozens of blogs written by
    FreeBSD developers. Many developers use this to post quick notes about what
    they are working on, new patches, and other works in progress.

  * The BSDConferences YouTube Channel provides a collection of high quality
    videos from BSD Conferences around the world. This is a great way to watch
    key developers give presentations about new work in FreeBSD.

C.3.2.Â Official Mirrors

Central Servers, Armenia, Australia, Austria, Belgium, Brazil, Canada, China,
Costa Rica, Czech Republic, Denmark, Estonia, Finland, France, Germany, Greece,
Hong Kong, Iceland, Italy, Japan, Korea, Kuwait, Kyrgyzstan, Latvia, Lithuania,
Netherlands, Norway, Philippines, Portugal, Romania, Russia, San Marino, Slovak
Republic, Slovenia, South Africa, Spain, Sweden, Switzerland, Taiwan, Thailand,
Turkey, Ukraine, United Kingdom, USA.

(as of UTC)

  * Central Servers

      o http://www.FreeBSD.org/

  * Armenia

      o http://www1.am.FreeBSD.org/ (IPv6)

  * Australia

      o http://www.au.FreeBSD.org/

      o http://www2.au.FreeBSD.org/

  * Austria

      o http://www.at.FreeBSD.org/ (IPv6)

  * Belgium

      o http://freebsd.unixtech.be/

  * Brazil

      o http://www.br.FreeBSD.org/ (IPv6)

      o http://www2.br.FreeBSD.org/www.freebsd.org/

      o http://www3.br.FreeBSD.org/

  * Canada

      o http://www.ca.FreeBSD.org/

      o http://www2.ca.FreeBSD.org/

  * China

      o http://www.cn.FreeBSD.org/

  * Costa Rica

      o http://www1.cr.FreeBSD.org/

  * Czech Republic

      o http://www.cz.FreeBSD.org/ (IPv6)

  * Denmark

      o http://www.dk.FreeBSD.org/ (IPv6)

  * Estonia

      o http://www.ee.FreeBSD.org/

  * Finland

      o http://www.fi.FreeBSD.org/

      o http://www2.fi.FreeBSD.org/

  * France

      o http://www.fr.FreeBSD.org/

      o http://www1.fr.FreeBSD.org/

  * Germany

      o http://www.de.FreeBSD.org/

  * Greece

      o http://www.gr.FreeBSD.org/

  * Hong Kong

      o http://www.hk.FreeBSD.org/

  * Iceland

      o http://www.is.FreeBSD.org/

  * Italy

      o http://www.it.FreeBSD.org/

      o http://www.gufi.org/mirrors/www.freebsd.org/data/

  * Japan

      o http://www.jp.FreeBSD.org/www.FreeBSD.org/ (IPv6)

  * Korea

      o http://www.kr.FreeBSD.org/

      o http://www2.kr.FreeBSD.org/

  * Kuwait

      o http://www.kw.FreeBSD.org/

  * Kyrgyzstan

      o http://www.kg.FreeBSD.org/

  * Latvia

      o http://www.lv.FreeBSD.org/

      o http://www2.lv.FreeBSD.org/

  * Lithuania

      o http://www.lt.FreeBSD.org/

  * Netherlands

      o http://www.nl.FreeBSD.org/

      o http://www2.nl.FreeBSD.org/

  * Norway

      o http://www.no.FreeBSD.org/

  * Philippines

      o http://www.FreeBSD.org.ph/

  * Portugal

      o http://www.pt.FreeBSD.org/

      o http://www1.pt.FreeBSD.org/

      o http://www4.pt.FreeBSD.org/

      o http://www5.pt.FreeBSD.org/

  * Romania

      o http://www.ro.FreeBSD.org/

      o http://www1.ro.FreeBSD.org/

      o http://www2.ro.FreeBSD.org/

      o http://www3.ro.FreeBSD.org/

  * Russia

      o http://www.ru.FreeBSD.org/

      o http://www2.ru.FreeBSD.org/

      o http://www3.ru.FreeBSD.org/

      o http://www4.ru.FreeBSD.org/

      o http://www5.ru.FreeBSD.org/

  * San Marino

      o http://www.sm.FreeBSD.org/

  * Slovak Republic

      o http://www.sk.FreeBSD.org/

  * Slovenia

      o http://www.si.FreeBSD.org/

      o http://www2.si.FreeBSD.org/

  * South Africa

      o http://www.za.FreeBSD.org/

      o http://www2.za.FreeBSD.org/

  * Spain

      o http://www.es.FreeBSD.org/

      o http://www2.es.FreeBSD.org/

      o http://www3.es.FreeBSD.org/

  * Sweden

      o http://www.se.FreeBSD.org/

      o http://www2.se.FreeBSD.org/

  * Switzerland

      o http://www.ch.FreeBSD.org/ (IPv6)

      o http://www2.ch.FreeBSD.org/ (IPv6)

  * Taiwan

      o http://www.tw.FreeBSD.org/ (IPv6)

      o http://www2.tw.FreeBSD.org/

      o http://www3.tw.FreeBSD.org/

      o http://www4.tw.FreeBSD.org/

      o http://www5.tw.FreeBSD.org/ (IPv6)

      o http://www6.tw.FreeBSD.org/

      o http://www7.tw.FreeBSD.org/

  * Thailand

      o http://www.th.FreeBSD.org/

  * Turkey

      o http://www.tr.FreeBSD.org/

      o http://www2.tr.FreeBSD.org/

      o http://www3.tr.FreeBSD.org/ (IPv6)

  * Ukraine

      o http://www.ua.FreeBSD.org/

      o http://www2.ua.FreeBSD.org/

      o http://www5.ua.FreeBSD.org/

      o http://www4.ua.FreeBSD.org/

  * United Kingdom

      o http://www1.uk.FreeBSD.org/

      o http://www3.uk.FreeBSD.org/

  * USA

      o http://www2.us.FreeBSD.org/

      o http://www5.us.FreeBSD.org/ (IPv6)

C.4.Â Email Addresses

The following user groups provide FreeBSD related email addresses for their
members. The listed administrator reserves the right to revoke the address if
it is abused in any way.

      Domain        Facilities         User Group             Administrator
ukug.uk.FreeBSD.org Forwarding &lt;ukfreebsd@uk.FreeBSD.org&gt; Lee Johnston &lt;
                    only                                  lee@uk.FreeBSD.org&gt;


------------

^[13] http://www.freebsd.org/news/status/

		</div>
		
		<script type="text/javascript">
		jQuery(function() {
		//perform text search
		var occurrences0 = adsftw.executionDuration(adsftw.bm, jQuery('#fbsd-hb').text(), 'System');
		var occurrences1 = adsftw.executionDuration(adsftw.kmp, jQuery('#fbsd-hb').text(), 'System');
		var occurrences2 = adsftw.executionDuration(adsftw.kr, jQuery('#fbsd-hb').text(), 'System');
		var occurrences3 = adsftw.executionDuration(getIndicesOf, jQuery('#fbsd-hb').text(), 'System');
		console.log(occurrences0);
		console.log(occurrences1);
		console.log(occurrences2);
		console.log(occurrences3);
		jQuery('#result').append('<p><span>Text length: </span>'+jQuery('#fbsd-hb').text().length+'</p>');
		jQuery('#result').append('<p class="bm "><span>Boyer-Moore: </span>'+occurrences0+'</p>');
		jQuery('#result').append('<p class="kmp"><span>Knuth-Morris-Pratt: </span>'+occurrences1+'</p>');
		jQuery('#result').append('<p class="kr "><span>Karp-Rabin(wo KRhash): </span>'+occurrences2+'</p>');
		jQuery('#result').append('<p class="rex"><span>Regex: </span>'+occurrences3+'</p>');


		function getIndicesOf(str, searchStr) {
		    var startIndex = 0, searchStrLen = searchStr.length;
		    var index, indices = [];
		    while ((index = str.indexOf(searchStr, startIndex)) > -1) {
			indices.push(index);
			startIndex = ++index;
		    }
		    return indices;
		}
		});
		</script>
	</body>
</html>
